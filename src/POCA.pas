(******************************************************************************
 *                                     POCA                                   *
 ******************************************************************************
 *            for version see POCAVersion constant string here below          *
 ******************************************************************************
 *                                zlib license                                *
 *============================================================================*
 *                                                                            *
 * Copyright (C) 2011-2025, Benjamin Rosseaux (benjamin@rosseaux.com)         *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 *                                                                            *
 ******************************************************************************
 *                  General guidelines for code contributors                  *
 *============================================================================*
 *                                                                            *
 * 1. Make sure you are legally allowed to make a contribution under the zlib *
 *    license.                                                                *
 * 2. The zlib license header goes at the top of each source file, with       *
 *    appropriate copyright notice.                                           *
 * 3. After a pull request, check the status of your pull request on          *
      http://github.com/BeRo1985/poca                                         *
 * 4. Write code, which is compatible with Delphi 7-XE7 and FreePascal >= 3.0 *
 *    so don't use generics/templates, operator overloading and another newer *
 *    syntax features than Delphi 7 has support for that, but if needed, make *
 *    it out-ifdef-able.                                                      *
 * 5. Don't use Delphi-only, FreePascal-only or Lazarus-only libraries/units, *
 *    but if needed, make it out-ifdef-able.                                  *
 * 6. No use of third-party libraries/units as possible, but if needed, make  *
 *    it out-ifdef-able.                                                      *
 * 7. Try to use const when possible.                                         *
 * 8. Make sure to comment out writeln, used while debugging.                 *
 * 9. Make sure the code compiles on 32-bit and 64-bit platforms (x86-32,     *
 *    x86-64, ARM, ARM64, etc.).                                              *
 *                                                                            *
 ******************************************************************************)
 unit POCA;
{$ifdef fpc}
 {$mode delphi}
 {$ifdef cpui386}
  {$define cpu386}
  {$define cpu32}
 {$endif}
 {$ifdef cpu386}
  {$asmmode intel}
  {$define cpu32}
 {$endif}
 {$ifdef cpuamd64}
  {$asmmode intel}
  {$define cpu64}
 {$endif}
 {$ifdef FPC_LITTLE_ENDIAN}
  {$define LITTLE_ENDIAN}
 {$else}
  {$ifdef FPC_BIG_ENDIAN}
   {$define BIG_ENDIAN}
  {$endif}
 {$endif}
 {-$pic off}
 {$define caninline}
 {$ifdef FPC_HAS_TYPE_EXTENDED}
  {$define HAS_TYPE_EXTENDED}
 {$else}
  {$undef HAS_TYPE_EXTENDED}
 {$endif}
 {$ifdef FPC_HAS_TYPE_DOUBLE}
  {$define HAS_TYPE_DOUBLE}
 {$else}
  {$undef HAS_TYPE_DOUBLE}
 {$endif}
 {$ifdef FPC_HAS_TYPE_SINGLE}
  {$define HAS_TYPE_SINGLE}
 {$else}
  {$undef HAS_TYPE_SINGLE}
 {$endif}
{$else}
 {$realcompatibility off}
 {$localsymbols on}
 {$define LITTLE_ENDIAN}
 {$if defined(cpux64)}
  {$define cpu64}
  {$define cpuamd64}
 {$elseif defined(cpu386)}
  {$define cpu32}
 {$else}
  {$ifndef cpu64}
   {$define cpu32}
  {$endif}
 {$ifend}
 {$define HAS_TYPE_EXTENDED}
 {$define HAS_TYPE_DOUBLE}
 {$define HAS_TYPE_SINGLE}
 {$ifndef BCB}
  {$ifdef ver120}
   {$define Delphi4or5}
  {$endif}
  {$ifdef ver130}
   {$define Delphi4or5}
  {$endif}
  {$ifdef ver140}
   {$define Delphi6}
  {$endif}
  {$ifdef ver150}
   {$define Delphi7}
  {$endif}
  {$ifdef ver170}
   {$define Delphi2005}
  {$endif}
 {$else}
  {$ifdef ver120}
   {$define Delphi4or5}
   {$define BCB4}
  {$endif}
  {$ifdef ver130}
   {$define Delphi4or5}
  {$endif}
 {$endif}
 {$ifdef conditionalexpressions}
  {$if CompilerVersion>=24}
   {$legacyifend on}
  {$ifend}
  {$if CompilerVersion>=14.0}
   {$if CompilerVersion=14.0}
    {$define Delphi6}
   {$ifend}
   {$define Delphi6AndUp}
  {$ifend}
  {$if CompilerVersion>=15.0}
   {$if CompilerVersion=15.0}
    {$define Delphi7}
   {$ifend}
   {$define Delphi7AndUp}
  {$ifend}
  {$if CompilerVersion>=17.0}
   {$if CompilerVersion=17.0}
    {$define Delphi2005}
   {$ifend}
   {$define Delphi2005AndUp}
  {$ifend}
  {$if CompilerVersion>=18.0}
   {$if CompilerVersion=18.0}
    {$define BDS2006}
    {$define Delphi2006}
   {$ifend}
   {$define Delphi2006AndUp}
  {$ifend}
  {$if CompilerVersion>=18.5}
   {$if CompilerVersion=18.5}
    {$define Delphi2007}
   {$ifend}
   {$define Delphi2007AndUp}
  {$ifend}
  {$if CompilerVersion=19.0}
   {$define Delphi2007Net}
  {$ifend}
  {$if CompilerVersion>=20.0}
   {$if CompilerVersion=20.0}
    {$define Delphi2009}
   {$ifend}
   {$define Delphi2009AndUp}
  {$ifend}
  {$if CompilerVersion>=21.0}
   {$if CompilerVersion=21.0}
    {$define Delphi2010}
   {$ifend}
   {$define Delphi2010AndUp}
  {$ifend}
  {$if CompilerVersion>=22.0}
   {$if CompilerVersion=22.0}
    {$define DelphiXE}
   {$ifend}
   {$define DelphiXEAndUp}
  {$ifend}
  {$if CompilerVersion>=23.0}
   {$if CompilerVersion=23.0}
    {$define DelphiXE2}
   {$ifend}
   {$define DelphiXE2AndUp}
  {$ifend}
  {$if CompilerVersion>=24.0}
   {$if CompilerVersion=24.0}
    {$define DelphiXE3}
   {$ifend}
   {$define DelphiXE3AndUp}
  {$ifend}
  {$if CompilerVersion>=25.0}
   {$if CompilerVersion=25.0}
    {$define DelphiXE4}
   {$ifend}
   {$define DelphiXE4AndUp}
  {$ifend}
  {$if CompilerVersion>=26.0}
   {$if CompilerVersion=26.0}
    {$define DelphiXE5}
   {$ifend}
   {$define DelphiXE5AndUp}
  {$ifend}
  {$if CompilerVersion>=27.0}
   {$if CompilerVersion=27.0}
    {$define DelphiXE6}
   {$ifend}
   {$define DelphiXE6AndUp}
  {$ifend}
  {$if CompilerVersion>=28.0}
   {$if CompilerVersion=28.0}
    {$define DelphiXE7}
   {$ifend}
   {$define DelphiXE7AndUp}
  {$ifend}
  {$if CompilerVersion>=29.0}
   {$if CompilerVersion=29.0}
    {$define DelphiXE8}
   {$ifend}
   {$define DelphiXE8AndUp}
  {$ifend}
  {$if CompilerVersion>=30.0}
   {$if CompilerVersion=30.0}
    {$define Delphi10Seattle}
   {$ifend}
   {$define Delphi10SeattleAndUp}
  {$ifend}
  {$if CompilerVersion>=31.0}
   {$if CompilerVersion=31.0}
    {$define Delphi10Berlin}
   {$ifend}
   {$define Delphi10BerlinAndUp}
  {$ifend}
  {$if CompilerVersion>=32.0}
   {$if CompilerVersion=32.0}
    {$define Delphi10Tokyo}
   {$ifend}
   {$define Delphi10TokyoAndUp}
  {$ifend}
  {$if CompilerVersion>=33.0}
   {$if CompilerVersion=33.0}
    {$define Delphi10Rio}
   {$ifend}
   {$define Delphi10RioAndUp}
  {$ifend}
 {$endif}
 {$ifndef Delphi4or5}
  {$ifndef BCB}
   {$define Delphi6AndUp}
  {$endif}
   {$ifndef Delphi6}
    {$define BCB6OrDelphi7AndUp}
    {$ifndef BCB}
     {$define Delphi7AndUp}
    {$endif}
    {$ifndef BCB}
     {$ifndef Delphi7}
      {$ifndef Delphi2005}
       {$define BDS2006AndUp}
      {$endif}
     {$endif}
    {$endif}
   {$endif}
 {$endif}
 {$ifdef Delphi6AndUp}
  {$warn symbol_platform off}
  {$warn symbol_deprecated off}
 {$endif}
{$endif}
{$ifdef win32}
 {$define windows}
{$endif}
{$ifdef win64}
 {$define windows}
{$endif}
{$ifdef wince}
 {$define windows}
{$endif}
{$rangechecks off}
{$extendedsyntax on}
{$writeableconst on}
{$hints off}
{$booleval off}
{$typedaddress off}
{$stackframes off}
{$varstringchecks on}
{$typeinfo on}
{$overflowchecks off}
{$longstrings on}
{$openstrings on}
{$ifndef HAS_TYPE_DOUBLE}
 {$error No double floating point precision}
{$endif}
{$define POCAGarbageCollectorListsDoNeedFallbackLocking}
{$undef POCAGarbageCollectorListsFallbackTwoLocking}
{$undef POCAGarbageCollectorListsUsePlainAssemblerCode}
{$undef UseRegister}
{$ifdef cpu386}
 {$undef POCAGarbageCollectorListsDoNeedFallbackLocking}
 {$define POCAGarbageCollectorListsUsePlainAssemblerCode}
 {$define POCAHasJIT}
 {$define UseRegister}
{$endif}
{$ifdef cpuamd64}
 {$undef POCAGarbageCollectorListsDoNeedFallbackLocking}
 {$define POCAGarbageCollectorListsUsePlainAssemblerCode}
 {-$define POCAHasJIT}
 {$define UseRegister}
{$endif}
{$undef POCAGarbageCollectorPoolBlockInstance}
{$undef POCAGarbageCollectorPoolBlockReferenceCounting}
{-$define pocastrictutf8}

{$if defined(cpu386) or defined(cpux86_64) or (defined(fpc) and defined(cpuaarch64))}
 {$define POCACanUseDCAS}
 {$undef POCACanUseDCAS}
{$else}
 {$undef POCACanUseDCAS}
{$ifend}

{$ifdef POCANoMemoryPools}
 {$undef POCAMemoryPools}
{$else}
 {$define POCAMemoryPools}
{$endif}

{$undef POCAClosureArrayValues}

interface

uses {$ifdef unix}dynlibs,BaseUnix,Unix,UnixType,termio,dl,{$else}Windows,{$endif}SysUtils,Classes,{$ifdef DelphiXE2AndUp}IOUtils,{$endif}DateUtils,Math,Variants,TypInfo{$ifndef fpc},SyncObjs{$endif},FLRE,PasDblStrUtils,PUCU,PasMP;

const POCAVersion='2025-04-15-15-11-0000';

      POCA_MAX_RECURSION=1024;

      POCAHashMapItemsPerBucketsThreshold=5;
      POCAHashMapMaxSize=1 shl 16;

      POCA_PROTOTYPE_RECURSION_LIMIT=128;
      POCA_CONSTRUCTOR_RECURSION_LIMIT=128;

      popNOP=0;
      popADD=1;
      popSUB=2;
      popMUL=3;
      popDIV=4;
      popNEG=5;
      popNOT=6;
      popCAT=7;
      popLT=8;
      popLTEQ=9;
      popGT=10;
      popGTEQ=11;
      popEQ=12;
      popNEQ=13;
      popCMP=14;
      popSEQ=15;
      popSNEQ=16;
      popEACH=17;
      popJMP=18;
      popJMPLOOP=19;
      popJIFTRUE=20;
      popJIFFALSE=21;
      popJIFTRUELOOP=22;
      popJIFFALSELOOP=23;
      popFCALL=24;
      popMCALL=25;
      popRETURN=26;
      popLOADCODE=27;
      popLOADCONST=28;
      popLOADONE=29;
      popLOADZERO=30;
      popLOADINT32=31;
      popLOADNULL=32;
      popLOADTHAT=33;
      popLOADTHIS=34;
      popLOADSELF=35;
      popLOADLOCAL=36;
      popCOPY=37;
      popARRAYINSERT=38;
      popARRAYEXTRACT=39;
      popINSERT=40;
      popEXTRACT=41;
      popGETLENGTH=42;
      popGETMEMBER=43;
      popSETMEMBER=44;
      popGETLOCAL=45;
      popSETLOCAL=46;
      popGETLOCALVALUE=47;
      popSETLOCALVALUE=48;
      popGETOUTERVALUE=49;
      popSETOUTERVALUE=50;
      popNEWARRAY=51;
      popARRAYPUSH=52;
      popARRAYRANGEPUSH=53;
      popNEWHASH=54;
      popHASHAPPEND=55;
      popSETSYM=56;
      popINDEX=57;
      popFCALLH=58;
      popMCALLH=59;
      popUNPACK=60;
      popSLICE=61;
      popSLICE2=62;
      popSLICE3=63;
      popTRY=64;
      popTRYBLOCKEND=65;
      popTHROW=66;
      popDEC=67;
      popINC=68;
      popBAND=69;
      popBXOR=70;
      popBOR=71;
      popBNOT=72;
      popBSHL=73;
      popBSHR=74;
      popBUSHR=75;
      popMOD=76;
      popPOW=77;
      popINHERITEDGETMEMBER=78;
      popKEY=79;
      popIN=80;
      popINRANGE=81;
      popFTAILCALL=82;
      popMTAILCALL=83;
      popFTAILCALLH=84;
      popMTAILCALLH=85;
      popINSTANCEOF=86;
      popBREAKPOINT=87;
      popNUM=88;
      popN_NOT=89;
      popN_ADD=90;
      popN_SUB=91;
      popN_MUL=92;
      popN_DIV=93;
      popN_NEG=94;
      popN_LT=95;
      popN_LTEQ=96;
      popN_GT=97;
      popN_GTEQ=98;
      popN_EQ=99;
      popN_NEQ=100;
      popN_CMP=101;
      popN_DEC=102;
      popN_INC=103;
      popN_BAND=104;
      popN_BXOR=105;
      popN_BOR=106;
      popN_BNOT=107;
      popN_BSHL=108;
      popN_BSHR=109;
      popN_BUSHR=110;
      popN_MOD=111;
      popN_POW=112;
      popN_INRANGE=113;
      popN_JIFTRUE=114;
      popN_JIFFALSE=115;
      popN_JIFTRUELOOP=116;
      popN_JIFFALSELOOP=117;
      popN_JIFLT=118;
      popN_JIFLTEQ=119;
      popN_JIFGT=120;
      popN_JIFGTEQ=121;
      popN_JIFEQ=122;
      popN_JIFNEQ=123;
      popN_JIFLTLOOP=124;
      popN_JIFLTEQLOOP=125;
      popN_JIFGTLOOP=126;
      popN_JIFGTEQLOOP=127;
      popN_JIFEQLOOP=128;
      popN_JIFNEQLOOP=129;
      popUPDATESTRING=130;
      popREGEXP=131;
      popREGEXPEQ=132;
      popREGEXPNEQ=133;
      popSQRT=134;
      popN_SQRT=135;
      popGETPROTOTYPE=136;
      popSETPROTOTYPE=137;
      popGETCONSTRUCTOR=138;
      popSETCONSTRUCTOR=139;
      popDELETE=140;
      popDELETEEX=141;
      popDEFINED=142;
      popDEFINEDEX=143;
      popLOADGLOBAL=144;
      popLOADBASECLASS=145;
      popGETHASHKIND=146;
      popSETHASHKIND=147;
      popTYPEOF=148;
      popIDOF=149;
      popGHOSTTYPEOF=150;
      popELVIS=151;
      popIS=152;
      popJIFNULL=153;
      popJIFNOTNULL=154;
      popSAFEEXTRACT=155;
      popSAFEGETMEMBER=156;
      popSETCONSTLOCAL=157;
      popCOUNT=158;

      pvtNULL=0;
      pvtNUMBER=1;
      pvtREFERENCE=2;
      pvtSTRING=3;
      pvtARRAY=4;
      pvtHASH=5;
      pvtCODE=6;
      pvtFUNCTION=7;
      pvtNATIVECODE=8;
      pvtGHOST=9;
      pvtCOUNT=10;

      pvtFIRSTREF=pvtSTRING;

      phkHASH=0;
      phkCLASS=1;
      phkMODULE=2;

      POCAKeywordChars=['a'..'z'];

      POCAIdentifierCharsAtBegin=['a'..'z','A'..'Z','_'];
      POCAIdentifierCharsAfterBegin=['a'..'z','A'..'Z','0'..'9','_'];
      POCAIdentifierChars=POCAIdentifierCharsAtBegin+POCAIdentifierCharsAfterBegin;

      pcsNONE=0;
      pcsOUTSIDE=1;
      pcsINSIDE=2;
      pcsINSIDETERMINATED=3;
      pcsTERMINATED=4;

      pgcbNONE=0;
      pgcbWHITE=1 shl 0;
      pgcbBLACK=1 shl 1;
      pgcbGRAY=1 shl 2;
      pgcbPERSISTENT=1 shl 3;
      pgcbPERSISTENTROOT=1 shl 4;

      pgcbWASPERSISTENT=1 shl 5;
      pgcbWASPERSISTENTROOT=1 shl 6;

      pgcbLIST=pgcbWHITE or pgcbGRAY or pgcbBLACK or pgcbPERSISTENT or pgcbPERSISTENTROOT;

      pgcscSHIFT=8;
      pgcscMAX=longword($ffffff);
      pgcscONE=longword(1 shl pgcscSHIFT);
      pgcscMAXSHIFTED=longword(pgcscMAX shl pgcscSHIFT);

      pgcbBITS=pgcscONE-1;

type PPOCAInt8=^TPOCAInt8;
     TPOCAInt8={$ifdef fpc}Int8{$else}ShortInt{$endif};

     PPOCAUInt8=^TPOCAUInt8;
     TPOCAUInt8={$ifdef fpc}UInt8{$else}Byte{$endif};

     PPOCAInt16=^TPOCAInt16;
     TPOCAInt16={$ifdef fpc}Int16{$else}SmallInt{$endif};

     PPOCAUInt16=^TPOCAUInt16;
     TPOCAUInt16={$ifdef fpc}UInt16{$else}Word{$endif};

     PPOCAInt32=^TPOCAInt32;
     TPOCAInt32={$ifdef fpc}Int32{$else}LongInt{$endif};

     PPOCAUInt32=^TPOCAUInt32;
     TPOCAUInt32={$ifdef fpc}UInt32{$else}LongWord{$endif};

     PPOCAInt64=^TPOCAInt64;
     TPOCAInt64=Int64;

     PPOCAUInt64=^TPOCAUInt64;
     TPOCAUInt64=UInt64;

     PPOCABool32=^TPOCABool32;
     TPOCABool32=LongBool;

     PPOCAPtrUInt=^TPOCAPtrUInt;
     PPOCAPtrInt=^TPOCAPtrInt;

{$ifdef fpc}
     TPOCAPtrUInt=PtrUInt;
     TPOCAPtrInt=PtrInt;
{$else}
{$if Declared(CompilerVersion) and (CompilerVersion>=23.0)}
     TPOCAPtrUInt=NativeUInt;
     TPOCAPtrInt=NativeInt;
{$else}
{$ifdef cpu64}
     TPOCAPtrUInt=TPOCAUInt64;
     TPOCAPtrInt=TPOCAInt64;
{$else}
     TPOCAPtrUInt=TPOCAUInt32;
     TPOCAPtrInt=TPOCAInt32;
{$endif}
{$ifend}
{$endif}

     PPOCANativeUInt=^TPOCANativeUInt;
     PPOCANativeInt=^TPOCANativeInt;
     TPOCANativeUInt=TPOCAPtrUInt;
     TPOCANativeInt=TPOCAPtrInt;

     PPOCAUInt8Array=^TPOCAUInt8Array;
     TPOCAUInt8Array=array[0..($7fffffff div sizeof(TPOCAUInt8))-1] of TPOCAUInt8;

     PPOCAUInt16Array=^TPOCAUInt16Array;
     TPOCAUInt16Array=array[0..($7fffffff div sizeof(TPOCAUInt16))-1] of TPOCAUInt16;

     PPOCABool32Array=^TPOCABool32Array;
     TPOCABool32Array=array[0..($7fffffff div sizeof(TPOCABool32))-1] of TPOCABool32;

     PPOCAInt32Array=^TPOCAInt32Array;
     TPOCAInt32Array=array[0..($7fffffff div sizeof(TPOCAInt32))-1] of TPOCAInt32;

     PPOCAUInt32Array=^TPOCAUInt32Array;
     TPOCAUInt32Array=array[0..($7fffffff div sizeof(TPOCAUInt32))-1] of TPOCAUInt32;

     PPOCAPointer=^TPOCAPointer;
     TPOCAPointer=Pointer;

     PPOCAPointerArray=^TPOCAPointerArray;
     TPOCAPointerArray=array[0..($7fffffff div sizeof(TPOCAPointer))-1] of TPOCAPointer;

{$ifdef cpu64}
const POCAValueReferenceMask=TPOCAUInt64(TPOCAUInt64(TPOCAUInt64(1) shl 48)-1);
      POCAValueReferenceSignalMask=TPOCAUInt64(not POCAValueReferenceMask);
{$else}
const POCAValueReferenceTag=TPOCAUInt32($7fff6789); // $7ff56789
{$endif}

type PPOCADoubleHiLo=^TPOCADoubleHiLo;
     TPOCADoubleHiLo=packed record
{$ifdef BIG_ENDIAN}
      Hi,Lo:TPOCAUInt32;
{$else}
      Lo,Hi:TPOCAUInt32;
{$endif}
     end;

     PPOCADoubleBytes=^TPOCADoubleBytes;
     TPOCADoubleBytes=array[0..sizeof(double)-1] of TPOCAUInt8;

     TPOCAKeywordChars='a'..'z';

     PPOCAContext=^TPOCAContext;

     TPOCAUTF8String=TPUCUUTF8String;

     TPOCAUTF16String=TPUCUUTF16String;

     TPOCARawByteString=TPUCURawByteString;

     TPOCAUCS4Char=TPOCAInt32;

     TPOCAUCS4CharSigned=TPOCAUInt32;

     TPOCAUCS4String=array of TPOCAUCS4Char;

     PPOCATokenType=^TPOCATokenType;
     TPOCATokenType=(
      ptNONE,
      ptTOP,
      ptAND,
      ptOR,
      ptNOT,
      ptLPAR,
      ptRPAR,
      ptLBRA,
      ptRBRA,
      ptLCURL,
      ptRCURL,
      ptMUL,
      ptPLUS,
      ptMINUS,
      ptNEG,
      ptDIV,
      ptNUM,
      ptCOLON,
      ptDOT,
      ptCOMMA,
      ptSEMI,
      ptASSIGN,
      ptLT,
      ptLTEQ,
      ptEQ,
      ptNEQ,
      ptGT,
      ptGTEQ,
      ptCMP,
      ptIF,
      ptELSEIF,
      ptELSE,
      ptFOR,
      ptFOREACH,
      ptWHILE,
      ptRETURN,
      ptBREAK,
      ptCONTINUE,
      ptFUNCTION,
      ptSYMBOL,
      ptLITERALNUM,
      ptLITERALSTR,
      ptEMPTY,
      ptNULL,
      ptELLIPSIS,
      ptQUESTION,
      ptVAR,
      ptPLUSEQ,
      ptMINUSEQ,
      ptMULEQ,
      ptDIVEQ,
      ptCATEQ,
      ptFORINDEX,
      ptLAND,
      ptLOR,
      ptTRY,
      ptCATCH,
      ptFINALLY,
      ptTHROW,
      ptDO,
      ptWHEN,
      ptSWITCH,
      ptCASE,
      ptDEFAULT,
      ptFALLTHROUGH,
      ptRETRY,
      ptPOSTDEC,
      ptPOSTINC,
      ptPREDEC,
      ptPREINC,
      ptBAND,
      ptBOR,
      ptBXOR,
      ptBNOT,
      ptBSHL,
      ptBSHR,
      ptBUSHR,
      ptBANDEQ,
      ptBOREQ,
      ptBXOREQ,
      ptBSHLEQ,
      ptBSHREQ,
      ptBUSHREQ,
      ptMOD,
      ptMODEQ,
      ptPOW,
      ptPOWEQ,
      ptREGISTER,
      ptSCOPE,
      ptCODE,
      ptSUPERTHAT,
      ptTHAT,
      ptTHIS,
      ptSELF,
      ptLOCAL,
      ptDEFINED,
      ptNEW,
      ptTRUE,
      ptFALSE,
      ptFASTFUNCTION,
      ptAT,
      ptATDOT,
      ptDOTDOT,
      ptSAFEDOT,
      ptSAFELBRA,
      ptSAFERBRA,
      ptFORKEY,
      ptINSTANCEOF,
      ptSEQ,
      ptSNEQ,
      ptIN,
      ptIS,
      ptSUPER,
      ptCAT,
      ptREGEXP,
      ptREGEXPEQ,
      ptREGEXPNEQ,
      ptPROTOTYPE,
      ptDELETE,
      ptCLASS,
      ptMODULE,
      ptEXTENDS,
      ptLAMBDA,
      ptFASTLAMBDA,
      ptCLASSFUNCTION,
      ptMODULEFUNCTION,
      ptGLOBAL,
      ptBASECLASS,
      ptLET,
      ptREG,
      ptCONST,
      ptFUNC,
      ptFASTFUNC,
      ptHASHKIND,
      ptTYPEOF,
      ptIDOF,
      ptGHOSTTYPEOF,
      ptCOLONCOLON,
      ptCONSTRUCTOR,
      ptBREAKPOINT,
      ptIMPORT,
      ptEXPORT,
      ptAUTOSEMI,
      ptELVIS,
      ptELVISEQ,
      ptSYMBOLNAME,
      ptSUPERCODESYMBOL,
      ptNULLISHOR
     );

     PPOCAMetaOp=^TPOCAMetaOp;
     TPOCAMetaOp=(
      pmoNONE,
      pmoADD,
      pmoSUB,
      pmoMUL,
      pmoDIV,
      pmoMOD,
      pmoPOW,
      pmoNEG,
      pmoLNOT,
      pmoBNOT,
      pmoBAND,
      pmoBOR,
      pmoBXOR,
      pmoBSHL,
      pmoBSHR,
      pmoBUSHR,
      pmoDEC,
      pmoINC,
      pmoEQ,
      pmoNEQ,
      pmoSEQ,
      pmoSNEQ,
      pmoLT,
      pmoLTEQ,
      pmoGT,
      pmoGTEQ,
      pmoIN,
      pmoINRANGE,
      pmoCONCAT,
      pmoCOMPARE,
      pmoEXIST,
      pmoGET,
      pmoSET,
      pmoDELETE,
      pmoSIZE,
      pmoCALL,
      pmoKEYS,
      pmoTONUMBER,
      pmoTOSTRING,
      pmoREGEXPEQ,
      pmoREGEXPNEQ,
      pmoSQRT
     );            

     PPOCATokenTypes=^TPOCATokenTypes;
     TPOCATokenTypes=set of TPOCATokenType;

     TPOCAStringTreeData=TPOCAInt64;

     PPOCAStringTreeNode=^TPOCAStringTreeNode;
     TPOCAStringTreeNode=record
      TheChar:ansichar;
      Data:TPOCAStringTreeData;
      DataExist:boolean;
      Previous,Next,Up,Down:PPOCAStringTreeNode;
     end;

     TPOCAStringTree=class
      private
       Root:PPOCAStringTreeNode;
       function CreateStringTreeNode(AChar:ansichar):PPOCAStringTreeNode;
       procedure DestroyStringTreeNode(Node:PPOCAStringTreeNode);
      public
       Hashing:boolean;
       constructor Create;
       destructor Destroy; override;
       procedure Clear;
       procedure DumpTree;
       procedure DumpList;
       procedure AppendTo(DestStringTree:TPOCAStringTree);
       procedure Optimize(DestStringTree:TPOCAStringTree);
       function Add(Content:TPOCARawByteString;Data:TPOCAStringTreeData;Replace:boolean=false):boolean;
       function Delete(Content:TPOCARawByteString):boolean;
       function Find(Content:TPOCARawByteString;var Data:TPOCAStringTreeData):boolean;
       function FindEx(Content:TPOCARawByteString;var Data:TPOCAStringTreeData;var Len:TPOCAInt32):boolean;
     end;

     PPOCAStringHashMapItem=^TPOCAStringHashMapItem;
     TPOCAStringHashMapItem=record
      Previous,Next,HashPrevious,HashNext:PPOCAStringHashMapItem;
      Hash:TPOCAUInt32;
      Key:TPOCARawByteString;
      Value:TPOCAInt64;
     end;

     TPOCAStringHashMapHashBucket=record
      HashFirst,HashLast:PPOCAStringHashMapItem;
     end;

     TPOCAStringHashMapHashBuckets=array of TPOCAStringHashMapHashBucket;

     TPOCAStringHashMap=class
      private
       LastUsedItem:PPOCAStringHashMapItem;
       procedure GrowAndRehashIfNeeded;
      protected
       function GetValue(const Key:TPOCARawByteString):TPOCAInt64;
       procedure SetValue(const Key:TPOCARawByteString;const Value:TPOCAInt64);
      public
       First,Last:PPOCAStringHashMapItem;
       HashBuckets:TPOCAStringHashMapHashBuckets;
       HashSize:TPOCAUInt32;
       HashSizeMask:TPOCAUInt32;
       HashedItems:TPOCAUInt32;
       HashBucketsUsed:TPOCAUInt32;
       Optimize:TPOCABool32;
       constructor Create(AOptimize:TPOCABool32);
       destructor Destroy; override;
       procedure Clear;
       function GetKey(const Key:TPOCARawByteString):PPOCAStringHashMapItem;
       function NewKey(const Key:TPOCARawByteString;Force:boolean=false):PPOCAStringHashMapItem;
       function DeleteKey(const Item:PPOCAStringHashMapItem):boolean;
       property Values[const Key:TPOCARawByteString]:TPOCAInt64 read GetValue write SetValue; default;
     end;

     TPOCAPointerList=class
      private
       List:PPOCAPointerArray;
       ListCount,ListCapacity:TPOCAInt32;
       function GetItem(Index:TPOCAInt32):TPOCAPointer;
       procedure SetItem(Index:TPOCAInt32;Value:TPOCAPointer);
      public
       constructor Create;
       destructor Destroy; override;
       procedure Clear;
       function Add(Item:TPOCAPointer):TPOCAInt32;
       procedure Insert(Index:TPOCAInt32;Item:TPOCAPointer);
       function Find(Item:TPOCAPointer):TPOCAInt32;
       function IndexOf(Item:TPOCAPointer):TPOCAInt32;
       procedure Delete(Index:TPOCAInt32);
       function Remove(Item:TPOCAPointer):TPOCAInt32;
       procedure Exchange(Index1,Index2:TPOCAInt32);
       procedure SetCapacity(NewCapacity:TPOCAInt32);
       procedure SetCount(NewCount:TPOCAInt32);
       property Count:TPOCAInt32 read ListCount write SetCount;
       property Capacity:TPOCAInt32 read ListCapacity write SetCapacity;
       property Items[Index:TPOCAInt32]:TPOCAPointer read GetItem write SetItem; default;
     end;

     PPOCAInstance=^TPOCAInstance;

     PPOCACoroutine=^TPOCACoroutine;

     TPOCACoroutineEntrypoint=procedure(Coroutine:PPOCACoroutine);

     TPOCACoroutine=record
      Fiber,Back:TPOCAPointer;
{$ifdef windows}
      FiberFPUCW,BackFPUCW:TPOCAUInt32;
{$endif}
      Entrypoint:TPOCACoroutineEntrypoint;
      Parameter:TPOCAPointer;
      State:TPOCAInt32;
      Resumed:TPasMPBool32;
      Terminated:TPasMPBool32;
      Event:{$ifdef fpc}PRTLEvent{$else}TEvent{$endif};
     end;

     TPOCAMetaOpNames=array[TPOCAMetaOp] of TPOCARawByteString;

     PPOCAValue=^TPOCAValue;
     PPOCAValues=^TPOCAValues;

{$ifdef POCAHasJIT}
     PPOCANativeCodeMemoryManagerBlock=^TPOCANativeCodeMemoryManagerBlock;
     TPOCANativeCodeMemoryManagerBlock=packed record
      Signature:TPOCAPtrUInt;
      Previous:PPOCANativeCodeMemoryManagerBlock;
      Next:PPOCANativeCodeMemoryManagerBlock;
      Size:TPOCAPtrUInt;
     end;

     PPOCANativeCodeMemoryManagerBlockContainer=^TPOCANativeCodeMemoryManagerBlockContainer;
     TPOCANativeCodeMemoryManagerBlockContainer=record
      Previous:PPOCANativeCodeMemoryManagerBlockContainer;
      Next:PPOCANativeCodeMemoryManagerBlockContainer;
      Base:TPOCAPointer;
      Size:TPOCAPtrUInt;
      Used:TPOCAPtrUInt;
      First:PPOCANativeCodeMemoryManagerBlock;
      Last:PPOCANativeCodeMemoryManagerBlock;
     end;

     PPOCANativeCodeMemoryManager=^TPOCANativeCodeMemoryManager;
     TPOCANativeCodeMemoryManager=record
      Instance:PPOCAInstance;
      PageSize:TPOCAPtrUInt;
      Alignment:TPOCAPtrUInt;
      First,Last:PPOCANativeCodeMemoryManagerBlockContainer;
     end;
{$endif}

     PPOCAMRSWLock=^TPOCAMRSWLock;
     TPOCAMRSWLock=record
      State:TPOCAInt32; // Sign bit is writer flag! 1.31 bit layout (1 bit writer count . 31 bit reader count)
     end;

{$ifdef POCAMemoryPools}
     PPOCAPoolBlock=^TPOCAPoolBlock;
{$endif}

     PPOCAObject=^TPOCAObject;

     PPOCAGarbageCollectorLinkedList=^TPOCAGarbageCollectorLinkedList;
     PPOCAGarbageCollectorLinkedListItem=^TPOCAGarbageCollectorLinkedListItem;
     TPOCAGarbageCollectorLinkedListItem=packed record
      List:PPOCAGarbageCollectorLinkedList;
      Previous:PPOCAGarbageCollectorLinkedListItem;
      Next:PPOCAGarbageCollectorLinkedListItem;
     end;

     TPOCAGarbageCollectorLinkedList=packed record
      Name:TPOCAUTF8String;
      First:PPOCAGarbageCollectorLinkedListItem;
      Last:PPOCAGarbageCollectorLinkedListItem;
      procedure Initialize(const aName:TPOCAUTF8String);
      procedure Finalize;
      function Empty:Boolean; {$ifdef caninline}inline;{$endif}
      function Filled:Boolean; {$ifdef caninline}inline;{$endif}
      procedure Push(Obj:PPOCAObject);
      function Pop(out Obj:PPOCAObject):boolean;
      function PopFromFront(out Obj:PPOCAObject):boolean;
      class procedure Remove(Obj:PPOCAObject); static; //{$ifdef caninline}inline;{$endif}
      function TakeOver(const Obj:PPOCAObject):boolean;
      function TakeOverAppend(const aSourceList:PPOCAGarbageCollectorLinkedList):boolean;
      function TakeOverAppendMark(const aSourceList:PPOCAGarbageCollectorLinkedList;const aBitsToAdd:TPOCAUInt32):boolean;
      class function Swap(var aList,aWithList:PPOCAGarbageCollectorLinkedList):boolean; static;
     end;

     PPOCAGarbageCollectorHeader=^TPOCAGarbageCollectorHeader;
     TPOCAGarbageCollectorHeader=packed record
      LinkedList:TPOCAGarbageCollectorLinkedListItem;
      State:TPOCAUInt32; // High 24 bits = survived cycles, low 8 bits = info bits
     end;

     PPOCAObjectHeader=^TPOCAObjectHeader;
     TPOCAObjectHeader=packed record
      GarbageCollector:TPOCAGarbageCollectorHeader;
      ValueType:TPOCAPtrInt;
{$ifndef POCAGarbageCollectorPoolBlockInstance}
      Instance:PPOCAInstance;
{$endif}
{$ifdef POCAMemoryPools}
      PoolBlock:PPOCAPoolBlock;
{$endif}
     end;

     PPPOCAObject=^PPOCAObject;
//   PPOCAObject=^TPOCAObject;
     TPOCAObject=packed record
      Header:TPOCAObjectHeader;
     end;

     PPPOCAObjects=^TPPOCAObjects;
     TPPOCAObjects=array[0..($7fffffff div sizeof(PPOCAObject))-1] of PPOCAObject;

     TPOCAStringUTF8Indices=array[0..2] of TPOCAPointer;

     PPOCAString=^TPOCAString;
     TPOCAString=packed record
      Header:TPOCAObjectHeader;
      Data:TPOCARawByteString;
      DataLength:TPOCAInt32;
      HashCode:TPOCAUInt32;
      UTF8Length:TPOCAInt32;
      UTF8CodePointsToCodeUnitsIndex:TPOCAPointer;
      UTF8CodeUnitsToCodePointsIndex:TPOCAPointer;
      UTF8CodePointsToCodeUnitsIndexSize:TPOCAUInt8;
      UTF8CodeUnitsToCodePointsIndexSize:TPOCAUInt8;
      UTF8:TPOCAUInt8;
      Dirty:bytebool;
     end;

     PPOCAArrayRecord=^TPOCAArrayRecord;

     PPOCAArray=^TPOCAArray;
     TPOCAArray=packed record
      Header:TPOCAObjectHeader;
      ArrayRecord:PPOCAArrayRecord;
     end;

     PPOCAHashRecord=^TPOCAHashRecord;

     PPOCAHash=^TPOCAHash;

     PPOCACode=^TPOCACode;

     PPOCAFunction=^TPOCAFunction;

     PPOCANativeCode=^TPOCANativeCode;

     PPOCAGhost=^TPOCAGhost;

     TPOCAValueReference=packed record
      case TPOCAUInt8 of
       pvtREFERENCE:(Obj:PPOCAObject);
       pvtSTRING:(StringObject:PPOCAString);
       pvtARRAY:(ArrayObject:PPOCAArray);
       pvtHASH:(HashObject:PPOCAHash);
       pvtCODE:(CodeObject:PPOCACode);
       pvtFUNCTION:(FunctionObject:PPOCAFunction);
       pvtNATIVECODE:(NativeCodeObject:PPOCANativeCode);
       pvtGHOST:(GhostObject:PPOCAGhost);
       pvtCOUNT:(Ptr:TPOCAPointer);
     end;

     TPOCAValue=packed record
      case TPOCAUInt8 of
       0:(Num:double);
       1:({$ifdef cpu64}Reference:TPOCAValueReference;{$else}{$ifdef LITTLE_ENDIAN}Reference:TPOCAValueReference;ReferenceTag:TPOCAUInt32;{$else}ReferenceTag:TPOCAUInt32;Reference:TPOCAValueReference;{$endif}{$endif});
       2:(CastedInt64:TPOCAInt64);
       3:(CastedUInt64:TPOCAUInt64);
       4:({$ifdef LITTLE_ENDIAN}CastedLo,CastedHi{$else}CastedHi,CastedLo{$endif}:TPOCAUInt32);
     end;

     TPOCAValueArray=array of TPOCAValue;
     PPOCAValueArray=^TPOCAValueArray;

     TPOCAValues=array[0..($7fffffff div sizeof(TPOCAValue))-1] of TPOCAValue;

     TPOCAValueArrayArray=array of TPOCAValueArray;

     TPPOCAValueArray=array of PPOCAValues;

//     TPPOCAValues=array[0..($7fffffff div sizeof(PPOCAValues))-1] of PPOCAValues;
//    PPPOCAValues=^TPPOCAValues;

     PPOCAHashEntity=^TPOCAHashEntity;
     TPOCAHashEntity=record
      Key:TPOCAValue;
      Value:TPOCAValue;
      Constant:Boolean;
     end;

     PPOCAHashEntityIndex=^TPOCAHashEntityIndex;
     TPOCAHashEntityIndex=array[0..($7fffffff div sizeof(TPOCAInt32))-1] of TPOCAInt32;

     PPOCAHashEntities=^TPOCAHashEntities;
     TPOCAHashEntities=array[0..($7fffffff div sizeof(TPOCAHashEntity))-1] of TPOCAHashEntity;

     PPPOCAHashEntities=^TPPOCAHashEntities;
     TPPOCAHashEntities=array[0..($7fffffff div sizeof(PPOCAHashEntity))-1] of PPOCAHashEntity;

     PPOCAHashEvents=^TPOCAHashEvents;
     TPOCAHashEvents=array[TPOCAMetaOp] of TPOCAValue;

     TPOCAHashRecord=record
      RealSize:TPOCAInt32;
      LogSize:TPOCAInt32;
      Size:TPOCAInt32;
      CellToEntityIndex:PPOCAHashEntityIndex;
      EntityToCellIndex:PPOCAHashEntityIndex;
      Entities:PPOCAHashEntities;
      Events:PPOCAHashEvents;
     end;

     TPOCAHashChildren=record
      First,Last:PPOCAHash;
      Previous,Next:PPOCAHash;
     end;

     TPOCAHashCache=record
      MRSWLock:TPOCAMRSWLock;
      Ready:TPOCABool32;
      ChainCount:TPOCAInt32;
      ChainEntities:PPPOCAHashEntities;
     end;

     TPOCAHash=packed record
      Header:TPOCAObjectHeader;
      HashRecord:PPOCAHashRecord;
      Children:TPOCAHashChildren;
      Prototype:PPOCAHash;
      Constructor_:PPOCAObject;
      Events:PPOCAHash;
      Ghost:PPOCAGhost;
      Kind:TPOCAInt32;
      Cache:TPOCAHashCache;
     end;

     TPOCAArrayRecord=record
      Size:TPOCAInt32;
      Allocated:TPOCAInt32;
      Data:array[0..0] of TPOCAValue;
     end;

     PPOCACodeLine=^TPOCACodeLine;
     TPOCACodeLine=record
      InstructionPointer:TPOCAUInt32;
      Line:TPOCAUInt32;
     end;

     TPOCACodeLines=array of TPOCACodeLine;

     TPOCACodeArgument=record
      public
       const pcakVAR=0;
             pcakREG=1;
             pcakFRAMEVALUE=2;
      public
       Kind:TPOCAUInt32;
       Level:TPOCAInt32;
       Index:TPOCAInt32;
     end;
     PPOCACodeArgument=^TPOCACodeArgument;

     TPOCACodeArguments=array[0..($7fffffff div sizeof(TPOCACodeArgument))-1] of TPOCACodeArgument;
     PPOCACodeArguments=^TPOCACodeArguments;

     TPOCACode=packed record
      Header:TPOCAObjectHeader;
      Name:TPOCARawByteString;
      Level:TPOCAInt32;
      UseFrameValues:TPOCABool32;
      CountFrameValues:TPOCAInt32;
      ClassFunction:TPOCABool32;
      FastFunction:TPOCABool32;
      IsEmpty:TPOCABool32;
      LocalsAsThisObj:TPOCABool32;
      CountRegisters:TPOCAUInt32;
      CountArguments:TPOCAUInt32;
      CountOptionalArguments:TPOCAUInt32;
      NeedArgumentArray:TPOCABool32;
      HasArguments:TPOCABool32;
      HasRestArguments:TPOCABool32;
      ConstantCount:TPOCAUInt32;
      ByteCode:PPOCAUInt32Array;
      ByteCodeSize:TPOCAUInt32;
      Constants:PPOCAValues;
      HasArgumentLocals:TPOCABool32;
      ArgumentSymbols:PPOCAInt32Array;
      ArgumentLocals:PPOCACodeArguments;
      OptionalArgumentSymbols:PPOCAInt32Array;
      OptionalArgumentLocals:PPOCACodeArguments;
      OptionalArgumentValues:PPOCAInt32Array;
      RegExps:PPOCAValues;
      CountRegExps:TPOCAUInt32;
      Lines:TPOCACodeLines;
      SourceFile:TPOCAInt32;
      RestArgSym:TPOCAUInt32;
{$ifdef POCAHasJIT}
      NativeCode:TPOCAPointer;
      NativeCodeSize:TPOCAUInt32;
      ByteCodeToNativeCodeMap:array of TPOCAUInt32;
      InterpretByteCodeMap:array of bytebool;
{$endif}
     end;

     TPOCAFunction=packed record
      Header:TPOCAObjectHeader;
      Code:TPOCAValue;
      Namespace:TPOCAValue;
      Obj:TPOCAValue;
{$ifdef POCAClosureArrayValues}
      ClosureValues:TPOCAValue;
{$else}
      ClosureValues:TPOCAValueArrayArray;
{$endif}
      Next:TPOCAValue;
     end;

     PPOCAFrame=^TPOCAFrame;
     TPOCAFrame=record
      Func:TPOCAValue;
      Locals:TPOCAValue;
      Obj:TPOCAValue;
      InstructionPointer:TPOCAInt32;
      ResultRegister:TPOCAUInt32;
      Registers:TPOCAValueArray;
      CountRegisters:TPOCAInt32;
      Arguments:TPOCAValueArray;
      CountArguments:TPOCAInt32;
{$ifdef POCAClosureArrayValues}
      LocalValues:TPOCAValue;
      OuterValueLevels:TPOCAValue;
{$else}
      LocalValues:TPOCAValueArray;
      OuterValueLevels:TPOCAValueArrayArray;
{$endif}
      CountOuterValueLevels:TPOCAInt32;
     end;

     TPOCANativeFunction=function(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;

     TPOCANativeDestroyFunction=procedure(const UserData:TPOCAPointer);

     TPOCANativeCode=record
      Header:TPOCAObjectHeader;
      FunctionPointer:TPOCANativeFunction;
      DestroyFunctionPointer:TPOCANativeDestroyFunction;
      UserData:TPOCAPointer;
     end;

     PPOCAGhostType=^TPOCAGhostType;
     TPOCAGhostType=record
      Destroy:procedure(const Ghost:PPOCAGhost);
      CanDestroy:function(const Ghost:PPOCAGhost):TPOCABool32;
      Mark:function(const Ghost:PPOCAGhost):TPOCABool32;
      ExistKey:function(const Context:PPOCAContext;const Ghost:PPOCAGhost;const aKey:TPOCAValue;const aCacheIndex:PPOCAUInt32):TPOCABool32;
      GetKey:function(const Context:PPOCAContext;const Ghost:PPOCAGhost;const aKey:TPOCAValue;out aValue:TPOCAValue;const aCacheIndex:PPOCAUInt32):TPOCABool32;
      SetKey:function(const Context:PPOCAContext;const Ghost:PPOCAGhost;const aKey:TPOCAValue;const aValue:TPOCAValue;const aCacheIndex:PPOCAUInt32):TPOCABool32;
      Name:TPOCARawByteString;
     end;

     PPOCAGhostPtrType=^TPOCAGhostPtrType;
     TPOCAGhostPtrType=(pgptRAW,pgptOBJECT);

     TPOCAGhost=record
      Header:TPOCAObjectHeader;
      GhostType:PPOCAGhostType;
      PtrType:TPOCAGhostPtrType;
      Ptr:TPOCAPointer;
      Hash:PPOCAHash;
     end;

{$ifdef POCAMemoryPools}

     TPOCAPoolBlock=record
{$ifdef POCAGarbageCollectorPoolBlockReferenceCounting}
      ReferenceCounter:TPOCAInt32;
{$endif}
{$ifdef POCAGarbageCollectorPoolBlockInstance}
      Instance:PPOCAInstance;
{$endif}
      Data:TPOCAPointer;
      Size:TPOCAInt32;
      Previous:PPOCAPoolBlock;
      Next:PPOCAPoolBlock;
     end;

     PPOCAPool=^TPOCAPool;
     TPOCAPool=record
      Instance:PPOCAInstance;
      ValueType:TPOCAInt32;
      ElementRealSize:TPOCAInt32;
      ElementSize:TPOCAInt32;
      Size:TPOCAInt32;
      FreeObjects:PPPOCAObjects;
      FreeSize:TPOCAInt32;
      FreeCount:TPOCAInt32;
//    FreeLock:TPOCAInt32;
      FirstBlock:PPOCAPoolBlock;
      LastBlock:PPOCAPoolBlock;
     end;

     PPOCAPools=^TPOCAPools;
     TPOCAPools=array[0..pvtCOUNT-1] of TPOCAPool;

     PPOCAContextObjectPool=^TPOCAContextObjectPool;
     TPOCAContextObjectPool=record
      Objects:PPPOCAObjects;
      Size:TPOCAPtrInt;
      Count:TPOCAPtrInt;
     end;

     PPOCAContextObjectPools=^TPOCAContextObjectPools;
     TPOCAContextObjectPools=array[0..pvtCOUNT-1] of TPOCAContextObjectPool;

{$endif}

     TPOCAGarbageCollectorState=(pgcsRESET,pgcsINIT,pgcsMARKROOTS,pgcsMARKPROTECTED,pgcsMARKGREYS,pgcsSWEEPINIT,pgcsMARKWHITEGHOSTS,pgcsMARKWHITEGHOSTGREYS,pgcsSWEEP,pgcsFLIP,pgcsDONE);

     PPOCAGarbageCollector=^TPOCAGarbageCollector;
     TPOCAGarbageCollector=record

      Instance:PPOCAInstance;
     
      WhiteMask:TPOCAUInt32;
      BlackMask:TPOCAUInt32;

      // Ephemeral generation
      WhiteLists:array[boolean] of PPOCAGarbageCollectorLinkedList;
      GrayList:TPOCAGarbageCollectorLinkedList;
      BlackLists:array[boolean] of PPOCAGarbageCollectorLinkedList;

      // Persistent generation
      PersistentLists:array[boolean] of TPOCAGarbageCollectorLinkedList;
      PersistentRootLists:array[boolean] of TPOCAGarbageCollectorLinkedList;

      // Sweeping stuff
      WhiteGhostList:TPOCAGarbageCollectorLinkedList;
      SweepLists:array[boolean] of TPOCAGarbageCollectorLinkedList;

      // Other stuff
      State:TPOCAGarbageCollectorState;
      LastFullCycleCounter:TPOCAUInt64;
      FullCycleCounter:TPOCAUInt64;
      Lock:TPOCAPointer;
      ProtectList:TPOCAPointerList;
      Allocated:TPOCAInt32;
      FreeCount:TPOCAInt32;
      FullAllocationCounter:TPOCAInt32;
      AllocationCounter:TPOCAInt32;
      PersistentCycleCounter:TPOCAInt32;
      PersistentForceScan:TPOCABool32;
      DynamicThreshold:TPasMPBool32;
      IncrementalCollectionThresholdFactor:TPOCAInt32;
      FullCollectionThresholdFactor:TPOCAInt32;
      MarkFactor:TPOCAInt32;
      GhostFactor:TPOCAInt32;
      SweepFactor:TPOCAInt32;
      PersistentThreshold:TPOCAInt32;
      PersistentInterval:TPOCAInt32;
      ExhaustionCollect:TPOCABool32;
      ExhaustionIncrementalFullCycleThreshold:TPOCAInt32;
      ExhaustionIncrementalFullCycleCounter:TPOCAInt32;
      Active:TPOCABool32;
      Incremental:TPOCABool32;
      Generational:TPOCABool32;
      LocalContextPoolSize:TPOCAInt32;
      ContextCacheSize:TPOCAInt32;
      MinimumBlockSize:TPOCAInt32;
      ScanContextGrays:TPasMPBool32;

      function IsWhite(const Obj:PPOCAObject):Boolean;
      class function IsGray(const Obj:PPOCAObject):Boolean; static;
      function IsBlack(const Obj:PPOCAObject):Boolean;
      function IsGrayOrBlack(const Obj:PPOCAObject):Boolean;

      procedure WriteBarrierMark(const Obj:PPOCAObject);
      procedure WriteBarrierMarkParent(const ParentObj:PPOCAObject);
      procedure WriteBarrierPersistent(const ParentObj:PPOCAObject);
      procedure WriteBarrierNonPersistent(const Obj:PPOCAObject);
      procedure WriteBarrierObject(const ParentObj,Obj:PPOCAObject);
      class procedure WriteBarrier(const ParentObj:PPOCAObject;const Value:TPOCAValue); static;

      function MarkObjectAsGray(Obj:PPOCAObject):boolean;
      function MarkValue(const Value:TPOCAValue):boolean;
      function MarkArrayAsGray(Obj:PPOCAArray):boolean;
      function MarkHashAsGray(Obj:PPOCAHash):boolean;
      function MarkCodeAsGray(Obj:PPOCACode):boolean;
      function MarkFunctionAsGray(Obj:PPOCAFunction):boolean;
      function MarkGhostAsGray(Obj:PPOCAGhost):boolean;

      procedure TryMarkGhostAsGray(Obj:PPOCAObject);

      function MarkObjectContent(Obj:PPOCAObject):boolean;

      procedure MarkObject(Obj:PPOCAObject);

      procedure MarkTemporarySavedObjects(Context:PPOCAContext);

      procedure MarkGlobals;

      function MarkContexts:boolean;

      function MarkContextGrays:boolean;

      procedure MarkPersistents;

      procedure MarkRoots;

      procedure MarkProtected;

      procedure Reset;

      procedure Init;

      procedure Flip;

      function CollectCycle:boolean;

      procedure CollectAll;
      
     end;

     TPOCARequestGarbageCollection=(prgcNONE,prgcCYCLE,prgcFULLEPHEMERAL,prgcFULL);

     TPOCAModuleLoaderFunction=function(const aContext:PPOCAContext;const aModuleName:TPOCAUTF8String;out aModuleCode,aModuleFileName:TPOCAUTF8String;out aModuleDateTime:TDateTime):Boolean;

     TPOCAModuleLoaderFunctions=array of TPOCAModuleLoaderFunction;

     PPOCAGlobals=^TPOCAGlobals;
     TPOCAGlobals=record

      Instance:PPOCAInstance;

      StrictMode:TPOCABool32;

{$ifdef POCAMemoryPools}
      Pools:TPOCAPools;
{$endif}

{$ifdef POCAHasJIT}
      NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;
{$endif}

      GarbageCollector:TPOCAGarbageCollector;

      DeadBlocks:PPOCAPointer;
      DeadSize:TPOCAInt32;
      DeadCount:TPOCAInt32;
      DeadAllocationCount:TPOCAInt32;

      ThreadCount:TPOCAInt32;
      WaitCount:TPOCAInt32;
      RequestGarbageCollection:TPOCARequestGarbageCollection;
      Bottleneck:TPOCABool32;
      Lock:TPOCAPointer;
      Semaphore:TPOCAPointer;

      SourceFiles:TPOCAValue;

      UniqueStringArray:TPOCAValue;
      UniqueStringHashMap:TPOCAStringHashMap;
      UniqueStringLock:TPOCAPointer;

      ArgumentsValueReference:TPOCAValue;
      ConstructorValueReference:TPOCAValue;

      NullValueReference:TPOCAValue;
      ReferenceValueReference:TPOCAValue;
      NumberValueReference:TPOCAValue;
      StringValueReference:TPOCAValue;
      ArrayValueReference:TPOCAValue;
      GhostClassValueReference:TPOCAValue;
      ClassValueReference:TPOCAValue;
      GhostModuleValueReference:TPOCAValue;
      ModuleValueReference:TPOCAValue;
      GhostHashValueReference:TPOCAValue;
      HashValueReference:TPOCAValue;
      FunctionValueReference:TPOCAValue;
      ClassGhostValueReference:TPOCAValue;  
      ModuleGhostValueReference:TPOCAValue;
      HashGhostValueReference:TPOCAValue;
      GhostValueReference:TPOCAValue;
      CodeValueReference:TPOCAValue;
      NativeCodeValueReference:TPOCAValue;
      UnknownValueReference:TPOCAValue;
      LengthStringReference:TPOCAValue;

      Symbols:TPOCAValue;

      Save:TPOCAValue;

      Namespace:TPOCAValue;

      HiddenNamespace:TPOCAValue;

      RootArray:TPOCAValue;
      RootHash:TPOCAValue;

      ModuleScopes:TPOCAValue;
      ModuleValues:TPOCAValue;
      ModuleTimes:TPOCAValue;

      BaseClass:TPOCAValue;

      ArrayHash:TPOCAValue;
      HashHash:TPOCAValue;
      NumberHash:TPOCAValue;
      StringHash:TPOCAValue;
      IOHash:TPOCAValue;
      RegExpHash:TPOCAValue;
      CoroutineHash:TPOCAValue;
      ThreadHash:TPOCAValue;
      LockHash:TPOCAValue;
      SemaphoreHash:TPOCAValue;

      FreeContextCount:TPOCAInt32;
      FreeContexts:PPOCAContext;

      ModuleLoaderFunctions:TPOCAModuleLoaderFunctions;
      CountModuleLoaderFunctions:TPOCAInt32;

{$if defined(fpc) and defined(Unix)}
      OriginalTerm:TTermios;
{$elseif defined(Windows)}
      ConsoleInputHandle:Windows.THandle;
      ConsoleOutputHandle:Windows.THandle;
      OldConsoleModeIn:DWORD;
      OldConsoleModeOut:DWORD;
{$ifend}

      FirstContext:PPOCAContext;
      LastContext:PPOCAContext;

      HostData:TPOCAPointer;
      HostDataFreeable:TPOCABool32;

     end;

     PPOCAFrameStack=^TPOCAFrameStack;
     TPOCAFrameStack=array[0..POCA_MAX_RECURSION-1] of TPOCAFrame;

     TPOCAUserIOWrite=procedure(const aContext:PPOCAContext;const aString:TPOCAUTF8String);
     TPOCAUserIOWriteLn=procedure(const aContext:PPOCAContext;const aString:TPOCAUTF8String);
     TPOCAUserIOReadLn=procedure(const aContext:PPOCAContext;out aString:TPOCAUTF8String;out aNull:Boolean);
     TPOCAUserIOFlush=procedure(const aContext:PPOCAContext);

     TPOCAContext=record

      Instance:PPOCAInstance;

      Active:TPOCABool32;

      GarbageCollectorLockCount:TPOCAInt32;

{$ifdef POCAMemoryPools}
      ContextObjectPools:TPOCAContextObjectPools;
{$endif}

      FrameStack:TPOCAFrameStack;
      FrameTop:TPOCAInt32;

      TemporarySavedObjects:PPPOCAObjects;
      TemporarySavedObjectCount:TPOCAInt32;
      TemporarySavedObjectSize:TPOCAInt32;

      GrayList:TPOCAGarbageCollectorLinkedList;

      CallDepth:TPOCAInt32;
      CallParent:PPOCAContext;
      CallChild:PPOCAContext;

      CoroutineData:TPOCAPointer;

      ThreadData:TPOCAPointer;

      UserData:TPOCAPointer;

      UserIOWrite:TPOCAUserIOWrite;
      UserIOWriteLn:TPOCAUserIOWriteLn;
      UserIOReadLn:TPOCAUserIOReadLn;
      UserIOFlush:TPOCAUserIOFlush;

      NextFree:PPOCAContext;

      Previous:PPOCAContext;
      Next:PPOCAContext;

     end;

     TPOCAInstance=record
      Globals:TPOCAGlobals;
      SourceFiles:TStringList;
      IncludeDirectories:TStringList;
      AutomaticSemicolonInsertion:boolean;
     end;

     EPOCAError=class(Exception)
      public
       SourceFile,SourceLine,SourceColumn:TPOCAInt32;
       Value:TPOCAValue;
       constructor Create(const AMessage:TPOCAUTF8String); overload;
       constructor Create(const ASourceFile,ASourceLine,ASourceColumn:TPOCAInt32;const AMessage:TPOCAUTF8String); overload;
       constructor Create(const AValue:TPOCAValue); overload;
       constructor Create(const ASourceFile,ASourceLine,ASourceColumn:TPOCAInt32;const AValue:TPOCAValue); overload;
     end;

     EPOCASyntaxError=class(EPOCAError);

     EPOCARuntimeError=class(EPOCAError);

     EPOCAScriptError=class(EPOCAError);

     EPOCACoroutineTerminated=class(EPOCAError);

     EPOCARegExpNFACollectError=class(EPOCAError);

     TPOCANativeObjectMethod=function(const Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32):TPOCAValue of object;

     PPOCANativeObjectProperty=^TPOCANativeObjectProperty;
     TPOCANativeObjectProperty=record
      Key:TPOCAValue;
      PropInfo:PPropInfo;
      Method:TPOCANativeObjectMethod;
      Value:TPOCAValue;
     end;

     TPOCANativeObjectProperties=array of TPOCANativeObjectProperty;

     TPOCANativeObject=class
      private
       fInstance:PPOCAInstance;
       fExpandable:boolean;
       fPropList:PPropList;
       fPropListLen:TPOCAInt32;
       fPropHashMap:TPOCAStringHashMap;
       fProperties:TPOCANativeObjectProperties;
       fCountProperties:TPOCAInt32;
       fGhostType:TPOCAGhostType;
       fGhostValue:TPOCAValue;
       fHashValue:TPOCAValue;
       fEventsHashValue:TPOCAValue;
      public
       constructor Create(const aInstance:PPOCAInstance;const aContext:PPOCAContext;const aPrototype,aConstructor:PPOCAValue;const aExpandable:boolean); reintroduce; virtual;
       destructor Destroy; override;
       function Mark:boolean; virtual;
       function FindPropertyIndex(const Context:PPOCAContext;const Key:TPOCAValue;const CacheIndex:PLongword=nil):TPOCAInt32; virtual;
       function GetPropertyValue(const Context:PPOCAContext;const PropertyIndex:TPOCAInt32;var Value:TPOCAValue):boolean; virtual;
       function SetPropertyValue(const Context:PPOCAContext;const PropertyIndex:TPOCAInt32;const Value:TPOCAValue):boolean; virtual;
       property Instance:PPOCAInstance read fInstance;
       property Expandable:boolean read fExpandable;
       property GhostValue:TPOCAValue read fGhostValue;
       property HashValue:TPOCAValue read fHashValue;
       property EventsHashValue:TPOCAValue read fEventsHashValue;
     end;

const POCAValueNull:TPOCAValue=({$ifdef cpu64}Reference:(Ptr:TPOCAPointer(TPOCAPtrUInt(POCAValueReferenceSignalMask)));{$else}{$ifdef LITTLE_ENDIAN}Reference:(Ptr:nil);ReferenceTag:POCAValueReferenceTag;{$else}ReferenceTag:POCAValueReferenceTag;Reference:(Ptr:nil);{$endif}{$endif});
      POCAValueNullCastedUInt64={$ifdef cpu64}TPOCAUInt64(TPOCAPtrUInt(POCAValueReferenceSignalMask)){$else}TPOCAUInt64(TPOCAUInt64(POCAValueReferenceTag) shl 32){$endif};

      POCATypeSizes:array[pvtNULL..pvtGHOST] of TPOCAInt32=(-1, // pvtNULL
                                                            -1, // pvtNUMBER
                                                            -1, // pvtREFERENCE
                                                            sizeof(TPOCAString),
                                                            sizeof(TPOCAArray),
                                                            sizeof(TPOCAHash),
                                                            sizeof(TPOCACode),
                                                            sizeof(TPOCAFunction),
                                                            sizeof(TPOCANativeCode),
                                                            sizeof(TPOCAGhost));

      POCADefaultFormatSettings:TFormatSettings=(
{$ifdef DelphiXEAndUp}
        CurrencyString:'$';
        CurrencyFormat:1;
        CurrencyDecimals:2;
        DateSeparator:'-';
        TimeSeparator:':';
        ListSeparator:',';
        ShortDateFormat:'d/m/y';
        LongDateFormat:'dd" "mmmm" "yyyy';
        TimeAMString:'AM';
        TimePMString:'PM';
        ShortTimeFormat:'hh:nn';
        LongTimeFormat:'hh:nn:ss';
        ShortMonthNames:('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec');
        LongMonthNames:('January','February','March','April','May','June','July','August','September','October','November','December');
        ShortDayNames:('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
        LongDayNames:('Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday');
        ThousandSeparator:',';
        DecimalSeparator:'.';
        TwoDigitYearCenturyWindow:50;
        NegCurrFormat:5;
{$else}
       CurrencyFormat:1;
       NegCurrFormat:5;
       ThousandSeparator:',';
       DecimalSeparator:'.';
       CurrencyDecimals:2;
       DateSeparator:'-';
       TimeSeparator:':';
       ListSeparator:',';
       CurrencyString:'$';
       ShortDateFormat:'d/m/y';
       LongDateFormat:'dd" "mmmm" "yyyy';
       TimeAMString:'AM';
       TimePMString:'PM';
       ShortTimeFormat:'hh:nn';
       LongTimeFormat:'hh:nn:ss';
       ShortMonthNames:('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec');
       LongMonthNames:('January','February','March','April','May','June','July','August','September','October','November','December');
       ShortDayNames:('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
       LongDayNames:('Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday');
       TwoDigitYearCenturyWindow:50;
{$endif}
      );

      POCALocaleCharset:TPOCAUTF8String='UTF8';

{$ifdef BIG_ENDIAN}
      POCADoubleNaN:TPOCADoubleBytes=($7f,$ff,$ff,$ff,$ff,$ff,$ff,$ff);
      POCADoubleInfPos:TPOCADoubleBytes=($7f,$f0,$00,$00,$00,$00,$00,$00);
      POCADoubleInfNeg:TPOCADoubleBytes=($ff,$f0,$00,$00,$00,$00,$00,$00);
      POCADoubleMax:TPOCADoubleBytes=($7f,$ef,$ff,$ff,$ff,$ff,$ff,$ff);
      POCADoubleMin:TPOCADoubleBytes=($00,$00,$00,$00,$00,$00,$00,$01);
{$else}
      POCADoubleNaN:TPOCADoubleBytes=($ff,$ff,$ff,$ff,$ff,$ff,$ff,$7f);
      POCADoubleInfPos:TPOCADoubleBytes=($00,$00,$00,$00,$00,$00,$f0,$7f);
      POCADoubleInfNeg:TPOCADoubleBytes=($00,$00,$00,$00,$00,$00,$f0,$ff);
      POCADoubleMax:TPOCADoubleBytes=($ff,$ff,$ff,$ff,$ff,$ff,$ef,$7f);
      POCADoubleMin:TPOCADoubleBytes=($01,$00,$00,$00,$00,$00,$00,$00);
{$endif}
      POCADoubleZero:double=0.0;
      POCADoubleOne:double=1.0;

var POCALocaleFormatSettings:TFormatSettings;

{$ifdef POCAHasJIT}
{$ifdef unix}
    fpmprotect:function(__addr:TPOCAPointer;__len:cardinal;__prot:TPOCAInt32):TPOCAInt32; cdecl;// external 'c' name 'mprotect';
{$endif}
{$endif}

function POCARoundUpToPowerOfTwo(x:TPOCAPtrUInt):TPOCAPtrUInt; {$ifdef caninline}inline;{$endif}
function POCARoundUpToMask(x,m:TPOCAPtrUInt):TPOCAPtrUInt; {$ifdef caninline}inline;{$endif}

function POCAIsNaN(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsFinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsPosInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsNegInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsPosZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsNegZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsNegative(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}

function POCADoubleAbsolute(const AValue:double):double; {$ifdef caninline}inline;{$endif}

function POCADoubleToString(const AValue:double):TPOCARawByteString;

function POCARegExpCompile(Context:PPOCAContext;const s:TPOCARawByteString;IsUTF8:TPOCAInt32):TFLRE;

function POCAGetValueType(const v:TPOCAValue):TPOCAInt32; {$ifdef caninline}inline;{$endif}
function POCAGetValueReferencePointer(const v:TPOCAValue):TPOCAPointer; {$ifdef caninline}inline;{$endif}
procedure POCASetValueReferencePointer(out v:TPOCAValue;const Ptr:TPOCAPointer); {$ifdef caninline}inline;{$endif}
procedure POCASetValueNumber(out v:TPOCAValue;const n:double); {$ifdef caninline}inline;{$endif}

function POCAIsValueReference(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueNumber(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueObject(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueObjectAndGetReferencePointer(const v:TPOCAValue;var p):boolean;
function POCAIsValueNull(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueReferenceType(const v:TPOCAValue;t:TPOCAInt32):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueSimpleHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueEventHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueGhostEventHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAGetValueHashType(const v:TPOCAValue):TPOCAInt32; {$ifdef caninline}inline;{$endif}
function POCAIsValueCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueFunction(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueFunctionOrNativeCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueNativeCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueGhost(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueScalarType(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueIdentical(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}

function POCALockCreate:TPOCAPointer;
procedure POCALockDestroy(var Lock:TPOCAPointer);
procedure POCALockEnter(Lock:TPOCAPointer);
procedure POCALockLeave(Lock:TPOCAPointer);

function POCASemaphoreCreate:TPOCAPointer;
procedure POCASemaphoreDestroy(var Semaphore:TPOCAPointer);
procedure POCASemaphoreDown(Semaphore:TPOCAPointer);
procedure POCASemaphoreUp(Semaphore:TPOCAPointer;Count:TPOCAInt32);

procedure POCAWait; {$ifdef cpu386}register;{$endif}

procedure POCAMRSWLockInit(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockDone(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockReadLock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockReadUnlock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockWriteLock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockWriteUnlock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockReadToWrite(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockWriteToRead(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
function POCAMRSWLockReaders(MRSWLock:PPOCAMRSWLock):TPOCAInt32; {$ifdef cpu386}register;{$endif}
function POCAMRSWLockWriters(MRSWLock:PPOCAMRSWLock):TPOCAInt32; {$ifdef cpu386}register;{$endif}

function POCAGarbageCollectorProcessIncrementalCycle(const Instance:PPOCAInstance):Boolean;
procedure POCAGarbageCollectorProcessFullCycle(const Instance:PPOCAInstance);

procedure POCAGarbageCollectorWriteBarrier(const ParentObj:PPOCAObject;const Value:TPOCAValue);

procedure POCATemporarySave(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}
procedure POCAResetTemporarySaves(Context:PPOCAContext); {$ifdef UseRegister}register;{$endif}

procedure POCAProtect(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}
procedure POCAUnprotect(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}

function POCATypeOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;

function POCAIDOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;

function POCAGhostTypeOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;

function POCAObject(Instance:PPOCAInstance;ValueType:TPOCAInt32;Obj:PPOCAObject):TPOCAValue;

function POCAIsValueTrue(Context:PPOCAContext;const Value:TPOCAValue):boolean; {$ifdef UseRegister}register;{$endif}

function POCABooleanValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCANumberValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCAStringValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}

function POCAGetBooleanValue(Context:PPOCAContext;const Value:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAGetNumberValue(Context:PPOCAContext;const Value:TPOCAValue):double; {$ifdef caninline}inline;{$endif}
function POCAGetStringValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCARawByteString; {$ifdef caninline}inline;{$endif}
function POCAGetVariantValue(Context:PPOCAContext;const Value:TPOCAValue):Variant; {$ifdef caninline}inline;{$endif}

function POCAIsStringUTF8(Context:PPOCAContext;const Value:TPOCAValue):boolean;
function POCAGetStringUTF8(Context:PPOCAContext;const Value:TPOCAValue):TPOCAInt32;
function POCAGetStringUTF8Length(Context:PPOCAContext;const Value:TPOCAValue):TPOCAInt32;

function POCANew(Context:PPOCAContext;ValueType:TPOCAInt32;var Obj:PPOCAObject):TPOCAValue;

function POCAStringUTF8GetCodeUnit(Context:PPOCAContext;const Value:TPOCAValue;CodePoint:TPOCAInt32):TPOCAInt32;
function POCAStringUTF8GetCodePoint(Context:PPOCAContext;const Value:TPOCAValue;CodeUnit:TPOCAInt32):TPOCAInt32;
function POCAStringUTF8CopyCodePointRange(Context:PPOCAContext;const Value:TPOCAValue;FromCodePoint,ToCodePoint:TPOCAInt32):TPOCARawByteString;
procedure POCAStringUpdate(Context:PPOCAContext;const Value:TPOCAValue);

function POCANewNumber(Context:PPOCAContext;const Data:double=0.0):TPOCAValue;
function POCANewString(Context:PPOCAContext;const Data:TPOCARawByteString=''):TPOCAValue;
function POCANewUniqueString(Context:PPOCAContext;const Data:TPOCARawByteString=''):TPOCAValue;
function POCANewArray(Context:PPOCAContext):TPOCAValue;
function POCANewHash(Context:PPOCAContext):TPOCAValue;
function POCANewCode(Context:PPOCAContext):TPOCAValue;
function POCANewNativeCode(Context:PPOCAContext;const FunctionPointer:TPOCANativeFunction;const DestroyFunctionPointer:TPOCANativeDestroyFunction=nil;const UserData:TPOCAPointer=nil):TPOCAValue;
function POCANewFunction(Context:PPOCAContext;const Code:TPOCAValue):TPOCAValue;
function POCANewGhost(Context:PPOCAContext;const GhostType:PPOCAGhostType;const Ptr:TPOCAPointer;const Hash:PPOCAHash=nil;const PtrType:TPOCAGhostPtrType=pgptRAW):TPOCAValue;
function POCANewNativeObject(Context:PPOCAContext;const NativeObjectValue:TPOCANativeObject):TPOCAValue;
function POCANewValueFromVariant(Context:PPOCAContext;const VariantValue:Variant):TPOCAValue;

function POCAGhostGetType(const r:TPOCAValue):PPOCAGhostType; {$ifdef caninline}inline;{$endif}
function POCAGhostGetPointer(const r:TPOCAValue):TPOCAPointer; {$ifdef caninline}inline;{$endif}
function POCAGhostFastGetPointer(const r:TPOCAValue):TPOCAPointer; {$ifdef caninline}inline;{$endif}
function POCAGhostGetHash(const r:TPOCAValue):PPOCAHash; {$ifdef caninline}inline;{$endif}
function POCAGhostGetHashValue(const r:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCAGhostSetHash(const r:TPOCAValue;const h:PPOCAHash):boolean; {$ifdef caninline}inline;{$endif}
function POCAGhostSetHashValue(const r,h:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}

procedure POCAAtomicSetValue(var Dst:TPOCAValue;const Src:TPOCAValue);
function POCANil:TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCAEndToken:TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCANumber(Num:double):TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCAString(Context:PPOCAContext;const Str:TPOCARawByteString):TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCAEqual(const a,b:TPOCAValue):boolean; overload;
function POCAStrictEqual(const a,b:TPOCAValue):boolean; overload;
function POCACompareString(const a,b:TPOCARawByteString):TPOCAInt32;
function POCACompare(Context:PPOCAContext;const a,b:TPOCAValue):TPOCAInt32;
function POCAEqual(const a:TPOCAValue;const s:TPOCARawByteString):boolean; overload;
function POCAStrictEqual(const a:TPOCAValue;const s:TPOCARawByteString):boolean; overload;
function POCAStringEqual(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAObjectEqual(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}

procedure POCASetUserData(Context:PPOCAContext;p:TPOCAPointer); {$ifdef caninline}inline;{$endif}
function POCAGetUserData(Context:PPOCAContext):TPOCAPointer; {$ifdef caninline}inline;{$endif}

procedure POCAAddSymbol(Context:PPOCAContext;const Dst:TPOCAValue;Symbol:TPOCARawByteString;const Value:TPOCAValue;const Constant:Boolean=false); {$ifdef caninline}inline;{$endif}

procedure POCAAddNativeFunction(Context:PPOCAContext;const Hash:TPOCAValue;const FunctionName:TPOCARawByteString;const FunctionPointer:TPOCANativeFunction;const DestroyFunctionPointer:TPOCANativeDestroyFunction=nil;const UserData:TPOCAPointer=nil;const Constant:Boolean=false); {$ifdef caninline}inline;{$endif}

function POCAInternSymbol(Context:PPOCAContext;Instance:PPOCAInstance;const Symbol:TPOCAValue;const Constant:Boolean=false):TPOCAValue; {$ifdef caninline}inline;{$endif}

function POCAMarkValue(Instance:PPOCAInstance;const Value:TPOCAValue):TPOCABool32;

function POCAArrayGet(const ArrayObject:TPOCAValue;i:TPOCAInt32):TPOCAValue;
procedure POCAArraySet(const ArrayObject:TPOCAValue;i:TPOCAInt32;const Value:TPOCAValue);
function POCAArraySize(const ArrayObject:TPOCAValue):TPOCAUInt32;
function POCAArrayPush(const ArrayObject:TPOCAValue;const Value:TPOCAValue):TPOCAUInt32;
function POCAArrayRangePush(Context:PPOCAContext;const ArrayObject:TPOCAValue;const FromValue,ToValue:TPOCAValue):TPOCAUInt32;
function POCAArrayDelete(const ArrayObject:TPOCAValue;const Index:TPOCAInt32):TPOCAUInt32;
function POCAArrayRemove(const ArrayObject:TPOCAValue;const Value:TPOCAValue):TPOCAUInt32;
function POCAArrayIndexOf(const ArrayObject:TPOCAValue;const Value:TPOCAValue):TPOCAInt32;
function POCAArrayLastIndexOf(const ArrayObject:TPOCAValue;const Value:TPOCAValue):TPOCAInt32;
procedure POCAArraySetSize(const ArrayObject:TPOCAValue;Size:TPOCAInt32);
function POCAArrayPop(const ArrayObject:TPOCAValue):TPOCAValue;
procedure POCAArraySort(Context:PPOCAContext;const ArrayObject:TPOCAValue); overload;
procedure POCAArraySort(Context:PPOCAContext;const ArrayObject,CompareFunction:TPOCAValue); overload;
procedure POCAArraySort(Context:PPOCAContext;const ArrayObject:TPOCAValue;const ItemIndex:TPOCAInt32); overload;

function POCAHashString(const Str:TPOCARawByteString):TPOCAUInt32;
function POCAHashNumber(const Num:double):TPOCAUInt32;
function POCAHashObj(const Obj:TPOCAPointer):TPOCAUInt32;

procedure POCAHashLockInvalidate(Hash:PPOCAHash);
procedure POCAHashInvalidate(Hash:PPOCAHash);

procedure POCAHashRebuildCache(Hash:PPOCAHash);

procedure POCAHashClearPrototype(Hash:PPOCAHash);
function POCAHashSetPrototype(Context:PPOCAContext;const Hash:TPOCAValue;const Prototype:PPOCAHash):TPOCABool32;
function POCAHashSetPrototypeValue(Context:PPOCAContext;const Hash,Prototype:TPOCAValue):TPOCABool32;
function POCAHashGetPrototype(const Hash:TPOCAValue):PPOCAHash;
function POCAHashGetPrototypeValue(const Hash:TPOCAValue):TPOCAValue;

procedure POCAHashClearConstructor(Hash:PPOCAHash);
function POCAHashSetConstructor(Context:PPOCAContext;const Hash:TPOCAValue;const Constructor_:PPOCAObject):TPOCABool32;
function POCAHashSetConstructorValue(Context:PPOCAContext;const Hash,Constructor_:TPOCAValue):TPOCABool32;
function POCAHashGetConstructor(const Hash:TPOCAValue):PPOCAObject;
function POCAHashGetConstructorValue(const Hash:TPOCAValue):TPOCAValue;

function POCAHashSetHashEvents(Context:PPOCAContext;const ToHash,FromHash:TPOCAValue):TPOCABool32;
function POCAHashGetHashEventsHash(const Hash:TPOCAValue):TPOCAValue;
function POCAHashGetHashEvents(const Hash:TPOCAValue):PPOCAHashEvents; overload;
function POCAHashGetHashEvents(const Hash:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;
function POCAHashGetHashEvents(const v1,v2:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;
function POCAHashGetHashEvents(const v1,v2,v3:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;

function POCAHashSetGhost(Context:PPOCAContext;const Hash:TPOCAValue;Ghost:PPOCAGhost):TPOCABool32;
function POCAHashSetGhostValue(Context:PPOCAContext;const Hash,Ghost:TPOCAValue):TPOCABool32;
function POCAHashGetGhost(const Hash:TPOCAValue):PPOCAGhost;
function POCAHashGetGhostValue(const Hash:TPOCAValue):TPOCAValue;

function POCAHashSetKind(Context:PPOCAContext;const Hash:TPOCAValue;Kind:TPOCAInt32):TPOCABool32;
function POCAHashGetKind(const Hash:TPOCAValue):TPOCAInt32;

function POCAHashRawSize(const Hash:TPOCAValue):TPOCAInt32;
function POCAHashRawExist(const Hash:TPOCAValue;const Key:TPOCAValue):boolean;
function POCAHashRawGet(const Hash:TPOCAValue;const Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
function POCAHashRawSet(const Hash,Key,Value:TPOCAValue;const Constant:Boolean=false):boolean;
function POCAHashRawDelete(const Hash,Key:TPOCAValue):boolean;
procedure POCAHashRawKeys(const Dst,Hash:TPOCAValue);
function POCAHashSize(Context:PPOCAContext;const Hash:TPOCAValue):TPOCAInt32;
function POCAHashExist(Context:PPOCAContext;const Hash,Key:TPOCAValue):boolean;
function POCAHashGet(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
function POCAHashGetInherited(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
function POCAHashSet(Context:PPOCAContext;const Hash,Key,Value:TPOCAValue;const Constant:Boolean=false):boolean;
function POCAHashDelete(Context:PPOCAContext;const Hash,Key:TPOCAValue):boolean;
procedure POCAHashOwnKeys(Context:PPOCAContext;const Dst,Hash:TPOCAValue);
procedure POCAHashKeys(Context:PPOCAContext;const Dst,Hash:TPOCAValue);
function POCAHashGetString(Context:PPOCAContext;const Hash:TPOCAValue;const Key:TPOCARawByteString):TPOCAValue;
procedure POCAHashSetString(Context:PPOCAContext;const Hash:TPOCAValue;const Key:TPOCARawByteString;const Value:TPOCAValue;const Constant:Boolean=false);
procedure POCAHashDeleteString(Context:PPOCAContext;const Hash:TPOCAValue;const Key:TPOCARawByteString);
procedure POCAHashCombine(Context:PPOCAContext;const Hash,Source:TPOCAValue);
function POCAHashInstanceOf(Context:PPOCAContext;const Hash,OfHash:TPOCAValue):TPOCABool32;
function POCAHashIs(Context:PPOCAContext;const Hash,OfObject:TPOCAValue):TPOCABool32;
function POCAHashArray(Context:PPOCAContext;const Hash:TPOCAValue):TPOCAValue;

function POCAObjectInstanceOf(Context:PPOCAContext;const Value,OfValue:TPOCAValue):TPOCABool32; {$ifdef caninline}inline;{$endif}
function POCAObjectIs(Context:PPOCAContext;const Value,OfValue:TPOCAValue):TPOCABool32; {$ifdef caninline}inline;{$endif}

function POCAContextCreate(Instance:PPOCAInstance):PPOCAContext;
procedure POCAContextDestroy(Context:PPOCAContext);
function POCAContextSub(Super:PPOCAContext):PPOCAContext;

function POCAStringDump(Context:PPOCAContext;const ToDumpValue:TPOCAValue):TPOCARawByteString;

function POCAInstanceCreate:PPOCAInstance;
procedure POCAInstanceDestroy(var Instance:PPOCAInstance);

function POCACompile(Instance:PPOCAInstance;Context:PPOCAContext;const Source:TPOCARawByteString;const SourceFileName:TPOCARawByteString=''):TPOCAValue;

procedure POCASave(Context:PPOCAContext;Obj:TPOCAValue);

function POCAStackDepth(Context:PPOCAContext):TPOCAInt32;

function POCAFindFrame(Context:PPOCAContext;var OutContext:PPOCAContext;FrameNumber:TPOCAInt32):TPOCAInt32;

function POCAGetSourceLine(Context:PPOCAContext;FrameNumber:TPOCAInt32):TPOCAInt32;

function POCAGetSourceFile(Context:PPOCAContext;FrameNumber:TPOCAInt32):TPOCAInt32;

function POCAGetSourceFileName(Context:PPOCAContext;FrameNumber:TPOCAInt32;AbsolutePath:Boolean=false):TPOCAUTF8String;

function POCABindToContext(Context:PPOCAContext;Code:TPOCAValue):TPOCAValue;

function POCACall(Context:PPOCAContext;Func:TPOCAValue;Arguments:PPOCAValues;CountArguments:TPOCAInt32;Obj:TPOCAValue;Locals:TPOCAValue):TPOCAValue;

procedure POCARuntimeError(Context:PPOCAContext;const Msg:TPOCAUTF8String);

function POCARun(Context:PPOCAContext):TPOCAValue;

function POCAGetFileContent(FileName:TPOCAUTF8String):TPOCARawByteString;

function POCAIsPathSeparator(const aChar:AnsiChar):Boolean;
function POCACorrectPathSeparators(const aPath:TPOCARawByteString):TPOCARawByteString;
function POCAExpandRelativePath(const aRelativePath:TPOCARawByteString;const aBasePath:TPOCARawByteString=''):TPOCARawByteString;
function POCAConvertPathToRelative(aAbsolutePath,aBasePath:TPOCARawByteString):TPOCARawByteString;
function POCAExtractFilePath(aPath:TPOCARawByteString):TPOCARawByteString;

procedure InitializePOCA;
procedure FinalizePOCA;

implementation

//const EPSILON=1e-18;
const ConstructorValueSymbolString:TPOCARawByteString='$|constuctor|$';

type TPOCALexerKeywordTokens=array[TPOCATokenType] of TPOCARawByteString;

     PPOCALexerKeywordTokenCharTreeNode=^TPOCALexerKeywordTokenCharTreeNode;
     TPOCALexerKeywordTokenCharTreeNode=record
      Children:array[TPOCAKeywordChars] of PPOCALexerKeywordTokenCharTreeNode;
      HasChildren:boolean;
      Token:TPOCATokenType;
     end;

const POCAInitialized:boolean=false;

{$ifdef POCAHasJIT}
      bncmmMemoryBlockSignature:TPOCAPtrUInt={$ifdef cpu64}$1337bab3deadc0d3{$else}$deadc0d3{$endif};

      bncmmMINBLOCKCONTAINERSIZE=1048576;
{$endif}

      FPUExceptionMask:TFPUExceptionMask=[exInvalidOp,exDenormalized,exZeroDivide,exOverflow,exUnderflow,exPrecision];
      FPURoundingMode:TFPURoundingMode=rmNearest;
      FPUPrecisionMode:TFPUPrecisionMode={$ifdef HAS_TYPE_EXTENDED}pmEXTENDED{$else}pmDOUBLE{$endif};

//    HASH_MAGIC=TPOCAUInt32(2654435769);

      CELL_EMPTY=-1;
      CELL_DELETED=-2;

      ENT_EMPTY=-1;
      ENT_DELETED=-2;

var LexerKeywordTokens:TPOCALexerKeywordTokens;
    LexerKeywordTokenCharTreeRootNode:PPOCALexerKeywordTokenCharTreeNode;

    MetaOpNames:TPOCAMetaOpNames;
    MetaOpNamesHashMap:TPOCAStringHashMap;

procedure InitializeConsole(Context:PPOCAContext);
{$if defined(fpc) and defined(Unix)}
var Term:TTermios;
{$ifend}
begin
{$if defined(fpc) and defined(Unix)}
 Term.c_line:=#0;
 TCGetAttr(0,Term);
 Context^.Instance.Globals.OriginalTerm:=Term;
 Term.c_lflag:=Term.c_lflag and not (termio.ECHO or termio.ICANON {or termio.ISIG} or termio.IEXTEN);
 Term.c_iflag:=Term.c_iflag and not (termio.IXON or termio.ICRNL);
 TCSetAttr(0,TCSAFLUSH,Term);
{$elseif defined(Windows)}
 SetConsoleCP(CP_UTF8);
 SetConsoleOutputCP(CP_UTF8);
 Context^.Instance.Globals.ConsoleInputHandle:=GetStdHandle(STD_INPUT_HANDLE);
 Context^.Instance.Globals.ConsoleOutputHandle:=GetStdHandle(STD_OUTPUT_HANDLE);
 GetConsoleMode(Context^.Instance.Globals.ConsoleInputHandle,Context^.Instance.Globals.OldConsoleModeIn);
 SetConsoleMode(Context^.Instance.Globals.ConsoleInputHandle,(ENABLE_VIRTUAL_TERMINAL_INPUT or
                                                              ENABLE_WINDOW_INPUT or
                                                              ENABLE_MOUSE_INPUT) and not
                                                             (//ENABLE_PROCESSED_INPUT or
                                                              ENABLE_WRAP_AT_EOL_OUTPUT));
 GetConsoleMode(Context^.Instance.Globals.ConsoleOutputHandle,Context^.Instance.Globals.OldConsoleModeOut);
 SetConsoleMode(Context^.Instance.Globals.ConsoleOutputHandle,Context^.Instance.Globals.OldConsoleModeOut or (ENABLE_PROCESSED_OUTPUT or
                                                                                                              ENABLE_VIRTUAL_TERMINAL_PROCESSING));
{$ifend}
end;

procedure FinalizeConsole(Context:PPOCAContext);
begin
{$if defined(fpc) and defined(Unix)}
 TCSetAttr(0,TCSAFLUSH,Context^.Instance.Globals.OriginalTerm);
{$elseif defined(Windows)}
 SetConsoleMode(Context^.Instance.Globals.ConsoleInputHandle,Context^.Instance.Globals.OldConsoleModeIn);
 SetConsoleMode(Context^.Instance.Globals.ConsoleOutputHandle,Context^.Instance.Globals.OldConsoleModeOut);
{$ifend}
end;

function ReadKey(Context:PPOCAContext):TPOCAUInt32;
{$if defined(Windows)}
var ReadCount,Index:DWORD;
    InputRecord:_INPUT_RECORD;
    Data:array[0..7] of AnsiChar;
    ConsoleInputHandle:THandle;
 function ReadInput:DWORD;
 var Surrogate,CharValue:DWORD;
 begin

  repeat

   if not ReadConsoleInputW(ConsoleInputHandle,InputRecord,1,ReadCount) then begin
    exit;
   end;

   if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) and InputRecord.Event.KeyEvent.bKeyDown then begin

    CharValue:=ord(InputRecord.Event.KeyEvent.UnicodeChar);

    while CharValue=0 do begin

     if not ReadConsoleInputW(ConsoleInputHandle,InputRecord,1,ReadCount) then begin
      exit;
     end;

     if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) then begin
      CharValue:=ord(InputRecord.Event.KeyEvent.UnicodeChar);
      if not InputRecord.Event.KeyEvent.bKeyDown then begin
       break;
      end;
     end;
    end;

    if CharValue>=$80 then begin

     if (CharValue>=$d800) and (CharValue<$e000) then begin
      if not ReadConsoleInputW(ConsoleInputHandle,InputRecord,1,ReadCount) then begin
       exit;
      end;
      if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) and InputRecord.Event.KeyEvent.bKeyDown then begin
       Surrogate:=ord(InputRecord.Event.KeyEvent.UnicodeChar);
       while Surrogate=0 do begin
        if not ReadConsoleInputW(ConsoleInputHandle,InputRecord,1,ReadCount) then begin
         exit;
        end;
        if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) then begin
         Surrogate:=ord(InputRecord.Event.KeyEvent.UnicodeChar);
         if not InputRecord.Event.KeyEvent.bKeyDown then begin
          break;
         end;
        end;
       end;
       CharValue:=($010000-$dc00)+((CharValue-$d800) shl 10)+Surrogate;
      end;
     end;

     result:=CharValue;
     exit;

    end else begin

     result:=TPOCAUInt8(CharValue);

    end;

    break;

   end;

  until false;
 end;
{$elseif defined(fpc) and defined(Unix)}
var InputFD:pollfd;
    InputChar:AnsiChar;
{$ifend}
begin
 result:=0;
{$if defined(Windows)}
 ReadCount:=0;
 ConsoleInputHandle:=GetStdHandle(STD_INPUT_HANDLE);
 if PeekConsoleInputW(ConsoleInputHandle,InputRecord,1,ReadCount) and
   (ReadCount=1) and
    (InputRecord.EventType=KEY_EVENT) and
    InputRecord.Event.KeyEvent.bKeyDown then begin
  result:=ReadInput;
 end else begin
  if ReadCount=1 then begin
   ReadConsoleInputW(ConsoleInputHandle,InputRecord,1,ReadCount);
  end;
 end;
{$elseif defined(fpc) and defined(Unix)}
 InputFD.fd:=StdInputHandle;
 InputFD.events:=POLLIN;
 if FpPoll(@InputFD,1,1)>0 then begin
  if fpRead(StdInputHandle,@InputChar,1)<>0 then begin
   result:=ord(InputChar);
  end;
 end;
{$ifend}
end;

{$warnings off}
procedure InitializeLocaleFormatSettings;
{$ifdef windows}
{$ifdef fpc}
var i:TPOCAInt32;
begin
 POCALocaleCharset:='ISO-8859-1';
 POCALocaleFormatSettings:=POCADefaultFormatSettings;
 for i:= 1 to 12 do begin
  POCALocaleFormatSettings.ShortMonthNames[i]:=SysUtils.ShortMonthNames[i];
  POCALocaleFormatSettings.LongMonthNames[i]:=SysUtils.LongMonthNames[i];
 end;
 for i:=1 to 7 do begin
  POCALocaleFormatSettings.ShortDayNames[i]:=SysUtils.ShortDayNames[i];
  POCALocaleFormatSettings.LongDayNames[i]:=SysUtils.LongDayNames[i];
 end;
 POCALocaleFormatSettings.DateSeparator:=SysUtils.DateSeparator;
 POCALocaleFormatSettings.ShortDateFormat:=SysUtils.ShortDateFormat;
 POCALocaleFormatSettings.LongDateFormat:=SysUtils.LongDateFormat;
 POCALocaleFormatSettings.TimeSeparator:=SysUtils.TimeSeparator;
 POCALocaleFormatSettings.TimeAMString:=SysUtils.TimeAMString;
 POCALocaleFormatSettings.TimePMString:=SysUtils.TimePMString;
 POCALocaleFormatSettings.ShortTimeFormat:=SysUtils.ShortTimeFormat;
 POCALocaleFormatSettings.LongTimeFormat:=SysUtils.LongTimeFormat;
 POCALocaleFormatSettings.CurrencyString:=SysUtils.CurrencyString;
 POCALocaleFormatSettings.CurrencyFormat:=SysUtils.CurrencyFormat;
 POCALocaleFormatSettings.NegCurrFormat:=SysUtils.NegCurrFormat;
 POCALocaleFormatSettings.ThousandSeparator:=SysUtils.ThousandSeparator;
 POCALocaleFormatSettings.DecimalSeparator:=SysUtils.DecimalSeparator;
 POCALocaleFormatSettings.CurrencyDecimals:=SysUtils.CurrencyDecimals;
 POCALocaleFormatSettings.ListSeparator:=SysUtils.ListSeparator;
end;
{$else}
var HourFormat,TimePrefix,TimePostfix:TPOCAUTF8String;
    LID:LCID;
    i,LCP,Day:TPOCAInt32;
begin
 POCALocaleFormatSettings:=POCADefaultFormatSettings;
 LID:=GetThreadLocale;
 if not TryStrToInt(GetLocaleStr(LID,LOCALE_IDEFAULTANSICODEPAGE,inttostr(GetACP)),LCP) then begin
  LCP:=GetACP;
 end;
 if LCP>0 then begin
  POCALocaleCharset:='WINDOWS-'+inttostr(LCP);
 end else begin
  POCALocaleCharset:='ISO_8859_1';
 end;
{$ifdef DelphiXEAndUp}
 for i:=1 to 12 do begin
  POCALocaleFormatSettings.ShortMonthNames[i]:=GetLocaleStr(LID,LOCALE_SABBREVMONTHNAME1+i-1,FormatSettings.ShortMonthNames[i]);
  POCALocaleFormatSettings.LongMonthNames[i]:=GetLocaleStr(LID,LOCALE_SMONTHNAME1+i-1,FormatSettings.LongMonthNames[i]);
 end;
 for i:=1 to 7 do begin
  Day:=(i+5) mod 7;
  POCALocaleFormatSettings.ShortDayNames[i]:=GetLocaleStr(LID,LOCALE_SABBREVDAYNAME1+Day,FormatSettings.ShortDayNames[i]);
  POCALocaleFormatSettings.LongDayNames[i]:=GetLocaleStr(LID,LOCALE_SDAYNAME1+Day,FormatSettings.LongDayNames[i]);
 end;
{$else}
 for i:=1 to 12 do begin
  POCALocaleFormatSettings.ShortMonthNames[i]:=GetLocaleStr(LID,LOCALE_SABBREVMONTHNAME1+i-1,ShortMonthNames[i]);
  POCALocaleFormatSettings.LongMonthNames[i]:=GetLocaleStr(LID,LOCALE_SMONTHNAME1+i-1,LongMonthNames[i]);
 end;
 for i:=1 to 7 do begin
  Day:=(i+5) mod 7;
  POCALocaleFormatSettings.ShortDayNames[i]:=GetLocaleStr(LID,LOCALE_SABBREVDAYNAME1+Day,ShortDayNames[i]);
  POCALocaleFormatSettings.LongDayNames[i]:=GetLocaleStr(LID,LOCALE_SDAYNAME1+Day,LongDayNames[i]);
 end;
{$endif}
 POCALocaleFormatSettings.DateSeparator:=GetLocaleChar(LID,LOCALE_SDATE,'/');
 POCALocaleFormatSettings.ShortDateFormat:=GetLocaleStr(LID,LOCALE_SSHORTDATE,'m/d/yy');
 POCALocaleFormatSettings.LongDateFormat:=GetLocaleStr(LID,LOCALE_SLONGDATE,'mmmm d, yyyy');
 POCALocaleFormatSettings.TimeSeparator:=GetLocaleChar(LID,LOCALE_STIME,':');
 POCALocaleFormatSettings.TimeAMString:=GetLocaleStr(LID,LOCALE_S1159,'AM');
 POCALocaleFormatSettings.TimePMString:=GetLocaleStr(LID,LOCALE_S2359,'PM');
 if StrToIntDef(GetLocaleStr(LID,LOCALE_ITLZERO,'0'),0)=0 then begin
  HourFormat:='h';
 end else begin
  HourFormat:='hh';
 end;
 TimePostfix:='';
 TimePrefix:='';
 if StrToIntDef(GetLocaleStr(LID,LOCALE_ITIME,'0'),0)=0 then begin
  if StrToIntDef(GetLocaleStr(LID,LOCALE_ITIMEMARKPOSN,'0'),0)=0 then begin
   TimePostfix:=' AMPM';
  end else begin
   TimePrefix:='AMPM ';
  end;
 end;
 POCALocaleFormatSettings.ShortTimeFormat:=TimePrefix+HourFormat+':nn'+TimePrefix;
 POCALocaleFormatSettings.LongTimeFormat:=TimePrefix+HourFormat+':nn:ss'+TimePrefix;
 POCALocaleFormatSettings.CurrencyString:=GetLocaleStr(LID,LOCALE_SCURRENCY,'');
 POCALocaleFormatSettings.CurrencyFormat:=StrToIntDef(GetLocaleStr(LID,LOCALE_ICURRENCY,'0'),0);
 POCALocaleFormatSettings.NegCurrFormat:=StrToIntDef(GetLocaleStr(LID,LOCALE_INEGCURR,'0'),0);
 POCALocaleFormatSettings.ThousandSeparator:=GetLocaleChar(LID,LOCALE_STHOUSAND,',');
 POCALocaleFormatSettings.DecimalSeparator:=GetLocaleChar(LID,LOCALE_SDECIMAL,'.');
 POCALocaleFormatSettings.CurrencyDecimals:=StrToIntDef(GetLocaleStr(LID,LOCALE_ICURRDIGITS,'0'),0);
 POCALocaleFormatSettings.ListSeparator:=GetLocaleChar(LID,LOCALE_SLIST,',');
end;
{$endif}
{$else}
var i:TPOCAInt32;
begin
 POCALocaleCharset:='ISO-8859-1';
 POCALocaleFormatSettings:=POCADefaultFormatSettings;
 for i:= 1 to 12 do begin
  POCALocaleFormatSettings.ShortMonthNames[i]:=SysUtils.ShortMonthNames[i];
  POCALocaleFormatSettings.LongMonthNames[i]:=SysUtils.LongMonthNames[i];
 end;
 for i:=1 to 7 do begin
  POCALocaleFormatSettings.ShortDayNames[i]:=SysUtils.ShortDayNames[i];
  POCALocaleFormatSettings.LongDayNames[i]:=SysUtils.LongDayNames[i];
 end;
 POCALocaleFormatSettings.DateSeparator:=SysUtils.DateSeparator;
 POCALocaleFormatSettings.ShortDateFormat:=SysUtils.ShortDateFormat;
 POCALocaleFormatSettings.LongDateFormat:=SysUtils.LongDateFormat;
 POCALocaleFormatSettings.TimeSeparator:=SysUtils.TimeSeparator;
 POCALocaleFormatSettings.TimeAMString:=SysUtils.TimeAMString;
 POCALocaleFormatSettings.TimePMString:=SysUtils.TimePMString;
 POCALocaleFormatSettings.ShortTimeFormat:=SysUtils.ShortTimeFormat;
 POCALocaleFormatSettings.LongTimeFormat:=SysUtils.LongTimeFormat;
 POCALocaleFormatSettings.CurrencyString:=SysUtils.CurrencyString;
 POCALocaleFormatSettings.CurrencyFormat:=SysUtils.CurrencyFormat;
 POCALocaleFormatSettings.NegCurrFormat:=SysUtils.NegCurrFormat;
 POCALocaleFormatSettings.ThousandSeparator:=SysUtils.ThousandSeparator;
 POCALocaleFormatSettings.DecimalSeparator:=SysUtils.DecimalSeparator;
 POCALocaleFormatSettings.CurrencyDecimals:=SysUtils.CurrencyDecimals;
 POCALocaleFormatSettings.ListSeparator:=SysUtils.ListSeparator;
end;
{$endif}
{$warnings on}

function GetDateTimeUTCOffset(const aWhen:TDateTime):TDateTime;
{$if defined(fpc) and declared(GetLocalTimeOffset)}
begin
 result:=GetLocalTimeOffset/1440.0;
end;
{$elseif defined(DelphiXE2AndUp) and declared(TTimeZone)}
begin
 result:=0.0;
 result:=result+TTimeZone.Local.GetUtcOffset(aWhen);
end;
{$else}
var SystemTimes:array[0..1] of TSystemTime;
    DateTimes:array[0..1] of TDateTime;
begin
{$if declared(GetUniversalTime)}
 GetUniversalTime(SystemTimes[0]);
{$else}
 GetSystemTime(SystemTimes[0]);
{$ifend}
 GetLocalTime(SystemTimes[1]);
 DateTimes[0]:=SystemTimeToDateTime(SystemTimes[0]);
 DateTimes[1]:=SystemTimeToDateTime(SystemTimes[1]);
 result:=MinutesBetween(DateTimes[0],DateTimes[1])/1440.0;
end;
{$ifend}

function DateTimeFromLocalTimeToUniversalTime(const aDateTime:TDateTime):TDateTime;
{$if defined(fpc) and declared(LocalTimeToUniversal)}
begin
 result:=LocalTimeToUniversal(aDateTime);
end;
{$elseif defined(DelphiXE2AndUp) and declared(TTimeZone)}
begin
 result:=TTimeZone.Local.ToUniversalTime(aDateTime);
end;
{$else}
begin
 result:=aDateTime+GetDateTimeUTCOffset(aDataTime);
end;
{$ifend}

function DateTimeFromUniversalTimeToLocalTime(const aDateTime:TDateTime):TDateTime;
{$if defined(fpc) and declared(LocalTimeToUniversal)}
begin
 result:=UniversalTimeToLocal(aDateTime);
end;
{$elseif defined(DelphiXE2AndUp) and declared(TTimeZone)}
begin
 result:=TTimeZone.Local.ToLocalTime(aDateTime);
end;
{$else}
begin
 result:=aDateTime-GetDateTimeUTCOffset(aDateTime);
end;
{$ifend}

{$if not declared(NowUTC)}
function NowUTC:TDateTime;
{$if defined(DelphiXE2AndUp)}
begin
 result:=TDateTime.NowUTC;
end;
{$else}
begin
 result:=DateTimeFromLocalTimeToUniversalTime(Now);
end;
{$ifend}
{$ifend}

{$if not declared(FileAgeUTC)}
function FileAgeUTC(const FileName:String;out FileDateTimeUTC:TDateTime;FollowLink:Boolean=True):Boolean;
begin
{$if defined(DelphiXE2AndUp)}
 result:=FileExists(FileName);
 if result then begin
  FileDateTimeUTC:=TFile.GetLastWriteTimeUtc(FileName);
 end;
{$else}
 result:=FileAge(FileName,FileDateTimeUTC{$ifdef fpc},FollowLink{$endif});
 if result then begin
  FileDateTimeUTC:=DateTimeFromLocalTimeToUniversalTime(FileDateTimeUTC);
 end;
{$ifend}
end;
{$ifend}

function DateTimeFromUnixTime(const aUnixTime:TPOCAInt64):TDateTime;
{$if declared(UnixToDateTime)}
begin
 result:=UnixToDateTime(aUnixTime);
end;
{$else}
begin
 result:=(TDateTime(aUnixTime)/86400.0)+25569.0;
end;
{$ifend}

function DateTimeToUnixTime(const aDateTime:TDateTime):TPOCAInt64;
{$if declared(DateTimeToUnix)}
begin
 result:=DateTimeToUnix(aDateTime);
end;
{$else}
begin
 result:=Trunc((aDateTime-25569.0)*86400.0);
end;
{$ifend}

const POCAmsPerMinute=60000.0/86400.0;
      POCAmsPerDay=86400000.0/86400.0;
      POCAmsPerHour=3600000.0/86400.0;
      POCAmsPerSecond=1000.0/86400.0;
      POCAmsPerMillisecond=1.0/86400.0;

      ParserMonthNames:array[0..11] of widestring=('jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec');
      ParserDayNames:array[0..6] of widestring=('sun','mon','tue','wed','thu','fri','sat');

function MakeDate(Year,Month,Date:TPOCAInt32):TDateTime;
begin
 result:=EncodeDate(Year,Month,Date);
end;

function MakeTime(Hour,Minute,Second,Millisecond:TPOCAInt32):TDateTime;
begin
 result:=EncodeTime(Hour,Minute,Second,Millisecond);
end;

function TimeClip(const DateTime:TDateTime):TDateTime;
begin
 result:=DateTime;
end;

function ParseISOTime(s:TPOCARawByteString):TDateTime;
 function IsDigit(const w:AnsiChar):boolean;
 begin
  result:=(UInt8(w)>=ord('0')) and (UInt8(w)<=ord('9'));
 end;
 function ParseDay(const ss:TPOCARawByteString):TDateTime;
 var Offset:TPOCAInt32;
 begin
  if (length(ss)=10) and (IsDigit(ss[1]) and IsDigit(ss[2]) and IsDigit(ss[3]) and IsDigit(ss[4]) and (ss[5]='-') and IsDigit(ss[6]) and IsDigit(ss[7]) and (ss[8]='-') and IsDigit(ss[9]) and IsDigit(ss[10])) then begin
   Offset:=1;
  end else if (length(ss)=8) and (IsDigit(ss[1]) and IsDigit(ss[2]) and IsDigit(ss[3]) and IsDigit(ss[4]) and IsDigit(ss[5]) and IsDigit(ss[6]) and IsDigit(ss[7]) and IsDigit(ss[8])) then begin
   Offset:=0;
  end else begin
   result:=double(pointer(@POCADoubleNaN)^);
   exit;
  end;
  result:=MakeDate(StrToIntDef(copy(ss,1,4),0),StrToIntDef(copy(ss,5+(1*Offset),2),0),StrToIntDef(copy(ss,7+(2*Offset),2),0));
 end;
 function ParseTime(const ss:TPOCARawByteString):TDateTime;
 var s,ms:TPOCARawByteString;
     i,Offset,Hours,Minutes,Seconds,Milliseconds:TPOCAInt32;
     WithSeconds:boolean;
 begin
  i:=Pos(',',ss);
  if i=0 then begin
   i:=Pos('.',ss);
  end;
  if i=0 then begin
   s:=ss;
   ms:='';
  end else begin
   s:=copy(ss,1,i-1);
   ms:=copy(ms,i+1,(length(ss)-i)+1);
  end;
  if (length(s)=8) and (IsDigit(s[1]) and IsDigit(s[2]) and (s[3]=':') and IsDigit(s[4]) and IsDigit(s[5]) and (s[6]=':') and IsDigit(s[7]) and IsDigit(s[8])) then begin
   Offset:=1;
   WithSeconds:=true;
  end else if (length(s)=6) and (IsDigit(s[1]) and IsDigit(s[2]) and IsDigit(s[3]) and IsDigit(s[4]) and IsDigit(s[5]) and IsDigit(s[6])) then begin
   Offset:=0;
   WithSeconds:=true;
  end else if (length(s)=5) and (IsDigit(s[1]) and IsDigit(s[2]) and (s[3]=':') and IsDigit(s[4]) and IsDigit(s[5])) then begin
   Offset:=1;
   WithSeconds:=false;
  end else if (length(s)=4) and (IsDigit(s[1]) and IsDigit(s[2]) and IsDigit(s[3]) and IsDigit(s[4])) then begin
   Offset:=0;
   WithSeconds:=false;
  end else begin
   result:=double(pointer(@POCADoubleNaN)^);
   exit;
  end;
  Hours:=StrToIntDef(copy(s,1,2),100);
  Minutes:=StrToIntDef(copy(s,3+(1*Offset),2),100);
  if WithSeconds then begin
   Seconds:=StrToIntDef(copy(s,5+(2*Offset),2),100);
  end else begin
   Seconds:=0;
   if length(ms)>0 then begin
    result:=double(pointer(@POCADoubleNaN)^);
    exit;
   end;
  end;
  case length(ms) of
   0:begin
    Milliseconds:=0;
   end;
   3:begin
    Milliseconds:=StrToIntDef(ms,10000);
   end;
   else begin
    result:=double(pointer(@POCADoubleNaN)^);
    exit;
   end;
  end;
  result:=MakeTime(Hours,Minutes,Seconds,Milliseconds);
 end;
var i,j,k:TPOCAInt32;
    sz:TPOCARawByteString;
    Delta:TDateTime;
begin
 i:=Pos('T',s);
 if i=0 then begin
  i:=Pos(' ',s);
 end;
 if i>0 then begin
  j:=Pos('Z',s);
  if j=0 then begin
   j:=length(s)+1;
   for k:=length(s) downto i+1 do begin
    if (s[k]='-') or (s[k]='+') then begin
     j:=k;
     break;
    end;
   end;
  end;
  sz:=copy(s,j,(length(s)-j)+1);
  s:=copy(s,1,j-1);
  Delta:=0;
  if (length(sz)=6) and ((sz[1]='-') or (sz[1]='+')) and IsDigit(sz[2]) and IsDigit(sz[3]) and (sz[4]=':') and IsDigit(sz[5]) and IsDigit(sz[6]) then begin
   i:=StrToIntDef(copy(sz,2,2),-1);
   j:=StrToIntDef(copy(sz,5,2),-1);
   if ((i>=0) and (i<=24)) and ((j>=0) and (j<=60)) then begin
    Delta:=(i*60)+j;
    if sz[1]='-' then begin
     Delta:=-Delta;
    end;
   end else begin
    result:=double(pointer(@POCADoubleNaN)^);
    exit;
   end;
  end else if (length(sz)>0) and (sz<>'Z') then begin
   result:=double(pointer(@POCADoubleNaN)^);
   exit;
  end;
  result:=TimeClip((ParseDay(copy(s,1,i-1))+ParseTime(copy(s,i+1,(length(s)-i)+1)))-(Delta*POCAmsPerMinute));
 end else begin
  result:=double(pointer(@POCADoubleNaN)^);
 end;
end;

function ParseTime(s:TPOCARawByteString):TDateTime;
var p:TPOCAInt32;
 function IsWhite(const w:AnsiChar):boolean;
 begin
  result:=UInt8(w)<=32;
 end;
 function IsLetter(const w:AnsiChar):boolean;
 begin
  result:=((UInt8(w)>=ord('a')) and (UInt8(w)<=ord('z'))) or ((UInt8(w)>=ord('Z')) and (UInt8(w)<=ord('Z')));
 end;
 function IsDigit(const w:AnsiChar):boolean;
 begin
  result:=(UInt8(w)>=ord('0')) and (UInt8(w)<=ord('9'));
 end;
 function ToLower(const w:AnsiChar):AnsiChar;
 begin
  if (UInt8(w)>=ord('A')) and (UInt8(w)<=ord('Z')) then begin
   result:=AnsiChar(UInt8(UInt8(AnsiChar(w))+(ord('a')-ord('A'))));
  end;
 end;
 procedure SkipWhite;
 begin
  while p<length(s) do begin
   if IsWhite(s[p]) then begin
    inc(p);
   end else begin
    break;
   end;
  end;
 end;
var i,d,m,y,hr,min,sec,ms,wd:TPOCAInt32;
    t:TPOCARawByteString;
    yneg:boolean;
begin
 result:=double(pointer(@POCADoubleNaN)^);

 p:=1;

 SkipWhite;

 if ((p+2)<=length(s)) and (IsLetter(s[p]) and IsLetter(s[p+1]) and IsLetter(s[p+2])) then begin
  t:=Lowercase(copy(s,p,3));
  for wd:=low(ParserDayNames) to high(ParserDayNames) do begin
   if t=ParserDayNames[wd] then begin
    inc(p,3);
    if (p<=length(s)) and (s[p]=',') then begin
     inc(p);
    end;
    SkipWhite;
    break;
   end;
  end;
 end;

 if (p<=length(s)) and IsDigit(s[p]) then begin
  d:=0;
  while (p<=length(s)) and IsDigit(s[p]) do begin
   d:=(d*10)+(UInt8(AnsiChar(s[p]))-ord('0'));
   inc(p);
  end;
  if not ((p<=length(s)) and IsWhite(s[p])) then begin
   exit;
  end;
  SkipWhite;
  if not (((p+2)<=length(s)) and (IsLetter(s[p]) and IsLetter(s[p+1]) and IsLetter(s[p+2]))) then begin
   exit;
  end;
  t:=Lowercase(copy(s,p,3));
  inc(p,3);
  m:=0;
  for i:=low(ParserMonthNames) to high(ParserMonthNames) do begin
   if t=ParserMonthNames[i] then begin
    m:=i;
    break;
   end;
  end;
 end else begin
  if not (((p+2)<=length(s)) and (IsLetter(s[p]) and IsLetter(s[p+1]) and IsLetter(s[p+2]))) then begin
   exit;
  end;
  t:=Lowercase(copy(s,p,3));
  inc(p,3);
  m:=0;
  for i:=low(ParserMonthNames) to high(ParserMonthNames) do begin
   if t=ParserMonthNames[i] then begin
    m:=i;
    break;
   end;
  end;
  if not ((p<=length(s)) and IsWhite(s[p])) then begin
   exit;
  end;
  SkipWhite;
  d:=0;
  while (p<=length(s)) and IsDigit(s[p]) do begin
   d:=(d*10)+(UInt8(AnsiChar(s[p]))-ord('0'));
   inc(p);
  end;
 end;
 if (m<0) or ((d<1) or (d>31)) then begin
  exit;
 end;

 if not ((p<=length(s)) and IsWhite(s[p])) then begin
  exit;
 end;
 SkipWhite;

 yneg:=(p<=length(s)) and (s[p]='-');
 if yneg then begin
  inc(p);
 end;
 if not ((p<=length(s)) and IsDigit(s[p])) then begin
  exit;
 end;
 y:=0;
 while (p<=length(s)) and IsDigit(s[p]) do begin
  y:=(y*10)+(UInt8(AnsiChar(s[p]))-ord('0'));
  inc(p);
 end;
 if yneg then begin
  y:=-y;
 end;

 hr:=0;
 min:=0;
 sec:=0;
 ms:=0;
 if (p<=length(s)) and IsWhite(s[p]) then begin
  SkipWhite;
  if ((p+4)<=length(s)) and (IsDigit(s[p]) and IsDigit(s[p+1]) and (s[p+2]=':') and IsDigit(s[p+3]) and IsDigit(s[p+4])) then begin
   hr:=((UInt8(AnsiChar(s[p]))-ord('0'))*10)+(UInt8(AnsiChar(s[p+1]))-ord('0'));
   min:=((UInt8(AnsiChar(s[p+3]))-ord('0'))*10)+(UInt8(AnsiChar(s[p+4]))-ord('0'));
   inc(p,5);
   if ((p+2)<=length(s)) and ((s[p]=':') and IsDigit(s[p+1]) and IsDigit(s[p+2])) then begin
    sec:=((UInt8(AnsiChar(s[p+1]))-ord('0'))*10)+(UInt8(AnsiChar(s[p+2]))-ord('0'));
    inc(p,3);
   end;
   if ((p+3)<=length(s)) and (((s[p]=':') or (s[p]='.')) and IsDigit(s[p+1]) and IsDigit(s[p+2]) and IsDigit(s[p+3])) then begin
    ms:=((UInt8(AnsiChar(s[p+1]))-ord('0'))*100)+((UInt8(AnsiChar(s[p+2]))-ord('0'))*10)+(UInt8(AnsiChar(s[p+3]))-ord('0'));
    inc(p,4);
   end;
  end;
 end;
 if ((hr<0) or (hr>=24)) or ((min<0) or (min>=60)) or ((sec<0) or (sec>=60)) or ((ms<0) or (ms>=1000)) then begin
  exit;
 end;

 result:=(MakeDate(y,m,d)+MakeTime(hr,min,sec,ms));

 SkipWhite;
 if ((p+2)<=length(s)) and (((s[p]='G') and (s[p+1]='M') and (s[p+2]='T')) or ((s[p]='U') and (s[p+1]='T') and (s[p+2]='C'))) then begin
  inc(p,3);
  if ((p+4)<=length(s)) and (((s[p]='-') or (s[p]='+')) and IsDigit(s[p+1]) and IsDigit(s[p+2]) and IsDigit(s[p+3]) and IsDigit(s[p+4])) then begin
   i:=((((UInt8(AnsiChar(s[p+1]))-ord('0'))*10)+((UInt8(AnsiChar(s[p+2]))-ord('0'))))*60)+(((UInt8(AnsiChar(s[p+3]))-ord('0'))*10)+(UInt8(AnsiChar(s[p+4]))-ord('0')));
   if s[p]='-' then begin
    i:=-i;
   end;
   result:=result-(POCAmsPerMinute*i);
  end;
 end else begin
  result:=DateTimeFromLocalTimeToUniversalTime(MakeDate(y,m,d)+MakeTime(hr,min,sec,ms));
 end;

 result:=TimeClip(result);

end;

function ParseNetscapeTime(s:TPOCARawByteString):TDateTime;
var p:TPOCAInt32;
 function IsWhite(const w:AnsiChar):boolean;
 begin
  result:=UInt8(w)<=32;
 end;
 function IsLetter(const w:AnsiChar):boolean;
 begin
  result:=((UInt8(w)>=ord('a')) and (UInt8(w)<=ord('z'))) or ((UInt8(w)>=ord('Z')) and (UInt8(w)<=ord('Z')));
 end;
 function IsDigit(const w:AnsiChar):boolean;
 begin
  result:=(UInt8(w)>=ord('0')) and (UInt8(w)<=ord('9'));
 end;
 function ToLower(const w:AnsiChar):AnsiChar;
 begin
  if (UInt8(w)>=ord('A')) and (UInt8(w)<=ord('Z')) then begin
   result:=AnsiChar(UInt8(UInt8(AnsiChar(w))+(ord('a')-ord('A'))));
  end;
 end;
 procedure SkipWhite;
 begin
  while p<length(s) do begin
   if IsWhite(s[p]) then begin
    inc(p);
   end else begin
    break;
   end;
  end;
 end;
var i,j,d,m,y,hr,min,sec,ms:TPOCAInt32;
    neg:boolean;
    n:array[0..2] of TPOCAInt32;
begin
 result:=double(pointer(@POCADoubleNaN)^);

 p:=1;

 SkipWhite;

 for j:=0 to 2 do begin
  if j<>0 then begin
   SkipWhite;
   if (p<=length(s)) and (s[p]='/') then begin
    inc(p);
   end else begin
    exit;
   end;
   SkipWhite;
  end;
  n[j]:=0;
  neg:=(p<=length(s)) and (s[p]='-');
  if neg then begin
   inc(p);
  end;
  if (p<=length(s)) and IsDigit(s[p]) then begin
   i:=0;
   while (p<=length(s)) and IsDigit(s[p]) do begin
    i:=(i*10)+(UInt8(AnsiChar(s[p]))-ord('0'));
    inc(p);
   end;
   if neg then begin
    i:=-i;
   end;
   n[j]:=i;
  end else begin
   exit;
  end;
 end;
 if (n[0]>=70) and (n[1]>=70) then begin
  exit;
 end;
 if n[0]>=70 then begin
  y:=n[0]+1900;
  m:=n[1];
  d:=n[2];
 end else begin
  m:=n[0];
  d:=n[1];
  y:=n[2];
  if y<100 then begin
   y:=n[0]+1900;
  end;
 end;
 if (m<0) or ((d<1) or (d>31)) then begin
  exit;
 end;

 hr:=0;
 min:=0;
 sec:=0;
 ms:=0;

 if not ((p<=length(s)) and IsWhite(s[p])) then begin
  SkipWhite;

  if (p<=length(s)) and IsDigit(s[p]) then begin
   i:=0;
   while (p<=length(s)) and IsDigit(s[p]) do begin
    i:=(i*10)+(UInt8(AnsiChar(s[p]))-ord('0'));
    inc(p);
   end;
   hr:=i;
   SkipWhite;
   if (p<=length(s)) and (s[p]=':') then begin
    inc(p);
    SkipWhite;

    if (p<=length(s)) and IsDigit(s[p]) then begin
     i:=0;
     while (p<=length(s)) and IsDigit(s[p]) do begin
      i:=(i*10)+(UInt8(AnsiChar(s[p]))-ord('0'));
      inc(p);
     end;
     min:=i;
     SkipWhite;
     if (p<=length(s)) and (s[p]=':') then begin
      inc(p);
      SkipWhite;

      if (p<=length(s)) and IsDigit(s[p]) then begin
       i:=0;
       while (p<=length(s)) and IsDigit(s[p]) do begin
        i:=(i*10)+(UInt8(AnsiChar(s[p]))-ord('0'));
        inc(p);
       end;
       sec:=i;
       SkipWhite;
       if (p<=length(s)) and ((s[p]=':') or (s[p]='.')) then begin
        inc(p);
        SkipWhite;
        if (p<=length(s)) and IsDigit(s[p]) then begin
         i:=0;
         while (p<=length(s)) and IsDigit(s[p]) do begin
          i:=(i*10)+(UInt8(AnsiChar(s[p]))-ord('0'));
          inc(p);
         end;
         ms:=i;
         SkipWhite;
        end;
       end;
      end else begin
       exit;
      end;

     end;

     if ((p+1)<=length(s)) and (ToLower(s[p+1])='m') then begin
      if ToLower(s[p])='a' then begin
       if (hr<1) or (hr>12) then begin
        exit;
       end;
       hr:=(hr mod 12)+12;
      end else if ToLower(s[p])='p' then begin
       if (hr<1) or (hr>12) then begin
        exit;
       end;
       hr:=hr mod 12;
      end else begin
       exit;
      end;
      inc(p,2);
      SkipWhite;
     end;

    end else begin
     exit;
    end;

   end;
  end;

 end;

 if ((hr<0) or (hr>=24)) or ((min<0) or (min>=60)) or ((sec<0) or (sec>=60)) or ((ms<0) or (ms>=1000)) then begin
  exit;
 end;

 result:=DateTimeFromLocalTimeToUniversalTime(MakeDate(y,m,d)+MakeTime(hr,min,sec,ms));

end;

function ParseDateTime(const aDateTime:TPOCARawByteString):TDateTime;
begin
 result:=ParseTime(aDateTime);
 if IsNaN(result) then begin
  result:=ParseISOTime(aDateTime);
  if IsNaN(result) then begin
   result:=ParseNetscapeTime(aDateTime);
{$if declared(StrToDateTimeDef)}
   if IsNaN(result) then begin
    result:=StrToDateTimeDef(aDateTime,NaN);
   end;
{$ifend}
  end;
 end;
end;

function PosEx(const SubStr,s:TPOCARawByteString;Offset:TPOCAInt32=1):TPOCAInt32;
var i,x,LenSubStr:TPOCAInt32;
begin
 if Offset=1 then begin
  result:=System.Pos(SubStr,s);
 end else begin
  result:=0;
  LenSubStr:=length(SubStr);
  for i:=Offset to (length(s)-LenSubStr)+1 do begin
   if s[i]=SubStr[1] then begin
    x:=1;
    while (x<LenSubStr) and (s[i+x]=SubStr[x+1]) do begin
     inc(x);
    end;
    if x=LenSubStr then begin
     result:=i;
     break;
    end;
   end;
  end;
 end;
end;

{$if defined(fpc) and defined(Linux)}
type TReadLine_readline=function(_para1:PAnsiChar):PAnsiChar; cdecl;
     TReadLine_add_history=procedure(_para1:PAnsiChar); cdecl;
     TReadLine_free=procedure(_para1:TPOCAPointer); cdecl;

var ReadLine_readline:TReadLine_readline=nil;
    ReadLine_add_history:TReadLine_add_history=nil;
    ReadLine_free:TReadLine_free=nil;
    ReadLine_LibHandle:TLibHandle=NilHandle;
    ReadLine_CLibHandle:TLibHandle=NilHandle;
    ReadLine_Initialized_State:TPasMPInt32=0;

procedure ReadLine_Initialize;
var Index:TPOCAInt32;
begin
 if TPasMPInterlocked.CompareExchange(ReadLine_Initialized_State,1,0)=0 then begin
  try
   try
    ReadLine_LibHandle:=SafeLoadLibrary('libreadline.so');
    if ReadLine_LibHandle<>NilHandle then begin
     @ReadLine_readline:=GetProcAddress(ReadLine_LibHandle,'readline');
     @ReadLine_add_history:=GetProcAddress(ReadLine_LibHandle,'add_history');
    end;
    for Index:=-1 to 128 do begin
     if Index<0 then begin
      ReadLine_CLibHandle:=SafeLoadLibrary('libc.so');
     end else begin
      ReadLine_CLibHandle:=SafeLoadLibrary('libc.so.'+IntToStr(Index));
     end;
     if ReadLine_CLibHandle<>NilHandle then begin
      break;
     end;
    end;
    if ReadLine_CLibHandle<>NilHandle then begin
     @ReadLine_free:=GetProcAddress(ReadLine_CLibHandle,'free');
    end;
   except
   end;
  finally
   TPasMPInterlocked.Write(ReadLine_Initialized_State,2);
  end;
 end else begin
  while TPasMPInterlocked.Read(ReadLine_Initialized_State)<>2 do begin
   TPasMP.Relax;
  end;
 end;
end;
{$ifend}

function ReadLine(const aContext:PPOCAContext;const aPrompt:TPOCAUTF8String;out aNull:Boolean):TPOCAUTF8String;
{$if defined(fpc) and defined(Linux)}
var s:TPOCAUTF8String;
    t:TPOCAUTF8String;
    p:PAnsiChar;
begin
 ReadLine_Initialize;
 if assigned(ReadLine_readline) and assigned(ReadLine_add_history) and assigned(ReadLine_free) then begin
  if length(aPrompt)>0 then begin
   p:=ReadLine_readline(PAnsiChar(aPrompt));
  end else begin
   p:=ReadLine_readline(nil);
  end;
  if assigned(p) then begin
   aNull:=false;
   result:=PUCUUTF8Correct(p);
   if length(trim(result))>0 then begin
    ReadLine_add_history(p);
   end;
   ReadLine_free(p);
  end else begin
   aNull:=true;
   result:='';
  end;
 end else begin
  aNull:=false;
  s:='';
  if length(aPrompt)>0 then begin
   if assigned(aContext) and assigned(aContext^.UserIOWrite) then begin
    aContext^.UserIOWrite(aContext,aPrompt);
   end else begin
    System.Write(aPrompt);
   end;
  end;
  if assigned(aContext) and assigned(aContext^.UserIOReadLn) then begin
   aContext^.UserIOReadLn(aContext,t,aNull);
   s:=t;
  end else begin
   System.ReadLn(s);
  end;
  result:=s;
 end;
end;
{$else}
var s:TPOCAUTF8String;
    t:TPOCAUTF8String;
begin
 aNull:=false;
 s:='';
 if length(aPrompt)>0 then begin
  if assigned(aContext) and assigned(aContext^.UserIOWrite) then begin
   aContext^.UserIOWrite(aContext,aPrompt);
  end else begin
   System.Write(aPrompt);
  end;
 end;
 if assigned(aContext) and assigned(aContext^.UserIOReadLn) then begin
  aContext^.UserIOReadLn(aContext,t,aNull);
  s:=t;
 end else begin
  System.ReadLn(s);
 end;
 result:=s;
end;
{$ifend}

function CompareEx(const SubStr,s:TPOCARawByteString;Offset:TPOCAInt32=1):boolean;
var i,x,LenSubStr:TPOCAInt32;
begin
 result:=false;
 i:=Offset;
 LenSubStr:=length(SubStr);
 if (i<=((Length(s)-LenSubStr)+1)) and (s[i]=SubStr[1]) then begin
  x:=1;
  while (x<LenSubStr) and (s[i+x]=SubStr[x+1]) do begin
   inc(x);
  end;
  result:=x=LenSubStr;
 end;
end;

function POCARoundUpToPowerOfTwo(x:TPOCAPtrUInt):TPOCAPtrUInt; {$ifdef caninline}inline;{$endif}
begin
 dec(x);
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
{$ifdef cpu64}
 x:=x or (x shr 32);
{$endif}
 result:=x+1;
end;

function POCARoundUpToMask(x,m:TPOCAPtrUInt):TPOCAPtrUInt; {$ifdef caninline}inline;{$endif}
begin
 if (x and (m-1))<>0 then begin
  result:=(x+m) and not (m-1);
 end else begin
  result:=x;
 end;
end;

{$ifdef cpu64}
function POCAIsNaN(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=((PPOCAINT64(@AValue)^ and $7ff0000000000000)=$7ff0000000000000) and ((PPOCAINT64(@AValue)^ and $000fffffffffffff)<>$0000000000000000);
end;

function POCAIsInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCAINT64(@AValue)^ and $7fffffffffffffff)=$7ff0000000000000;
end;

function POCAIsFinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCAINT64(@AValue)^ and $7ff0000000000000)<>$7ff0000000000000;
end;

function POCAIsPosInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=PPOCAINT64(@AValue)^=TPOCAInt64($7ff0000000000000);
end;

function POCAIsNegInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
{$ifdef fpc}
 result:=TPOCAUInt64(TPOCAPointer(@AValue)^)=TPOCAUInt64($fff0000000000000);
{$else}
 result:=PPOCAInt64(@AValue)^=TPOCAInt64($fff0000000000000);
{$endif}
end;

function POCAIsPosZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=PPOCAINT64(@AValue)^=TPOCAInt64($0000000000000000);
end;

function POCAIsNegZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
{$ifdef fpc}
 result:=TPOCAUInt64(TPOCAPointer(@AValue)^)=TPOCAUInt64($8000000000000000);
{$else}
 result:=PPOCAInt64(@AValue)^=TPOCAInt64($8000000000000000);
{$endif}
end;

function POCAIsZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
{$ifdef fpc}
 result:=(TPOCAUInt64(TPOCAPointer(@AValue)^) and TPOCAUInt64($7fffffffffffffff))=UInt64($0000000000000000);
{$else}
 result:=(PPOCAInt64(@AValue)^ and TPOCAInt64($7fffffffffffffff))=TPOCAInt64($0000000000000000);
{$endif}
end;

function POCAIsNegative(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
{$ifdef fpc}
 result:=(TPOCAUInt64(TPOCAPointer(@AValue)^) and TPOCAUInt64($8000000000000000))<>0;
{$else}
 result:=(PPOCAInt64(@AValue)^ shr 63)<>0;
{$endif}
end;
{$else}
{$ifdef TrickyNumberChecks}
function POCAIsNaN(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
var l:TPOCAUInt32;
begin
 l:=PPOCADoubleHiLo(@AValue)^.Lo;
 result:=(TPOCAUInt32($7ff00000-TPOCAUInt32(TPOCAUInt32(PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff) or ((l or (-l)) shr 31))) shr 31)<>0;
end;

function POCAIsInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=TPOCAUInt32((TPOCAUInt32(PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff) xor $7ff00000) or PPOCADoubleHiLo(@AValue)^.Lo)=0;
end;

function POCAIsFinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(TPOCAUInt32((PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff)-$7ff00000) shr 31)<>0;
end;

function POCAIsPosInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
var h:TPOCAUInt32;
begin
 h:=PPOCADoubleHiLo(@AValue)^.Hi;
 result:=TPOCAUInt32(((TPOCAUInt32(h and $7fffffff) xor $7ff00000) or PPOCADoubleHiLo(@AValue)^.Lo) or TPOCAUInt32(h shr 31))=0;
end;

function POCAIsNegInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
var h:TPOCAUInt32;
begin
 h:=PPOCADoubleHiLo(@AValue)^.Hi;
 result:=TPOCAUInt32(((TPOCAUInt32(h and $7fffffff) xor $7ff00000) or PPOCADoubleHiLo(@AValue)^.Lo) or TPOCAUInt32(TPOCAUInt32(not h) shr 31))=0;
end;

function POCAIsPosZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
var h:TPOCAUInt32;
begin
 h:=PPOCADoubleHiLo(@AValue)^.Hi;
 result:=TPOCAUInt32(TPOCAUInt32(TPOCAUInt32(h and $7fffffff) or PPOCADoubleHiLo(@AValue)^.Lo) or TPOCAUInt32(h shr 31))=0;
end;

function POCAIsNegZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
var h:TPOCAUInt32;
begin
 h:=PPOCADoubleHiLo(@AValue)^.Hi;
 result:=TPOCAUInt32(TPOCAUInt32(TPOCAUInt32(h and $7fffffff) or PPOCADoubleHiLo(@AValue)^.Lo) or TPOCAUInt32(TPOCAUInt32(not h) shr 31))=0;
end;

function POCAIsZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=TPOCAUInt32(TPOCAUInt32(PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff) or PPOCADoubleHiLo(@AValue)^.Lo)=0;
end;

function POCAIsNegative(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=TPOCAUInt32(PPOCADoubleHiLo(@AValue)^.Hi and TPOCAUInt32($80000000))<>0;
end;
{$else}
function POCAIsNaN(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=((PPOCADoubleHiLo(@AValue)^.Hi and $7ff00000)=$7ff00000) and (((PPOCADoubleHiLo(@AValue)^.Hi and $000fffff) or PPOCADoubleHiLo(@AValue)^.Lo)<>0);
end;

function POCAIsInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=((PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff)=$7ff00000) and (PPOCADoubleHiLo(@AValue)^.Lo=0);
end;

function POCAIsFinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi and $7ff00000)<>$7ff00000;
end;

function POCAIsPosInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi=$7ff00000) and (PPOCADoubleHiLo(@AValue)^.Lo=0);
end;

function POCAIsNegInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi=$fff00000) and (PPOCADoubleHiLo(@AValue)^.Lo=0);
end;

function POCAIsPosZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi or PPOCADoubleHiLo(@AValue)^.Lo)=0;
end;

function POCAIsNegZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi=$80000000) and (PPOCADoubleHiLo(@AValue)^.Lo=0);
end;

function POCAIsZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=((PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff) or PPOCADoubleHiLo(@AValue)^.Lo)=0;
end;

function POCAIsNegative(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi and $80000000)<>0;
end;
{$endif}
{$endif}

function POCADoubleAbsolute(const AValue:double):double; {$ifdef caninline}inline;{$endif}
begin
{$ifdef cpu64}
 PPOCAINT64(@result)^:=PPOCAINT64(@AValue)^ and $7fffffffffffffff;
{$else}
 PPOCADoubleHiLo(@result)^.Hi:=PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff;
 PPOCADoubleHiLo(@result)^.Lo:=PPOCADoubleHiLo(@AValue)^.Lo;
{$endif}
end;

function Floor(FloatValue:double):double; {$ifdef caninline}inline;{$endif}
begin
 result:=System.int(FloatValue);
 if System.frac(FloatValue)<0 then begin
  result:=result-1;
 end;
end;

function Ceil(FloatValue:double):double; {$ifdef caninline}inline;{$endif}
begin
 result:=System.int(FloatValue);
 if System.frac(FloatValue)>0 then begin
  result:=result+1;
 end;
end;

function Modulo(x,y:double):double;{$if defined(cpu386)}stdcall; assembler;
asm
 fld qword ptr y
 fld qword ptr x
 @Repeat:
  fprem
  fstsw ax
  sahf
  jp @Repeat
 fstp st(1)
end;
{$elseif (defined(cpuamd64) or defined(cpux64))}{$ifdef fpc}ms_abi_default; nostackframe;{$endif} assembler;
asm
{$ifndef fpc}
 .noframe
{$endif}
 // Requires SSE2:
{movapd xmm2,xmm0
 divsd xmm2,xmm1
 cvttsd2si rax,xmm2
 pxor xmm2,xmm2
 cvtsi2sd xmm2,rax
 mulsd xmm1,xmm2
 subsd xmm0,xmm1}
 // Requires SSE4.1:
 movapd xmm2,xmm0
 divsd xmm2,xmm1
 roundsd xmm2,xmm2,1 // 1 = Floor
 mulsd xmm2,xmm1
 subsd xmm0,xmm2
end;
{$else}
begin
 result:=x-(Floor(x/y)*y);
end;
{$ifend}

function POCADoubleToString(const AValue:double):TPOCARawByteString;
begin
 result:=ConvertDoubleToString(AValue,omStandard,0);
end;

procedure GetMemAligned(var p;Size:TPOCAPtrInt;Align:TPOCAPtrUInt=16);
{$ifdef DelphiXE2AndUp}
begin
 GetMem(TPOCAPointer(p),Size);
end;
{$else}
var Original,Aligned:TPOCAPointer;
    Temp:PPOCAPointer;
    Mask:TPOCAPtrUInt;
begin
 if (Align and (Align-1))<>0 then begin
  dec(Align);
  Align:=Align or (Align shr 1);
  Align:=Align or (Align shr 2);
  Align:=Align or (Align shr 4);
  Align:=Align or (Align shr 8);
  Align:=Align or (Align shr 16);
{$ifdef cpu64}
  Align:=Align or (Align shr 32);
{$endif}
  inc(Align);
 end;
 Mask:=Align-1;
 inc(Size,((Align shl 1)+sizeof(TPOCAPointer)));
 GetMem(Original,Size);
 FillChar(Original^,Size,#0);
 Aligned:=TPOCAPointer(TPOCAPtrUInt(TPOCAPtrUInt(Original)+sizeof(TPOCAPointer)));
 if (Align>1) and ((TPOCAPtrUInt(Aligned) and Mask)<>0) then begin
  inc(TPOCAPtrUInt(Aligned),TPOCAPtrUInt(TPOCAPtrUInt(Align)-(TPOCAPtrUInt(Aligned) and Mask)));
 end;
 Temp:=TPOCAPointer(TPOCAPtrUInt(TPOCAPtrUInt(Aligned)-sizeof(TPOCAPointer)));
 Temp^:=Original;
 Temp:=TPOCAPointer(@p);
 Temp^:=Aligned;
end;
{$endif}

procedure FreeMemAligned(const p);
{$ifdef DelphiXE2AndUp}
begin
 FreeMem(TPOCAPointer(p));
end;
{$else}
var pp:TPOCAPointer;
begin
 pp:=TPOCAPointer(TPOCAPointer(@p)^);
 if assigned(pp) then begin
  pp:=TPOCAPointer(TPOCAPointer(TPOCAPtrUInt(TPOCAPtrUInt(pp)-sizeof(TPOCAPointer)))^);
  FreeMem(pp);
 end;
end;
{$endif}

{$ifdef POCAHasJIT}
procedure POCANativeCodeMemoryManagerFreeBlockContainer(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;BlockContainer:PPOCANativeCodeMemoryManagerBlockContainer); forward;

function POCANativeCodeMemoryManagerCreate(Instance:PPOCAInstance):PPOCANativeCodeMemoryManager;
{$ifdef windows}
var SystemInfo:TSystemInfo;
{$else}
{$ifdef unix}
{$endif}
{$endif}
begin
 New(result);
 FillChar(result^,sizeof(TPOCANativeCodeMemoryManager),#0);
 result^.Instance:=Instance;
{$ifdef windows}
 GetSystemInfo(SystemInfo);
 result^.PageSize:=POCARoundUpToPowerOfTwo(SystemInfo.dwPageSize);
{$else}
{$ifdef unix}
 result^.PageSize:=4096;
{$else}
 result^.PageSize:=4096;
{$endif}
{$endif}
{$ifdef cpu386}
 result^.Alignment:=16;
{$else}
{$ifdef cpuamd64}
 result^.Alignment:=16;
{$else}
{$ifdef cpuarm}
 result^.Alignment:=16;
{$else}
 result^.Alignment:=PageSize;
{$endif}
{$endif}
{$endif}
 result^.First:=nil;
 result^.Last:=nil;
end;

procedure POCANativeCodeMemoryManagerDestroy(var NativeCodeMemoryManager:PPOCANativeCodeMemoryManager);
begin
 if assigned(NativeCodeMemoryManager) then begin
  while assigned(NativeCodeMemoryManager^.First) do begin
   POCANativeCodeMemoryManagerFreeBlockContainer(NativeCodeMemoryManager,NativeCodeMemoryManager^.First);
  end;
  Dispose(NativeCodeMemoryManager);
  NativeCodeMemoryManager:=nil;
 end;
end;

function POCANativeCodeMemoryManagerAllocateBlockContainer(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;BlockContainerSize:TPOCAPtrUInt):PPOCANativeCodeMemoryManagerBlockContainer;
var Size:TPOCAPtrUInt;
    Block:PPOCANativeCodeMemoryManagerBlock;
begin
 if BlockContainerSize>0 then begin
  Size:=POCARoundUpToMask(BlockContainerSize,NativeCodeMemoryManager^.PageSize);
  New(result);
{$ifdef windows}
  result^.Base:=VirtualAlloc(nil,Size,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
{$else}
{$ifdef unix}
  result^.Base:=fpmmap(nil,Size,PROT_READ or PROT_WRITE or PROT_EXEC,MAP_PRIVATE or MAP_ANONYMOUS,-1,0);
{$else}
  GetMem(result^.Base,Size);
{$endif}
{$endif}
  result^.Size:=Size;
  result^.Used:=sizeof(TPOCANativeCodeMemoryManagerBlock)*2;
  if assigned(NativeCodeMemoryManager^.Last) then begin
   NativeCodeMemoryManager^.Last^.Next:=result;
   result^.Previous:=NativeCodeMemoryManager^.Last;
   NativeCodeMemoryManager^.Last:=result;
   result^.Next:=nil;
  end else begin
   NativeCodeMemoryManager^.First:=result;
   NativeCodeMemoryManager^.Last:=result;
   result^.Previous:=nil;
   result^.Next:=nil;
  end;
  FillChar(result^.Base^,result^.Size,#0);
  result^.First:=result^.Base;
  result^.Last:=TPOCAPointer(@PPOCAUInt8Array(result^.Base)^[result^.Size-sizeof(TPOCANativeCodeMemoryManagerBlock)]);
  Block:=result^.First;
  Block^.Signature:=bncmmMemoryBlockSignature;
  Block^.Previous:=nil;
  Block^.Next:=result^.Last;
  Block^.Size:=0;
  Block:=result^.Last;
  Block^.Signature:=bncmmMemoryBlockSignature;
  Block^.Previous:=result^.First;
  Block^.Next:=nil;
  Block^.Size:=0;
 end else begin
  result:=nil;
 end;
end;

procedure POCANativeCodeMemoryManagerFreeBlockContainer(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;BlockContainer:PPOCANativeCodeMemoryManagerBlockContainer);
begin
 if assigned(BlockContainer^.Previous) then begin
  BlockContainer^.Previous^.Next:=BlockContainer^.Next;
 end else if NativeCodeMemoryManager^.First=BlockContainer then begin
  NativeCodeMemoryManager^.First:=BlockContainer^.Next;
 end;
 if assigned(BlockContainer^.Next) then begin
  BlockContainer^.Next^.Previous:=BlockContainer^.Previous;
 end else if NativeCodeMemoryManager^.Last=BlockContainer^.Previous then begin
  NativeCodeMemoryManager^.Last:=BlockContainer^.Previous;
 end;
{$ifdef windows}
 VirtualFree(BlockContainer^.Base,0,MEM_RELEASE);
{$else}
{$ifdef unix}
 fpmunmap(BlockContainer^.Base,BlockContainer^.Size);
{$else}
 FreeMem(BlockContainer^.Base);
{$endif}
{$endif}
 Dispose(BlockContainer);
end;

function POCANativeCodeMemoryManagerGetMemory(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;Size:TPOCAPtrUInt):TPOCAPointer;
var BlockContainer:PPOCANativeCodeMemoryManagerBlockContainer;
    CurrentBlock,NewBlock:PPOCANativeCodeMemoryManagerBlock;
    DestSize,BlockContainerSize:TPOCAPtrUInt;
begin
 result:=nil;
 if Size>0 then begin
  DestSize:=Size+sizeof(TPOCANativeCodeMemoryManagerBlock);
  BlockContainer:=NativeCodeMemoryManager^.First;
  repeat
   while assigned(BlockContainer) do begin
    if (BlockContainer^.Used+DestSize)<=BlockContainer^.Size then begin
     CurrentBlock:=BlockContainer^.First;
     while assigned(CurrentBlock) and (CurrentBlock^.Signature=bncmmMemoryBlockSignature) and assigned(CurrentBlock^.Next) do begin
      NewBlock:=TPOCAPointer(TPOCAPtrUInt(POCARoundUpToMask(TPOCAPtrUInt(TPOCAPointer(@PPOCAUInt8Array(CurrentBlock)^[(sizeof(TPOCANativeCodeMemoryManagerBlock)*2)+CurrentBlock^.Size])),NativeCodeMemoryManager^.Alignment)-sizeof(TPOCANativeCodeMemoryManagerBlock)));
      if (TPOCAPtrUInt(CurrentBlock^.Next)-TPOCAPtrUInt(NewBlock))>=DestSize then begin
       NewBlock^.Signature:=bncmmMemoryBlockSignature;
       NewBlock^.Previous:=CurrentBlock;
       NewBlock^.Next:=CurrentBlock^.Next;
       NewBlock^.Size:=Size;
       CurrentBlock^.Next^.Previous:=NewBlock;
       CurrentBlock^.Next:=NewBlock;
       result:=TPOCAPointer(@PPOCAUInt8Array(NewBlock)^[sizeof(TPOCANativeCodeMemoryManagerBlock)]);
       inc(BlockContainer^.Used,DestSize);
       exit;
      end else begin
       CurrentBlock:=CurrentBlock^.Next;
      end;
     end;
    end;
    BlockContainer:=BlockContainer^.Next;
   end;
   if DestSize<=bncmmMINBLOCKCONTAINERSIZE then begin
    BlockContainerSize:=bncmmMINBLOCKCONTAINERSIZE;
   end else begin
    BlockContainerSize:=POCARoundUpToPowerOfTwo(DestSize);
   end;
   BlockContainer:=POCANativeCodeMemoryManagerAllocateBlockContainer(NativeCodeMemoryManager,BlockContainerSize);
   if not assigned(BlockContainer) then begin
    break;
   end;
  until false;
 end;
end;

procedure POCANativeCodeMemoryManagerFreeMemory(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;p:TPOCAPointer);
var BlockContainer:PPOCANativeCodeMemoryManagerBlockContainer;
    CurrentBlock:PPOCANativeCodeMemoryManagerBlock;
begin
 BlockContainer:=NativeCodeMemoryManager^.First;
 while assigned(BlockContainer) do begin
  if ((TPOCAPtrUInt(BlockContainer^.Base)+sizeof(TPOCANativeCodeMemoryManagerBlock))<=TPOCAPtrUInt(p)) and ((TPOCAPtrUInt(p)+sizeof(TPOCANativeCodeMemoryManagerBlock))<(TPOCAPtrUInt(BlockContainer^.Base)+BlockContainer^.Size)) then begin
   CurrentBlock:=TPOCAPointer(TPOCAPtrUInt(TPOCAPtrUInt(p)-sizeof(TPOCANativeCodeMemoryManagerBlock)));
   if (CurrentBlock^.Signature=bncmmMemoryBlockSignature) and (CurrentBlock<>BlockContainer^.First) and (CurrentBlock<>BlockContainer^.Last) then begin
    dec(BlockContainer^.Used,CurrentBlock^.Size+sizeof(TPOCANativeCodeMemoryManagerBlock));
    CurrentBlock^.Signature:=0;
    CurrentBlock^.Previous^.Next:=CurrentBlock^.Next;
    CurrentBlock^.Next^.Previous:=CurrentBlock^.Previous;
    if (assigned(BlockContainer^.First) and (BlockContainer^.First^.Next=BlockContainer^.Last)) or not assigned(BlockContainer^.First) then begin
     POCANativeCodeMemoryManagerFreeBlockContainer(NativeCodeMemoryManager,BlockContainer);
    end;
    exit;
   end;
  end;
  BlockContainer:=BlockContainer^.Next;
 end;
end;

function POCANativeCodeMemoryManagerReallocateMemory(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;p:TPOCAPointer;Size:TPOCAPtrUInt):TPOCAPointer;
var BlockContainer:PPOCANativeCodeMemoryManagerBlockContainer;
    CurrentBlock:PPOCANativeCodeMemoryManagerBlock;
    DestSize:TPOCAPtrUInt;
begin
 result:=nil;
 if assigned(p) then begin
  if Size=0 then begin
   POCANativeCodeMemoryManagerFreeMemory(NativeCodeMemoryManager,p);
  end else begin
   DestSize:=Size+sizeof(TPOCANativeCodeMemoryManagerBlock);
   BlockContainer:=NativeCodeMemoryManager^.First;
   while assigned(BlockContainer) do begin
    if ((TPOCAPtrUInt(BlockContainer^.Base)+sizeof(TPOCANativeCodeMemoryManagerBlock))<=TPOCAPtrUInt(p)) and ((TPOCAPtrUInt(p)+sizeof(TPOCANativeCodeMemoryManagerBlock))<(TPOCAPtrUInt(BlockContainer^.Base)+BlockContainer^.Size)) then begin
     CurrentBlock:=TPOCAPointer(TPOCAPtrUInt(TPOCAPtrUInt(p)-sizeof(TPOCANativeCodeMemoryManagerBlock)));
     if (CurrentBlock^.Signature=bncmmMemoryBlockSignature) and (CurrentBlock<>BlockContainer^.First) and (CurrentBlock<>BlockContainer^.Last) then begin
      if (TPOCAPtrUInt(CurrentBlock^.Next)-TPOCAPtrUInt(CurrentBlock))>=DestSize then begin
       CurrentBlock^.Size:=Size;
       result:=p;
       exit;
      end else begin
       result:=POCANativeCodeMemoryManagerGetMemory(NativeCodeMemoryManager,Size);
       if assigned(result) then begin
        if CurrentBlock^.Size<Size then begin
         Move(p^,result^,CurrentBlock^.Size);
        end else begin
         Move(p^,result^,Size);
        end;
       end;
       POCANativeCodeMemoryManagerFreeMemory(NativeCodeMemoryManager,p);
       exit;
      end;
     end;
    end;
    BlockContainer:=BlockContainer^.Next;
   end;
  end;
  POCANativeCodeMemoryManagerFreeMemory(NativeCodeMemoryManager,p);
 end else if Size<>0 then begin
  result:=POCANativeCodeMemoryManagerGetMemory(NativeCodeMemoryManager,Size);
 end;
end;
{$endif}

{$if defined(cpuamd64) and not defined(fpc)}
procedure POCA_x86_64_Pause; assembler; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifndef fpc}
 .noframe
{$endif}
 rep nop
end;
{$ifend}

procedure POCAWait; {$ifdef cpu386}register;{$endif}
{$ifdef unix}
{$ifndef usecthreads}
var timeout:timeval;
{$endif}
{$endif}
begin
{$ifdef win32}
 sleep(0);
{$else}
{$ifdef unix}
{$ifdef usecthreads}
 sched_yield;
{$else}
 timeout.tv_sec:=0;
 timeout.tv_usec:=0;
 fpselect(0,nil,nil,nil,@timeout);
{$endif}
{$else}
{$ifdef cpu386}
 asm
  rep nop // aka PAUSE instruction
 end;
{$else}
{$ifdef cpuamd64}
{$ifdef fpc}
 asm
  rep nop // aka PAUSE instruction
 end;
{$else}
 POCA_x86_64_Pause;
{$endif}
{$endif}
{$endif}
{$endif}
{$endif}
end;

procedure POCAMRSWLockInit(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 xor ecx,ecx
 lock xchg dword ptr [eax+TPOCAMRSWLock.State],ecx
end;
{$else}
begin
 TPasMPInterlocked.Exchange(MRSWLock^.State,0);
end;
{$endif}

procedure POCAMRSWLockDone(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 xor ecx,ecx
 lock xchg dword ptr [eax+TPOCAMRSWLock.State],ecx
end;
{$else}
begin
 TPasMPInterlocked.Exchange(MRSWLock^.State,0);
end;
{$endif}

procedure POCAMRSWLockReadLock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 @TryLoop:
 lock inc dword ptr [eax+TPOCAMRSWLock.State]
 js @TryUndo
 jmp @TryLoopDone
 @TryUndo:
 lock dec dword ptr [eax+TPOCAMRSWLock.State]
 @WaitLoop:
 cmp dword ptr [eax+TPOCAMRSWLock.State],0
 js @WaitLoop
 jmp @TryLoop
 @TryLoopDone:
end;
{$else}
var Current:TPOCAInt32;
begin
 repeat
  Current:=MRSWLock^.State and $fffffffe;
 until TPasMPInterlocked.CompareExchange(MRSWLock^.State,Current+2,Current)=Current;
end;
{$endif}

procedure POCAMRSWLockReadUnlock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 lock dec dword ptr [eax+TPOCAMRSWLock.State]
end;
{$else}
begin
 TPasMPInterlocked.Add(MRSWLock^.State,-2);
end;
{$endif}

procedure POCAMRSWLockWriteLock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 @TryLoop:
 lock bts dword ptr [eax+TPOCAMRSWLock.State],31
 jc @WaitLoop
 test dword ptr [eax+TPOCAMRSWLock.State],$7fffffff
 jnz @TryUndo
 jmp @TryLoopDone
 @TryUndo:
 lock btr dword ptr [eax+TPOCAMRSWLock.State],31
 @WaitLoop:
 cmp dword ptr [eax+TPOCAMRSWLock.State],0
 jnz @WaitLoop
 jmp @TryLoop
 @TryLoopDone:
end;
{$else}
var Current:TPOCAInt32;
begin
 repeat
  Current:=MRSWLock^.State and $fffffffe;
 until TPasMPInterlocked.CompareExchange(MRSWLock^.State,Current or 1,Current)=Current;
 while MRSWLock^.State<>1 do begin
 end;
end;
{$endif}

procedure POCAMRSWLockWriteUnlock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 lock btr dword ptr [eax+TPOCAMRSWLock.State],31
end;
{$else}
begin
 TPasMPInterlocked.Exchange(MRSWLock^.State,0);
end;
{$endif}

procedure POCAMRSWLockReadToWrite(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 // Don't use lock cmpxchg! To avoid dead locks :-)
 lock dec dword ptr [eax+TPOCAMRSWLock.State]
 @TryLoop:
 lock bts dword ptr [eax+TPOCAMRSWLock.State],31
 jc @WaitLoop
 test dword ptr [eax+TPOCAMRSWLock.State],$7fffffff
 jnz @TryUndo
 jmp @TryLoopDone
 @TryUndo:
 lock btr dword ptr [eax+TPOCAMRSWLock.State],31
 @WaitLoop:
 cmp dword ptr [eax+TPOCAMRSWLock.State],0
 jnz @WaitLoop
 jmp @TryLoop
 @TryLoopDone:
end;
{$else}
var Current:TPOCAInt32;
begin
 repeat
  Current:=MRSWLock^.State and $fffffffe;
 until TPasMPInterlocked.CompareExchange(MRSWLock^.State,(Current-2) or 1,Current)=Current;
 while MRSWLock^.State<>1 do begin
 end;
end;
{$endif}

procedure POCAMRSWLockWriteToRead(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 mov ecx,1
 lock xchg dword ptr [eax+TPOCAMRSWLock.State],ecx
end;
{$else}
begin
 TPasMPInterlocked.Exchange(MRSWLock^.State,2);
end;
{$endif}

function POCAMRSWLockReaders(MRSWLock:PPOCAMRSWLock):TPOCAInt32; {$ifdef cpu386}register;{$endif}
begin
{$ifdef cpu386}
 result:=TPOCAInt32(TPOCAUInt32(MRSWLock^.State and $7fffffff));
{$else}
 result:=TPOCAInt32(TPOCAUInt32(MRSWLock^.State shr 1));
{$endif}
end;

function POCAMRSWLockWriters(MRSWLock:PPOCAMRSWLock):TPOCAInt32; {$ifdef cpu386}register;{$endif}
begin
{$ifdef cpu386}
 result:=TPOCAInt32(TPOCAUInt32(MRSWLock^.State shr 31));
{$else}
 result:=TPOCAInt32(TPOCAUInt32(MRSWLock^.State and 1));
{$endif}
end;

constructor TPOCAPointerList.Create;
begin
 inherited Create;
 List:=nil;
 ListCount:=0;
 ListCapacity:=0;
 Clear;
end;

destructor TPOCAPointerList.Destroy;
begin
 Clear;
 inherited Destroy;
end;

procedure TPOCAPointerList.Clear;
begin
 ListCount:=0;
 ListCapacity:=0;
 if assigned(List) then begin
  FreeMem(List);
  List:=nil;
 end;
end;

procedure TPOCAPointerList.SetCapacity(NewCapacity:TPOCAInt32);
begin
 if (NewCapacity>=0) and (NewCapacity<MaxListSize) then begin
  ReallocMem(List,NewCapacity*sizeof(TPOCAPointer));
  ListCapacity:=NewCapacity;
  if ListCapacity<ListCount then begin
   ListCount:=ListCapacity;
  end;
  if ListCapacity<NewCapacity then begin
   FillChar(List^[ListCapacity],(NewCapacity-ListCapacity)*sizeof(TPOCAPointer),#0);
  end;
 end;
end;

procedure TPOCAPointerList.SetCount(NewCount:TPOCAInt32);
var NewCapacity:TPOCAInt32;
begin
 if NewCount<ListCount then begin
  if NewCount<1024 then begin
   NewCapacity:=1024;
  end else begin
   NewCapacity:=POCARoundUpToPowerOfTwo(NewCount);
  end;
  if NewCapacity<>ListCapacity then begin
   ReallocMem(List,NewCapacity*sizeof(TPOCAPointer));
   ListCapacity:=NewCapacity;
  end;
 end else if NewCount>ListCount then begin
  if NewCount>ListCapacity then begin
   if NewCount<1024 then begin
    NewCapacity:=1024;
   end else begin
    NewCapacity:=POCARoundUpToPowerOfTwo(NewCount);
   end;
   ReallocMem(List,NewCapacity*sizeof(TPOCAPointer));
   if ListCount<NewCapacity then begin
    FillChar(List^[ListCount],(NewCapacity-ListCount)*sizeof(TPOCAPointer),#0);
   end else if ListCapacity<NewCapacity then begin
    FillChar(List^[ListCapacity],(NewCapacity-ListCapacity)*sizeof(TPOCAPointer),#0);
   end;
   ListCapacity:=NewCapacity;
  end;
 end;
 ListCount:=NewCount;
end;

function TPOCAPointerList.Add(Item:TPOCAPointer):TPOCAInt32;
begin
 result:=ListCount;
 SetCount(result+1);
 List^[result]:=Item;
end;

procedure TPOCAPointerList.Insert(Index:TPOCAInt32;Item:TPOCAPointer);
var i:TPOCAInt32;
begin
 if (Index>=0) and (Index<ListCount) then begin
  SetCount(ListCount+1);
  for i:=ListCount-1 downto Index do begin
   List^[i+1]:=List^[i];
  end;
  List^[Index]:=Item;
 end else if Index=ListCount then begin
  Add(Item);
 end else if Index>ListCount then begin
  SetCount(Index);
  Add(Item);
 end;
end;

function TPOCAPointerList.Find(Item:TPOCAPointer):TPOCAInt32;
var i:TPOCAInt32;
begin
 for i:=0 to ListCount-1 do begin
  if List^[i]=Item then begin
   result:=i;
   exit;
  end;
 end;
 result:=-1;
end;

function TPOCAPointerList.IndexOf(Item:TPOCAPointer):TPOCAInt32;
begin
 result:=Find(Item);
end;

procedure TPOCAPointerList.Delete(Index:TPOCAInt32);
var i,j,k:TPOCAInt32;
begin
 if (Index>=0) and (Index<ListCount) then begin
  k:=ListCount-1;
  j:=Index;
  List^[Index]:=nil;
  for i:=j to k-1 do begin
   List^[i]:=List^[i+1];
  end;
  SetCount(k);
 end;
end;

function TPOCAPointerList.Remove(Item:TPOCAPointer):TPOCAInt32;
begin
 result:=Find(Item);
 if result>=0 then begin
  Delete(result);
 end;
end;

procedure TPOCAPointerList.Exchange(Index1,Index2:TPOCAInt32);
var TempPointer:TPOCAPointer;
begin
 if (Index1>=0) and (Index1<ListCount) and (Index2>=0) and (Index2<ListCount) then begin
  TempPointer:=List^[Index1];
  List^[Index1]:=List^[Index2];
  List^[Index2]:=TempPointer;
 end;
end;

function TPOCAPointerList.GetItem(Index:TPOCAInt32):TPOCAPointer;
begin
 if (Index>=0) and (Index<ListCount) then begin
  result:=List^[Index];
 end else begin
  result:=nil;
 end;
end;

procedure TPOCAPointerList.SetItem(Index:TPOCAInt32;Value:TPOCAPointer);
begin
 if (Index>=0) and (Index<ListCount) then begin
  List^[Index]:=Value;
 end;
end;

function POCARegExpCompile(Context:PPOCAContext;const s:TPOCARawByteString;IsUTF8:TPOCAInt32):TFLRE;
begin
 result:=nil;
 try
  result:=TFLRE.Create(s,[rfDELIMITERS]);
 except
  on e:Exception do begin
   FreeAndNil(result);
   POCARuntimeError(Context,TPOCAUTF8String(e.Message));
  end;
 end;
end;

{$ifdef Windows}
{$define UseFibersForCoroutines}
{$else}
{$define UseThreadsForCoroutines}
{$endif}

{$if defined(UseFibersForCoroutines)}
function CreateFiber(dwStackSize:TPOCAUInt32;lpStartAddress,lpParameter:TPOCAPointer):TPOCAPointer; stdcall; external 'kernel32.dll' name 'CreateFiber';
procedure DeleteFiber(lpFiber:TPOCAPointer); stdcall; external 'kernel32.dll' name 'DeleteFiber';
procedure SwitchToFiber(lpFiber:TPOCAPointer); stdcall; external 'kernel32.dll' name 'SwitchToFiber';
function ConvertThreadToFiber(lpParameter:TPOCAPointer):TPOCAPointer; stdcall; external 'kernel32.dll' name 'ConvertThreadToFiber';

function GetCurrentFiber:TPOCAPointer; assembler; register;
asm
{$ifdef cpu386}
 mov eax,dword ptr fs:[$10] // $1016
{$else}
{$ifdef cpuamd64}
 mov rax,qword ptr gs:[$20]
{$endif}
{$endif}
end;

function GetFiberData:TPOCAPointer; assembler; register;
asm
{$ifdef cpu386}
 mov eax,dword ptr fs:[$10] // $1016
 mov eax,dword ptr [eax]
{$else}
{$ifdef cpuamd64}
 mov rax,qword ptr gs:[$20]
 mov rax,qword ptr [rax]
{$endif}
{$endif}
end;
{$elseif not defined(UseThreadsForCoroutines)}
{$if defined(cpu386)}
type PPOCACoroutineContextJmpBuf=^TPOCACoroutineContextJmpBuf;
     TPOCACoroutineContextJmpBuf=record
      RegEBX,RegESI,RegEDI,RegESP,RegEBP,RegEIP:TPOCAUInt32;
      FPUCW:TPOCAUInt16;
     end;

     PPOCACoroutineContext=^TPOCACoroutineContext;
     TPOCACoroutineContext=record
      JmpBuf:TPOCACoroutineContextJmpBuf;
      Stack:TPOCAPointer;
      StackSize:TPOCAInt32;
     end;

function POCACoroutineContextSetJmp(JmpBuf:PPOCACoroutineContextJmpBuf):TPOCAInt32; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
 fstcw word ptr [eax+TPOCACoroutineContextJmpBuf.FPUCW]
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegEBX],ebx
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegESI],esi
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegEDI],edi
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegEBP],ebp
 lea edx,dword ptr [esp+4]
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegESP],edx
 mov edx,dword ptr [esp]
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegEIP],edx
 xor eax,eax
end;

procedure POCACoroutineContextLongJmp(JmpBuf:PPOCACoroutineContextJmpBuf;ResultValue:TPOCAInt32); assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
 xchg edx,eax
 fldcw word ptr [edx+TPOCACoroutineContextJmpBuf.FPUCW]
 mov ebx,dword ptr [edx+TPOCACoroutineContextJmpBuf.RegEBX]
 mov esi,dword ptr [edx+TPOCACoroutineContextJmpBuf.RegESI]
 mov edi,dword ptr [edx+TPOCACoroutineContextJmpBuf.RegEDI]
 mov ebp,dword ptr [edx+TPOCACoroutineContextJmpBuf.RegEBP]
 mov esp,dword ptr [edx+TPOCACoroutineContextJmpBuf.RegESP]
 jmp dword ptr [edx+TPOCACoroutineContextJmpBuf.RegEIP]
end;

function POCACoroutineContextCreate(StackSize:TPOCAInt32;Entrypoint,Parameter:TPOCAPointer):PPOCACoroutineContext;
begin
 New(result);
 FillChar(result^,sizeof(TPOCACoroutineContext),#0);
 if assigned(Entrypoint) then begin
  result^.StackSize:=StackSize;
  GetMem(result^.Stack,StackSize);
  FillChar(result^.Stack^,StackSize,#0);
  POCACoroutineContextSetJmp(@result^.JmpBuf);
  result^.JmpBuf.RegESP:={$ifdef fpc}TPOCAPtrUInt{$else}TPOCAUInt32{$endif}(result^.Stack)+TPOCAUInt32(StackSize-TPOCAInt32(sizeof(TPOCAPointer)*2));
  TPOCAPointer(TPOCAPointer({$ifdef fpc}TPOCAPtrUInt{$else}TPOCAUInt32{$endif}({$ifdef fpc}TPOCAPtrUInt{$else}TPOCAUInt32{$endif}(result^.JmpBuf.RegESP+sizeof(TPOCAPointer))))^):=Parameter;
  result^.JmpBuf.RegEBP:=0;
  result^.JmpBuf.RegEIP:={$ifdef fpc}TPOCAPtrUInt{$else}TPOCAUInt32{$endif}(Entrypoint);
 end;
end;

procedure POCACoroutineContextDestroy(Context:PPOCACoroutineContext);
begin
 if assigned(Context) then begin
  if assigned(Context^.Stack) then begin
   FreeMem(Context^.Stack);
   Context^.Stack:=nil;
  end;
  Dispose(Context);
  Context:=nil;
 end;
end;

procedure POCACoroutineContextSwitch(FromContext,ToContext:PPOCACoroutineContext);
begin
 if POCACoroutineContextSetJmp(@FromContext^.JmpBuf)=0 then begin
  POCACoroutineContextLongJmp(@ToContext^.JmpBuf,1);
 end;
end;

procedure POCACoroutineContextGet(Context:PPOCACoroutineContext);
begin
 POCACoroutineContextSetJmp(@Context^.JmpBuf);
end;
{$elseif defined(cpuamd64)}
type PPOCACoroutineContextJmpBuf=^TPOCACoroutineContextJmpBuf;
     TPOCACoroutineContextJmpBuf=record
      RegRBX{$ifdef win64},RegRCX{$endif},RegRBP,RegR12,RegR13,RegR14,RegR15,RegRSP,RegRIP{$ifdef win64},RegRSI,RegRDI{$else},RegRDI{$endif}:TPOCAUInt64;
     end;

     PPOCACoroutineContext=^TPOCACoroutineContext;
     TPOCACoroutineContext=record
      JmpBuf:TPOCACoroutineContextJmpBuf;
      Stack:TPOCAPointer;
      StackSize:TPOCAInt32;
     end;

function POCACoroutineContextSetJmp(JmpBuf:PPOCACoroutineContextJmpBuf):TPOCAInt32; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifdef win64}
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRBX],rbx
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRCX],rcx
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRBP],rbp
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR12],r12
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR13],r13
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR14],r14
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR15],r15
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRSI],rsi
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRDI],rdi
 lea rdx,qword ptr [rsp+8]
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRSP],rdx
 mov r8,qword ptr [rsp+0]
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRIP],r8
 xor rax,rax
{$else}
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRBX],rbx
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRBP],rbp
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR12],r12
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR13],r13
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR14],r14
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR15],r15
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRDI],rdi
 lea rdx,qword ptr [rsp+8]
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRSP],rdx
 mov rsi,qword ptr [rsp+0]
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRIP],rsi
 xor rax,rax
{$endif}
end;

procedure POCACoroutineContextLongJmp(JmpBuf:PPOCACoroutineContextJmpBuf;ResultValue:TPOCAInt32); assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifdef win64}
 mov rbx,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRBX]
 mov rbp,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRBP]
 mov r12,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR12]
 mov r13,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR13]
 mov r14,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR14]
 mov r15,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR15]
 test edx,edx
 mov eax,1
 cmove edx,eax
 mov eax,edx
 mov rsp,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRSP]
 mov rdx,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRIP]
 mov rsi,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRSI]
 push qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRCX]
 mov rdi,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRDI]
 pop rcx
 jmp rdx
{$else}
 mov rbx,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRBX]
 mov rbp,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRBP]
 mov r12,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR12]
 mov r13,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR13]
 mov r14,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR14]
 mov r15,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR15]
 test esi,esi
 mov eax,1
 cmove esi,eax
 mov eax,esi
 mov rsp,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRSP]
 push qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRDI]
 mov rdx,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRIP]
 pop rdi
 jmp rdx
{$endif}
end;

function POCACoroutineContextCreate(StackSize:TPOCAInt32;Entrypoint,Parameter:TPOCAPointer):PPOCACoroutineContext;
begin
 New(result);
 FillChar(result^,sizeof(TPOCACoroutineContext),#0);
 if assigned(Entrypoint) then begin
  result^.StackSize:=StackSize;
  GetMem(result^.Stack,StackSize);
  FillChar(result^.Stack^,StackSize,#0);
  POCACoroutineContextSetJmp(@result^.JmpBuf);
  result^.JmpBuf.RegRSP:={$ifdef fpc}TPOCAPtrUInt{$else}TPOCAInt64{$endif}(result^.Stack)+{$ifdef fpc}TPOCAPtrUInt{$else}TPOCAInt64{$endif}(StackSize-{$ifdef fpc}TPOCAPtrInt{$else}TPOCAInt64{$endif}(sizeof(TPOCAPointer)*2));
  TPOCAPointer(TPOCAPointer({$ifdef fpc}TPOCAPtrUInt{$else}TPOCAUInt32{$endif}({$ifdef fpc}TPOCAPtrUInt{$else}TPOCAInt64{$endif}(result^.JmpBuf.RegRSP+sizeof(TPOCAPointer))))^):=Parameter;
{$ifdef win64}
  result^.JmpBuf.RegRCX:={$ifdef fpc}TPOCAPtrUInt{$else}{$endif}(Parameter);
{$else}
  result^.JmpBuf.RegRDI:={$ifdef fpc}TPOCAPtrUInt{$else}{$endif}(Parameter);
{$endif}
  result^.JmpBuf.RegRBP:=0;
  result^.JmpBuf.RegRIP:={$ifdef fpc}TPOCAPtrUInt{$else}{$endif}(Entrypoint);
 end;
end;

procedure POCACoroutineContextDestroy(Context:PPOCACoroutineContext);
begin
 if assigned(Context) then begin
  if assigned(Context^.Stack) then begin
   FreeMem(Context^.Stack);
   Context^.Stack:=nil;
  end;
  Dispose(Context);
  Context:=nil;
 end;
end;

procedure POCACoroutineContextSwitch(FromContext,ToContext:PPOCACoroutineContext);
begin
 if POCACoroutineContextSetJmp(@FromContext^.JmpBuf)=0 then begin
  POCACoroutineContextLongJmp(@ToContext^.JmpBuf,1);
 end;
end;

procedure POCACoroutineContextGet(Context:PPOCACoroutineContext);
begin
 POCACoroutineContextSetJmp(@Context^.JmpBuf);
end;
{$else}
 {$define UseThreadsForCoroutines}
{$ifend}
{$ifend}

procedure POCACoroutineYield(Coroutine:PPOCACoroutine); forward;
procedure POCACoroutineEndYield(Coroutine:PPOCACoroutine); forward;

procedure POCACoroutineEntrypoint(Coroutine:PPOCACoroutine); {$ifndef UseThreadsForCoroutines}{$ifdef cpuamd64}register;{$else}{$ifdef windows}stdcall;{$else}cdecl;{$endif}{$endif}{$endif}
begin
 if assigned(Coroutine) then begin
  TPasMPInterlocked.Write(Coroutine^.Resumed,TPasMPBool32(true));
  if not Coroutine^.Terminated then begin
   try
    if assigned(Coroutine^.Entrypoint) then begin
     Coroutine^.Entrypoint(Coroutine);
    end;
   except
    on e:EPOCACoroutineTerminated do begin
    end;
    else begin
    end;
   end;
  end;
  TPasMPInterlocked.Exchange(Coroutine^.State,pcsINSIDETERMINATED);
  POCACoroutineEndYield(Coroutine);
 end;
end;

{$ifdef UseThreadsForCoroutines}
type PPOCACoroutineContext=^TPOCACoroutineContext;
     TPOCACoroutineContext=record
      Coroutine:PPOCACoroutine;
      Handle:THandle;
      ThreadID:{$ifdef fpc}TThreadID{$else}THandle{$endif};
      ResumeEvent,YieldEvent,TerminatedEvent:{$ifdef fpc}PRTLEvent{$else}TEvent{$endif};
     end;

{$ifdef fpc}
function POCACoroutineContextEntrypoint(CoroutineContext:TPOCAPointer):TPOCAPtrInt;
{$else}
function POCACoroutineContextEntrypoint(CoroutineContext:TPOCAPointer):TPOCAUInt32;
{$endif}
begin
 if assigned(CoroutineContext) then begin
{$ifdef fpc}
  RTLEventWaitFor(PPOCACoroutineContext(CoroutineContext)^.ResumeEvent);
{$else}
  PPOCACoroutineContext(CoroutineContext)^.ResumeEvent.WaitFor;
{$endif}
  try
   POCACoroutineEntrypoint(PPOCACoroutineContext(CoroutineContext)^.Coroutine);
  except
  end;
  EndThread(0);
 end;
 result:=0;
end;

function POCACoroutineContextCreate(StackSize:TPOCAInt32;Entrypoint:TPOCAPointer;Coroutine:PPOCACoroutine):PPOCACoroutineContext;
begin
 New(result);
 FillChar(result^,sizeof(TPOCACoroutineContext),#0);
 if assigned(Entrypoint) then begin
  result^.Coroutine:=Coroutine;
  result^.ResumeEvent:={$ifdef fpc}RTLEventCreate{$else}TEvent.Create(nil,false,false,''){$endif};
  result^.YieldEvent:={$ifdef fpc}RTLEventCreate{$else}TEvent.Create(nil,false,false,''){$endif};
  result^.TerminatedEvent:={$ifdef fpc}RTLEventCreate{$else}TEvent.Create(nil,false,false,''){$endif};
{$ifdef fpc}
  result^.Handle:=BeginThread(POCACoroutineContextEntrypoint,result,result^.ThreadID);
{$else}
  result^.Handle:=BeginThread(nil,StackSize,@POCACoroutineContextEntrypoint,result,0,result^.ThreadID);
{$endif}
 end;
end;

procedure POCACoroutineContextDestroy(Context:PPOCACoroutineContext);
begin
 if assigned(Context) then begin
  if (Context^.Coroutine^.State<>pcsINSIDETERMINATED) and (Context^.Coroutine^.State<>pcsTERMINATED) then begin
   TPasMPInterlocked.Write(Context^.Coroutine.Terminated,TPasMPBool32(true));
{$ifdef fpc}
   RTLEventSetEvent(Context^.ResumeEvent);
   RTLEventWaitFor(Context^.YieldEvent,1000);
   RTLEventWaitFor(Context^.TerminatedEvent,1000);
{$else}
   Context^.ResumeEvent.SetEvent;
   Context^.YieldEvent.WaitFor(1000);
   Context^.TerminatedEvent.WaitFor(1000);
{$endif}
   if (Context^.Coroutine^.State<>pcsINSIDETERMINATED) and (Context^.Coroutine^.State<>pcsTERMINATED) then begin
    try
{$ifdef fpc}
     System.KillThread(Context^.ThreadID);
{$else}
     TerminateThread(Context^.Handle,0);
{$endif}
    except
    end;
   end;
  end;
{$ifdef fpc}
  WaitForThreadTerminate(Context^.ThreadID,0);
  CloseThread(Context^.ThreadID);
{$else}
{$ifdef win32}
  WaitForSingleObject(Context^.Handle,TPOCAUInt32($ffffffff));
  CloseHandle(Context^.Handle);
{$endif}
{$endif}
{$ifdef fpc}
  RTLEventDestroy(Context^.ResumeEvent);
  RTLEventDestroy(Context^.YieldEvent);
  RTLEventDestroy(Context^.TerminatedEvent);
{$else}
  FreeAndNil(Context^.ResumeEvent);
  FreeAndNil(Context^.YieldEvent);
  FreeAndNil(Context^.TerminatedEvent);
{$endif}
  Dispose(Context);
  Context:=nil;
 end;
end;
{$endif}

function POCACoroutineCreate(EntryPoint:TPOCAPointer;StackSize:TPOCAInt32;Parameter:TPOCAPointer):PPOCACoroutine;
begin
 if StackSize=0 then begin
  StackSize:=65536;
 end;
 New(result);
 FillChar(result^,sizeof(TPOCACoroutine),#0);
 result^.Entrypoint:=EntryPoint;
 result^.Parameter:=Parameter;
 result^.State:=pcsOUTSIDE;
 result^.Resumed:=false;
 result^.Terminated:=false;
 result^.Event:={$ifdef fpc}RTLEventCreate{$else}TEvent.Create(nil,false,false,''){$endif};
{$if defined(UseFibersForCoroutines)}
 result^.Fiber:=CreateFiber(StackSize,@POCACoroutineEntrypoint,result);
 if not assigned(result^.Fiber) then begin
  RaiseLastOSError;
 end;
{$elseif defined(UseThreadsForCoroutines)}
 result^.Fiber:=POCACoroutineContextCreate(StackSize,@POCACoroutineEntrypoint,result);
 result^.Back:=nil;
{$else}
 result^.Fiber:=POCACoroutineContextCreate(StackSize,@POCACoroutineEntrypoint,result);
 result^.Back:=POCACoroutineContextCreate(0,nil,nil);
{$ifend}
end;

procedure POCACoroutineDestroy(Coroutine:PPOCACoroutine);
begin
 if assigned(Coroutine) then begin
{$if defined(UseFibersForCoroutines)}
  if assigned(Coroutine^.Fiber) then begin
   DeleteFiber(Coroutine^.Fiber);
   Coroutine^.Fiber:=nil;
  end;
{$elseif defined(UseThreadsForCoroutines)}
  POCACoroutineContextDestroy(Coroutine^.Fiber);
  Coroutine^.Fiber:=nil;
{$else}
  POCACoroutineContextDestroy(Coroutine^.Fiber);
  POCACoroutineContextDestroy(Coroutine^.Back);
  Coroutine^.Fiber:=nil;
  Coroutine^.Back:=nil;
{$ifend}
{$ifdef fpc}
  RTLEventDestroy(Coroutine^.Event);
{$else}
  FreeAndNil(Coroutine^.Event);
{$endif}
  Dispose(Coroutine);
  Coroutine:=nil;
 end;
end;

procedure POCACoroutineRaise(const s:TPOCAUTF8String);
begin
 raise EPOCARuntimeError.Create(String(s));
end;

function POCACoroutineResume(Coroutine:PPOCACoroutine;Throw:Boolean):Boolean;
{$ifdef UseFibersForCoroutines}
var Current:TPOCAPointer;
{$endif}
begin
 if assigned(Coroutine) then begin
  if (Coroutine^.State=pcsINSIDETERMINATED) or (Coroutine^.State=pcsTERMINATED) then begin
   if Throw then begin
    POCACoroutineRaise('Coroutine is already terminated');
   end;
   result:=false;
  end else begin
   while TPasMPInterlocked.CompareExchange(Coroutine^.State,pcsINSIDE,pcsOUTSIDE)=pcsINSIDE do begin
{$ifdef fpc}
    RTLEventWaitFor(Coroutine^.Event);
{$else}
    Coroutine^.Event.WaitFor(INFINITE);
{$endif}
   end;
   if assigned(Coroutine^.Fiber) then begin
{$if defined(UseFibersForCoroutines)}
    Current:=GetCurrentFiber;
    if (not assigned(Current)) or (Current=TPOCAPointer(TPOCAPtrUInt($1e00))) then begin
     Coroutine^.Back:=ConvertThreadToFiber(nil);
    end else begin
     Coroutine^.Back:=Current;
    end;
    Coroutine^.BackFPUCW:=Get8087CW;
    SwitchToFiber(Coroutine^.Fiber);
    Set8087CW(Coroutine^.BackFPUCW);
{$elseif defined(UseThreadsForCoroutines)}
{$ifdef fpc}
    RTLEventSetEvent(PPOCACoroutineContext(Coroutine^.Fiber)^.ResumeEvent);
    RTLEventWaitFor(PPOCACoroutineContext(Coroutine^.Fiber)^.YieldEvent);
{$else}
    PPOCACoroutineContext(Coroutine^.Fiber)^.ResumeEvent.SetEvent;
    PPOCACoroutineContext(Coroutine^.Fiber)^.YieldEvent.WaitFor(INFINITE);
{$endif}
{$else}
    POCACoroutineContextGet(Coroutine^.Back);
    POCACoroutineContextSwitch(Coroutine^.Back,Coroutine^.Fiber);
{$ifend}
   end;
   case Coroutine^.State of
    pcsINSIDE:begin
     TPasMPInterlocked.Exchange(Coroutine^.State,pcsOUTSIDE);
    end;
    pcsINSIDETERMINATED:begin
     TPasMPInterlocked.Exchange(Coroutine^.State,pcsTERMINATED);
    end;
   end;
{$ifdef fpc}
   RTLEventSetEvent(Coroutine^.Event);
{$else}
   Coroutine^.Event.SetEvent;
{$endif}
  end;
  result:=true;
 end else begin
  result:=false;
 end;
end;

procedure POCACoroutineYield(Coroutine:PPOCACoroutine);
begin
 if assigned(Coroutine) then begin
{$if defined(UseFibersForCoroutines)}
  if Coroutine^.State in [pcsINSIDE,pcsINSIDETERMINATED] then begin
   Coroutine^.FiberFPUCW:=Get8087CW;
   SwitchToFiber(Coroutine^.Back);
   Set8087CW(Coroutine^.FiberFPUCW);
  end else begin
   POCACoroutineRaise('The program control flow is outside coroutine');
  end;
{$elseif defined(UseThreadsForCoroutines)}
{$ifdef fpc}
  RTLEventSetEvent(PPOCACoroutineContext(Coroutine^.Fiber)^.YieldEvent);
  RTLEventWaitFor(PPOCACoroutineContext(Coroutine^.Fiber)^.ResumeEvent);
{$else}
  PPOCACoroutineContext(Coroutine^.Fiber)^.YieldEvent.SetEvent;
  PPOCACoroutineContext(Coroutine^.Fiber)^.ResumeEvent.WaitFor(INFINITE);
{$endif}
  if Coroutine^.Terminated then begin
   raise EPOCACoroutineTerminated.Create('Coroutine terminated');
  end;
{$else}
  if Coroutine^.State in [pcsINSIDE,pcsINSIDETERMINATED] then begin
   POCACoroutineContextSwitch(Coroutine^.Fiber,Coroutine^.Back);
  end else begin
   POCACoroutineRaise('The program control flow is outside coroutine');
  end;
{$ifend}
 end;
end;

procedure POCACoroutineEndYield(Coroutine:PPOCACoroutine);
begin
 if assigned(Coroutine) then begin
{$if defined(UseFibersForCoroutines)}
  if Coroutine^.State in [pcsINSIDE,pcsINSIDETERMINATED] then begin
   Coroutine^.FiberFPUCW:=Get8087CW;
   SwitchToFiber(Coroutine^.Back);
   Set8087CW(Coroutine^.FiberFPUCW);
  end else begin
   POCACoroutineRaise('The program control flow is outside coroutine');
  end;
{$elseif defined(UseThreadsForCoroutines)}
{$ifdef fpc}
  RTLEventSetEvent(PPOCACoroutineContext(Coroutine^.Fiber)^.YieldEvent);
  RTLEventSetEvent(PPOCACoroutineContext(Coroutine^.Fiber)^.TerminatedEvent);
{$else}
  PPOCACoroutineContext(Coroutine^.Fiber)^.YieldEvent.SetEvent;
  PPOCACoroutineContext(Coroutine^.Fiber)^.TerminatedEvent.SetEvent;
{$endif}
{$else}
  if Coroutine^.State in [pcsINSIDE,pcsINSIDETERMINATED] then begin
   POCACoroutineContextSwitch(Coroutine^.Fiber,Coroutine^.Back);
  end else begin
   POCACoroutineRaise('The program control flow is outside coroutine');
  end;
{$ifend}
 end;
end;

type PPOCACoroutineData=^TPOCACoroutineData;
     TPOCACoroutineData=record
      Context:PPOCAContext;
      Data:TPOCAValue;
      Func:TPOCAValue;
      Coroutine:PPOCACoroutine;
      Arguments:TPOCAValueArray;
      FromValue:TPOCAValue;
      ToValue:TPOCAValue;
      DataValue:TPOCAValue;
      ExceptionHolder:Exception;
     end;

constructor TPOCAStringTree.Create;
begin
 inherited Create;
 Root:=nil;
 Clear;
end;

destructor TPOCAStringTree.Destroy;
begin
 Clear;
 inherited Destroy;
end;

function TPOCAStringTree.CreateStringTreeNode(AChar:ansichar):PPOCAStringTreeNode;
begin
 getmem(result,sizeof(TPOCAStringTreeNode));
 result^.TheChar:=AChar;
 result^.Data:=0;
 result^.DataExist:=false;
 result^.Previous:=nil;
 result^.Next:=nil;
 result^.Up:=nil;
 result^.Down:=nil;
end;

procedure TPOCAStringTree.DestroyStringTreeNode(Node:PPOCAStringTreeNode);
begin
 if not assigned(Node) then exit;
 DestroyStringTreeNode(Node^.Next);
 DestroyStringTreeNode(Node^.Down);
 freemem(Node);
end;

procedure TPOCAStringTree.Clear;
begin
 DestroyStringTreeNode(Root);
 Root:=nil;
end;

procedure TPOCAStringTree.DumpTree;
var Ident:TPOCAInt32;
 procedure DumpNode(Node:PPOCAStringTreeNode);
 var SubNode:PPOCAStringTreeNode;
     IdentCounter,IdentOld:TPOCAInt32;
 begin
  for IdentCounter:=1 to Ident do begin
   write(' ');
  end;
  write(Node^.TheChar);
  IdentOld:=Ident;
  SubNode:=Node^.Next;
  while assigned(SubNode) do begin
   write(SubNode.TheChar);
   if not assigned(SubNode^.Next) then begin
    break;
   end;
   inc(Ident);
   SubNode:=SubNode^.Next;
  end;
  writeln;
  inc(Ident);
  while assigned(SubNode) and (SubNode<>Node) do begin
   if assigned(SubNode^.Down) then begin
    DumpNode(SubNode^.Down);
   end;
   SubNode:=SubNode^.Previous;
   dec(Ident);
  end;
  Ident:=IdentOld;
  if assigned(Node^.Down) then begin
   DumpNode(Node^.Down);
  end;
 end;
begin
 Ident:=0;
 DumpNode(Root);
end;

procedure TPOCAStringTree.DumpList;
 procedure DumpNode(Node:PPOCAStringTreeNode;ParentStr:TPOCARawByteString);
 begin
  if assigned(Node) then begin
   ParentStr:=ParentStr;
   if Node^.DataExist then begin
    writeln(ParentStr+TPOCARawByteString(Node^.TheChar));
   end;
   if assigned(Node^.Next) then begin
    DumpNode(Node^.Next,ParentStr+TPOCARawByteString(Node^.TheChar));
   end;
   if assigned(Node^.Down) then begin
    DumpNode(Node^.Down,ParentStr);
   end;
  end;
 end;
begin
 if assigned(Root) then begin
  DumpNode(Root,'');
 end;
end;

procedure TPOCAStringTree.AppendTo(DestStringTree:TPOCAStringTree);
 procedure DumpNode(Node:PPOCAStringTreeNode;ParentStr:TPOCARawByteString);
 begin
  if assigned(Node) then begin
   ParentStr:=ParentStr;
   if Node^.DataExist then begin
    DestStringTree.Add(ParentStr+Node^.TheChar,Node^.Data);
   end;
   if assigned(Node^.Next) then begin
    DumpNode(Node^.Next,ParentStr+Node^.TheChar);
   end;
   if assigned(Node^.Down) then begin
    DumpNode(Node^.Down,ParentStr);
   end;
  end;
 end;
begin
 if assigned(DestStringTree) and assigned(Root) then begin
  DumpNode(Root,'');
 end;
end;

procedure TPOCAStringTree.Optimize(DestStringTree:TPOCAStringTree);
 procedure DumpNode(Node:PPOCAStringTreeNode;ParentStr:TPOCARawByteString);
 begin
  if assigned(Node) then begin
   ParentStr:=ParentStr;
   if Node^.DataExist then begin
    DestStringTree.Add(ParentStr+Node^.TheChar,Node^.Data);
   end;
   if assigned(Node^.Next) then begin
    DumpNode(Node^.Next,ParentStr+Node^.TheChar);
   end;
   if assigned(Node^.Down) then begin
    DumpNode(Node^.Down,ParentStr);
   end;
  end;
 end;
begin
 if assigned(DestStringTree) then begin
  DestStringTree.Clear;
  if assigned(Root) then begin
   DumpNode(Root,'');
  end;
 end;
end;

function TPOCAStringTree.Add(Content:TPOCARawByteString;Data:TPOCAStringTreeData;Replace:boolean=false):boolean;
var StringLength,Position,PositionCounter:TPOCAInt32;
    NewNode,LastNode,Node:PPOCAStringTreeNode;
    StringChar,NodeChar:ansichar;
begin
 result:=false;
 StringLength:=length(Content);
 if StringLength>0 then begin
  LastNode:=nil;
  Node:=Root;
  for Position:=1 to StringLength do begin
   StringChar:=Content[Position];
   if assigned(Node) then begin
    NodeChar:=Node^.TheChar;
    if NodeChar=StringChar then begin
     LastNode:=Node;
     Node:=Node^.Next;
   end else begin
     while (NodeChar<StringChar) and assigned(Node^.Down) do begin
      Node:=Node^.Down;
      NodeChar:=Node^.TheChar;
     end;
     if NodeChar=StringChar then begin
      LastNode:=Node;
      Node:=Node^.Next;
     end else begin
      NewNode:=CreateStringTreeNode(StringChar);
      if NodeChar<StringChar then begin
       NewNode^.Down:=Node^.Down;
       NewNode^.Up:=Node;
       if assigned(NewNode^.Down) then begin
        NewNode^.Down^.Up:=NewNode;
       end;
       NewNode^.Previous:=Node^.Previous;
       Node^.Down:=NewNode;
      end else if NodeChar>StringChar then begin
       NewNode^.Down:=Node;
       NewNode^.Up:=Node^.Up;
       if assigned(NewNode^.Up) then begin
        NewNode^.Up^.Down:=NewNode;
       end;
       NewNode^.Previous:=Node^.Previous;
       if not assigned(NewNode^.Up) then begin
        if assigned(NewNode^.Previous) then begin
         NewNode^.Previous^.Next:=NewNode;
        end else begin
         Root:=NewNode;
        end;
       end;
       Node^.Up:=NewNode;
      end;
      LastNode:=NewNode;
      Node:=LastNode^.Next;
     end;
    end;
   end else begin
    for PositionCounter:=Position to StringLength do begin
     NewNode:=CreateStringTreeNode(Content[PositionCounter]);
     if assigned(LastNode) then begin
      NewNode^.Previous:=LastNode;
      LastNode^.Next:=NewNode;
      LastNode:=LastNode^.Next;
     end else begin
      if not assigned(Root) then begin
       Root:=NewNode;
       LastNode:=Root;
      end;
     end;
    end;
    break;
   end;
  end;
  if assigned(LastNode) then begin
   if Replace or not LastNode^.DataExist then begin
    LastNode^.Data:=Data;
    LastNode^.DataExist:=true;
    result:=true;
   end;
  end;
 end;
end;

function TPOCAStringTree.Delete(Content:TPOCARawByteString):boolean;
var StringLength,Position:TPOCAInt32;
    Node:PPOCAStringTreeNode;
    StringChar,NodeChar:ansichar;
begin
 result:=false;
 StringLength:=length(Content);
 if StringLength>0 then begin
  Node:=Root;
  for Position:=1 to StringLength do begin
   StringChar:=Content[Position];
   if assigned(Node) then begin
    NodeChar:=Node^.TheChar;
    while (NodeChar<>StringChar) and assigned(Node^.Down) do begin
     Node:=Node^.Down;
     NodeChar:=Node^.TheChar;
    end;
    if NodeChar=StringChar then begin
     if (Position=StringLength) and Node^.DataExist then begin
      Node^.DataExist:=false;
      result:=true;
      exit;
     end;
     Node:=Node^.Next;
    end else begin
     break;
    end;
   end else begin
    break;
   end;
  end;
 end;
end;

function TPOCAStringTree.Find(Content:TPOCARawByteString;var Data:TPOCAStringTreeData):boolean;
var StringLength,Position:TPOCAInt32;
    Node:PPOCAStringTreeNode;
    StringChar,NodeChar:ansichar;
begin
 result:=false;
 StringLength:=length(Content);
 if StringLength>0 then begin
  Node:=Root;
  for Position:=1 to StringLength do begin
   StringChar:=Content[Position];
   if assigned(Node) then begin
    NodeChar:=Node^.TheChar;
    while (NodeChar<>StringChar) and assigned(Node^.Down) do begin
     Node:=Node^.Down;
     NodeChar:=Node^.TheChar;
    end;
    if NodeChar=StringChar then begin
     if (Position=StringLength) and Node^.DataExist then begin
      Data:=Node^.Data;
      result:=true;
      exit;
     end;
     Node:=Node^.Next;
    end else begin
     break;
    end;
   end else begin
    break;
   end;
  end;
 end;
end;

function TPOCAStringTree.FindEx(Content:TPOCARawByteString;var Data:TPOCAStringTreeData;var Len:TPOCAInt32):boolean;
var StringLength,Position:TPOCAInt32;
    Node:PPOCAStringTreeNode;
    StringChar,NodeChar:ansichar;
begin
 result:=false;
 Len:=0;
 StringLength:=length(Content);
 if StringLength>0 then begin
  Node:=Root;
  for Position:=1 to StringLength do begin
   StringChar:=Content[Position];
   if assigned(Node) then begin
    NodeChar:=Node^.TheChar;
    while (NodeChar<>StringChar) and assigned(Node^.Down) do begin
     Node:=Node^.Down;
     NodeChar:=Node^.TheChar;
    end;
    if NodeChar=StringChar then begin
     if Node^.DataExist then begin
      Len:=Position;
      Data:=Node^.Data;
      result:=true;
     end;
     Node:=Node^.Next;
    end else begin
     break;
    end;
   end else begin
    break;
   end;
  end;
 end;
end;

constructor TPOCAStringHashMap.Create(AOptimize:TPOCABool32);
var Hash:TPOCAUInt32;
begin
 inherited Create;
 FillChar(HashBuckets,sizeof(TPOCAStringHashMapHashBuckets),#0);
 First:=nil;
 Last:=nil;
 HashSize:=256;
 HashSizeMask:=HashSize-1;
 HashedItems:=0;
 HashBucketsUsed:=0;
 HashBuckets:=nil;
 SetLength(HashBuckets,HashSize);
 for Hash:=0 to HashSizeMask do begin
  HashBuckets[Hash].HashFirst:=nil;
  HashBuckets[Hash].HashLast:=nil;
 end;
 LastUsedItem:=nil;
 Optimize:=AOptimize;
end;

destructor TPOCAStringHashMap.Destroy;
begin
 Clear;
 SetLength(HashBuckets,0);
 inherited Destroy;
end;

procedure TPOCAStringHashMap.Clear;
var Hash:TPOCAUInt32;
    Item,NextItem:PPOCAStringHashMapItem;
begin
 Item:=First;
 while assigned(Item) do begin
  NextItem:=Item^.Next;
  Item^.Next:=nil;
  Item^.Key:='';
  Item^.Value:=0;
  Dispose(Item);
  Item:=NextItem;
 end;
 First:=nil;
 Last:=nil;
 LastUsedItem:=nil;
 HashSize:=256;
 HashSizeMask:=HashSize-1;
 HashedItems:=0;
 HashBucketsUsed:=0;
 SetLength(HashBuckets,HashSize);
 for Hash:=0 to HashSizeMask do begin
  HashBuckets[Hash].HashFirst:=nil;
  HashBuckets[Hash].HashLast:=nil;
 end;
end;

procedure TPOCAStringHashMap.GrowAndRehashIfNeeded;
var Hash:TPOCAUInt32;
    Item:PPOCAStringHashMapItem;
begin
 if (HashSize<POCAHashMapMaxSize) and (HashedItems>=(HashBucketsUsed*POCAHashMapItemsPerBucketsThreshold)) then begin
  LastUsedItem:=nil;
  for Hash:=0 to HashSizeMask do begin
   HashBuckets[Hash].HashFirst:=nil;
   HashBuckets[Hash].HashLast:=nil;
  end;
  inc(HashSize,HashSize);
  if HashSize>POCAHashMapMaxSize then begin
   HashSize:=POCAHashMapMaxSize;
  end;
  HashSizeMask:=HashSize-1;
  SetLength(HashBuckets,HashSize);
  for Hash:=0 to HashSizeMask do begin
   HashBuckets[Hash].HashFirst:=nil;
   HashBuckets[Hash].HashLast:=nil;
  end;
  HashedItems:=0;
  Item:=First;
  while assigned(Item) do begin
   inc(HashedItems);
   Item^.HashPrevious:=nil;
   Item^.HashNext:=nil;
   Item:=Item^.Next;
  end;
  HashBucketsUsed:=0;
  Item:=First;
  while assigned(Item) do begin
   Hash:=POCAHashString(Item^.Key) and HashSizeMask;
   Item^.Hash:=Hash;
   if assigned(HashBuckets[Hash].HashLast) then begin
    HashBuckets[Hash].HashLast^.HashNext:=Item;
    Item^.HashPrevious:=HashBuckets[Hash].HashLast;
    HashBuckets[Hash].HashLast:=Item;
    Item^.HashNext:=nil;
   end else begin
    inc(HashBucketsUsed);
    HashBuckets[Hash].HashFirst:=Item;
    HashBuckets[Hash].HashLast:=Item;
    Item^.HashPrevious:=nil;
    Item^.HashNext:=nil;
   end;
   Item:=Item^.Next;
  end;
 end;
end;

function TPOCAStringHashMap.GetKey(const Key:TPOCARawByteString):PPOCAStringHashMapItem;
var Hash:TPOCAUInt32;
begin
 if assigned(LastUsedItem) and (LastUsedItem^.Key=Key) then begin
  result:=LastUsedItem;
  Hash:=result^.Hash;
 end else begin
  Hash:=POCAHashString(Key) and HashSizeMask;
  result:=HashBuckets[Hash].HashFirst;
  while assigned(result) and (result^.Key<>Key) do begin
   result:=result^.HashNext;
  end;
 end;
 if Optimize and assigned(result) then begin
  LastUsedItem:=result;
  if HashBuckets[Hash].HashFirst<>result then begin
   if assigned(result^.HashPrevious) then begin
    result^.HashPrevious^.HashNext:=result^.HashNext;
   end;
   if assigned(result^.HashNext) then begin
    result^.HashNext^.HashPrevious:=result^.HashPrevious;
   end else if HashBuckets[Hash].HashLast=result then begin
    HashBuckets[Hash].HashLast:=result^.HashPrevious;
   end;
   HashBuckets[Hash].HashFirst^.HashPrevious:=result;
   result^.HashNext:=HashBuckets[Hash].HashFirst;
   result^.HashPrevious:=nil;
   HashBuckets[Hash].HashFirst:=result;
  end;
 end;
end;

function TPOCAStringHashMap.NewKey(const Key:TPOCARawByteString;Force:boolean=false):PPOCAStringHashMapItem;
var Hash:TPOCAUInt32;
begin
 if Force then begin
  result:=nil;
  Hash:=POCAHashString(Key) and HashSizeMask;
 end else if assigned(LastUsedItem) and (LastUsedItem^.Key=Key) then begin
  result:=LastUsedItem;
  Hash:=result^.Hash;
 end else begin
  Hash:=POCAHashString(Key) and HashSizeMask;
  result:=HashBuckets[Hash].HashFirst;
  if not assigned(result) then begin
   inc(HashBucketsUsed);
  end;
  while assigned(result) and (result^.Key<>Key) do begin
   result:=result^.HashNext;
  end;
 end;
 if not assigned(result) then begin
  inc(HashedItems);
  New(result);
  fillchar(result^,sizeof(TPOCAStringHashMapItem),#0);
  result^.Hash:=Hash;
  result^.Key:=Key;
  if assigned(HashBuckets[Hash].HashLast) then begin
   HashBuckets[Hash].HashLast^.HashNext:=result;
   result^.HashPrevious:=HashBuckets[Hash].HashLast;
   result^.HashNext:=nil;
   HashBuckets[Hash].HashLast:=result;
  end else begin
   HashBuckets[Hash].HashFirst:=result;
   HashBuckets[Hash].HashLast:=result;
   result^.HashPrevious:=nil;
   result^.HashNext:=nil;
  end;
  if assigned(Last) then begin
   Last^.Next:=result;
   result^.Previous:=Last;
   result^.Next:=nil;
   Last:=result;
  end else begin
   First:=result;
   Last:=result;
   result^.Previous:=nil;
   result^.Next:=nil;
  end;
  LastUsedItem:=result;
 end;
 GrowAndRehashIfNeeded;
end;

function TPOCAStringHashMap.DeleteKey(const Item:PPOCAStringHashMapItem):boolean;
begin
 result:=assigned(Item);
 if result then begin
  if LastUsedItem=Item then begin
   if assigned(Item^.Next) then begin
    LastUsedItem:=Item^.Next;
   end else begin
    LastUsedItem:=Item^.Previous;
   end;
  end;
  if assigned(Item^.Previous) then begin
   Item^.Previous^.Next:=Item^.Next;
  end else if First=Item then begin
   First:=Item^.Next;
  end;
  if assigned(Item^.Next) then begin
   Item^.Next^.Previous:=Item^.Previous;
  end else if Last=Item then begin
   Last:=Item^.Previous;
  end;
  Item^.Next:=nil;
  Item^.Previous:=nil;
  if assigned(Item^.HashPrevious) then begin
   Item^.HashPrevious^.HashNext:=Item^.HashNext;
  end else if HashBuckets[Item^.Hash].HashFirst=Item then begin
   HashBuckets[Item^.Hash].HashFirst:=Item^.HashNext;
  end;
  if assigned(Item^.HashNext) then begin
   Item^.HashNext^.HashPrevious:=Item^.HashPrevious;
  end else if HashBuckets[Item^.Hash].HashLast=Item then begin
   HashBuckets[Item^.Hash].HashLast:=Item^.HashPrevious;
  end;
  Item^.HashNext:=nil;
  Item^.HashPrevious:=nil;
  Item^.Key:='';
  Item^.Value:=0;
  Dispose(Item);
  dec(HashedItems);
 end;
end;

function TPOCAStringHashMap.GetValue(const Key:TPOCARawByteString):TPOCAInt64;
var Item:PPOCAStringHashMapItem;
begin
 Item:=GetKey(Key);
 if assigned(Item) then begin
  result:=Item^.Value;
 end else begin
  result:=-1;
 end;
end;

procedure TPOCAStringHashMap.SetValue(const Key:TPOCARawByteString;const Value:TPOCAInt64);
var Item:PPOCAStringHashMapItem;
begin
 Item:=GetKey(Key);
 if not assigned(Item) then begin
  Item:=NewKey(Key,true);
 end;
 if assigned(Item) then begin
  Item^.Value:=Value;
 end;
end;

function POCAGetValueType(const v:TPOCAValue):TPOCAInt32; {$ifdef caninline}inline;{$endif}
{$ifdef cpu64}
var p:PPOCAObject;
begin
 if (TPOCAUInt64(TPOCAPointer(@v.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask then begin
  p:=TPOCAPointer(TPOCAPtrUInt(v.Reference.Obj) and POCAValueReferenceMask);
  if assigned(p) then begin
   result:=p^.Header.ValueType;
  end else begin
   result:=pvtNULL;
  end;
 end else begin
  result:=pvtNUMBER;
 end;
end;
{$else}
begin
 if v.ReferenceTag=POCAValueReferenceTag then begin
  if assigned(v.Reference.Obj) then begin
   result:=v.Reference.Obj^.Header.ValueType;
  end else begin
   result:=pvtNULL;
  end;
 end else begin
  result:=pvtNUMBER;
 end;
end;
{$endif}

function POCAGetValueReferencePointer(const v:TPOCAValue):TPOCAPointer; {$ifdef caninline}inline;{$endif}
begin
 result:={$ifdef cpu64}TPOCAPointer(TPOCAPtrUInt(v.Reference.Ptr) and POCAValueReferenceMask){$else}v.Reference.Ptr{$endif};
end;

procedure POCASetValueReferencePointer(out v:TPOCAValue;const Ptr:TPOCAPointer); {$ifdef caninline}inline;{$endif}
begin
{$ifdef cpu64}
 v.Reference.Ptr:=TPOCAPointer(TPOCAPtrUInt((TPOCAPtrUInt(Ptr) and POCAValueReferenceMask) or POCAValueReferenceSignalMask));
{$else}
 v.ReferenceTag:=POCAValueReferenceTag;
 v.Reference.Ptr:=Ptr;
{$endif}
end;

procedure POCASetValueNumber(out v:TPOCAValue;const n:double); {$ifdef caninline}inline;{$endif}
begin
{$ifdef cpu64}
 TPOCAUInt64(TPOCAPointer(@v.Num)^):=TPOCAUInt64(TPOCAPointer(@n)^);
{$else}
{v.ReferenceTag:=not POCAValueReferenceTag;
 v.Num:=n;(*{}
 TPOCAInt64(TPOCAPointer(@v.Num)^):=TPOCAInt64(TPOCAPointer(@n)^);(**)
{$endif}
end;

function POCAIsValueReference(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:={$ifdef cpu64}(TPOCAUInt64(TPOCAPointer(@v.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask{$else}v.ReferenceTag=POCAValueReferenceTag{$endif};
end;

function POCAIsValueNumber(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:={$ifdef cpu64}(TPOCAUInt64(TPOCAPointer(@v.Num)^) and POCAValueReferenceSignalMask)<>POCAValueReferenceSignalMask{$else}v.ReferenceTag<>POCAValueReferenceTag{$endif};
end;

function POCAIsValueObject(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:={$ifdef cpu64}((TPOCAUInt64(TPOCAPointer(@v.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and assigned(TPOCAPointer(TPOCAPtrUInt(v.Reference.Ptr) and POCAValueReferenceMask)){$else}(v.ReferenceTag=POCAValueReferenceTag) and assigned(v.Reference.Ptr){$endif};
end;

function POCAIsValueObjectAndGetReferencePointer(const v:TPOCAValue;var p):boolean;
begin
 TPOCAPointer(p):={$ifdef cpu64}TPOCAPointer(TPOCAPtrUInt(v.Reference.Ptr) and POCAValueReferenceMask){$else}v.Reference.Ptr{$endif};
 result:={$ifdef cpu64}((TPOCAUInt64(TPOCAPointer(@v.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and assigned(TPOCAPointer(p)){$else}(v.ReferenceTag=POCAValueReferenceTag) and assigned(TPOCAPointer(p)){$endif};
end;

function POCAIsValueNull(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:={$ifdef cpu64}((TPOCAUInt64(TPOCAPointer(@v.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and not assigned(TPOCAPointer(TPOCAPtrUInt(v.Reference.Ptr) and POCAValueReferenceMask)){$else}(v.ReferenceTag=POCAValueReferenceTag) and not assigned(v.Reference.Ptr){$endif};
end;

function POCAIsValueReferenceType(const v:TPOCAValue;t:TPOCAInt32):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=t);
end;

function POCAIsValueString(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtSTRING);
end;

function POCAIsValueArray(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtARRAY);
end;

function POCAIsValueHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtHASH);
end;

function POCAIsValueSimpleHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
var Hash:PPOCAHash;
begin
 Hash:=PPOCAHash(POCAGetValueReferencePointer(v));
 result:=(POCAIsValueObject(v) and (Hash^.Header.ValueType=pvtHASH)) and not assigned(Hash^.Events);
end;

function POCAIsValueEventHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
var Hash:PPOCAHash;
begin
 Hash:=PPOCAHash(POCAGetValueReferencePointer(v));
 result:=(POCAIsValueObject(v) and (Hash^.Header.ValueType=pvtHASH)) and assigned(Hash^.Events);
end;

function POCAIsValueGhostEventHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
var Ghost:PPOCAGhost;
begin         
 Ghost:=PPOCAGhost(POCAGetValueReferencePointer(v));
 result:=(POCAIsValueObject(v) and (Ghost^.Header.ValueType=pvtGHOST)) and assigned(Ghost^.Hash) and assigned(Ghost^.Hash^.Events);
end;

function POCAGetValueHashType(const v:TPOCAValue):TPOCAInt32; {$ifdef caninline}inline;{$endif}
var Hash:PPOCAHash;
begin
 Hash:=PPOCAHash(POCAGetValueReferencePointer(v));
 if POCAIsValueObject(v) and (Hash^.Header.ValueType=pvtHASH) then begin
  if assigned(Hash^.Events) then begin
   result:=2;
  end else begin
   result:=1;
  end;
 end else begin
  result:=0;
 end;
end;

function POCAIsValueCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtCODE);
end;

function POCAIsValueFunction(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtFUNCTION);
end;

function POCAIsValueFunctionOrNativeCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType in [pvtFUNCTION,pvtNATIVECODE]);
end;

function POCAIsValueNativeCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtNATIVECODE);
end;

function POCAIsValueGhost(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtGHOST);
end;

function POCAIsValueScalarType(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueNumber(v) or POCAIsValueString(v);
end;

function POCAIsValueIdentical(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(POCAIsValueReference(a) and POCAIsValueReference(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b));
end;

function Hex2Byte(c:ansichar):TPOCAUInt8;
begin
 case c of
  '0'..'9':begin
   result:=ord(c)-ord('0');
  end;
  'a'..'f':begin
   result:=(ord(c)-ord('a'))+$a;
  end;
  'A'..'F':begin
   result:=(ord(c)-ord('A'))+$a;
  end;
  else begin
   result:=0;
  end;
 end;
end;

function sar(Value,Shift:TPOCAInt32):TPOCAInt32;
{$ifdef HasSAR} inline;
begin
result:=SARLongint(Value,Shift);
end;
{$else}
{$ifdef cpu386}
{$ifdef fpc} assembler; register; //inline;
asm
 mov ecx,edx
 sar eax,cl
end;// ['eax','edx','ecx'];
{$else} assembler; register;
asm
 mov ecx,edx
 sar eax,cl
end;
{$endif}
{$else}
{$ifdef cpuarm} assembler; //inline;
asm
 mov r0,r0,asr R1
end;// ['r0','R1'];
{$else}{$ifdef caninline}inline;{$endif}
begin
{$ifdef HasSAR}
 result:=SARLongint(Value,Shift);
{$else}
 Shift:=Shift and 31;
 result:=(TPOCAUInt32(Value) shr Shift) or (TPOCAUInt32(TPOCAInt32(TPOCAUInt32(0-TPOCAUInt32(TPOCAUInt32(Value) shr 31)) and TPOCAUInt32(0-TPOCAUInt32(ord(Shift<>0) and 1)))) shl (32-Shift));
{$endif}
end;
{$endif}
{$endif}
{$endif}

function sar64(Value:TPOCAInt64;Shift:TPOCAInt32):TPOCAInt64; {$ifdef caninline}inline;{$endif}
begin
{$ifdef HasSAR}
 result:=SARInt64(Value,Shift);
{$else}
 Shift:=Shift and 63;
 result:=TPOCAInt64(TPOCAUInt64(TPOCAUInt64(TPOCAUInt64(Value) shr Shift) or (TPOCAUInt64(TPOCAInt64(TPOCAUInt64(0-TPOCAUInt64(TPOCAUInt64(Value) shr 63)) and TPOCAUInt64(TPOCAInt64(0-(ord(Shift<>0) and 1))))) shl (64-Shift))));
{$endif}
end;

constructor EPOCAError.Create(const AMessage:TPOCAUTF8String);
begin
 inherited Create(String(AMessage));
 SourceFile:=-1;
 SourceLine:=-1;
 SourceColumn:=-1;
end;

constructor EPOCAError.Create(const ASourceFile,ASourceLine,ASourceColumn:TPOCAInt32;const AMessage:TPOCAUTF8String);
begin
 inherited Create(String(AMessage));
 SourceFile:=ASourceFile;
 SourceLine:=ASourceLine;
 SourceColumn:=ASourceColumn;
end;

constructor EPOCAError.Create(const AValue:TPOCAValue);
begin
 inherited Create('');
 SourceFile:=-1;
 SourceLine:=-1;
 SourceColumn:=-1;
 Value:=AValue;
end;

constructor EPOCAError.Create(const ASourceFile,ASourceLine,ASourceColumn:TPOCAInt32;const AValue:TPOCAValue);
begin
 inherited Create('');
 SourceFile:=ASourceFile;
 SourceLine:=ASourceLine;
 SourceColumn:=ASourceColumn;
 Value:=AValue;
end;

function POCALockCreate:TPOCAPointer;
begin
 result:=TPasMPCriticalSection.Create;
end;

procedure POCALockDestroy(var Lock:TPOCAPointer);
begin
 if assigned(Lock) then begin
  TPasMPCriticalSection(Lock).Free;
  Lock:=nil;
 end;
end;

procedure POCALockEnter(Lock:TPOCAPointer);
begin
 if assigned(Lock) then begin
  TPasMPCriticalSection(Lock).Acquire;
 end;
end;

procedure POCALockLeave(Lock:TPOCAPointer);
begin
 if assigned(Lock) then begin
  TPasMPCriticalSection(Lock).Release;
 end;
end;

function POCASemaphoreCreate:TPOCAPointer;
begin
 result:=TPasMPSemaphore.Create(0,$7fffffff);
end;

procedure POCASemaphoreDestroy(var Semaphore:TPOCAPointer);
begin
 if assigned(Semaphore) then begin
  TPasMPSemaphore(Semaphore).Free;
  Semaphore:=nil;
 end;
end;

procedure POCASemaphoreDown(Semaphore:TPOCAPointer);
begin
 if assigned(Semaphore) then begin
  TPasMPSemaphore(Semaphore).Acquire(1);
 end;
end;

procedure POCASemaphoreUp(Semaphore:TPOCAPointer;Count:TPOCAInt32);
begin
 if assigned(Semaphore) then begin
  TPasMPSemaphore(Semaphore).Release(Count);
 end;
end;

type PPOCAThreadData=^TPOCAThreadData;
     TPOCAThreadData=record
      Handle:{$ifdef fpc}TThreadID{$else}THandle{$endif};
      StartSemaphore:TPOCAPointer;
      Started:TPasMPBool32;
      Terminated:TPasMPBool32;
      ThreadID:{$ifdef fpc}TThreadID{$else}Cardinal{$endif};
      Context:PPOCAContext;
      Data:TPOCAValue;
      Func:TPOCAValue;
      Arguments:TPOCAValueArray;
     end;

{$ifdef fpc}
function POCAThreadProc(ThreadData:TPOCAPointer):TPOCAPtrInt;
{$else}
function POCAThreadProc(ThreadData:TPOCAPointer):TPOCAUInt32;
{$endif}
begin
 result:=0;
 try
  POCASemaphoreDown(PPOCAThreadData(ThreadData)^.StartSemaphore);
  TPasMPInterlocked.Write(PPOCAThreadData(ThreadData)^.Started,true);
  try
   if length(PPOCAThreadData(ThreadData)^.Arguments)>0 then begin
    POCACall(PPOCAThreadData(ThreadData)^.Context,PPOCAThreadData(ThreadData)^.Func,@PPOCAThreadData(ThreadData)^.Arguments[0],length(PPOCAThreadData(ThreadData)^.Arguments),POCAValueNull,POCAValueNull);
   end else begin
    POCACall(PPOCAThreadData(ThreadData)^.Context,PPOCAThreadData(ThreadData)^.Func,nil,0,POCAValueNull,POCAValueNull);
   end;
  except
  end;
  TPasMPInterlocked.Write(PPOCAThreadData(ThreadData)^.Terminated,true);
  POCAContextDestroy(PPOCAThreadData(ThreadData)^.Context);
  PPOCAThreadData(ThreadData)^.Context:=nil;
 finally
 end;
 EndThread(result);
end;

procedure POCAFinalizeString(Obj:PPOCAString);
begin
 Obj^.Data:='';
 if assigned(Obj^.UTF8CodePointsToCodeUnitsIndex) then begin
  FreeMem(Obj^.UTF8CodePointsToCodeUnitsIndex);
  Obj^.UTF8CodePointsToCodeUnitsIndex:=nil;
 end;
 if assigned(Obj^.UTF8CodeUnitsToCodePointsIndex) then begin
  FreeMem(Obj^.UTF8CodeUnitsToCodePointsIndex);
  Obj^.UTF8CodeUnitsToCodePointsIndex:=nil;
 end;
end;

procedure POCAFinalizeArray(Obj:PPOCAArray);
begin
 if assigned(Obj^.ArrayRecord) then begin
  FreeMem(Obj^.ArrayRecord);
  Obj^.ArrayRecord:=nil;
 end;
end;

procedure POCAFinalizeHash(Obj:PPOCAHash);
begin
 POCAHashClearPrototype(Obj);
 if assigned(Obj^.HashRecord) then begin
  FreeMem(Obj^.HashRecord);
  Obj^.HashRecord:=nil;
 end;
 if assigned(Obj^.Cache.ChainEntities) then begin
  FreeMem(Obj^.Cache.ChainEntities);
  Obj^.Cache.ChainEntities:=nil;
 end;
end;

procedure POCACodeGCClean(Obj:PPOCACode);
begin
 if assigned(Obj^.ByteCode) then begin
  FreeMem(Obj^.ByteCode);
  Obj^.ByteCode:=nil;
 end;
 if assigned(Obj^.Constants) then begin
  FreeMem(Obj^.Constants);
  Obj^.Constants:=nil;
 end;
 if assigned(Obj^.ArgumentSymbols) then begin
  FreeMem(Obj^.ArgumentSymbols);
  Obj^.ArgumentSymbols:=nil;
 end;
 if assigned(Obj^.ArgumentLocals) then begin
  FreeMem(Obj^.ArgumentLocals);
  Obj^.ArgumentLocals:=nil;
 end;
 if assigned(Obj^.OptionalArgumentSymbols) then begin
  FreeMem(Obj^.OptionalArgumentSymbols);
  Obj^.OptionalArgumentSymbols:=nil;
 end;
 if assigned(Obj^.OptionalArgumentLocals) then begin
  FreeMem(Obj^.OptionalArgumentLocals);
  Obj^.OptionalArgumentLocals:=nil;
 end;
 if assigned(Obj^.OptionalArgumentValues) then begin
  FreeMem(Obj^.OptionalArgumentValues);
  Obj^.OptionalArgumentValues:=nil;
 end;
 if assigned(Obj^.RegExps) then begin
  FreeMem(Obj^.RegExps);
  Obj^.RegExps:=nil;
 end;
 if length(Obj^.Lines)>0 then begin
  SetLength(Obj^.Lines,0);
  Obj^.Lines:=nil;
 end;
{$ifdef POCAHasJIT}
 if assigned(Obj^.NativeCode) then begin
  POCANativeCodeMemoryManagerFreeMemory(Obj^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance^.Globals.NativeCodeMemoryManager,Obj^.NativeCode);
  Obj^.NativeCode:=nil;
 end;
 if length(Obj^.ByteCodeToNativeCodeMap)>0 then begin
  SetLength(Obj^.ByteCodeToNativeCodeMap,0);
  Obj^.ByteCodeToNativeCodeMap:=nil;
 end;
 if length(Obj^.InterpretByteCodeMap)>0 then begin
  SetLength(Obj^.InterpretByteCodeMap,0);
  Obj^.InterpretByteCodeMap:=nil;
 end;
{$endif}
end;

procedure POCAFuncGCClean(Obj:PPOCAFunction);
begin
{$ifndef POCAClosureArrayValues}
 Obj^.ClosureValues:=nil;
{$endif}
end;

procedure POCANativeCodeGCClean(Obj:PPOCANativeCode);
begin
 if assigned(Obj^.UserData) then begin
  if assigned(Obj^.DestroyFunctionPointer) then begin
   Obj^.DestroyFunctionPointer(Obj^.UserData);
   Obj^.DestroyFunctionPointer:=nil;
  end;
  Obj^.UserData:=nil;
 end;
end;

procedure POCAGhostGCClean(Obj:PPOCAGhost);
begin
 if assigned(Obj^.Ptr) then begin
  if assigned(Obj^.GhostType) then begin
   if assigned(addr(Obj^.GhostType.Destroy)) then begin
    Obj^.GhostType.Destroy(Obj);
   end;
   Obj^.GhostType:=nil;
  end;
  Obj^.Ptr:=nil;
 end;
end;

procedure POCACleanElement(Obj:PPOCAObject); {$ifdef UseRegister}register;{$endif}
begin
 if assigned(Obj) then begin
//case Pool^.ValueType of
  case Obj^.Header.ValueType of
   pvtSTRING:begin
    POCAFinalizeString(TPOCAPointer(Obj));
   end;
   pvtARRAY:begin
    POCAFinalizeArray(TPOCAPointer(Obj));
   end;
   pvtHASH:begin
    POCAFinalizeHash(TPOCAPointer(Obj));
   end;
   pvtCODE:begin
    POCACodeGCClean(TPOCAPointer(Obj));
   end;
   pvtFUNCTION:begin
    POCAFuncGCClean(TPOCAPointer(Obj));
   end;
   pvtNATIVECODE:begin
    POCANativeCodeGCClean(TPOCAPointer(Obj));
   end;
   pvtGHOST:begin
    POCAGhostGCClean(TPOCAPointer(Obj));
   end;
  end;
  if assigned(Obj^.Header.GarbageCollector.LinkedList.Previous) then begin
   TPOCAGarbageCollectorLinkedList.Remove(Obj);
  end;
 end;
end;

{$ifdef POCAMemoryPools}
procedure POCAPoolNewBlock(Pool:PPOCAPool;Size:TPOCAInt32); {$ifdef UseRegister}register;{$endif}
var PoolBlockSize,BlockSize,i:TPOCAInt32;
    Block:PPOCAPoolBlock;
    Obj:PPOCAObject;
begin
 if Pool^.ElementRealSize>0 then begin
  if Size<Pool.Instance^.Globals.GarbageCollector.MinimumBlockSize then begin
   Size:=Pool.Instance^.Globals.GarbageCollector.MinimumBlockSize;
   if Size<16 then begin
    Size:=16;
   end;
  end;
  begin
   PoolBlockSize:=POCARoundUpToMask(sizeof(TPOCAPoolBlock),16);
   BlockSize:=PoolBlockSize+(Size*Pool^.ElementSize);
   GetMemAligned(Block,BlockSize,16);
   FillChar(Block^,BlockSize,#0);
{$ifdef POCAGarbageCollectorPoolBlockReferenceCounting}
   Block^.ReferenceCounter:=0;
{$endif}
{$ifdef POCAGarbageCollectorPoolBlockInstance}
   Block^.Instance:=Pool^.Instance;
{$endif}
   Block^.Data:=TPOCAPointer(@PPOCAUInt8Array(Block)^[PoolBlockSize]);
   Block^.Size:=Size;
   Block^.Next:=nil;
   if assigned(Pool^.LastBlock) then begin
    Block^.Previous:=Pool^.LastBlock;
    Block^.Previous^.Next:=Block;
   end else begin
    Block^.Previous:=nil;
    Pool^.FirstBlock:=Block;
   end;
   Pool^.LastBlock:=Block;
   TPasMPInterlocked.Add(Pool^.Size,Block^.Size);
  end;
  begin
   if Pool^.FreeSize<Pool^.Size then begin
    i:=POCARoundUpToPowerOfTwo(Pool^.Size);
    ReallocMem(Pool^.FreeObjects,SizeOf(PPOCAObject)*i);
    FillChar(Pool^.FreeObjects^[Pool^.FreeSize],SizeOf(PPOCAObject)*(i-Pool^.FreeSize),AnsiChar(#0));
    Pool^.FreeSize:=i;
   end;
  end;
  begin
   for i:=0 to Size-1 do begin
    Obj:=PPOCAObject(TPOCAPointer(@PPOCAUInt8Array(Block^.Data)^[i*Pool^.ElementSize]));
    Obj^.Header.ValueType:=Pool^.ValueType;
{$ifndef POCAGarbageCollectorPoolBlockInstance}
    Obj^.Header.Instance:=Pool^.Instance;
{$endif}
    Obj^.Header.PoolBlock:=Block;
    Obj^.Header.GarbageCollector.LinkedList.List:=nil;
    Obj^.Header.GarbageCollector.LinkedList.Previous:=nil;
    Obj^.Header.GarbageCollector.LinkedList.Next:=nil;
    Pool^.FreeObjects^[Pool^.FreeCount]:=Obj;
    inc(Pool^.FreeCount);
   end;
   TPasMPInterlocked.Add(Pool^.Instance^.Globals.GarbageCollector.Allocated,Size);
   TPasMPInterlocked.Add(Pool^.Instance^.Globals.GarbageCollector.FreeCount,Size);
// Pool^.FreeLock:=0;
  end;
 end;
end;

procedure POCAPoolCleanElement(Pool:PPOCAPool;Obj:PPOCAObject); {$ifdef UseRegister}register;{$endif} forward;

procedure POCAPoolFreeBlock(Pool:PPOCAPool;Block:PPOCAPoolBlock); {$ifdef UseRegister}register;{$endif}
var Element,OtherElement:TPOCAInt32;
    Obj,OtherObj:PPOCAObject;
begin
 for Element:=0 to Block^.Size-1 do begin
  Obj:=PPOCAObject(TPOCAPointer(@PPOCAUInt8Array(Block^.Data)^[Element*Pool^.ElementSize]));
{$ifndef POCAGarbageCollectorPoolBlockInstance}
  Obj^.Header.Instance:=Pool^.Instance;
{$endif}
  POCAPoolCleanElement(Pool,Obj);
 end;
 if Pool^.FreeCount>0 then begin
  Element:=Pool^.FreeCount-1;
  while Element>=0 do begin
   Obj:=Pool^.FreeObjects[Element];
   if (TPUCUPtrUInt(Obj)>=TPUCUPtrUInt(Block^.Data)) and (TPUCUPtrUInt(Obj)<(TPUCUPtrUInt(Block^.Data)+(Block^.Size*Pool^.ElementSize))) then begin
    if Element=(Pool^.FreeCount-1) then begin
     Pool^.FreeObjects[Element]:=nil;
    end else begin
     Pool^.FreeObjects[Element]:=Pool^.FreeObjects[Pool^.FreeCount-1];
     Pool^.FreeObjects[Pool^.FreeCount-1]:=nil;
    end;
    dec(Pool^.FreeCount);
   end else begin
    dec(Element);
   end;
  end;
 end;
 if assigned(Block^.Previous) then begin
  Block^.Previous^.Next:=Block^.Next;
 end else if Pool^.FirstBlock=Block then begin
  Pool^.FirstBlock:=Block^.Next;
 end;
 if assigned(Block^.Next) then begin
  Block^.Next^.Previous:=Block^.Previous;
 end else if Pool^.LastBlock=Block then begin
  Pool^.LastBlock:=Block^.Next;
 end;
 TPasMPInterlocked.Add(Pool^.Size,-Block^.Size);
 FreeMemAligned(Block);
end;

procedure POCAPoolCleanElement(Pool:PPOCAPool;Obj:PPOCAObject); {$ifdef UseRegister}register;{$endif}
begin
 if assigned(Obj) then begin
  POCACleanElement(Obj);
  if sizeof(TPOCAObjectHeader)<Pool^.ElementRealSize then begin
   FillChar(PPOCAUInt8Array(Obj)^[sizeof(TPOCAObjectHeader)],Pool^.ElementRealSize-sizeof(TPOCAObjectHeader),#0);
  end;
  Obj^.Header.GarbageCollector.State:=0;
 end;
end;

procedure POCAPoolFreeElement(Pool:PPOCAPool;Obj:PPOCAObject); {$ifdef UseRegister}register;{$endif}
begin            
 POCAPoolCleanElement(Pool,Obj);
{$ifdef POCAGarbageCollectorPoolBlockReferenceCounting}
 if TPasMPInterlocked.Decrement(Obj^.Header.PoolBlock^.ReferenceCounter)=0 then begin
  POCAPoolFreeBlock(Pool,Obj^.Header.PoolBlock);
 end else{$endif} begin
  Pool^.FreeObjects^[Pool^.FreeCount]:=Obj;
  inc(Pool^.FreeCount);
  TPasMPInterlocked.Increment(Pool^.Instance^.Globals.GarbageCollector.FreeCount);
 end;
end;

procedure POCAPoolInit(Instance:PPOCAInstance;Pool:PPOCAPool;ValueType:TPOCAInt32); {$ifdef UseRegister}register;{$endif}
begin
 FillChar(Pool^,sizeof(TPOCAPool),#0);
 Pool^.Instance:=Instance;
 Pool^.ValueType:=ValueType;
 Pool^.ElementRealSize:=POCATypeSizes[ValueType];
 if Pool^.ElementRealSize<0 then begin
  Pool^.ElementSize:=-1;
 end else begin
  Pool^.ElementSize:=POCARoundUpToMask(Pool^.ElementRealSize,16);
 end;
 Pool^.FreeObjects:=nil;
 Pool^.FreeSize:=0;
 Pool^.FreeCount:=0;
//Pool^.FreeLock:=0;
 Pool^.Size:=0;
 Pool^.FirstBlock:=nil;
 Pool^.LastBlock:=nil;
 POCAPoolNewBlock(Pool,Pool.Instance^.Globals.GarbageCollector.MinimumBlockSize);
end;

procedure POCAPoolDone(Pool:PPOCAPool); {$ifdef UseRegister}register;{$endif}
var Instance:PPOCAInstance;
    CurrentBlock,NextBlock:PPOCAPoolBlock;
    Element:TPOCAInt32;
    Obj:PPOCAObject;
begin
 Instance:=Pool^.Instance;
 if Pool^.ElementRealSize>0 then begin
  Pool^.FreeCount:=0;
  CurrentBlock:=Pool^.FirstBlock;
  while assigned(CurrentBlock) do begin
   NextBlock:=CurrentBlock^.Next;
   if assigned(CurrentBlock^.Data) then begin
    for Element:=0 to CurrentBlock^.Size-1 do begin
     Obj:=PPOCAObject(TPOCAPointer(@PPOCAUInt8Array(CurrentBlock^.Data)^[Element*Pool^.ElementSize]));
{$ifndef POCAGarbageCollectorPoolBlockInstance}
     Obj^.Header.Instance:=Instance;
{$endif}
     POCAPoolCleanElement(Pool,Obj);
    end;
    CurrentBlock^.Data:=nil;
   end;
   CurrentBlock^.Size:=0;
   CurrentBlock^.Next:=nil;
   FreeMemAligned(CurrentBlock);
   CurrentBlock:=NextBlock;
  end;
 end;
 if assigned(Pool^.FreeObjects) then begin
  FreeMem(Pool^.FreeObjects);
  Pool^.FreeObjects:=nil;
 end;
 FillChar(Pool^,sizeof(TPOCAPool),#0);
end;
{$else}
procedure POCAFreeElement(Obj:PPOCAObject); {$ifdef UseRegister}register;{$endif}
begin
 if assigned(Obj) then begin
//writeln(IntToHex(TPOCAPtrUInt(Obj),16));
  POCACleanElement(Obj);
  FreeMem(Obj);
 end;
end;
{$endif}

procedure POCAFreeDead(Instance:PPOCAInstance); {$ifdef UseRegister}register;{$endif}
var i:TPOCAInt32;
    p:TPOCAPointer;
begin
 for i:=0 to Instance^.Globals.DeadCount-1 do begin
  p:=PPOCAPointerArray(Instance^.Globals.DeadBlocks)^[i];
  if assigned(p) then begin
   PPOCAPointerArray(Instance^.Globals.DeadBlocks)^[i]:=nil;
   FreeMem(p);
  end;
 end;
 Instance^.Globals.DeadCount:=0;
end;

function POCAGarbageCollectorFree(Instance:PPOCAInstance):TPOCAInt32; {$ifdef UseRegister}register;{$endif}
var GarbageCollector:PPOCAGarbageCollector;
begin
 GarbageCollector:=@Instance^.Globals.GarbageCollector;
 result:=GarbageCollector^.FreeCount;
end;

function POCAGarbageCollectorUsed(Instance:PPOCAInstance):TPOCAInt32; {$ifdef UseRegister}register;{$endif}
var GarbageCollector:PPOCAGarbageCollector;
begin
 GarbageCollector:=@Instance^.Globals.GarbageCollector;
 result:=GarbageCollector^.Allocated-GarbageCollector^.FreeCount;
end;

function POCAMarkValue(Instance:PPOCAInstance;const Value:TPOCAValue):TPOCABool32;
begin
 if POCAIsValueObject(Value) then begin
  result:=Instance^.Globals.GarbageCollector.MarkObjectAsGray(PPOCAObject(POCAGetValueReferencePointer(Value)));
 end else begin
  result:=false;
 end;
end;

function POCACoroutineGhostMarkEx(const Data:TPOCAPointer):TPOCABool32; forward;
function POCAThreadGhostMarkEx(const Data:TPOCAPointer):TPOCABool32; forward;

procedure TPOCAGarbageCollectorLinkedList.Initialize(const aName:TPOCAUTF8String); //{$ifdef caninline}inline;{$endif}
begin
 Name:=aName;
 First:=nil;
 Last:=nil;
end;

procedure TPOCAGarbageCollectorLinkedList.Finalize;
{$ifdef POCAMemoryPools}
begin
 First:=nil;
 Last:=nil;
end;
{$else}
var Obj:PPOCAObject;
    Node,NextNode:PPOCAGarbageCollectorLinkedListItem;
begin
 Node:=First;
 while assigned(Node) do begin
  NextNode:=Node^.Next;
  Obj:=TPOCAPointer(Node);
  FreeMem(Obj);
  Node:=NextNode;
 end;
 First:=nil;
 Last:=nil;
end;
{$endif}

function TPOCAGarbageCollectorLinkedList.Empty:Boolean;
begin
 result:=not assigned(First);
end;

function TPOCAGarbageCollectorLinkedList.Filled:Boolean;
begin
 result:=assigned(First);
end;

procedure TPOCAGarbageCollectorLinkedList.Push(Obj:PPOCAObject);
var Node:PPOCAGarbageCollectorLinkedListItem absolute Obj;
begin
 Assert(not assigned(Node^.List),'Inconsistent garbage collector linked list object ownership');
 Node^.List:=@self;
 if assigned(Last) then begin
  Node^.Previous:=Last;
  Last^.Next:=Node;
 end else begin
  Node^.Previous:=nil;
  First:=Node;
 end;
 Node^.Next:=nil;
 Last:=Node;
end;

function TPOCAGarbageCollectorLinkedList.Pop(out Obj:PPOCAObject):boolean;
var Node:PPOCAGarbageCollectorLinkedListItem absolute Obj;
begin
 Obj:=TPOCAPointer(Last);
 result:=assigned(Obj);
 if result then begin
  Assert(Node^.List=@self,'Inconsistent garbage collector linked list object ownership');
  Obj:=TPOCAPointer(Node);
  if assigned(Node^.Previous) then begin
   Node^.Previous^.Next:=nil;
   Last:=Node^.Previous;
  end else begin
   First:=nil;
   Last:=nil;
  end;
  Node^.List:=nil;
  Node^.Previous:=nil;
  Node^.Next:=nil;
 end;
end;

function TPOCAGarbageCollectorLinkedList.PopFromFront(out Obj:PPOCAObject):boolean;
var Node:PPOCAGarbageCollectorLinkedListItem absolute Obj;
begin
 Obj:=TPOCAPointer(First);
 result:=assigned(Obj);
 if result then begin
  Assert(Node^.List=@self,'Inconsistent garbage collector linked list object ownership');
  if assigned(Node^.Next) then begin
   Node^.Next^.Previous:=nil;
   First:=Node^.Next;
  end else begin
   First:=nil;
   Last:=nil;
  end;
  Node^.List:=nil;
  Node^.Previous:=nil;
  Node^.Next:=nil;
 end;
end;

class procedure TPOCAGarbageCollectorLinkedList.Remove(Obj:PPOCAObject);
var Node:PPOCAGarbageCollectorLinkedListItem absolute Obj;
    List:PPOCAGarbageCollectorLinkedList;
begin
 List:=Node^.List;
 if assigned(List) then begin
  Node^.List:=nil;
  if assigned(Node^.Next) then begin
   Node^.Next^.Previous:=Node^.Previous;
  end else if List^.Last=Node then begin
   List^.Last:=Node^.Previous;
  end;
  if assigned(Node^.Previous) then begin
   Node^.Previous^.Next:=Node^.Next;
  end else if List^.First=Node then begin
   List^.First:=Node^.Next;
  end;
  Node^.Next:=nil;
  Node^.Previous:=nil;
 end;
end;

function TPOCAGarbageCollectorLinkedList.TakeOver(const Obj:PPOCAObject):boolean;
var Node:PPOCAGarbageCollectorLinkedListItem absolute Obj;
    List:PPOCAGarbageCollectorLinkedList;
begin
 result:=assigned(Obj) and (Node^.List<>@self);
 if assigned(Obj) then begin
  List:=Node^.List;
  if assigned(List) then begin
   if assigned(Node^.Next) then begin
    Node^.Next^.Previous:=Node^.Previous;
   end else if List^.Last=Node then begin
    List^.Last:=Node^.Previous;
   end;
   if assigned(Node^.Previous) then begin
    Node^.Previous^.Next:=Node^.Next;
   end else if List^.First=Node then begin
    List^.First:=Node^.Next;
   end;
  end else begin
   Assert(not assigned(List),'Inconsistent garbage collector linked list object ownership');
  end;
  Node^.List:=@self;
  if assigned(Last) then begin
   Node^.Previous:=Last;
   Last^.Next:=Node;
  end else begin
   Node^.Previous:=nil;
   First:=Node;
  end;
  Node^.Next:=nil;
  Last:=Node;
 end;
end;

function TPOCAGarbageCollectorLinkedList.TakeOverAppend(const aSourceList:PPOCAGarbageCollectorLinkedList):boolean;
var //Obj:PPOCAObject;
    Node:PPOCAGarbageCollectorLinkedListItem;
begin
 result:=(aSourceList<>@self) and assigned(aSourceList) and assigned(@self) and aSourceList^.Filled;
 if result then begin
  if assigned(aSourceList^.First) then begin
   Node:=aSourceList^.First;
   while assigned(Node) do begin
    Assert(Node^.List=aSourceList,'Inconsistent garbage collector linked list object ownership');
    Node^.List:=@self;
    Node:=Node^.Next;
   end;
   if assigned(Last) then begin
    Last^.Next:=aSourceList^.First;
    aSourceList^.First^.Previous:=Last;
   end else begin
    First:=aSourceList^.First;
   end;
   Last:=aSourceList^.Last;
   aSourceList^.First:=nil;
   aSourceList^.Last:=nil;
  end;
{ while aSourceList^.PopFromFront(Obj) do begin
   Push(Obj);
  end}
 end;
end;

function TPOCAGarbageCollectorLinkedList.TakeOverAppendMark(const aSourceList:PPOCAGarbageCollectorLinkedList;const aBitsToAdd:TPOCAUInt32):boolean;
var Node:PPOCAGarbageCollectorLinkedListItem;
begin
 result:=(aSourceList<>@self) and assigned(aSourceList) and assigned(@self) and aSourceList^.Filled;
 if result then begin
  if assigned(aSourceList^.First) then begin
   Node:=aSourceList^.First;
   while assigned(Node) do begin
    Assert(Node^.List=aSourceList,'Inconsistent garbage collector linked list object ownership');
    Node^.List:=@self;
    PPOCAObject(Node)^.Header.GarbageCollector.State:=(PPOCAObject(Node)^.Header.GarbageCollector.State and not pgcbLIST) or aBitsToAdd;
    Node:=Node^.Next;
   end;
   if assigned(Last) then begin
    Last^.Next:=aSourceList^.First;
    aSourceList^.First^.Previous:=Last;
   end else begin
    First:=aSourceList^.First;
   end;
   Last:=aSourceList^.Last;
   aSourceList^.First:=nil;
   aSourceList^.Last:=nil;
  end;
 end;
end;
{var Obj:PPOCAObject;
begin
 result:=(aSourceList<>@self) and assigned(aSourceList) and assigned(@self) and aSourceList^.Filled;
 if result then begin
  Obj:=nil;
  while aSourceList^.PopFromFront(Obj) do begin
   Push(Obj);
   Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or aBitsToAdd;
  end;
 end;
end;//}

class function TPOCAGarbageCollectorLinkedList.Swap(var aList,aWithList:PPOCAGarbageCollectorLinkedList):boolean;
var List:PPOCAGarbageCollectorLinkedList;
    Name:TPOCAUTF8String;
begin
 result:=(aList<>aWithList) and assigned(aList) and assigned(aWithList);
 if result then begin
  List:=aList;
  aList:=aWithList;
  aWithList:=List;
  Name:=aList^.Name;
  aList^.Name:=aWithList^.Name;
  aWithList^.Name:=Name;
 end;
end; 

procedure POCAGarbageCollectorWriteBarrier(const ParentObj:PPOCAObject;const Value:TPOCAValue);
begin
 TPOCAGarbageCollector.WriteBarrier(ParentObj,Value);
end;

function TPOCAGarbageCollector.IsWhite(const Obj:PPOCAObject):Boolean;
begin
 result:=(Obj^.Header.GarbageCollector.State and WhiteMask)<>0;
end;

class function TPOCAGarbageCollector.IsGray(const Obj:PPOCAObject):Boolean;
begin
 result:=(Obj^.Header.GarbageCollector.State and pgcbGRAY)<>0;
end;

function TPOCAGarbageCollector.IsBlack(const Obj:PPOCAObject):Boolean;
begin
 result:=(Obj^.Header.GarbageCollector.State and BlackMask)<>0;
end;

function TPOCAGarbageCollector.IsGrayOrBlack(const Obj:PPOCAObject):Boolean;
begin
 result:=(Obj^.Header.GarbageCollector.State and (pgcbGRAY or BlackMask))<>0;
end;

procedure TPOCAGarbageCollector.WriteBarrierMark(const Obj:PPOCAObject);
begin
 // Obj: white -> gray
 POCALockEnter(Lock);
 try
  // Re-check after locking
  if IsWhite(Obj) then begin
   // Move to gray list
   GrayList.TakeOver(Obj);
   Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbGRAY;
  end;
 finally
  POCALockLeave(Lock);
 end;
end;

procedure TPOCAGarbageCollector.WriteBarrierMarkParent(const ParentObj:PPOCAObject);
begin
 // ParentObj: white -> gray
 POCALockEnter(Lock);
 try
  // Re-check after locking
  if not IsGray(ParentObj) then begin
   GrayList.TakeOver(ParentObj);
   ParentObj^.Header.GarbageCollector.State:=(ParentObj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbGRAY;
  end; 
 finally
  POCALockLeave(Lock);
 end;
end;

procedure TPOCAGarbageCollector.WriteBarrierPersistent(const ParentObj:PPOCAObject);
begin
 POCALockEnter(Lock);
 try
  // Re-check after locking
  if (ParentObj^.Header.GarbageCollector.State and pgcbPERSISTENT)<>0 then begin
   // Move from persistent non-root list to persistent root list (aka remembered set)
   PersistentRootLists[ParentObj^.Header.ValueType=pvtGHOST].TakeOver(ParentObj);
   ParentObj^.Header.GarbageCollector.State:=(ParentObj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbPERSISTENTROOT;
  end;
 finally
  POCALockLeave(Lock);
 end;
end;

procedure TPOCAGarbageCollector.WriteBarrierNonPersistent(const Obj:PPOCAObject);
begin
 POCALockEnter(Lock);
 try
  // Re-check after locking
  if (Obj^.Header.GarbageCollector.State and (pgcbPERSISTENT or pgcbPERSISTENTROOT))<>0 then begin
   // Move from persistent back to gray list
   GrayList.TakeOver(Obj);
   Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not (pgcbLIST or pgcbPERSISTENT or pgcbPERSISTENTROOT)) or pgcbGRAY;
  end;
 finally
  POCALockLeave(Lock);
 end;
end;

procedure TPOCAGarbageCollector.WriteBarrierObject(const ParentObj,Obj:PPOCAObject);
begin

 // Write-barrier (forward barrier: white -> gray)
 // Pre-check before locking
 if IsWhite(Obj) then begin
  if assigned(ParentObj) then begin
   if IsBlack(ParentObj) then begin
    // The parent holder object is in the black object list, so mark our to-store-object gray
    WriteBarrierMark(Obj);
   end else if IsWhite(ParentObj) then begin
    // The parent holder object is in the white object list, so mark the parent holder object gray
    WriteBarrierMarkParent(ParentObj);
   end;
  end else begin
   // Mark our object gray, if ParentObj is null
   WriteBarrierMark(Obj);
  end;
 end;

 // Persistent -> ephemeral inter-generation-reference forward write-barrier
 // Pre-check before locking
 if assigned(ParentObj) and
    (((Obj^.Header.GarbageCollector.State and (pgcbPERSISTENT or pgcbPERSISTENTROOT))=0) and
     ((ParentObj^.Header.GarbageCollector.State and pgcbPERSISTENT)<>0)) then begin
  if Generational then begin
   WriteBarrierPersistent(ParentObj); // Move from persistent non-root list to persistent root list (aka remembered set) when the generational mode is active
  end else begin
   WriteBarrierNonPersistent(ParentObj); // Move from persistent to gray list when the generational mode is not active
  end;
 end;

end;

class procedure TPOCAGarbageCollector.WriteBarrier(const ParentObj:PPOCAObject;const Value:TPOCAValue);
var Obj:PPOCAObject;
    GarbageCollector:PPOCAGarbageCollector;
begin
 if POCAIsValueObjectAndGetReferencePointer(Value,Obj) then begin
  if assigned(ParentObj) then begin
   GarbageCollector:=@ParentObj^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance^.Globals.GarbageCollector;
   if not assigned(GarbageCollector) then begin
    GarbageCollector:=@Obj^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance^.Globals.GarbageCollector;
   end;
  end else begin
   GarbageCollector:=@Obj^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance^.Globals.GarbageCollector;
  end;
  if assigned(GarbageCollector) then begin
   GarbageCollector^.WriteBarrierObject(ParentObj,Obj);
  end;
 end;
end;

function TPOCAGarbageCollector.MarkObjectAsGray(Obj:PPOCAObject):boolean;
begin
 if assigned(Obj) then begin
  result:=(Obj^.Header.GarbageCollector.State and (pgcbPERSISTENT or pgcbPERSISTENTROOT))=0;
  if result and not IsGrayOrBlack(Obj) then begin
   GrayList.TakeOver(Obj);
   Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbGRAY;
  end;
 end else begin
  result:=false;
 end;
end;

function TPOCAGarbageCollector.MarkValue(const Value:TPOCAValue):boolean;
begin
 if POCAIsValueObject(Value) then begin
  result:=MarkObjectAsGray(PPOCAObject(POCAGetValueReferencePointer(Value)));
 end else begin
  result:=false;
 end;
end;

function TPOCAGarbageCollector.MarkArrayAsGray(Obj:PPOCAArray):boolean;
var ArrayRecord:PPOCAArrayRecord;
    i:TPOCAInt32;
begin
 result:=false;
 ArrayRecord:=Obj^.ArrayRecord;
 if assigned(ArrayRecord) then begin
  for i:=0 to ArrayRecord^.Size-1 do begin
   if MarkValue(ArrayRecord^.Data[i]) then begin
    result:=true;
   end;
  end;
 end;
end;

function TPOCAGarbageCollector.MarkHashAsGray(Obj:PPOCAHash):boolean;
var HashRec:PPOCAHashRecord;
    HashEntity:PPOCAHashEntity;
    i:TPOCAInt32;
    j:TPOCAInt32;
    mo:TPOCAMetaOp;
begin
 result:=false;
 HashRec:=Obj^.HashRecord;
 if assigned(HashRec) then begin
  for i:=0 to (2 shl HashRec^.LogSize)-1 do begin
   j:=HashRec^.CellToEntityIndex^[i];
   if j>=0 then begin
    HashEntity:=@HashRec^.Entities^[j];
    if MarkValue(HashEntity^.Key) then begin
     result:=true;
    end;
    if MarkValue(HashEntity^.Value) then begin
     result:=true;
    end;
   end;
  end;
  if assigned(HashRec^.Events) then begin
   for mo:=low(TPOCAHashEvents) to high(TPOCAHashEvents) do begin
    if MarkValue(HashRec^.Events[mo]) then begin
     result:=true;
    end;
   end;
  end;
 end;
 if assigned(Obj^.Prototype) then begin
  if MarkObjectAsGray(TPOCAPointer(Obj^.Prototype)) then begin
   result:=true;
  end;
 end;
 if assigned(Obj^.Events) then begin
  if MarkObjectAsGray(TPOCAPointer(Obj^.Events)) then begin
   result:=true;
  end;
 end;
 if assigned(Obj^.Ghost) then begin
  if MarkObjectAsGray(TPOCAPointer(Obj^.Ghost)) then begin
   result:=true;
  end;
 end;
end;

function TPOCAGarbageCollector.MarkCodeAsGray(Obj:PPOCACode):boolean;
var i:TPOCAInt32;
begin
 result:=false;
 for i:=0 to Obj^.ConstantCount-1 do begin
  if MarkValue(Obj^.Constants^[i]) then begin
   result:=true;
  end;
 end;
 for i:=0 to Obj^.CountRegExps-1 do begin
  if MarkValue(Obj^.RegExps^[i]) then begin
   result:=true;
  end;
 end;
end;

function TPOCAGarbageCollector.MarkFunctionAsGray(Obj:PPOCAFunction):boolean;
var Index,OtherIndex:TPOCAInt32;
begin
 result:=false;
 if MarkValue(Obj^.Code) then begin
  result:=true;
 end;
 if MarkValue(Obj^.Namespace) then begin
  result:=true;
 end;
 if MarkValue(Obj^.Obj) then begin
  result:=true;
 end;
{$ifdef POCAClosureArrayValues}
 MarkValue(Obj^.ClosureValues);
{$else}
 for Index:=0 to length(Obj^.ClosureValues)-1 do begin
  for OtherIndex:=0 to length(Obj^.ClosureValues[Index])-1 do begin
   if MarkValue(Obj^.ClosureValues[Index][OtherIndex]) then begin
    result:=true;
   end;
  end;
 end;
{$endif}
 if MarkValue(Obj^.Next) then begin
  result:=true;
 end;
end;

function TPOCAGarbageCollector.MarkGhostAsGray(Obj:PPOCAGhost):boolean;
begin
 result:=false;
 if assigned(Obj^.GhostType) and assigned(addr(Obj^.GhostType^.Mark)) then begin
  if Obj^.GhostType^.Mark(Obj) then begin
   result:=true;
  end;
 end;
 if assigned(Obj^.Hash) then begin
  if MarkObjectAsGray(TPOCAPointer(Obj^.Hash)) then begin
   result:=true;
  end;
 end;
end;

procedure TPOCAGarbageCollector.TryMarkGhostAsGray(Obj:PPOCAObject);
begin
 if Obj^.Header.ValueType=pvtGHOST then begin
  MarkGhostAsGray(TPOCAPointer(Obj));
 end;
end;

function TPOCAGarbageCollector.MarkObjectContent(Obj:PPOCAObject):boolean;
begin
 case Obj^.Header.ValueType of
  pvtREFERENCE:begin
   result:=MarkObjectAsGray(TPOCAPointer(Obj));
  end;
  pvtSTRING:begin
   result:=MarkObjectAsGray(TPOCAPointer(Obj));
  end;
  pvtARRAY:begin
   result:=MarkArrayAsGray(TPOCAPointer(Obj));
  end;
  pvtHASH:begin
   result:=MarkHashAsGray(TPOCAPointer(Obj));
  end;
  pvtCODE:begin
   result:=MarkCodeAsGray(TPOCAPointer(Obj));
  end;
  pvtFUNCTION:begin
   result:=MarkFunctionAsGray(TPOCAPointer(Obj));
  end;
  pvtNATIVECODE:begin
   result:=MarkObjectAsGray(TPOCAPointer(Obj));
  end;
  pvtGHOST:begin
   result:=MarkGhostAsGray(TPOCAPointer(Obj));
  end;
  else begin
   result:=false;
  end;
 end;
end;

procedure TPOCAGarbageCollector.MarkObject(Obj:PPOCAObject);
begin
 if Generational then begin
  case Obj^.Header.GarbageCollector.State and (pgcbPERSISTENT or pgcbPERSISTENTROOT or pgcbWASPERSISTENT or pgcbWASPERSISTENTROOT) of
   pgcbWASPERSISTENT:begin
    PersistentLists[Obj^.Header.ValueType=pvtGHOST].TakeOver(Obj);
    Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not (pgcbLIST or (pgcbWASPERSISTENT or pgcbWASPERSISTENTROOT))) or pgcbPERSISTENT;
    MarkObjectContent(Obj);
   end;
   pgcbWASPERSISTENT or pgcbWASPERSISTENTROOT,pgcbWASPERSISTENTROOT:begin
    PersistentRootLists[Obj^.Header.ValueType=pvtGHOST].TakeOver(Obj);
    Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not (pgcbLIST or (pgcbWASPERSISTENT or pgcbWASPERSISTENTROOT))) or pgcbPERSISTENTROOT;
    MarkObjectContent(Obj);
   end;
   0:begin
    if PersistentThreshold>0 then begin
     if TPOCAPtrUInt(Obj^.Header.GarbageCollector.State shr 8)>=TPOCAPtrUInt(PersistentThreshold) then begin
      PersistentLists[Obj^.Header.ValueType=pvtGHOST].TakeOver(Obj);
      Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and (pgcbBITS and not pgcbLIST)) or pgcbPERSISTENT;
     end else begin
      if (Obj^.Header.GarbageCollector.State shr pgcscSHIFT)<pgcscMAX then begin
       inc(Obj^.Header.GarbageCollector.State,pgcscONE);
      end;
      BlackLists[Obj^.Header.ValueType=pvtGHOST]^.TakeOver(Obj);
      Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or BlackMask;
     end;
    end else begin
     BlackLists[Obj^.Header.ValueType=pvtGHOST]^.TakeOver(Obj);
     Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or BlackMask;
    end;
    MarkObjectContent(Obj);
   end;
  end;
 end else begin
  BlackLists[Obj^.Header.ValueType=pvtGHOST]^.TakeOver(Obj);
  Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not (pgcbLIST or (pgcbWASPERSISTENT or pgcbWASPERSISTENTROOT))) or BlackMask;
  MarkObjectContent(Obj);
 end;
end;

procedure TPOCAGarbageCollector.MarkTemporarySavedObjects(Context:PPOCAContext);
var i:TPOCAInt32;
begin
 for i:=0 to Context^.TemporarySavedObjectCount-1 do begin
  MarkObjectAsGray(Context^.TemporarySavedObjects^[i]);
 end;
end;

procedure TPOCAGarbageCollector.MarkGlobals;
begin
 MarkValue(Instance^.Globals.RootArray);
 MarkValue(Instance^.Globals.RootHash);
 MarkValue(Instance^.Globals.Namespace);
 MarkValue(Instance^.Globals.HiddenNamespace);
 MarkValue(Instance^.Globals.ModuleScopes);
 MarkValue(Instance^.Globals.ModuleValues);
 MarkValue(Instance^.Globals.ModuleTimes);
 MarkValue(Instance^.Globals.BaseClass);
 MarkValue(Instance^.Globals.ArrayHash);
 MarkValue(Instance^.Globals.HashHash);
 MarkValue(Instance^.Globals.NumberHash);
 MarkValue(Instance^.Globals.StringHash);
 MarkValue(Instance^.Globals.IOHash);
 MarkValue(Instance^.Globals.RegExpHash);
 MarkValue(Instance^.Globals.CoroutineHash);
 MarkValue(Instance^.Globals.ThreadHash);
 MarkValue(Instance^.Globals.LockHash);
 MarkValue(Instance^.Globals.SemaphoreHash);
 MarkValue(Instance^.Globals.Save);
 MarkValue(Instance^.Globals.Symbols);
 MarkValue(Instance^.Globals.ArgumentsValueReference);
 MarkValue(Instance^.Globals.ConstructorValueReference);
 MarkValue(Instance^.Globals.NullValueReference);
 MarkValue(Instance^.Globals.ReferenceValueReference);
 MarkValue(Instance^.Globals.NumberValueReference);
 MarkValue(Instance^.Globals.StringValueReference);
 MarkValue(Instance^.Globals.ArrayValueReference);
 MarkValue(Instance^.Globals.GhostClassValueReference);
 MarkValue(Instance^.Globals.ClassValueReference);
 MarkValue(Instance^.Globals.GhostModuleValueReference);
 MarkValue(Instance^.Globals.ModuleValueReference);
 MarkValue(Instance^.Globals.GhostHashValueReference);
 MarkValue(Instance^.Globals.HashValueReference);
 MarkValue(Instance^.Globals.FunctionValueReference);
 MarkValue(Instance^.Globals.ClassGhostValueReference);
 MarkValue(Instance^.Globals.ModuleGhostValueReference);
 MarkValue(Instance^.Globals.HashGhostValueReference);
 MarkValue(Instance^.Globals.GhostValueReference);
 MarkValue(Instance^.Globals.CodeValueReference);
 MarkValue(Instance^.Globals.NativeCodeValueReference);
 MarkValue(Instance^.Globals.UnknownValueReference);
 MarkValue(Instance^.Globals.LengthStringReference);
 MarkValue(Instance^.Globals.SourceFiles);
 MarkValue(Instance^.Globals.UniqueStringArray);
end;

function TPOCAGarbageCollector.MarkContexts:boolean;
var Context:PPOCAContext;
    Frame:PPOCAFrame;
    i,j,k:TPOCAInt32;
begin
 Context:=Instance^.Globals.FirstContext;
 while assigned(Context) do begin
  for i:=0 to Context^.FrameTop-1 do begin
   Frame:=@Context^.FrameStack[i];
   MarkValue(Frame^.Func);
   MarkValue(Frame^.Locals);
   MarkValue(Frame^.Obj);
   for j:=0 to Frame^.CountRegisters-1 do begin
    MarkValue(Frame^.Registers[j]);
   end;
   for j:=0 to Frame^.CountArguments-1 do begin
    MarkValue(Frame^.Arguments[j]);
   end;
{$ifdef POCAClosureArrayValues}
   MarkValue(Frame^.LocalValues);
   MarkValue(Frame^.OuterValueLevels);
{$else}
   for j:=0 to length(Frame^.LocalValues)-1 do begin
    MarkValue(Frame^.LocalValues[j]);
   end;
   for j:=0 to Min(length(Frame^.OuterValueLevels),Frame^.CountOuterValueLevels)-1 do begin
    for k:=0 to length(Frame^.OuterValueLevels[j])-1 do begin
     if MarkValue(Frame^.OuterValueLevels[j][k]) then begin
      result:=true;
     end;
    end;
   end;
{$endif}
  end;
  if assigned(PPOCACoroutineData(Context^.CoroutineData)) and (assigned(PPOCACoroutineData(Context^.CoroutineData)^.Coroutine) and (PPOCACoroutineData(Context^.CoroutineData)^.Coroutine^.State<>pcsTERMINATED)) then begin
   POCACoroutineGhostMarkEx(Context^.ThreadData);
  end;
  if assigned(PPOCAThreadData(Context^.ThreadData)) and not PPOCAThreadData(Context^.ThreadData)^.Terminated then begin
   POCAThreadGhostMarkEx(Context^.ThreadData);
  end;
  MarkTemporarySavedObjects(Context);
  GrayList.TakeOverAppend(@Context^.GrayList);
  Context:=Context^.Next;
 end;
 result:=assigned(GrayList.First);
end;

function TPOCAGarbageCollector.MarkContextGrays:boolean;
var Context:PPOCAContext;
begin
 if TPasMPInterlocked.CompareExchange(ScanContextGrays,TPasMPBool32(false),TPasMPBool32(true)) then begin
  Context:=Instance^.Globals.FirstContext;
  while assigned(Context) do begin
   GrayList.TakeOverAppend(@Context^.GrayList);
   Context:=Context^.Next;
  end;
  result:=assigned(GrayList.First);
 end else begin
  result:=false;
 end;
end;

procedure TPOCAGarbageCollector.MarkPersistents;
var Ghost:boolean;
    Obj,NextObj:PPOCAObject;
    List:PPOCAGarbageCollectorLinkedList;
begin
 for Ghost:=false to true do begin
  List:=@PersistentRootLists[Ghost];
  Obj:=TPOCAPointer(List^.First);
  while assigned(Obj) do begin
   NextObj:=TPOCAPointer(Obj^.Header.GarbageCollector.LinkedList.Next);
   if not MarkObjectContent(Obj) then begin
    // No more references to ephemeral generation objects, so move from the
    // persistent root list to the persistent list
    PersistentLists[Ghost].TakeOver(Obj);
    Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbPERSISTENT;
   end;
   Obj:=NextObj;
  end;
 end;
end;

procedure TPOCAGarbageCollector.MarkRoots;
begin
 MarkGlobals;
 MarkContexts;
 MarkPersistents;
end;

procedure TPOCAGarbageCollector.MarkProtected;
var Obj:PPOCAObject;
    i:TPOCAInt32;
begin
 for i:=0 to Instance^.Globals.GarbageCollector.ProtectList.Count-1 do begin
  Obj:=Instance^.Globals.GarbageCollector.ProtectList[i];
  if assigned(Obj) then begin
   MarkObjectAsGray(Obj);
  end;
 end;
end;

procedure TPOCAGarbageCollector.Reset;
var Ghost:boolean;
    Obj:PPOCAObject;
begin

 PersistentCycleCounter:=0;

 for Ghost:=false to true do begin
  WhiteLists[Ghost]^.TakeOverAppend(BlackLists[Ghost]);
  WhiteLists[Ghost]^.TakeOverAppend(@PersistentLists[Ghost]);
  WhiteLists[Ghost]^.TakeOverAppend(@PersistentRootLists[Ghost]);
  Obj:=TPOCAPointer(WhiteLists[Ghost]^.First);
  while assigned(Obj) do begin
   Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and (pgcbBITS and not pgcbLIST)) or WhiteMask;
   Obj:=TPOCAPointer(Obj^.Header.GarbageCollector.LinkedList.Next);
  end;
 end;

 Obj:=TPOCAPointer(GrayList.First);
 while assigned(Obj) do begin
  Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and (pgcbBITS and not pgcbLIST)) or pgcbGRAY;
  Obj:=TPOCAPointer(Obj^.Header.GarbageCollector.LinkedList.Next);
 end;

end;

procedure TPOCAGarbageCollector.Init;
var Ghost:boolean;
begin
 if Generational then begin
  if PersistentInterval>0 then begin
   inc(PersistentCycleCounter);
  end else begin
   PersistentCycleCounter:=0;
  end;
  if PersistentForceScan or ((PersistentInterval>0) and (PersistentCycleCounter>=PersistentInterval)) or (Instance^.Globals.RequestGarbageCollection=prgcFULL) then begin
   PersistentForceScan:=false;
   PersistentCycleCounter:=0;
   for Ghost:=false to true do begin
    WhiteLists[Ghost]^.TakeOverAppendMark(@PersistentLists[Ghost],WhiteMask or pgcbWASPERSISTENT);
    WhiteLists[Ghost]^.TakeOverAppendMark(@PersistentRootLists[Ghost],WhiteMask or pgcbWASPERSISTENTROOT);
   end;
  end;
 end else begin
  PersistentForceScan:=false;
  PersistentCycleCounter:=0;
  for Ghost:=false to true do begin
   GrayList.TakeOverAppendMark(@PersistentLists[Ghost],pgcbGRAY);
   GrayList.TakeOverAppendMark(@PersistentRootLists[Ghost],pgcbGRAY);
  end;
 end;
end;

procedure TPOCAGarbageCollector.Flip;
var Ghost:boolean;
begin
 // Swap the roles of the white and black lists, but also swap the roles of the white and black bit masks.
 if WhiteMask=pgcbWHITE then begin
  WhiteMask:=pgcbBLACK;
  BlackMask:=pgcbWHITE;
 end else begin
  WhiteMask:=pgcbWHITE;
  BlackMask:=pgcbBLACK;
 end;
 for Ghost:=false to true do begin
  TPOCAGarbageCollectorLinkedList.Swap(WhiteLists[Ghost],BlackLists[Ghost]);
 end;
end;

function TPOCAGarbageCollector.CollectCycle:boolean;
var i:TPOCAInt32;
    Obj:PPOCAObject;
    Ghost:boolean;
begin

 result:=Active;
 if not result then begin
  exit;
 end;

 POCALockEnter(Lock);
 try

  if Generational and not Incremental then begin
   State:=pgcsINIT;
  end else if not (Incremental or Generational) then begin
   State:=pgcsRESET;
  end else begin
   // Incremental
   if PersistentForceScan and (State<>pgcsINIT) then begin
    State:=pgcsINIT;
   end;
  end;

  repeat

   case State of

    pgcsRESET:begin
     Reset;
     State:=pgcsINIT;
    end;

    pgcsINIT:begin
     Init;
     State:=pgcsMARKROOTS;
    end;

    pgcsMARKROOTS:begin
     MarkRoots;
     State:=pgcsMARKPROTECTED;
    end;

    pgcsMARKPROTECTED:begin
     MarkProtected;
     State:=pgcsMARKGREYS;
    end;

    pgcsMARKGREYS,pgcsMARKWHITEGHOSTGREYS:begin
     if State=pgcsMARKGREYS then begin
      MarkContextGrays;
     end;
     if GrayList.Filled then begin
      case Instance^.Globals.RequestGarbageCollection of
       prgcCYCLE:begin
        if Incremental then begin
         i:=POCAGarbageCollectorUsed(Instance);
         if i<>0 then begin
          i:=(i*MarkFactor) shr 8;
          if i<1024 then begin
           i:=1024;
          end;
         end;
        end else begin
         i:=-1;
        end;
       end;
       else {prgcFULLEPHEMERAL,prgcFULL:}begin
        i:=-1;
       end;
      end;
      while (i<>0) and GrayList.Pop(Obj) do begin
       if i>0 then begin
        dec(i);
       end;
       MarkObject(TPOCAPointer(Obj));
      end;
      if GrayList.Empty then begin
       if State=pgcsMARKWHITEGHOSTGREYS then begin
        State:=pgcsSWEEP;
       end else begin
        State:=pgcsSWEEPINIT;
       end;
       if MarkFactor>=256 then begin
        continue;
       end;
      end;
      if Incremental then begin
       break;
      end else begin
       continue;
      end;
     end else begin
      if State=pgcsMARKWHITEGHOSTGREYS then begin
       State:=pgcsSWEEP;
      end else begin
       State:=pgcsSWEEPINIT;
      end;
     end;
    end;

    pgcsSWEEPINIT:begin
     // Scan contexts again before we are beginning sweeping (due to VM registers)
     if MarkContexts then begin
      State:=pgcsMARKGREYS;
     end else begin
      State:=pgcsFLIP;
      for Ghost:=false to true do begin
       if WhiteLists[Ghost]^.Filled then begin
        if Ghost then begin
         WhiteGhostList.TakeOverAppend(WhiteLists[Ghost]);
         State:=pgcsMARKWHITEGHOSTS;
        end else begin
         SweepLists[Ghost].TakeOverAppendMark(WhiteLists[Ghost],0);
         if State=pgcsFLIP then begin
          State:=pgcsSWEEP;
         end;
        end;
       end;
      end;
     end;
    end;

    pgcsMARKWHITEGHOSTS:begin
     case Instance^.Globals.RequestGarbageCollection of
      prgcCYCLE:begin
       if Incremental then begin
        i:=POCAGarbageCollectorUsed(Instance);
        if i<>0 then begin
         i:=(i*GhostFactor) shr 8;
         if i<1024 then begin
          i:=1024;
         end;
        end;
       end else begin
        i:=-1;
       end;
      end;
      else {prgcFULLEPHEMERAL,prgcFULL:}begin
       i:=-1;
      end;
     end;
     while (i<>0) and WhiteGhostList.Pop(Obj) do begin
      if i>0 then begin
       dec(i);
      end;
      if (((Obj^.Header.ValueType=pvtGHOST) and assigned(PPOCAGhost(Obj)^.GhostType)) and assigned(addr(PPOCAGhost(Obj)^.GhostType^.CanDestroy))) and not PPOCAGhost(Obj)^.GhostType^.CanDestroy(PPOCAGhost(Obj)) then begin
       GrayList.TakeOver(Obj);
       Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbGRAY;
      end else begin
       SweepLists[Obj^.Header.ValueType=pvtGHOST].TakeOver(Obj);
       Obj^.Header.GarbageCollector.State:=Obj^.Header.GarbageCollector.State and not pgcbLIST;
       TryMarkGhostAsGray(Obj);
      end;
     end;
     if WhiteGhostList.Empty then begin
      if GrayList.Empty then begin
       State:=pgcsSWEEP;
      end else begin
       State:=pgcsMARKWHITEGHOSTGREYS;
      end;
      if GhostFactor>=256 then begin
       continue;
      end;
     end;
     if Incremental then begin
      break;
     end else begin
      continue;
     end;
    end;

    pgcsSWEEP:begin
     case Instance^.Globals.RequestGarbageCollection of
      prgcCYCLE:begin
       if Incremental then begin
        i:=POCAGarbageCollectorUsed(Instance);
        if i<>0 then begin
         i:=(i*SweepFactor) shr 8;
         if i<1024 then begin
          i:=1024;
         end;
        end;
       end else begin
        i:=-1;
       end;
      end;
      else {prgcFULLEPHEMERAL,prgcFULL:}begin
       i:=-1;
      end;
     end;
     State:=pgcsFLIP;
     for Ghost:=true downto false do begin
      while (i<>0) and SweepLists[Ghost].Pop(Obj) do begin
       dec(i);
{$ifdef POCAMemoryPools}
       POCAPoolFreeElement(@Instance^.Globals.Pools[Obj^.Header.ValueType],Obj);
{$else}
       POCAFreeElement(Obj);
       TPasMPInterlocked.Decrement(Allocated);
{$endif}
      end;
      if SweepLists[Ghost].Filled then begin
       State:=pgcsSWEEP;
      end;
      if i=0 then begin
       break;
      end;
     end;
     if Incremental then begin
      if (State=pgcsFLIP) and (SweepFactor>=256) then begin
       continue;
      end else begin
       break;
      end;
     end else begin
      continue;
     end;
    end;

    pgcsFLIP:begin
     Flip;
     State:=pgcsDONE;
    end;

    pgcsDONE:begin
     State:=pgcsINIT;
     Instance^.Globals.RequestGarbageCollection:=prgcNONE;
     inc(FullCycleCounter);
     result:=false;
     break;
    end;

    else begin
     result:=false;
     break;
    end;

   end;

  until false;

 finally
  POCALockLeave(Lock);
 end;

end;

procedure TPOCAGarbageCollector.CollectAll;
var i:TPOCAInt32;
begin
 if State<>pgcsINIT then begin
  while CollectCycle do begin
  end;
  State:=pgcsINIT;
//State:=pgcsRESET;
 end;
 while CollectCycle do begin
 end;
 begin
  Instance^.Globals.DeadAllocationCount:=0;
{$ifdef POCAMemoryPools}
  for i:=0 to pvtCOUNT-1 do begin
   inc(Instance^.Globals.DeadAllocationCount,Instance^.Globals.Pools[i].Size div 2);
  end;
{$endif}
  if Instance^.Globals.DeadSize<Instance^.Globals.DeadAllocationCount then begin
   Instance^.Globals.DeadSize:=Instance^.Globals.DeadAllocationCount;
   if Instance^.Globals.DeadSize<256 then begin
    Instance^.Globals.DeadSize:=256;
   end;
   FreeMem(Instance^.Globals.DeadBlocks);
   GetMem(Instance^.Globals.DeadBlocks,Instance^.Globals.DeadSize*sizeof(TPOCAPointer));
   FillChar(Instance^.Globals.DeadBlocks^,Instance^.Globals.DeadSize*sizeof(TPOCAPointer),#0);
  end;
 end;
end;

procedure POCAGarbageCollectorBottleneck(Instance:PPOCAInstance); {$ifdef UseRegister}register;{$endif}
begin
 TPasMPInterlocked.Exchange(TPOCAInt32(Instance^.Globals.Bottleneck),TPOCAInt32(TPOCABool32(true)));
 while Instance^.Globals.Bottleneck and (Instance^.Globals.WaitCount<(Instance^.Globals.ThreadCount-1)) do begin
  TPasMPInterlocked.Increment(Instance^.Globals.WaitCount);
  POCALockLeave(Instance^.Globals.Lock);
  try
   POCASemaphoreDown(Instance^.Globals.Semaphore);
  finally
   POCALockEnter(Instance^.Globals.Lock);
  end;
  TPasMPInterlocked.Decrement(Instance^.Globals.WaitCount);
 end;
 if Instance^.Globals.WaitCount>=(Instance^.Globals.ThreadCount-1) then begin
  POCAFreeDead(Instance);
  case Instance^.Globals.RequestGarbageCollection of
   prgcCYCLE:begin
    Instance^.Globals.GarbageCollector.CollectCycle;
   end;
   prgcFULLEPHEMERAL,prgcFULL:begin
    Instance^.Globals.GarbageCollector.CollectAll;
   end;
   else begin
   end;
  end;
  if Instance^.Globals.WaitCount<>0 then begin
   POCASemaphoreUp(Instance^.Globals.Semaphore,Instance^.Globals.WaitCount);
  end;
  TPasMPInterlocked.Exchange(TPOCAInt32(Instance^.Globals.Bottleneck),TPOCAInt32(TPOCABool32(false)));
 end;
end;

procedure POCAGarbageCollectorCheckBottleneck(Instance:PPOCAInstance); {$ifdef UseRegister}register;{$endif}
begin
 if Instance^.Globals.Bottleneck then begin
  POCALockEnter(Instance^.Globals.Lock);
  try
   POCAGarbageCollectorBottleneck(Instance);
  finally
   POCALockLeave(Instance^.Globals.Lock);
  end;
 end;
end;

procedure POCAGarbageCollectorDoBottleneck(Instance:PPOCAInstance); {$ifdef UseRegister}register;{$endif}
begin
 POCALockEnter(Instance^.Globals.Lock);
 try
  POCAGarbageCollectorBottleneck(Instance);
 finally
  POCALockLeave(Instance^.Globals.Lock);
 end;
end;

procedure POCAGarbageCollectorLock(Context:PPOCAContext); {$ifdef UseRegister}register;{$endif}
var Instance:PPOCAInstance;
begin
 Instance:=Context^.Instance;
 POCALockEnter(Instance^.Globals.Lock);
 try
  TPasMPInterlocked.Increment(Instance^.Globals.ThreadCount);
  TPasMPInterlocked.Increment(Context^.GarbageCollectorLockCount);
 finally
  POCALockLeave(Instance^.Globals.Lock);
 end;
 POCAGarbageCollectorCheckBottleneck(Instance);
end;

procedure POCAGarbageCollectorUnlock(Context:PPOCAContext); {$ifdef UseRegister}register;{$endif}
var Instance:PPOCAInstance;
begin
 if Context^.GarbageCollectorLockCount>0 then begin
  Instance:=Context^.Instance;
  POCALockEnter(Instance^.Globals.Lock);
  try
   TPasMPInterlocked.Decrement(Context^.GarbageCollectorLockCount);
   TPasMPInterlocked.Decrement(Instance^.Globals.ThreadCount);
   if (Instance^.Globals.WaitCount>0) and (Instance^.Globals.ThreadCount=Instance^.Globals.WaitCount) then begin
    POCASemaphoreUp(Instance^.Globals.Semaphore,1);
   end;
  finally
   POCALockLeave(Instance^.Globals.Lock);
  end;
 end;
end;

procedure POCAGarbageCollectorSwapFree(Instance:PPOCAInstance;Target:PPOCAPointer;Value:TPOCAPointer); {$ifdef UseRegister}register;{$endif}
var Old:TPOCAPointer;
begin
 POCALockEnter(Instance^.Globals.Lock);
 try
  Old:=Target^;
  Target^:=Value;
  if assigned(Old) then begin
   if Instance^.Globals.WaitCount>=(Instance^.Globals.ThreadCount-1) then begin
    FreeMem(Old);
    POCAFreeDead(Instance);
   end else begin
    while Instance^.Globals.DeadCount>=Instance^.Globals.DeadSize do begin
     POCAGarbageCollectorBottleneck(Instance);
    end;
    PPOCAPointerArray(Instance^.Globals.DeadBlocks)^[Instance^.Globals.DeadCount]:=Old;
    inc(Instance^.Globals.DeadCount);
   end;
  end;
 finally
  POCALockLeave(Instance^.Globals.Lock);
 end;
end;

function POCAGarbageCollectorProcessIncrementalCycle(const Instance:PPOCAInstance):Boolean;
begin
 if Instance^.Globals.GarbageCollector.Incremental then begin
  Instance^.Globals.RequestGarbageCollection:=prgcCYCLE;
 end else begin
  Instance^.Globals.RequestGarbageCollection:=prgcFULL;
 end;
 POCAGarbageCollectorDoBottleneck(Instance);
 if Instance^.Globals.GarbageCollector.LastFullCycleCounter<>Instance^.Globals.GarbageCollector.FullCycleCounter then begin
  Instance^.Globals.GarbageCollector.LastFullCycleCounter:=Instance^.Globals.GarbageCollector.FullCycleCounter;
  result:=false;
 end else begin
  result:=true;
 end;
end;

procedure POCAGarbageCollectorProcessFullCycle(const Instance:PPOCAInstance);
begin
 Instance^.Globals.RequestGarbageCollection:=prgcFULL;
 POCAGarbageCollectorDoBottleneck(Instance);
end;

procedure POCATemporarySave(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}
var Obj:PPOCAObject;
begin
 if POCAIsValueObjectAndGetReferencePointer(Value,Obj) then begin
  if (not assigned(Context^.TemporarySavedObjects)) or ((Context^.TemporarySavedObjectCount+1)>=Context^.TemporarySavedObjectSize) then begin
   Context^.TemporarySavedObjectSize:=POCARoundUpToPowerOfTwo((Context^.TemporarySavedObjectCount+1) shl 1);
   if Context^.TemporarySavedObjectSize<16 then begin
    Context^.TemporarySavedObjectSize:=16;
   end;
   ReallocMem(Context^.TemporarySavedObjects,Context^.TemporarySavedObjectSize*sizeof(PPOCAObject));
  end;
  Context^.TemporarySavedObjects^[Context^.TemporarySavedObjectCount]:=Obj;
  inc(Context^.TemporarySavedObjectCount);
 end;
end;

procedure POCAResetTemporarySaves(Context:PPOCAContext); {$ifdef UseRegister}register;{$endif}
begin
 Context^.TemporarySavedObjectCount:=0;
end;

procedure POCAProtect(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}
var GarbageCollector:PPOCAGarbageCollector;
begin
 GarbageCollector:=@Context^.Instance^.Globals.GarbageCollector;
 POCALockEnter(GarbageCollector^.Lock);
 try
  if POCAIsValueObject(Value) then begin
   if GarbageCollector^.ProtectList.Find(POCAGetValueReferencePointer(Value))<0 then begin
    GarbageCollector^.ProtectList.Add(POCAGetValueReferencePointer(Value));
    case GarbageCollector^.State of
     pgcsMARKGREYS:begin
      GarbageCollector^.State:=pgcsMARKPROTECTED;
     end;
     pgcsINIT,pgcsMARKROOTS,pgcsMARKPROTECTED:begin
     end;
     else begin
      GarbageCollector^.State:=pgcsINIT;
     end;
    end;
   end;
  end;
 finally
  POCALockLeave(GarbageCollector^.Lock);
 end;
end;

procedure POCAUnprotect(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}
var GarbageCollector:PPOCAGarbageCollector;
begin
 GarbageCollector:=@Context^.Instance^.Globals.GarbageCollector;
 POCALockEnter(GarbageCollector^.Lock);
 try
  if POCAIsValueObject(Value) then begin
   GarbageCollector^.ProtectList.Remove(POCAGetValueReferencePointer(Value));
  end;
 finally
  POCALockLeave(GarbageCollector^.Lock);
 end;
end;

function POCAConvertEvent(Context:PPOCAContext;const Value:TPOCAValue;const Operation:TPOCAMetaOp;var ResultValue:TPOCAValue):boolean;
var HashEvents:PPOCAHashEvents;
    SubContext:PPOCAContext;
begin
 HashEvents:=POCAHashGetHashEvents(Value,Operation);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[Operation]) then begin
  SubContext:=POCAContextSub(Context);
  try
   ResultValue:=POCACall(SubContext,HashEvents^[Operation],@Value,1,POCAValueNull,POCAValueNull);
   result:=true;
  finally
   POCAContextDestroy(SubContext);
  end;
 end else begin
  result:=false;
 end;
end;

function POCAConvertToNumberEvent(Context:PPOCAContext;const Value:TPOCAValue;var ResultValue:double):boolean;
var HashEvents:PPOCAHashEvents;
    SubContext:PPOCAContext;
    v:TPOCAValue;
begin
 result:=false;
 HashEvents:=POCAHashGetHashEvents(Value,pmoTONUMBER);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[pmoTONUMBER]) then begin
  SubContext:=POCAContextSub(Context);
  try
   v:=POCACall(SubContext,HashEvents^[pmoTONUMBER],@Value,1,POCAValueNull,POCAValueNull);
   if POCAIsValueNumber(v) then begin
    ResultValue:=v.Num;
    result:=true;
   end;
  finally
   POCAContextDestroy(SubContext);
  end;
 end;
end;

function POCAConvertToStringEvent(Context:PPOCAContext;const Value:TPOCAValue;var ResultValue:TPOCARawByteString):boolean;
var HashEvents:PPOCAHashEvents;
    SubContext:PPOCAContext;
    v:TPOCAValue;
begin
 result:=false;
 HashEvents:=POCAHashGetHashEvents(Value,pmoTOSTRING);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[pmoTOSTRING]) then begin
  SubContext:=POCAContextSub(Context);
  try
   v:=POCACall(SubContext,HashEvents^[pmoTOSTRING],@Value,1,POCAValueNull,POCAValueNull);
   if POCAIsValueString(v) then begin
    ResultValue:=PPOCAString(POCAGetValueReferencePointer(v))^.Data;
    result:=true;
   end;
  finally
   POCAContextDestroy(SubContext);
  end;
 end;
end;

function POCATypeOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=Context^.Instance.Globals.NullValueReference;
  end;
  pvtREFERENCE:begin
   result:=Context^.Instance.Globals.ReferenceValueReference;
  end;
  pvtNUMBER:begin
   result:=Context^.Instance.Globals.NumberValueReference;
  end;
  pvtSTRING:begin
   result:=Context^.Instance.Globals.StringValueReference;
  end;
  pvtARRAY:begin
   result:=Context^.Instance.Globals.ArrayValueReference;
  end;
  pvtHASH:begin
   case POCAHashGetKind(Value) of
    phkCLASS:begin
     if assigned(POCAHashGetGhost(Value)) then begin
      result:=Context^.Instance.Globals.GhostClassValueReference;
     end else begin
      result:=Context^.Instance.Globals.ClassValueReference;
     end;
    end;
    phkMODULE:begin
     if assigned(POCAHashGetGhost(Value)) then begin
      result:=Context^.Instance.Globals.GhostModuleValueReference;
     end else begin
      result:=Context^.Instance.Globals.ModuleValueReference;
     end;
    end;
    else begin
     if assigned(POCAHashGetGhost(Value)) then begin
      result:=Context^.Instance.Globals.GhostHashValueReference;
     end else begin
      result:=Context^.Instance.Globals.HashValueReference;
     end;
    end;
   end;
  end;
  pvtFUNCTION:begin
   result:=Context^.Instance.Globals.FunctionValueReference;
  end;
  pvtGHOST:begin
   if assigned(POCAGhostGetHash(Value)) then begin
    case POCAGhostGetHash(Value)^.Kind of
     phkCLASS:begin
      result:=Context^.Instance.Globals.ClassGhostValueReference;
     end;
     phkMODULE:begin
      result:=Context^.Instance.Globals.ModuleGhostValueReference;
     end;
     else begin
      result:=Context^.Instance.Globals.HashGhostValueReference;
     end;
    end;
   end else begin
    result:=Context^.Instance.Globals.GhostValueReference;
   end;
  end;
  pvtCODE:begin
   result:=Context^.Instance.Globals.CodeValueReference;
  end;
  pvtNATIVECODE:begin
   result:=Context^.Instance.Globals.NativeCodeValueReference;
  end;
  else begin
   result:=Context^.Instance.Globals.UnknownValueReference;
  end;
 end;
end;

function POCAIDOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;
var s:TPOCARawByteString;
    Ghost:PPOCAGhost;
begin
 if not POCAIsValueReference(Value) then begin
  POCARuntimeError(Context,'Bad arguments to "idof"');
  //result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end else begin
  case POCAGetValueType(Value) of
   pvtNULL:begin
    s:='null';
   end;
   pvtREFERENCE:begin
    s:='reference';
   end;
   pvtNUMBER:begin
    s:='number';
   end;
   pvtSTRING:begin
    s:='string';
   end;
   pvtARRAY:begin
    s:='array';
   end;
   pvtHASH:begin
    case POCAHashGetKind(Value) of
     phkCLASS:begin
      if assigned(POCAHashGetGhost(Value)) then begin
       s:='ghostclass';
      end else begin
       s:='class';
      end;
     end;
     phkMODULE:begin
      if assigned(POCAHashGetGhost(Value)) then begin
       s:='ghostmodule';
      end else begin
       s:='module';
      end;
     end;
     else begin
      if assigned(POCAHashGetGhost(Value)) then begin
       s:='ghosthash';
      end else begin
       s:='hash';
      end;
     end;
    end;
   end;
   pvtFUNCTION:begin
    s:='function';
   end;
   pvtGHOST:begin
    if assigned(POCAGhostGetHash(Value)) then begin
     case POCAGhostGetHash(Value)^.Kind of
      phkCLASS:begin
       s:='classghost';
      end;
      phkMODULE:begin
       s:='moduleghost';
      end;
      else begin
       s:='hashghost';
      end;
     end;
    end else begin
     s:='ghost';
    end;
    Ghost:=PPOCAGhost(POCAGetValueReferencePointer(Value));
    if length(Ghost^.GhostType^.Name)>0 then begin
     s:=s+'('+Ghost^.GhostType^.Name+')';
    end else begin
     s:=s+'('+TPOCARawByteString(IntToHex(TPOCAPtrUInt(Ghost^.GhostType),{$ifdef cpu64}16{$else}8{$endif}))+')';
    end;
   end;
   pvtCODE:begin
    s:='code';
   end;
   pvtNATIVECODE:begin
    s:='nativecode';
   end;
   else begin
    s:='unknown';
   end;
  end;
  result:=POCANewString(Context,s+':0x'+TPOCARawByteString(IntToHex(TPOCAPtrUInt(POCAGetValueReferencePointer(Value)),{$ifdef cpu64}16{$else}8{$endif})));
 end;
end;

function POCAGhostTypeOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;
var Ghost:PPOCAGhost;
begin
 if POCAIsValueGhost(Value) then begin
  Ghost:=PPOCAGhost(POCAGetValueReferencePointer(Value));
  if length(Ghost^.GhostType^.Name)>0 then begin
   result:=POCANewString(Context,Ghost^.GhostType^.Name);
  end else begin
   result:=POCANewString(Context,'0x'+TPOCARawByteString(IntToHex(TPOCAPtrUInt(Ghost^.GhostType),{$ifdef cpu64}16{$else}8{$endif})));
  end;
 end else begin
  //result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAObject(Instance:PPOCAInstance;ValueType:TPOCAInt32;Obj:PPOCAObject):TPOCAValue;
begin
 POCASetValueReferencePointer(result,Obj);
 if assigned(Obj) then begin
  Obj^.Header.ValueType:=ValueType;
{$ifndef POCAGarbageCollectorPoolBlockInstance}
  Obj^.Header.Instance:=Instance;
{$endif}  
 end;
end;

function POCAIsValueTrue(Context:PPOCAContext;const Value:TPOCAValue):boolean; {$ifdef UseRegister}register;{$endif}
var Num:double;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=false;
  end;
  pvtNUMBER:begin
   result:=Value.Num<>0;
  end;
  pvtSTRING:begin
   result:=true;
  end;
  else begin
   Num:=0;
   if POCAConvertToNumberEvent(Context,Value,Num) then begin
    result:=Num<>0;
   end else begin
    result:=false;
   end;
  end;
 end;
end;

function POCABooleanValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
var Num:double;
    OK:TPasDblStrUtilsBoolean;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
// result:=POCAValueNull;
   result.Num:=0;
  end;
  pvtNUMBER:begin
   result.Num:=ord(Value.Num<>0) and 1;
  end;
  pvtSTRING:begin
   if length(PPOCAString(POCAGetValueReferencePointer(Value))^.Data)=0 then begin
    result.Num:=0;
   end else begin
    Num:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(Value))^.Data,rmNearest,@OK);
    if OK then begin
     result.Num:=ord(Num<>0) and 1;
    end else begin
     result.Num:=ord(length(PPOCAString(POCAGetValueReferencePointer(Value))^.Data)>0) and 1;
    end;
   end;
  end;
  else begin
   result.Num:=0;
   if not POCAConvertToNumberEvent(Context,Value,result.Num) then begin
    result.Num:=1;
   end;
  end;
 end;
end;

function POCANumberValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
var OK:TPasDblStrUtilsBoolean;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
  pvtNUMBER:begin
   result:=Value;
  end;
  pvtSTRING:begin
   POCASetValueNumber(result,ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(Value))^.Data,rmNearest,@OK));
   if not OK then begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
  else begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
   POCAConvertEvent(Context,Value,pmoTONUMBER,result);
  end;
 end;
end;

function POCAStringValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
  pvtNUMBER:begin
   result:=POCANewString(Context,POCADoubleToString(Value.Num));
  end;
  pvtSTRING:begin
   result:=Value;
  end;
  else begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
   POCAConvertEvent(Context,Value,pmoTOSTRING,result);
  end;
 end;
end;

function POCAGetBooleanValue(Context:PPOCAContext;const Value:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
var Num:double;
    OK:TPasDblStrUtilsBoolean;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=false;
  end;
  pvtNUMBER:begin
   result:=Value.Num<>0;
  end;
  pvtSTRING:begin
   if length(PPOCAString(POCAGetValueReferencePointer(Value))^.Data)=0 then begin
    result:=false;
   end else begin
    Num:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(Value))^.Data,rmNearest,@OK);
    if OK then begin
     result:=Num<>0;
    end else begin
     result:=length(PPOCAString(POCAGetValueReferencePointer(Value))^.Data)>0;
    end;
   end;
  end;
  else begin
   Num:=0;
   if POCAConvertToNumberEvent(Context,Value,Num) then begin
    result:=Num<>0;
   end else begin
    result:=true;
   end;
  end;
 end;
end;

function POCAGetNumberValue(Context:PPOCAContext;const Value:TPOCAValue):double; {$ifdef caninline}inline;{$endif}
const NAN=0/0;
var OK:TPasDblStrUtilsBoolean;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=0;
  end;
  pvtNUMBER:begin
   result:=Value.Num;
  end;
  pvtSTRING:begin
   result:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(Value))^.Data,rmNearest,@OK);
   if not OK then begin
    result:=NAN;
   end;
  end;
  else begin
   result:=1;
   POCAConvertToNumberEvent(Context,Value,result);
  end;
 end;
end;

function POCAGetStringValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCARawByteString; {$ifdef caninline}inline;{$endif}
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:='';
  end;
  pvtNUMBER:begin
   result:=POCADoubleToString(Value.Num);
  end;
  pvtSTRING:begin
   result:=PPOCAString(POCAGetValueReferencePointer(Value))^.Data;
  end;
  else begin
   result:='';
   POCAConvertToStringEvent(Context,Value,result);
  end;
 end;
end;

function POCAGetVariantValue(Context:PPOCAContext;const Value:TPOCAValue):Variant; {$ifdef caninline}inline;{$endif}
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=Variants.Null;
  end;
  pvtNUMBER:begin
   result:=Value.Num;
  end;
  pvtSTRING:begin
   result:=PPOCAString(POCAGetValueReferencePointer(Value))^.Data;
  end;
  else begin
   result:=Variants.Null;
  end;
 end;
end;

function POCAIsStringUTF8(Context:PPOCAContext;const Value:TPOCAValue):boolean;
var s:TPOCARawByteString;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=false;
  end;
  pvtNUMBER:begin
   result:=false;
  end;
  pvtSTRING:begin
   result:=(PPOCAString(POCAGetValueReferencePointer(Value))^.UTF8=suISUTF8) or ((PPOCAString(POCAGetValueReferencePointer(Value))^.UTF8=suPOSSIBLEUTF8) and PUCUIsUTF8(PPOCAString(POCAGetValueReferencePointer(Value))^.Data));
  end;
  else begin
   s:='';
   POCAConvertToStringEvent(Context,Value,s);
   result:=PUCUIsUTF8(s);
  end;
 end;
end;

function POCAGetStringUTF8(Context:PPOCAContext;const Value:TPOCAValue):TPOCAInt32;
var s:TPOCARawByteString;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=suNOUTF8;
  end;
  pvtNUMBER:begin
   result:=suNOUTF8;
  end;
  pvtSTRING:begin
   result:=PPOCAString(POCAGetValueReferencePointer(Value))^.UTF8;
  end;
  else begin
   s:='';
   POCAConvertToStringEvent(Context,Value,s);
   result:=PUCUUTF8Get(s);
  end;
 end;
end;

function POCAGetStringUTF8Length(Context:PPOCAContext;const Value:TPOCAValue):TPOCAInt32;
var s:TPOCARawByteString;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=0;
  end;
  pvtNUMBER:begin
   result:=0;
  end;
  pvtSTRING:begin
   if PPOCAString(POCAGetValueReferencePointer(Value))^.UTF8=suISUTF8 then begin
    result:=PPOCAString(POCAGetValueReferencePointer(Value))^.UTF8Length;
   end else begin
    result:=PPOCAString(POCAGetValueReferencePointer(Value))^.DataLength;
   end;
  end;
  else begin
   s:='';
   POCAConvertToStringEvent(Context,Value,s);
   if PUCUIsUTF8(s) then begin
    result:=PUCUUTF8Length(s);
   end else begin
    result:=length(s);
   end;
  end;
 end;
end;

{$if defined(POCAMemoryPools)}
procedure POCAGarbageCollectorContextAllocate(Context:PPOCAContext;ValueType:TPOCAInt32);
var Instance:PPOCAInstance;
    GarbageCollector:PPOCAGarbageCollector;
    ContextObjectPool:PPOCAContextObjectPool;
    Pool:PPOCAPool;
    LocalContextPoolSize,Count,Need:TPOCAInt32;
    DoFull:Boolean;
begin

 Instance:=Context^.Instance;

 GarbageCollector:=@Instance^.Globals.GarbageCollector;

 POCAGarbageCollectorCheckBottleneck(Instance);

 POCALockEnter(Instance^.Globals.Lock);
 try

  LocalContextPoolSize:=GarbageCollector^.LocalContextPoolSize;

  ContextObjectPool:=@Context^.ContextObjectPools[ValueType];

  Pool:=@Instance^.Globals.Pools[ValueType];
  if ContextObjectPool^.Size<LocalContextPoolSize then begin
   ContextObjectPool^.Size:=LocalContextPoolSize;
   ReallocMem(ContextObjectPool^.Objects,ContextObjectPool^.Size*SizeOf(PPOCAObject));
  end;

  Need:=LocalContextPoolSize-ContextObjectPool^.Count;
  if Need>0 then begin

   if GarbageCollector^.IncrementalCollectionThresholdFactor>0 then begin
    if GarbageCollector^.DynamicThreshold then begin
     TPasMPInterlocked.Add(GarbageCollector^.AllocationCounter,Need);
     Count:=(POCAGarbageCollectorUsed(Instance)*GarbageCollector^.IncrementalCollectionThresholdFactor) shr 8;
     if Count<1024 then begin
      Count:=1024;
     end else if Count>=GarbageCollector^.Allocated then begin
      Count:=GarbageCollector^.Allocated;
     end;
     if GarbageCollector^.AllocationCounter>=Count then begin
      TPasMPInterlocked.Exchange(GarbageCollector^.AllocationCounter,0);
      Instance^.Globals.RequestGarbageCollection:=prgcCYCLE;
      POCAGarbageCollectorBottleneck(Instance);
     end;
    end else begin
     if TPasMPInterlocked.Sub(GarbageCollector^.AllocationCounter,Need)<=0 then begin
      Count:=(POCAGarbageCollectorUsed(Instance)*GarbageCollector^.IncrementalCollectionThresholdFactor) shr 8;
      if Count<1024 then begin
       Count:=1024;
      end;
      TPasMPInterlocked.Exchange(GarbageCollector^.AllocationCounter,Count);
      Instance^.Globals.RequestGarbageCollection:=prgcCYCLE;
      POCAGarbageCollectorBottleneck(Instance);
     end;
    end;
   end;

   if GarbageCollector^.FullCollectionThresholdFactor>0 then begin
    if GarbageCollector^.DynamicThreshold then begin
     TPasMPInterlocked.Add(GarbageCollector^.FullAllocationCounter,Need);
     Count:=(POCAGarbageCollectorUsed(Instance)*GarbageCollector^.FullCollectionThresholdFactor) shr 8;
     if Count<1024 then begin
      Count:=1024;
     end else if Count>=GarbageCollector^.Allocated then begin
      Count:=GarbageCollector^.Allocated;
     end;
     if GarbageCollector^.FullAllocationCounter>=Count then begin
      TPasMPInterlocked.Exchange(GarbageCollector^.FullAllocationCounter,0);
      Instance^.Globals.RequestGarbageCollection:=prgcFULL;
      POCAGarbageCollectorBottleneck(Instance);
     end;
    end else begin
     if TPasMPInterlocked.Sub(GarbageCollector^.FullAllocationCounter,Need)<=0 then begin
      Count:=(POCAGarbageCollectorUsed(Instance)*GarbageCollector^.FullCollectionThresholdFactor) shr 8;
      if Count<1024 then begin
       Count:=1024;
      end;
      TPasMPInterlocked.Exchange(GarbageCollector^.FullAllocationCounter,Count);
      Instance^.Globals.RequestGarbageCollection:=prgcFULL;
      POCAGarbageCollectorBottleneck(Instance);
     end;
    end;
   end;

  end;

  while ContextObjectPool^.Count<LocalContextPoolSize do begin

   if Pool^.FreeCount=0 then begin

    if GarbageCollector^.ExhaustionCollect then begin

     if GarbageCollector^.Incremental then begin
      DoFull:=false;
      if GarbageCollector^.ExhaustionIncrementalFullCycleThreshold>0 then begin
       TPasMPInterlocked.Increment(GarbageCollector^.ExhaustionIncrementalFullCycleCounter);
       if GarbageCollector^.ExhaustionIncrementalFullCycleCounter>=GarbageCollector^.ExhaustionIncrementalFullCycleThreshold then begin
        TPasMPInterlocked.Write(GarbageCollector^.ExhaustionIncrementalFullCycleCounter,0);
        DoFull:=true;
       end;
      end else if GarbageCollector^.ExhaustionIncrementalFullCycleThreshold<0 then begin
       DoFull:=true;
      end;
     end else begin
      DoFull:=true;
     end;

     if DoFull then begin
      if GarbageCollector^.Generational then begin
       Instance^.Globals.RequestGarbageCollection:=prgcFULLEPHEMERAL;
       POCAGarbageCollectorBottleneck(Instance);
       if Pool^.FreeCount=0 then begin
        Instance^.Globals.RequestGarbageCollection:=prgcFULL;
        POCAGarbageCollectorBottleneck(Instance);
       end;
      end else begin
       Instance^.Globals.RequestGarbageCollection:=prgcFULL;
       POCAGarbageCollectorBottleneck(Instance);
      end;
     end else begin
      Instance^.Globals.RequestGarbageCollection:=prgcCYCLE;
      POCAGarbageCollectorBottleneck(Instance);
     end;

    end;

    if Pool^.FreeCount=0 then begin
     POCAPoolNewBlock(Pool,Pool^.Size shr 3);
    end;

   end;

   dec(Pool^.FreeCount);

   ContextObjectPool^.Objects^[ContextObjectPool^.Count]:=Pool^.FreeObjects^[Pool^.FreeCount];

   inc(ContextObjectPool^.Count);

  end;

 finally
  POCALockLeave(Instance^.Globals.Lock);
 end;

end;
{$ifend}

function POCANew(Context:PPOCAContext;ValueType:TPOCAInt32;var Obj:PPOCAObject):TPOCAValue;
var Instance:PPOCAInstance;
    GarbageCollector:PPOCAGarbageCollector;
{$ifdef POCAMemoryPools}
    ContextObjectPool:PPOCAContextObjectPool;
{$else}
    Count:TPOCAInt32;
{$endif}
begin

 Instance:=Context^.Instance;

 GarbageCollector:=@Instance^.Globals.GarbageCollector;

{$ifdef POCAMemoryPools}

 ContextObjectPool:=@Context^.ContextObjectPools[ValueType];

 if ContextObjectPool^.Count=0 then begin
  POCAGarbageCollectorContextAllocate(Context,ValueType);
 end;

 dec(ContextObjectPool^.Count);

 Obj:=ContextObjectPool^.Objects^[ContextObjectPool^.Count];

{$else}

 if GarbageCollector^.IncrementalCollectionThresholdFactor>0 then begin
  if GarbageCollector^.DynamicThreshold then begin
   TPasMPInterlocked.Increment(GarbageCollector^.AllocationCounter);
   Count:=(POCAGarbageCollectorUsed(Instance)*GarbageCollector^.IncrementalCollectionThresholdFactor) shr 8;
   if Count<1024 then begin
    Count:=1024;
   end else if Count>=GarbageCollector^.Allocated then begin
    Count:=GarbageCollector^.Allocated;
   end;
   if GarbageCollector^.AllocationCounter>=Count then begin
    TPasMPInterlocked.Exchange(GarbageCollector^.AllocationCounter,0);
    Instance^.Globals.RequestGarbageCollection:=prgcCYCLE;
    POCAGarbageCollectorBottleneck(Instance);
   end;
  end else begin
   if TPasMPInterlocked.Decrement(GarbageCollector^.AllocationCounter)<=0 then begin
    Count:=(POCAGarbageCollectorUsed(Instance)*GarbageCollector^.IncrementalCollectionThresholdFactor) shr 8;
    if Count<1024 then begin
     Count:=1024;
    end;
    TPasMPInterlocked.Exchange(GarbageCollector^.AllocationCounter,Count);
    Instance^.Globals.RequestGarbageCollection:=prgcCYCLE;
    POCAGarbageCollectorBottleneck(Instance);
   end;
  end;
 end;

 if GarbageCollector^.FullCollectionThresholdFactor>0 then begin
  if GarbageCollector^.DynamicThreshold then begin
   TPasMPInterlocked.Increment(GarbageCollector^.FullAllocationCounter);
   Count:=(POCAGarbageCollectorUsed(Instance)*GarbageCollector^.FullCollectionThresholdFactor) shr 8;
   if Count<1024 then begin
    Count:=1024;
   end else if Count>=GarbageCollector^.Allocated then begin
    Count:=GarbageCollector^.Allocated;
   end;
   if GarbageCollector^.FullAllocationCounter>=Count then begin
    TPasMPInterlocked.Exchange(GarbageCollector^.FullAllocationCounter,0);
    Instance^.Globals.RequestGarbageCollection:=prgcFULL;
    POCAGarbageCollectorBottleneck(Instance);
   end;
  end else begin
   if TPasMPInterlocked.Decrement(GarbageCollector^.FullAllocationCounter)<=0 then begin
    Count:=(POCAGarbageCollectorUsed(Instance)*GarbageCollector^.FullCollectionThresholdFactor) shr 8;
    if Count<1024 then begin
     Count:=1024;
    end;
    TPasMPInterlocked.Exchange(GarbageCollector^.FullAllocationCounter,Count);
    Instance^.Globals.RequestGarbageCollection:=prgcFULL;
    POCAGarbageCollectorBottleneck(Instance);
   end;
  end;
 end;

 GetMem(Obj,POCARoundUpToMask(POCATypeSizes[ValueType],16));
 FillChar(Obj^,POCATypeSizes[ValueType],#0);
 Obj^.Header.GarbageCollector.LinkedList.List:=nil;
 Obj^.Header.GarbageCollector.LinkedList.Next:=nil;
 Obj^.Header.GarbageCollector.LinkedList.Previous:=nil;
 Obj^.Header.GarbageCollector.State:=0;
 Obj^.Header.Instance:=Context^.Instance;
 Obj^.Header.ValueType:=ValueType;

{$endif}

 TPasMPInterlocked.Write(GarbageCollector^.ScanContextGrays,TPasMPBool32(true));

 Context^.GrayList.Push(Obj);
 Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbGRAY;

{$ifdef POCAMemoryPools}
 TPasMPInterlocked.Decrement(GarbageCollector^.FreeCount);
{$else}
 TPasMPInterlocked.Increment(GarbageCollector^.Allocated);
{$endif}

{$ifdef POCAGarbageCollectorPoolBlockReferenceCounting}
 TPasMPInterlocked.Increment(Obj^.Header.PoolBlock^.ReferenceCounter);
{$endif}

 POCASetValueReferencePointer(result,Obj);

 POCATemporarySave(Context,result);

end;

function POCAStringUTF8GetCodeUnit(Context:PPOCAContext;const Value:TPOCAValue;CodePoint:TPOCAInt32):TPOCAInt32;
var Str:PPOCAString;
begin
 if POCAIsValueString(Value) then begin
  Str:=POCAGetValueReferencePointer(Value);
  if Str^.UTF8=suISUTF8 then begin
   result:=0;
   if (CodePoint>=0) and (CodePoint<Str^.UTF8Length) then begin
    if assigned(Str^.UTF8CodePointsToCodeUnitsIndex) then begin
     case Str^.UTF8CodePointsToCodeUnitsIndexSize of
      1:begin
       result:=TPOCAUInt8(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodePointsToCodeUnitsIndex)^[CodePoint])^);
      end;
      2:begin
       result:=TPOCAUInt16(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodePointsToCodeUnitsIndex)^[CodePoint shl 1])^);
      end;
      4:begin
       result:=TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodePointsToCodeUnitsIndex)^[CodePoint shl 2])^);
      end;
     end;
    end else begin
     result:=PUCUUTF8GetCodeUnit(Str^.Data,CodePoint);
    end;
   end else begin
    if CodePoint<0 then begin
     result:=0;
    end else begin
     result:=Str^.DataLength+1;
    end;
   end;
  end else begin
   result:=CodePoint+1;
  end;
 end else begin
  result:=0;
 end;
end;

function POCAStringUTF8GetCodePoint(Context:PPOCAContext;const Value:TPOCAValue;CodeUnit:TPOCAInt32):TPOCAInt32;
var Str:PPOCAString;
begin
 if POCAIsValueString(Value) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(Value));
  if Str^.UTF8=suISUTF8 then begin
   result:=-1;
   if (CodeUnit>0) and (CodeUnit<=Str^.DataLength) then begin
    if assigned(Str^.UTF8CodeUnitsToCodePointsIndex) then begin
     case Str^.UTF8CodeUnitsToCodePointsIndexSize of
      1:begin
       result:=TPOCAUInt8(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodeUnitsToCodePointsIndex)^[CodeUnit])^);
      end;
      2:begin
       result:=TPOCAUInt16(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodeUnitsToCodePointsIndex)^[CodeUnit shl 1])^);
      end;
      4:begin
       result:=TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodeUnitsToCodePointsIndex)^[CodeUnit shl 2])^);
      end;
     end;
    end else begin
     result:=PUCUUTF8GetCodePoint(Str^.Data,CodeUnit);
    end;
   end else begin
    if CodeUnit<0 then begin
     result:=-1;
    end else begin
     result:=Str^.UTF8Length;
    end;
   end;
  end else begin
   result:=CodeUnit-1;
  end;
 end else begin
  result:=-1;
 end;
end;

function POCAStringUTF8CopyCodePointRange(Context:PPOCAContext;const Value:TPOCAValue;FromCodePoint,ToCodePoint:TPOCAInt32):TPOCARawByteString;
var Str:PPOCAString;
    FromCodeUnit,ToCodeUnit:TPOCAInt32;
begin
 if ((FromCodePoint>=0) and (ToCodePoint>=FromCodePoint)) and POCAIsValueString(Value) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(Value));
  if Str^.UTF8=suISUTF8 then begin
   FromCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Value,FromCodePoint);
   ToCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Value,ToCodePoint+1);
  end else begin
   FromCodeUnit:=FromCodePoint+1;
   ToCodeUnit:=ToCodePoint+2;
  end;
  if (FromCodeUnit>0) and (ToCodeUnit>=FromCodeUnit) then begin
   result:=System.Copy(Str^.Data,FromCodeUnit,ToCodeUnit-FromCodeUnit);
  end else begin
   result:='';
  end;
 end else begin
  result:='';
 end;
end;

procedure POCAStringUpdate(Context:PPOCAContext;const Value:TPOCAValue);
var Str:PPOCAString;
    s:TPOCARawByteString;
    UTF8State:TPOCAUInt32;
    UTF8CodeUnit,UTF8CodePoint:TPOCAInt32;
begin
 if POCAIsValueString(Value) then begin
  Str:=POCAGetValueReferencePointer(Value);
  if Str^.Dirty then begin
   if assigned(Str^.UTF8CodePointsToCodeUnitsIndex) then begin
    FreeMem(Str^.UTF8CodePointsToCodeUnitsIndex);
    Str^.UTF8CodePointsToCodeUnitsIndex:=nil;
   end;
   if assigned(Str^.UTF8CodePointsToCodeUnitsIndex) then begin
    FreeMem(Str^.UTF8CodeUnitsToCodePointsIndex);
    Str^.UTF8CodeUnitsToCodePointsIndex:=nil;
   end;
{$ifdef pocastrictutf8}
   UTF8CodePoint:=0;
   while true do {$endif}begin
    s:=Str^.Data;
    Str^.DataLength:=length(s);
    UTF8State:=ucACCEPT;
    UTF8CodePoint:=0;
    for UTF8CodeUnit:=1 to length(s) do begin
     UTF8State:=PUCUUTF8DFATransitions[UTF8State+PUCUUTF8DFACharClasses[s[UTF8CodeUnit]]];
     case UTF8State of
      ucACCEPT:begin
       inc(UTF8CodePoint);
      end;
      ucERROR:begin
       break;
      end;
     end;
    end;
    if UTF8State=ucACCEPT then begin
     if length(s)<>UTF8CodePoint then begin
      Str^.UTF8:=suISUTF8;
     end else begin
      Str^.UTF8:=suPOSSIBLEUTF8;
     end;
    end else begin
{$ifdef pocastrictutf8}
     Str^.UTF8:=suISUTF8;
     Str^.Data:=PUCUUTF8Correct(Str^.Data);
     continue;
{$else}
     Str^.UTF8:=suNOUTF8;
{$endif}
    end;
{$ifdef pocastrictutf8}
    break;
{$endif}
   end;
   if Str^.UTF8=suISUTF8 then begin
    Str^.UTF8Length:=UTF8CodePoint;
    if Str^.DataLength<256 then begin
     Str^.UTF8CodePointsToCodeUnitsIndexSize:=1;
    end else if Str^.DataLength<65536 then begin
     Str^.UTF8CodePointsToCodeUnitsIndexSize:=2;
    end else begin
     Str^.UTF8CodePointsToCodeUnitsIndexSize:=4;
    end;
    if Str^.UTF8Length<256 then begin
     Str^.UTF8CodeUnitsToCodePointsIndexSize:=1;
    end else if Str^.UTF8Length<65536 then begin
     Str^.UTF8CodeUnitsToCodePointsIndexSize:=2;
    end else begin
     Str^.UTF8CodeUnitsToCodePointsIndexSize:=4;
    end;
    GetMem(Str^.UTF8CodePointsToCodeUnitsIndex,(Str^.UTF8Length+1)*Str^.UTF8CodePointsToCodeUnitsIndexSize);
    GetMem(Str^.UTF8CodeUnitsToCodePointsIndex,(Str^.DataLength+1)*Str^.UTF8CodeUnitsToCodePointsIndexSize);
    FillChar(Str^.UTF8CodePointsToCodeUnitsIndex^,(Str^.UTF8Length+1)*Str^.UTF8CodePointsToCodeUnitsIndexSize,#0);
    FillChar(Str^.UTF8CodeUnitsToCodePointsIndex^,(Str^.DataLength+1)*Str^.UTF8CodeUnitsToCodePointsIndexSize,#0);
    UTF8CodePoint:=0;
    UTF8CodeUnit:=1;
    while UTF8CodeUnit<=Str^.DataLength do begin
     case Str^.UTF8CodePointsToCodeUnitsIndexSize of
      1:begin
       TPOCAUInt8(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodePointsToCodeUnitsIndex)^[UTF8CodePoint])^):=UTF8CodeUnit;
      end;
      2:begin
       TPOCAUInt16(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodePointsToCodeUnitsIndex)^[UTF8CodePoint shl 1])^):=UTF8CodeUnit;
      end;
      4:begin
       TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodePointsToCodeUnitsIndex)^[UTF8CodePoint shl 2])^):=UTF8CodeUnit;
      end;
     end;
     case Str^.UTF8CodeUnitsToCodePointsIndexSize of
      1:begin
       TPOCAUInt8(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodeUnitsToCodePointsIndex)^[(UTF8CodeUnit-1)])^):=UTF8CodePoint;
      end;
      2:begin
       TPOCAUInt16(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodeUnitsToCodePointsIndex)^[(UTF8CodeUnit-1) shl 1])^):=UTF8CodePoint;
      end;
      4:begin
       TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodeUnitsToCodePointsIndex)^[(UTF8CodeUnit-1) shl 2])^):=UTF8CodePoint;
      end;
     end;
     inc(UTF8CodeUnit,PUCUUTF8CharSteps[Str^.Data[UTF8CodeUnit]]);
     inc(UTF8CodePoint);
    end;
    begin
     case Str^.UTF8CodePointsToCodeUnitsIndexSize of
      1:begin
       TPOCAUInt8(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodePointsToCodeUnitsIndex)^[UTF8CodePoint])^):=UTF8CodeUnit;
      end;
      2:begin
       TPOCAUInt16(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodePointsToCodeUnitsIndex)^[UTF8CodePoint shl 1])^):=UTF8CodeUnit;
      end;
      4:begin
       TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodePointsToCodeUnitsIndex)^[UTF8CodePoint shl 2])^):=UTF8CodeUnit;
      end;
     end;
     case Str^.UTF8CodeUnitsToCodePointsIndexSize of
      1:begin
       TPOCAUInt8(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodeUnitsToCodePointsIndex)^[(UTF8CodeUnit-1)])^):=UTF8CodePoint;
      end;
      2:begin
       TPOCAUInt16(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodeUnitsToCodePointsIndex)^[(UTF8CodeUnit-1) shl 1])^):=UTF8CodePoint;
      end;
      4:begin
       TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(Str^.UTF8CodeUnitsToCodePointsIndex)^[(UTF8CodeUnit-1) shl 2])^):=UTF8CodePoint;
      end;
     end;
    end;
   end else begin
    Str^.UTF8Length:=Str^.DataLength;
   end;
   Str^.Dirty:=false;
  end;
 end;
end;

function POCANewNumber(Context:PPOCAContext;const Data:double=0.0):TPOCAValue;
begin
 result.Num:=Data;
end;

function POCANewString(Context:PPOCAContext;const Data:TPOCARawByteString=''):TPOCAValue;
var Str:PPOCAString;
begin
 result:=POCANew(Context,pvtSTRING,PPOCAObject(Str));
//Str:=POCAGetValueReferencePointer(result);
 Str^.Data:=Data;
 Str^.DataLength:=length(Data);
 Str^.HashCode:=POCAHashString(Data);
 Str^.Dirty:=true;
 POCAStringUpdate(Context,result);
end;

function POCANewUniqueString(Context:PPOCAContext;const Data:TPOCARawByteString=''):TPOCAValue;
var Str:PPOCAString;
    Item:PPOCAStringHashMapItem;
    Value:TPOCAInt64;
begin
 POCALockEnter(Context^.Instance^.Globals.UniqueStringLock);
 try
  Item:=Context^.Instance^.Globals.UniqueStringHashMap.GetKey(Data);
  if assigned(Item) then begin
   POCALockLeave(Context^.Instance^.Globals.UniqueStringLock);
   try
    result:=POCAArrayGet(Context^.Instance^.Globals.UniqueStringArray,Item^.Value);
   finally
    POCALockEnter(Context^.Instance^.Globals.UniqueStringLock);
   end;
  end else begin
   POCALockLeave(Context^.Instance^.Globals.UniqueStringLock);
   try
    result:=POCANew(Context,pvtSTRING,PPOCAObject(Str));
//  Str:=POCAGetValueReferencePointer(result);
    Str^.Data:=Data;
    Str^.DataLength:=length(Str^.Data);
    Str^.HashCode:=POCAHashString(Data);
    Str^.Dirty:=true;
    POCAStringUpdate(Context,result);
    Value:=POCAArrayPush(Context^.Instance^.Globals.UniqueStringArray,result);
   finally
    POCALockEnter(Context^.Instance^.Globals.UniqueStringLock);
   end;
   Item:=Context^.Instance^.Globals.UniqueStringHashMap.NewKey(Data);
   Item^.Value:=Value;
  end;
 finally
  POCALockLeave(Context^.Instance^.Globals.UniqueStringLock);
 end;
end;

function POCANewArray(Context:PPOCAContext):TPOCAValue;
var Obj:PPOCAArray;
begin
 result:=POCANew(Context,pvtARRAY,PPOCAObject(Obj));
 Obj^.ArrayRecord:=nil;
end;

function POCANewHash(Context:PPOCAContext):TPOCAValue;
var Hash:PPOCAHash;
begin
 result:=POCANew(Context,pvtHASH,PPOCAObject(Hash));
{Hash^.HashRecord:=nil;
 Hash^.Prototype:=nil;
 Hash^.Constructor_:=nil;
 Hash^.Children.First:=nil;
 Hash^.Children.Last:=nil;
 Hash^.Children.Previous:=nil;
 Hash^.Children.Next:=nil;
 Hash^.Structure:=nil;
 Hash^.Events:=nil;
 Hash^.Ghost:=nil;}
end;

function POCANewCode(Context:PPOCAContext):TPOCAValue;
var Obj:PPOCACode;
begin
 result:=POCANew(Context,pvtCODE,PPOCAObject(Obj));
end;

function POCANewNativeCode(Context:PPOCAContext;const FunctionPointer:TPOCANativeFunction;const DestroyFunctionPointer:TPOCANativeDestroyFunction=nil;const UserData:TPOCAPointer=nil):TPOCAValue;
var Obj:PPOCANativeCode;
begin
 result:=POCANew(Context,pvtNATIVECODE,PPOCAObject(Obj));
 Obj^.FunctionPointer:=FunctionPointer;
 Obj^.DestroyFunctionPointer:=DestroyFunctionPointer;
 Obj^.UserData:=UserData;
end;

function POCANewFunction(Context:PPOCAContext;const Code:TPOCAValue):TPOCAValue;
var Func:PPOCAFunction;
begin
 result:=POCANew(Context,pvtFUNCTION,PPOCAObject(Func));
 Func^.Code:=Code;
 Func^.Namespace.CastedUInt64:=POCAValueNullCastedUInt64;
 Func^.Obj.CastedUInt64:=POCAValueNullCastedUInt64;
{$ifdef POCAClosureArrayValues}
 Func^.ClosureValues.CastedUInt64:=POCAValueNullCastedUInt64;
{$else}
 Func^.ClosureValues:=nil;
{$endif}
 Func^.Next.CastedUInt64:=POCAValueNullCastedUInt64;
end;

function POCANewGhost(Context:PPOCAContext;const GhostType:PPOCAGhostType;const Ptr:TPOCAPointer;const Hash:PPOCAHash=nil;const PtrType:TPOCAGhostPtrType=pgptRAW):TPOCAValue;
var Ghost:PPOCAGhost;
begin
 result:=POCANew(Context,pvtGHOST,PPOCAObject(Ghost));
 Ghost^.GhostType:=GhostType;
 Ghost^.PtrType:=PtrType;
 Ghost^.Ptr:=Ptr;
 Ghost^.Hash:=Hash;
end;

function POCANewNativeObject(Context:PPOCAContext;const NativeObjectValue:TPOCANativeObject):TPOCAValue;
begin
 if assigned(NativeObjectValue) then begin
  result:=NativeObjectValue.GhostValue;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCANewValueFromVariant(Context:PPOCAContext;const VariantValue:Variant):TPOCAValue;
begin
 case VarType(VariantValue) of
  varNull:begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
  varSmallInt,varInteger,varShortInt,varByte,varWord,varLongWord,varInt64{$ifdef fpc},varQWord{$endif}:begin
   result.Num:=VariantValue;
  end;
  varSingle,varDouble,varDATE,varCurrency:begin
   result.Num:=VariantValue;
  end;
  varBoolean:begin
   result.Num:=ord(boolean(VariantValue)) and 1;
  end;
  varString,varOleStr:begin
   result:=POCANewString(Context,TPOCARawByteString(VariantValue));
  end;
  else begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end;
end;

function POCAGhostGetType(const r:TPOCAValue):PPOCAGhostType; {$ifdef caninline}inline;{$endif}
begin
 if POCAIsValueGhost(r) then begin
  result:=PPOCAGhost(POCAGetValueReferencePointer(r))^.GhostType;
 end else begin
  result:=nil;
 end;
end;

function POCAGhostGetPointer(const r:TPOCAValue):TPOCAPointer; {$ifdef caninline}inline;{$endif}
begin
 if POCAIsValueGhost(r) then begin
  result:=PPOCAGhost(POCAGetValueReferencePointer(r))^.Ptr;
 end else begin
  result:=nil;
 end;
end;

function POCAGhostFastGetPointer(const r:TPOCAValue):TPOCAPointer; {$ifdef caninline}inline;{$endif}
begin
 result:=PPOCAGhost(POCAGetValueReferencePointer(r))^.Ptr;
end;

function POCAGhostGetHash(const r:TPOCAValue):PPOCAHash; {$ifdef caninline}inline;{$endif}
begin
 if POCAIsValueGhost(r) then begin
  result:=PPOCAGhost(POCAGetValueReferencePointer(r))^.Hash;
 end else begin
  result:=nil;
 end;
end;

function POCAGhostGetHashValue(const r:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
var p:TPOCAPointer;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if POCAIsValueGhost(r) then begin
  p:=PPOCAGhost(POCAGetValueReferencePointer(r))^.Hash;
  if assigned(p) then begin
   POCASetValueReferencePointer(result,p);
  end;
 end;
end;

function POCAGhostSetHash(const r:TPOCAValue;const h:PPOCAHash):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueGhost(r);
 if result then begin
  PPOCAGhost(POCAGetValueReferencePointer(r))^.Hash:=h;
 end;
end;

function POCAGhostSetHashValue(const r,h:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueGhost(r) and POCAIsValueHash(h);
 if result then begin
  PPOCAGhost(POCAGetValueReferencePointer(r))^.Hash:=PPOCAHash(POCAGetValueReferencePointer(h));
 end;
end;

procedure POCAAtomicSetValue(var Dst:TPOCAValue;const Src:TPOCAValue);
begin
 TPasMPInterlocked.Write(Dst.CastedInt64,Src.CastedInt64);
end;

function POCANil:TPOCAValue; {$ifdef caninline}inline;{$endif}
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
end;

function POCAEndToken:TPOCAValue; {$ifdef caninline}inline;{$endif}
begin
 POCASetValueReferencePointer(result,TPOCAPointer(TPOCAPtrUInt(1)));
end;

function POCANumber(Num:double):TPOCAValue; {$ifdef caninline}inline;{$endif}
begin
 POCASetValueNumber(result,Num);
end;

function POCAString(Context:PPOCAContext;const Str:TPOCARawByteString):TPOCAValue;
begin
 result:=POCANewString(Context,Str);
end;

function POCAEqual(const a,b:TPOCAValue):boolean; overload;
var na,nb:double;
    OK:TPasDblStrUtilsBoolean;
begin
 if ((POCAIsValueNumber(a) and POCAIsValueNumber(b)) and (a.Num=b.Num)) or
    ((POCAIsValueObject(a) and POCAIsValueObject(b)) and (a.Reference.Obj=b.Reference.Obj)) or
    (POCAIsValueNull(a) and POCAIsValueNull(b)) then begin
  result:=true;
 end else if POCAIsValueString(a) and POCAIsValueString(b) then begin
  result:=PPOCAString(POCAGetValueReferencePointer(a))^.Data=PPOCAString(POCAGetValueReferencePointer(b))^.Data;
 end else begin
  case POCAGetValueType(a) of
   pvtNULL:begin
    na:=0;
   end;
   pvtNUMBER:begin
    na:=a.Num;
   end;
   pvtSTRING:begin
    na:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(a))^.Data,rmNearest,@OK);
    if not OK then begin
     result:=false;
     exit;
    end;
   end;
   else begin
    result:=false;
    exit;
   end;
  end;
  case POCAGetValueType(b) of
   pvtNULL:begin
    nb:=0;
   end;
   pvtNUMBER:begin
    nb:=b.Num;
   end;
   pvtSTRING:begin
    nb:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(b))^.Data,rmNearest,@OK);
    if not OK then begin
     result:=false;
     exit;
    end;
   end;
   else begin
    result:=false;
    exit;
   end;
  end;
  result:=na=nb;
 end;
end;

function POCAStrictEqual(const a,b:TPOCAValue):boolean; overload;
var t:TPOCAInt32;
begin
 t:=POCAGetValueType(a);
 if t=POCAGetValueType(b) then begin
  case t of
   pvtNULL:begin
    result:=true;
   end;
   pvtNUMBER:begin
    result:=a.Num=b.Num;
   end;
   pvtSTRING:begin
    result:=PPOCAString(POCAGetValueReferencePointer(a))^.Data=PPOCAString(POCAGetValueReferencePointer(b))^.Data;
   end;
   else begin
    result:=(POCAIsValueObject(a) and POCAIsValueObject(b)) and (a.Reference.Obj=b.Reference.Obj);
   end;
  end;
 end else begin
  result:=false;
 end;
end;

function POCACompareString(const a,b:TPOCARawByteString):TPOCAInt32;
var c1,c2:PAnsiChar;
begin
 result:=0;
 c1:=PAnsiChar(a);
 c2:=PAnsiChar(b);
 if c1<>c2 then begin
  if not assigned(c1) then begin
   if assigned(c2) then begin
    result:=-1;
   end;
  end else begin
   if not assigned(c2) then begin
    result:=1;
   end else begin
    while (result=0) and ((ord(c1^) and ord(c2^))<>0) do begin
     result:=ord(c1^)-ord(c2^);
     inc(c1);
     inc(c2);
    end;
    if (result=0) and (c1^<>c2^) then begin
     if c1^=#0 then begin
      result:=-1;
     end else begin
      result:=1;
     end;
    end else if result<>0 then begin
     if result<0 then begin
      result:=-1;
     end else begin
      result:=1;
     end;
    end;
   end;
  end;
 end;
end;
            
function POCACompareEvent(Context:PPOCAContext;const a,b:TPOCAValue):TPOCAInt32;
var HashEvents:PPOCAHashEvents;
    SubContext:PPOCAContext;
    Values:array[0..1] of TPOCAValue;
begin
 HashEvents:=POCAHashGetHashEvents(a,b,pmoCOMPARE);
 if not assigned(HashEvents) then begin
  POCARuntimeError(Context,'Simple hashs cann''t use for this comparsion operation');
 end;
 if not POCAIsValueFunctionOrNativeCode(HashEvents^[pmoCOMPARE]) then begin
  POCARuntimeError(Context,'No matching hash event for this comparsion operation found');
 end;
 SubContext:=POCAContextSub(Context);
 try
  Values[0]:=a;
  Values[1]:=b;
  result:=trunc(POCAGetNumberValue(SubContext,POCACall(SubContext,HashEvents^[pmoCOMPARE],@Values[0],2,POCAValueNull,POCAValueNull)));
 finally
  POCAContextDestroy(SubContext);
 end;
end;

function POCACompare(Context:PPOCAContext;const a,b:TPOCAValue):TPOCAInt32;
var na,nb:double;
    OK:TPasDblStrUtilsBoolean;
begin
 if POCAIsValueString(a) and POCAIsValueString(b) then begin
  result:=POCACompareString(PPOCAString(POCAGetValueReferencePointer(a))^.Data,PPOCAString(POCAGetValueReferencePointer(b))^.Data);
 end else if ((POCAIsValueNumber(a) and POCAIsValueNumber(b)) and (a.Num=b.Num)) or
             ((POCAIsValueObject(a) and POCAIsValueObject(b)) and (a.Reference.Obj=b.Reference.Obj)) or
             (POCAIsValueNull(a) and POCAIsValueNull(b)) then begin
  result:=0;
 end else begin
  if POCAIsValueEventHash(a) or POCAIsValueEventHash(b) then begin
   result:=POCACompareEvent(Context,a,b);
  end else if POCAIsValueNumber(a) or POCAIsValueNumber(b) then begin
   case POCAGetValueType(a) of
    pvtNULL:begin
     na:=0;
    end;
    pvtNUMBER:begin
     na:=a.Num;
    end;
    pvtSTRING:begin
     na:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(a))^.Data,rmNearest,@OK);
     if not OK then begin
      result:=-1;
      exit;
     end;
    end;
    else begin
     result:=-1;
     exit;
    end;
   end;
   case POCAGetValueType(b) of
    pvtNULL:begin
     nb:=0;
    end;
    pvtNUMBER:begin
     nb:=b.Num;
    end;
    pvtSTRING:begin
     nb:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(b))^.Data,rmNearest,@OK);
     if not OK then begin
      result:=1;
      exit;
     end;
    end;
    else begin
     result:=1;
     exit;
    end;
   end;
   if na=nb then begin
    result:=0;
   end else begin
    if na<nb then begin
     result:=-1;
    end else begin
     result:=1;
    end;
   end;
  end else if POCAIsValueObject(a) and POCAIsValueObject(b) then begin
   if a.Reference.Obj=b.Reference.Obj then begin
    result:=0;
   end else begin
    if TPOCAPtrUInt(POCAGetValueReferencePointer(a))<TPOCAPtrUInt(POCAGetValueReferencePointer(b)) then begin
     result:=-1;
    end else begin
     result:=1;
    end;
   end;
  end else begin
   result:=a.CastedInt64-b.CastedInt64;
   if result<>0 then begin
    if result<0 then begin
     result:=-1;
    end else begin
     result:=1;
    end;
   end;
  end;
 end;
end;

function POCAEqual(const a:TPOCAValue;const s:TPOCARawByteString):boolean; overload;
var na,nb:double;
    OK:TPasDblStrUtilsBoolean;
begin
 if POCAIsValueString(a) and (PPOCAString(POCAGetValueReferencePointer(a))^.Data=s) then begin
  result:=true;
 end else begin
  if POCAIsValueNumber(a) then begin
   na:=a.Num;
  end else begin
   if not POCAIsValueString(a) then begin
    result:=false;
    exit;
   end;
   na:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(a))^.Data,rmNearest,@OK);
   if not OK then begin
    result:=false;
    exit;
   end;
  end;
  nb:=ConvertStringToDouble(s,rmNearest,@OK);
  if not OK then begin
   result:=false;
   exit;
  end;
  result:=na=nb;
 end;
end;

function POCAStrictEqual(const a:TPOCAValue;const s:TPOCARawByteString):boolean; overload;
begin
 result:=POCAIsValueString(a) and (PPOCAString(POCAGetValueReferencePointer(a))^.Data=s);
end;

function POCAStringEqual(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(POCAIsValueString(a) and POCAIsValueString(b)) and (PPOCAString(POCAGetValueReferencePointer(a))^.Data=PPOCAString(POCAGetValueReferencePointer(b))^.Data);
end;

function POCAObjectEqual(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(POCAIsValueObject(a) and POCAIsValueObject(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b));
end;

procedure POCASetUserData(Context:PPOCAContext;p:TPOCAPointer); {$ifdef caninline}inline;{$endif}
begin
 Context^.UserData:=p;
end;

function POCAGetUserData(Context:PPOCAContext):TPOCAPointer; {$ifdef caninline}inline;{$endif}
begin
 result:=Context^.UserData;
 if (not assigned(result)) and assigned(Context^.CallParent) then begin
  result:=POCAGetUserData(Context);
 end;
end;

procedure POCAAddSymbol(Context:PPOCAContext;const Dst:TPOCAValue;Symbol:TPOCARawByteString;const Value:TPOCAValue;const Constant:Boolean); {$ifdef caninline}inline;{$endif}
begin
 POCAHashSet(Context,Dst,POCAInternSymbol(Context,Context^.Instance,POCANewString(Context,Symbol)),Value,Constant);
end;

procedure POCAAddNativeFunction(Context:PPOCAContext;const Hash:TPOCAValue;const FunctionName:TPOCARawByteString;const FunctionPointer:TPOCANativeFunction;const DestroyFunctionPointer:TPOCANativeDestroyFunction;const UserData:TPOCAPointer;const Constant:Boolean); {$ifdef caninline}inline;{$endif}
begin
 POCAAddSymbol(Context,Hash,FunctionName,POCANewFunction(Context,POCANewNativeCode(Context,FunctionPointer,DestroyFunctionPointer,UserData)),Constant);
end;

function POCAArrayNewRecord(Old:PPOCAArrayRecord):PPOCAArrayRecord;
var i,OldSize,NewSize:TPOCAUInt32;
begin
 if assigned(Old) then begin
  OldSize:=Old^.Size;
 end else begin
  OldSize:=0;
 end;
 NewSize:=((OldSize*3) shr 1)+1;
 GetMem(result,sizeof(TPOCAArrayRecord)+(NewSize*sizeof(TPOCAValue)));
 FillChar(result^,sizeof(TPOCAArrayRecord)+(NewSize*sizeof(TPOCAValue)),#0);
 result^.Allocated:=NewSize;
 result^.Size:=OldSize;
 i:=0;
 while i<OldSize do begin
  result^.Data[i]:=Old^.Data[i];
  inc(i);
 end;
end;

function POCAArrayResize(ArrayObject:PPOCAArray):PPOCAArrayRecord;
begin
 result:=POCAArrayNewRecord(ArrayObject^.ArrayRecord);
 POCAGarbageCollectorSwapFree(ArrayObject^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,@ArrayObject^.ArrayRecord,result);
end;

function POCAArrayFastGet(const ArrayObject:TPOCAValue;i:TPOCAInt32):TPOCAValue; {$ifdef caninline}inline;{$endif}
begin
 result:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject))^.ArrayRecord^.Data[i];
end;

procedure POCAArrayFastSet(const ArrayObject:TPOCAValue;i:TPOCAInt32;const Value:TPOCAValue); {$ifdef caninline}inline;{$endif}
begin
 PPOCAArray(POCAGetValueReferencePointer(ArrayObject))^.ArrayRecord^.Data[i]:=Value;
end;

function POCAArrayGet(const ArrayObject:TPOCAValue;i:TPOCAInt32):TPOCAValue;
var ArrayRecord:PPOCAArrayRecord;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject))^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   while i<0 do begin
    inc(i,ArrayRecord^.Size);
   end;
   if (i>=0) and (i<ArrayRecord^.Size) then begin
    result:=ArrayRecord^.Data[i];
    exit;
   end;
  end;
 end;
 //result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
end;

procedure POCAArraySet(const ArrayObject:TPOCAValue;i:TPOCAInt32;const Value:TPOCAValue);
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   while i<0 do begin
    inc(i,ArrayRecord^.Size);
   end;
   if (i>=0) and (i<ArrayRecord^.Size) then begin
    ArrayRecord^.Data[i]:=Value;
    TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(ArrayInstance)),Value);
   end;
  end;
 end;
end;

function POCAArraySize(const ArrayObject:TPOCAValue):TPOCAUInt32;
var ArrayRecord:PPOCAArrayRecord;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject))^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   result:=ArrayRecord^.Size;
   exit;
  end;
 end;
 result:=0;
end;

function POCAArrayPush(const ArrayObject:TPOCAValue;const Value:TPOCAValue):TPOCAUInt32;
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  while (not assigned(ArrayRecord)) or (ArrayRecord^.Size>=ArrayRecord^.Allocated) do begin
   ArrayRecord:=POCAArrayResize(ArrayInstance);
  end;
  if assigned(ArrayRecord) then begin
   ArrayRecord^.Data[ArrayRecord^.Size]:=Value;
   TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(ArrayInstance)),Value);
   result:=ArrayRecord^.Size;
   TPasMPInterlocked.Increment(ArrayRecord^.Size);
   exit;
  end;
 end;
 result:=0;
end;

function POCAArrayRangePush(Context:PPOCAContext;const ArrayObject:TPOCAValue;const FromValue,ToValue:TPOCAValue):TPOCAUInt32;
var Value:TPOCAValue;
    ToNumber:double;
    sFrom,sTo:TPUCURawByteString;
    c:TPOCAUInt32;
    UTF8:boolean;
begin
 if POCAIsValueArray(ArrayObject) then begin
  if POCAIsValueNumber(FromValue) or POCAIsValueNumber(ToValue) then begin
   Value.Num:=POCAGetNumberValue(Context,FromValue);
   ToNumber:=POCAGetNumberValue(Context,ToValue);
   while POCAIsFinite(Value.Num) and (Value.Num<=ToNumber) do begin
    POCAArrayPush(ArrayObject,Value);
    Value.Num:=Value.Num+1;
   end;
  end else if POCAIsValueString(FromValue) or POCAIsValueString(ToValue) then begin
   sFrom:=POCAGetStringValue(Context,FromValue);
   sTo:=POCAGetStringValue(Context,ToValue);
   if POCAIsValueString(FromValue) and POCAIsValueString(ToValue) then begin
    UTF8:=(PPOCAString(POCAGetValueReferencePointer(FromValue))^.UTF8=suISUTF8) and (PPOCAString(POCAGetValueReferencePointer(ToValue))^.UTF8=suISUTF8);
   end else begin
    UTF8:=PUCUIsUTF8(sFrom) and PUCUIsUTF8(sTo);
   end;
   while (length(sFrom)>0) and (sFrom<=sTo) do begin
    POCAArrayPush(ArrayObject,POCANewString(Context,sFrom));
    if (not UTF8) or (ord(sFrom[1])<127) then begin
     inc(sFrom[1]);
    end else begin
     c:=PUCUUTF8CodeUnitGetChar(sFrom,1);
     inc(c);
     PUCUUTF8Delete(sFrom,1);
     sFrom:=PUCUUTF32CharToUTF8(c)+sFrom;
    end;
   end;
  end else begin
   POCARuntimeError(Context,'Invalid array range');
  end;
 end;
 result:=0;
end;

function POCAArrayDelete(const ArrayObject:TPOCAValue;const Index:TPOCAInt32):TPOCAUInt32;
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
    i,j:TPOCAInt32;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   i:=Index;
   while i<0 do begin
    inc(i,ArrayRecord^.Size);
   end;
   if (i>=0) and (i<ArrayRecord^.Size) then begin
    if (i+1)<ArrayRecord^.Size then begin
     for j:=(i+1) to ArrayRecord^.Size-1 do begin
      ArrayRecord^.Data[j-1]:=ArrayRecord^.Data[j];
     end;
    end;
    TPasMPInterlocked.Decrement(ArrayRecord^.Size);
    if ArrayRecord^.Size<(ArrayRecord^.Allocated shr 1) then begin
     POCAArrayResize(ArrayInstance);
    end;
   end;
  end;
 end;
 result:=0;
end;

function POCAArrayRemove(const ArrayObject:TPOCAValue;const Value:TPOCAValue):TPOCAUInt32;
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
    i,j:TPOCAInt32;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   i:=ArrayRecord^.Size-1;
   while i>=0 do begin
    if POCAEqual(ArrayRecord^.Data[i],Value) then begin
     if (i+1)<ArrayRecord^.Size then begin
      for j:=(i+1) to ArrayRecord^.Size-1 do begin
       ArrayRecord^.Data[j-1]:=ArrayRecord^.Data[j];
      end;
     end;
     TPasMPInterlocked.Decrement(ArrayRecord^.Size);
     if ArrayRecord^.Size<(ArrayRecord^.Allocated shr 1) then begin
      POCAArrayResize(ArrayInstance);
     end;
    end else begin
     dec(i);
    end;
   end;
  end;
 end;
 result:=0;
end;

function POCAArrayIndexOf(const ArrayObject:TPOCAValue;const Value:TPOCAValue):TPOCAInt32;
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
    i:TPOCAInt32;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   i:=0;
   while i<ArrayRecord^.Size do begin
    if POCAEqual(ArrayRecord^.Data[i],Value) then begin
     result:=i;
     exit;
    end;
    inc(i);
   end;
  end;
 end;
 result:=-1;
end;

function POCAArrayLastIndexOf(const ArrayObject:TPOCAValue;const Value:TPOCAValue):TPOCAInt32;
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
    i:TPOCAInt32;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   i:=ArrayRecord^.Size;
   while i>=0 do begin
    dec(i);
    if POCAEqual(ArrayRecord^.Data[i],Value) then begin
     result:=i;
     exit;
    end;
   end;
  end;
 end;
 result:=-1;
end;

procedure POCAArraySetSize(const ArrayObject:TPOCAValue;Size:TPOCAInt32);
var ArrayInstance:PPOCAArray;
    ArrayRecord,NewVecRec:PPOCAArrayRecord;
    i:TPOCAInt32;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  GetMem(NewVecRec,sizeof(TPOCAArrayRecord)+(Size*sizeof(TPOCAValue)));
  FillChar(NewVecRec^,sizeof(TPOCAArrayRecord)+(Size*sizeof(TPOCAValue)),#0);
  NewVecRec^.Size:=Size;
  NewVecRec^.Allocated:=Size;
  if assigned(ArrayRecord) then begin
   for i:=0 to Size-1 do begin
    if i<ArrayRecord^.Size then begin
     NewVecRec^.Data[i]:=ArrayRecord^.Data[i];
    end else begin
//   NewVecRec^.Data[i]:=POCAValueNull;
     NewVecRec^.Data[i].CastedUInt64:=POCAValueNullCastedUInt64;
    end;
   end;
  end else begin
   for i:=0 to Size-1 do begin
//  NewVecRec^.Data[i]:=POCAValueNull;
    NewVecRec^.Data[i].CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
  POCAGarbageCollectorSwapFree(ArrayInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,@ArrayInstance^.ArrayRecord,NewVecRec);
 end;
end;

function POCAArrayPop(const ArrayObject:TPOCAValue):TPOCAValue;
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   if ArrayRecord^.Size>0 then begin
    result:=ArrayRecord^.Data[ArrayRecord^.Size-1];
    TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(ArrayInstance)),result);
    TPasMPInterlocked.Decrement(ArrayRecord^.Size);
    if ArrayRecord^.Size<(ArrayRecord^.Allocated shr 1) then begin
     POCAArrayResize(ArrayInstance);
    end;
    exit;
   end;
  end;
 end;
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
end;

procedure POCAArraySort(Context:PPOCAContext;const ArrayObject:TPOCAValue);
type PStackItem=^TStackItem;
     TStackItem=record
      Left,Right,Depth:TPOCAInt32;
     end;
 function IntLog2(x:TPOCAUInt32):TPOCAUInt32; {$ifdef cpu386}assembler; register;
 asm
  test eax,eax
  jz @Done
  bsr eax,eax
  @Done:
 end;
{$else}
 begin
  x:=x or (x shr 1);
  x:=x or (x shr 2);
  x:=x or (x shr 4);
  x:=x or (x shr 8);
  x:=x or (x shr 16);
  x:=x shr 1;
  x:=x-((x shr 1) and $55555555);
  x:=((x shr 2) and $33333333)+(x and $33333333);
  x:=((x shr 4)+x) and $0f0f0f0f;
  x:=x+(x shr 8);
  x:=x+(x shr 16);
  result:=x and $3f;
 end;
{$endif}
var Left,Right,Depth,i,j,Middle,Size,Parent,Child:TPOCAInt64;
    Pivot,Temp:TPOCAValue;
    ArrayRecord:PPOCAArrayRecord;
    StackItem:PStackItem;
    Stack:array[0..31] of TStackItem;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject))^.ArrayRecord;
  if assigned(ArrayRecord) and (ArrayRecord^.Size>0) then begin
   Left:=0;
   Right:=ArrayRecord^.Size-1;
   if Left<Right then begin
    StackItem:=@Stack[0];
    StackItem^.Left:=Left;
    StackItem^.Right:=Right;
    StackItem^.Depth:=IntLog2((Right-Left)+1) shl 1;
    inc(StackItem);
    while TPOCAPtrUInt(TPOCAPointer(StackItem))>TPOCAPtrUInt(TPOCAPointer(@Stack[0])) do begin
     dec(StackItem);
     Left:=StackItem^.Left;
     Right:=StackItem^.Right;
     Depth:=StackItem^.Depth;
     if (Right-Left)<16 then begin
      // Insertion sort
      i:=Left+1;
      while i<=Right do begin
       Temp:=ArrayRecord^.Data[i];
       j:=i-1;
       if (j>=Left) and (POCACompare(Context,ArrayRecord^.Data[j],Temp)>0) then begin
        repeat
         ArrayRecord^.Data[j+1]:=ArrayRecord^.Data[j];
         dec(j);
        until not ((j>=Left) and (POCACompare(Context,ArrayRecord^.Data[j],Temp)>0));
        ArrayRecord^.Data[j+1]:=Temp;
       end;
       inc(i);
      end;
     end else begin
      if (Depth=0) or (TPOCAPtrUInt(TPOCAPointer(StackItem))>=TPOCAPtrUInt(TPOCAPointer(@Stack[high(Stack)-1]))) then begin
       // Heap sort
       Size:=(Right-Left)+1;
       i:=Size div 2;
       Temp.CastedInt64:=0;
       repeat
        if i>Left then begin
         dec(i);
         Temp:=ArrayRecord^.Data[Left+i];
        end else begin
         if Size=0 then begin
          break;
         end else begin
          dec(Size);
          Temp:=ArrayRecord^.Data[Left+Size];
          ArrayRecord^.Data[Left+Size]:=ArrayRecord^.Data[Left];
         end;
        end;
        Parent:=i;
        Child:=(i*2)+1;
        while Child<Size do begin
         if ((Child+1)<Size) and (POCACompare(Context,ArrayRecord^.Data[Left+Child+1],ArrayRecord^.Data[Left+Child])>0) then begin
          inc(Child);
         end;
         if POCACompare(Context,ArrayRecord^.Data[Left+Child],Temp)>0 then begin
          POCAArraySet(ArrayObject,Left+Parent,ArrayRecord^.Data[Left+Child]);
          Parent:=Child;
          Child:=(Parent*2)+1;
         end else begin
          break;
         end;
        end;
        ArrayRecord^.Data[Left+Parent]:=Temp;
       until false;
      end else begin
       // Quick sort width median-of-three optimization
       Middle:=Left+((Right-Left) shr 1);
       if (Right-Left)>3 then begin
        if POCACompare(Context,ArrayRecord^.Data[Left],ArrayRecord^.Data[Middle])>0 then begin
         Temp:=ArrayRecord^.Data[Left];
         ArrayRecord^.Data[Left]:=ArrayRecord^.Data[Middle];
         ArrayRecord^.Data[Middle]:=Temp;
        end;
        if POCACompare(Context,ArrayRecord^.Data[Left],ArrayRecord^.Data[Right])>0 then begin
         Temp:=ArrayRecord^.Data[Left];
         ArrayRecord^.Data[Left]:=ArrayRecord^.Data[Right];
         ArrayRecord^.Data[Right]:=Temp;
        end;
        if POCACompare(Context,ArrayRecord^.Data[Middle],ArrayRecord^.Data[Right])>0 then begin
         Temp:=ArrayRecord^.Data[Middle];
         ArrayRecord^.Data[Middle]:=ArrayRecord^.Data[Right];
         ArrayRecord^.Data[Right]:=Temp;
        end;
       end;
       Pivot:=ArrayRecord^.Data[Middle];
       i:=Left;
       j:=Right;
       repeat
        while (i<Right) and (POCACompare(Context,ArrayRecord^.Data[i],Pivot)<0) do begin
         inc(i);
        end;
        while (j>=i) and (POCACompare(Context,ArrayRecord^.Data[j],Pivot)>0) do begin
         dec(j);
        end;
        if i>j then begin
         break;
        end else begin
         if i<>j then begin
          Temp:=ArrayRecord^.Data[i];
          ArrayRecord^.Data[i]:=ArrayRecord^.Data[j];
          ArrayRecord^.Data[j]:=Temp;
         end;
         inc(i);
         dec(j);
        end;
       until false;
       if i<Right then begin
        StackItem^.Left:=i;
        StackItem^.Right:=Right;
        StackItem^.Depth:=Depth-1;
        inc(StackItem);
       end;
       if Left<j then begin
        StackItem^.Left:=Left;
        StackItem^.Right:=j;
        StackItem^.Depth:=Depth-1;
        inc(StackItem);
       end;
      end;
     end;
    end;
   end;
  end;
 end;
end;

procedure POCAArraySort(Context:PPOCAContext;const ArrayObject,CompareFunction:TPOCAValue);
type PStackItem=^TStackItem;
     TStackItem=record
      Left,Right,Depth:TPOCAInt32;
     end;
 function IntLog2(x:TPOCAUInt32):TPOCAUInt32; {$ifdef cpu386}assembler; register;
 asm
  test eax,eax
  jz @Done
  bsr eax,eax
  @Done:
 end;
{$else}
 begin
  x:=x or (x shr 1);
  x:=x or (x shr 2);
  x:=x or (x shr 4);
  x:=x or (x shr 8);
  x:=x or (x shr 16);
  x:=x shr 1;
  x:=x-((x shr 1) and $55555555);
  x:=((x shr 2) and $33333333)+(x and $33333333);
  x:=((x shr 4)+x) and $0f0f0f0f;
  x:=x+(x shr 8);
  x:=x+(x shr 16);
  result:=x and $3f;
 end;
{$endif}
 function Compare(const a,b:TPOCAValue):TPOCAInt32;
 var Arguments:array[0..1] of TPOCAValue;
     SubContext:PPOCAContext;
 begin
  Arguments[0]:=a;
  Arguments[1]:=b;
  SubContext:=POCAContextSub(Context);
  try
   result:=trunc(POCAGetNumberValue(SubContext,POCACall(SubContext,CompareFunction,@Arguments,2,ArrayObject,POCAValueNull)));
  finally
   POCAContextDestroy(SubContext);
  end;
 end;
var Left,Right,Depth,i,j,Middle,Size,Parent,Child:TPOCAInt64;
    Pivot,Temp:TPOCAValue;
    ArrayRecord:PPOCAArrayRecord;
    StackItem:PStackItem;
    Stack:array[0..31] of TStackItem;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject))^.ArrayRecord;
  if assigned(ArrayRecord) and (ArrayRecord^.Size>0) then begin
   Left:=0;
   Right:=ArrayRecord^.Size-1;
   if Left<Right then begin
    StackItem:=@Stack[0];
    StackItem^.Left:=Left;
    StackItem^.Right:=Right;
    StackItem^.Depth:=IntLog2((Right-Left)+1) shl 1;
    inc(StackItem);
    while TPOCAPtrUInt(TPOCAPointer(StackItem))>TPOCAPtrUInt(TPOCAPointer(@Stack[0])) do begin
     dec(StackItem);
     Left:=StackItem^.Left;
     Right:=StackItem^.Right;
     Depth:=StackItem^.Depth;
     if (Right-Left)<16 then begin
      // Insertion sort
      i:=Left+1;
      while i<=Right do begin
       Temp:=ArrayRecord^.Data[i];
       j:=i-1;
       if (j>=Left) and (Compare(ArrayRecord^.Data[j],Temp)>0) then begin
        repeat
         ArrayRecord^.Data[j+1]:=ArrayRecord^.Data[j];
         dec(j);
        until not ((j>=Left) and (Compare(ArrayRecord^.Data[j],Temp)>0));
        ArrayRecord^.Data[j+1]:=Temp;
       end;
       inc(i);
      end;
     end else begin
      if (Depth=0) or (TPOCAPtrUInt(TPOCAPointer(StackItem))>=TPOCAPtrUInt(TPOCAPointer(@Stack[high(Stack)-1]))) then begin
       // Heap sort
       Size:=(Right-Left)+1;
       i:=Size div 2;
       Temp.CastedInt64:=0;
       repeat
        if i>Left then begin
         dec(i);
         Temp:=ArrayRecord^.Data[Left+i];
        end else begin
         if Size=0 then begin
          break;
         end else begin
          dec(Size);
          Temp:=ArrayRecord^.Data[Left+Size];
          ArrayRecord^.Data[Left+Size]:=ArrayRecord^.Data[Left];
         end;
        end;
        Parent:=i;
        Child:=(i*2)+1;
        while Child<Size do begin
         if ((Child+1)<Size) and (Compare(ArrayRecord^.Data[Left+Child+1],ArrayRecord^.Data[Left+Child])>0) then begin
          inc(Child);
         end;
         if Compare(ArrayRecord^.Data[Left+Child],Temp)>0 then begin
          POCAArraySet(ArrayObject,Left+Parent,ArrayRecord^.Data[Left+Child]);
          Parent:=Child;
          Child:=(Parent*2)+1;
         end else begin
          break;
         end;
        end;
        ArrayRecord^.Data[Left+Parent]:=Temp;
       until false;
      end else begin
       // Quick sort width median-of-three optimization
       Middle:=Left+((Right-Left) shr 1);
       if (Right-Left)>3 then begin
        if Compare(ArrayRecord^.Data[Left],ArrayRecord^.Data[Middle])>0 then begin
         Temp:=ArrayRecord^.Data[Left];
         ArrayRecord^.Data[Left]:=ArrayRecord^.Data[Middle];
         ArrayRecord^.Data[Middle]:=Temp;
        end;
        if Compare(ArrayRecord^.Data[Left],ArrayRecord^.Data[Right])>0 then begin
         Temp:=ArrayRecord^.Data[Left];
         ArrayRecord^.Data[Left]:=ArrayRecord^.Data[Right];
         ArrayRecord^.Data[Right]:=Temp;
        end;
        if Compare(ArrayRecord^.Data[Middle],ArrayRecord^.Data[Right])>0 then begin
         Temp:=ArrayRecord^.Data[Middle];
         ArrayRecord^.Data[Middle]:=ArrayRecord^.Data[Right];
         ArrayRecord^.Data[Right]:=Temp;
        end;
       end;
       Pivot:=ArrayRecord^.Data[Middle];
       i:=Left;
       j:=Right;
       repeat
        while (i<Right) and (Compare(ArrayRecord^.Data[i],Pivot)<0) do begin
         inc(i);
        end;
        while (j>=i) and (Compare(ArrayRecord^.Data[j],Pivot)>0) do begin
         dec(j);
        end;
        if i>j then begin
         break;
        end else begin
         if i<>j then begin
          Temp:=ArrayRecord^.Data[i];
          ArrayRecord^.Data[i]:=ArrayRecord^.Data[j];
          ArrayRecord^.Data[j]:=Temp;
         end;
         inc(i);
         dec(j);
        end;
       until false;
       if i<Right then begin
        StackItem^.Left:=i;
        StackItem^.Right:=Right;
        StackItem^.Depth:=Depth-1;
        inc(StackItem);
       end;
       if Left<j then begin
        StackItem^.Left:=Left;
        StackItem^.Right:=j;
        StackItem^.Depth:=Depth-1;
        inc(StackItem);
       end;
      end;
     end;
    end;
   end;
  end;
 end;
end;

procedure POCAArraySort(Context:PPOCAContext;const ArrayObject:TPOCAValue;const ItemIndex:TPOCAInt32); overload;
type PStackItem=^TStackItem;
     TStackItem=record
      Left,Right,Depth:TPOCAInt32;
     end;
 function IntLog2(x:TPOCAUInt32):TPOCAUInt32; {$ifdef cpu386}assembler; register;
 asm
  test eax,eax
  jz @Done
  bsr eax,eax
  @Done:
 end;
{$else}
 begin
  x:=x or (x shr 1);
  x:=x or (x shr 2);
  x:=x or (x shr 4);
  x:=x or (x shr 8);
  x:=x or (x shr 16);
  x:=x shr 1;
  x:=x-((x shr 1) and $55555555);
  x:=((x shr 2) and $33333333)+(x and $33333333);
  x:=((x shr 4)+x) and $0f0f0f0f;
  x:=x+(x shr 8);
  x:=x+(x shr 16);
  result:=x and $3f;
 end;
{$endif}
 function Compare(const a,b:TPOCAValue):TPOCAInt32;
 var ArrayRecords:array[0..1] of PPOCAArrayRecord;
 begin
  if POCAIsValueArray(a) and POCAIsValueArray(b) then begin
   ArrayRecords[0]:=PPOCAArray(POCAGetValueReferencePointer(a))^.ArrayRecord;
   ArrayRecords[1]:=PPOCAArray(POCAGetValueReferencePointer(b))^.ArrayRecord;
   if (ItemIndex<ArrayRecords[0]^.Size) and (ItemIndex<ArrayRecords[1]^.Size) then begin
    result:=POCACompare(Context,ArrayRecords[0]^.Data[ItemIndex],ArrayRecords[1]^.Data[ItemIndex]);
   end else begin
    result:=0;
   end;
  end else begin
   result:=0;
  end;
 end;
var Left,Right,Depth,i,j,Middle,Size,Parent,Child:TPOCAInt64;
    Pivot,Temp:TPOCAValue;
    ArrayRecord:PPOCAArrayRecord;
    StackItem:PStackItem;
    Stack:array[0..31] of TStackItem;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject))^.ArrayRecord;
  if assigned(ArrayRecord) and (ArrayRecord^.Size>0) and (ItemIndex>=0) then begin
   Left:=0;
   Right:=ArrayRecord^.Size-1;
   if Left<Right then begin
    StackItem:=@Stack[0];
    StackItem^.Left:=Left;
    StackItem^.Right:=Right;
    StackItem^.Depth:=IntLog2((Right-Left)+1) shl 1;
    inc(StackItem);
    while TPOCAPtrUInt(TPOCAPointer(StackItem))>TPOCAPtrUInt(TPOCAPointer(@Stack[0])) do begin
     dec(StackItem);
     Left:=StackItem^.Left;
     Right:=StackItem^.Right;
     Depth:=StackItem^.Depth;
     if (Right-Left)<16 then begin
      // Insertion sort
      i:=Left+1;
      while i<=Right do begin
       Temp:=ArrayRecord^.Data[i];
       j:=i-1;
       if (j>=Left) and (Compare(ArrayRecord^.Data[j],Temp)>0) then begin
        repeat
         ArrayRecord^.Data[j+1]:=ArrayRecord^.Data[j];
         dec(j);
        until not ((j>=Left) and (Compare(ArrayRecord^.Data[j],Temp)>0));
        ArrayRecord^.Data[j+1]:=Temp;
       end;
       inc(i);
      end;
     end else begin
      if (Depth=0) or (TPOCAPtrUInt(TPOCAPointer(StackItem))>=TPOCAPtrUInt(TPOCAPointer(@Stack[high(Stack)-1]))) then begin
       // Heap sort
       Size:=(Right-Left)+1;
       i:=Size div 2;
       Temp.CastedInt64:=0;
       repeat
        if i>Left then begin
         dec(i);
         Temp:=ArrayRecord^.Data[Left+i];
        end else begin
         if Size=0 then begin
          break;
         end else begin
          dec(Size);
          Temp:=ArrayRecord^.Data[Left+Size];
          ArrayRecord^.Data[Left+Size]:=ArrayRecord^.Data[Left];
         end;
        end;
        Parent:=i;
        Child:=(i*2)+1;
        while Child<Size do begin
         if ((Child+1)<Size) and (Compare(ArrayRecord^.Data[Left+Child+1],ArrayRecord^.Data[Left+Child])>0) then begin
          inc(Child);
         end;
         if Compare(ArrayRecord^.Data[Left+Child],Temp)>0 then begin
          POCAArraySet(ArrayObject,Left+Parent,ArrayRecord^.Data[Left+Child]);
          Parent:=Child;
          Child:=(Parent*2)+1;
         end else begin
          break;
         end;
        end;
        ArrayRecord^.Data[Left+Parent]:=Temp;
       until false;
      end else begin
       // Quick sort width median-of-three optimization
       Middle:=Left+((Right-Left) shr 1);
       if (Right-Left)>3 then begin
        if Compare(ArrayRecord^.Data[Left],ArrayRecord^.Data[Middle])>0 then begin
         Temp:=ArrayRecord^.Data[Left];
         ArrayRecord^.Data[Left]:=ArrayRecord^.Data[Middle];
         ArrayRecord^.Data[Middle]:=Temp;
        end;
        if Compare(ArrayRecord^.Data[Left],ArrayRecord^.Data[Right])>0 then begin
         Temp:=ArrayRecord^.Data[Left];
         ArrayRecord^.Data[Left]:=ArrayRecord^.Data[Right];
         ArrayRecord^.Data[Right]:=Temp;
        end;
        if Compare(ArrayRecord^.Data[Middle],ArrayRecord^.Data[Right])>0 then begin
         Temp:=ArrayRecord^.Data[Middle];
         ArrayRecord^.Data[Middle]:=ArrayRecord^.Data[Right];
         ArrayRecord^.Data[Right]:=Temp;
        end;
       end;
       Pivot:=ArrayRecord^.Data[Middle];
       i:=Left;
       j:=Right;
       repeat
        while (i<Right) and (Compare(ArrayRecord^.Data[i],Pivot)<0) do begin
         inc(i);
        end;
        while (j>=i) and (Compare(ArrayRecord^.Data[j],Pivot)>0) do begin
         dec(j);
        end;
        if i>j then begin
         break;
        end else begin
         if i<>j then begin
          Temp:=ArrayRecord^.Data[i];
          ArrayRecord^.Data[i]:=ArrayRecord^.Data[j];
          ArrayRecord^.Data[j]:=Temp;
         end;
         inc(i);
         dec(j);
        end;
       until false;
       if i<Right then begin
        StackItem^.Left:=i;
        StackItem^.Right:=Right;
        StackItem^.Depth:=Depth-1;
        inc(StackItem);
       end;
       if Left<j then begin
        StackItem^.Left:=Left;
        StackItem^.Right:=j;
        StackItem^.Depth:=Depth-1;
        inc(StackItem);
       end;
      end;
     end;
    end;
   end;
  end;
 end;
end;

function POCAHashMix(const h:TPOCAUInt32):TPOCAUInt32; {$ifdef caninline}inline;{$endif}
begin
 result:=h;
 result:=(not result)+(result shr 23);
 result:=result xor (result shl 22);
 result:=result xor (result shr 7);
 result:=result xor (result shl 2);
 result:=result xor (result shr 20);
 result:=result xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=result xor (result shl 2) or (result shr (32-2));
end;

function POCAHashString(const Str:TPOCARawByteString):TPOCAUInt32;
{$ifdef cpuarm}
var b:PAnsiChar;
    len,h,i:TPOCAUInt32;
begin
 result:=2166136261;
 len:=length(Str);
 h:=len;
 if len>0 then begin
  b:=PAnsiChar(Str);
  while len>3 do begin
   i:=TPOCAUInt32(TPOCAPointer(b)^);
   h:=(h xor i) xor $2e63823a;
   inc(h,(h shl 15) or (h shr (32-15)));
   dec(h,(h shl 9) or (h shr (32-9)));
   inc(h,(h shl 4) or (h shr (32-4)));
   dec(h,(h shl 1) or (h shr (32-1)));
   h:=h xor (h shl 2) or (h shr (32-2));
   result:=result xor i;
   inc(result,(result shl 1)+(result shl 4)+(result shl 7)+(result shl 8)+(result shl 24));
   inc(b,4);
   dec(len,4);
  end;
  if len>1 then begin
   i:=TPOCAUInt16(TPOCAPointer(b)^);
   h:=(h xor i) xor $2e63823a;
   inc(h,(h shl 15) or (h shr (32-15)));
   dec(h,(h shl 9) or (h shr (32-9)));
   inc(h,(h shl 4) or (h shr (32-4)));
   dec(h,(h shl 1) or (h shr (32-1)));
   h:=h xor (h shl 2) or (h shr (32-2));
   result:=result xor i;
   inc(result,(result shl 1)+(result shl 4)+(result shl 7)+(result shl 8)+(result shl 24));
   inc(b,2);
   dec(len,2);
  end;
  if len>0 then begin
   i:=TPOCAUInt8(b^);
   h:=(h xor i) xor $2e63823a;
   inc(h,(h shl 15) or (h shr (32-15)));
   dec(h,(h shl 9) or (h shr (32-9)));
   inc(h,(h shl 4) or (h shr (32-4)));
   dec(h,(h shl 1) or (h shr (32-1)));
   h:=h xor (h shl 2) or (h shr (32-2));
   result:=result xor i;
   inc(result,(result shl 1)+(result shl 4)+(result shl 7)+(result shl 8)+(result shl 24));
  end;
 end;
 result:=result xor h;
 if result=0 then begin
  result:=$ffffffff;
 end;
end;
{$else}
const m=TPOCAUInt32($57559429);
      n=TPOCAUInt32($5052acdb);
var b:PAnsiChar;
    h,k,len:TPOCAUInt32;
    p:{$ifdef fpc}TPOCAUInt64{$else}TPOCAInt64{$endif};
begin
 len:=length(Str);
 h:=len;
 k:=h+n+1;
 if len>0 then begin
  b:=PAnsiChar(Str);
  while len>7 do begin
   begin
    p:=TPOCAUInt32(TPOCAPointer(b)^)*TPOCAUInt64(n);
    h:=h xor TPOCAUInt32(p and $ffffffff);
    k:=k xor TPOCAUInt32(p shr 32);
    inc(b,4);
   end;
   begin
    p:=TPOCAUInt32(TPOCAPointer(b)^)*TPOCAUInt64(m);
    k:=k xor TPOCAUInt32(p and $ffffffff);
    h:=h xor TPOCAUInt32(p shr 32);
    inc(b,4);
   end;
   dec(len,8);
  end;
  if len>3 then begin
   p:=TPOCAUInt32(TPOCAPointer(b)^)*TPOCAUInt64(n);
   h:=h xor TPOCAUInt32(p and $ffffffff);
   k:=k xor TPOCAUInt32(p shr 32);
   inc(b,4);
   dec(len,4);
  end;
  if len>0 then begin
   if len>1 then begin
    p:=TPOCAUInt16(TPOCAPointer(b)^);
    inc(b,2);
    dec(len,2);
   end else begin
    p:=0;
   end;
   if len>0 then begin
    p:=p or (TPOCAUInt8(b^) shl 16);
   end;
   p:=p*TPOCAUInt64(m);
   k:=k xor TPOCAUInt32(p and $ffffffff);
   h:=h xor TPOCAUInt32(p shr 32);
  end;
 end;
 begin
  p:=(h xor (k+n))*TPOCAUInt64(n);
  h:=h xor TPOCAUInt32(p and $ffffffff);
  k:=k xor TPOCAUInt32(p shr 32);
 end;
 result:=k xor h;
 if result=0 then begin
  result:=$ffffffff;
 end;
end;
{$endif}

function POCAHashNumber(const Num:double):TPOCAUInt32;
begin
 result:=TPOCAUInt32(TPOCAPointer(@Num)^) xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=((result xor (result shl 2) or (result shr (32-2))) xor TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(TPOCAPointer(@Num))^[sizeof(TPOCAUInt32)])^)) xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=result xor (result shl 2) or (result shr (32-2));
 dec(result,ord(result=0) and 1);
end;

function POCAHashObj(const Obj:TPOCAPointer):TPOCAUInt32;
begin
{$ifdef cpu64}
 result:=TPOCAUInt32(TPOCAPtrUInt(Obj) and $ffffffff) xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=((result xor (result shl 2) or (result shr (32-2))) xor (TPOCAPtrUInt(Obj) shr 32)) xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=result xor (result shl 2) or (result shr (32-2));
{$else}
 result:=TPOCAUInt32(TPOCAPointer(@Obj)^) xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=result xor (result shl 2) or (result shr (32-2));
{$endif}
 dec(result,ord(result=0) and 1);
end;

function POCAValueHash(const r:TPOCAValue):TPOCAUInt32;
var Str:PPOCAString;
begin
 case POCAGetValueType(r) of
  pvtNUMBER:begin
   result:=POCAHashNumber(r.Num);
  end;
  pvtSTRING:begin
   Str:=PPOCAString(POCAGetValueReferencePointer(R));
   result:=Str^.HashCode;
   if result=0 then begin
    result:=POCAHashString(Str^.Data);
    Str^.HashCode:=result;
   end;
  end;
  else begin
   result:=POCAHashObj(POCAGetValueReferencePointer(R));
  end;
 end;
end;

function POCAHashFindCell(HashRec:PPOCAHashRecord;const Key:TPOCAValue;HashCode:TPOCAUInt32):TPOCAUInt32; overload;
var Mask,Step,Start:TPOCAUInt32;
    Entity:TPOCAInt32;
begin
 Mask:=(2 shl HashRec^.LogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 if HashRec^.LogSize<>0 then begin
  result:=HashCode shr (32-HashRec^.LogSize);
 end else begin
  result:=0;
 end;
 Start:=result;
 repeat
  Entity:=HashRec^.CellToEntityIndex^[result];
  if (Entity=ENT_EMPTY) or ((Entity<>ENT_DELETED) and POCAEqual(HashRec^.Entities^[Entity].Key,Key)) then begin
   exit;
  end;
  result:=(result+Step) and Mask;
 until result=Start;
 repeat
  Entity:=HashRec^.CellToEntityIndex^[result];
  if (Entity=ENT_EMPTY) or (Entity=ENT_DELETED) then begin
   exit;
  end;
  result:=(result+Step) and Mask;
 until result=Start;
 result:=TPOCAUInt32($ffffffff);
end;

function POCAHashFindCell(HashRec:PPOCAHashRecord;const Key:TPOCARawByteString;HashCode:TPOCAUInt32):TPOCAUInt32; overload;
var Mask,Step,Start:TPOCAUInt32;
    Entity:TPOCAInt32;
begin
 Mask:=(2 shl HashRec^.LogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 if HashRec^.LogSize<>0 then begin
  result:=HashCode shr (32-HashRec^.LogSize);
 end else begin
  result:=0;
 end;
 Start:=result;
 repeat
  Entity:=HashRec^.CellToEntityIndex^[result];
  if (Entity=ENT_EMPTY) or ((Entity<>ENT_DELETED) and POCAEqual(HashRec^.Entities^[Entity].Key,Key)) then begin
   exit;
  end;
  result:=(result+Step) and Mask;
 until result=Start;
 repeat
  Entity:=HashRec^.CellToEntityIndex^[result];
  if (Entity=ENT_EMPTY) or (Entity=ENT_DELETED) then begin
   exit;
  end;
  result:=(result+Step) and Mask;
 until result=Start;
 result:=TPOCAUInt32($ffffffff);
end;

function POCAHashRecordSize(LogSize:TPOCAInt32;Events:boolean):TPOCAUInt32;
begin
 result:=sizeof(TPOCAHashRecord)+((2 shl LogSize)*((2*sizeof(TPOCAInt32))+sizeof(TPOCAHashEntity)));
 if Events then begin
  inc(result,sizeof(TPOCAHashEvents));
 end;
end;

function POCAHashResize(Instance:PPOCAInstance;Hash:PPOCAHash;Events:TPOCABool32=false):PPOCAHashRecord; forward;

function POCAHashCreateEvents(Instance:PPOCAInstance;Hash:PPOCAHash):PPOCAHashRecord;
var HashRec:PPOCAHashRecord;
    EntityRec:PPOCAHashEntity;
    Size,Entity:TPOCAInt32;
    i,j:TPOCAUInt32;
    Str:PPOCAString;
    Op:TPOCAInt32;
begin
 HashRec:=Hash^.HashRecord;
 if not assigned(HashRec) then begin
  POCAHashResize(Instance,Hash,false);
  HashRec:=Hash^.HashRecord;
 end;
 Size:=POCAHashRecordSize(HashRec^.LogSize,true);
 GetMem(result,Size);
 FillChar(result^,Size,#0);
 result^.Size:=HashRec^.Size;
 result^.RealSize:=HashRec^.RealSize;
 result^.LogSize:=HashRec^.LogSize;
 result^.CellToEntityIndex:=TPOCAPointer(@PPOCAUInt8Array(TPOCAPointer(result))^[sizeof(TPOCAHashRecord)]);
 result^.EntityToCellIndex:=TPOCAPointer(@result^.CellToEntityIndex^[2 shl HashRec^.LogSize]);
 result^.Entities:=TPOCAPointer(@result^.EntityToCellIndex^[2 shl HashRec^.LogSize]);
 result^.Events:=TPOCAPointer(@result^.Entities^[1 shl HashRec^.LogSize]);
 if (assigned(HashRec) and assigned(HashRec^.Events)) then begin
  result^.Events^:=HashRec^.Events^;
 end;
 i:=0;
 j:=2 shl HashRec^.LogSize;
 while i<j do begin
  Entity:=HashRec^.CellToEntityIndex^[i];
  result^.CellToEntityIndex^[i]:=Entity;
  result^.EntityToCellIndex^[i]:=HashRec^.EntityToCellIndex^[i];
  if Entity>=0 then begin
   EntityRec:=@result^.Entities^[Entity];
   EntityRec^:=HashRec^.Entities^[Entity];
   if POCAIsValueString(EntityRec^.Key) then begin
    Str:=PPOCAString(POCAGetValueReferencePointer(EntityRec^.Key));
    if (length(Str^.Data)>2) and ((Str^.Data[1]='_') and (Str^.Data[2]='_')) then begin
     Op:=MetaOpNamesHashMap.GetValue(Str^.Data);
     if Op>=0 then begin
      result^.Events[TPOCAMetaOp(Op)]:=EntityRec^.Value;
     end;
    end;
   end;
  end;
  inc(i);
 end;
 POCAMRSWLockReadLock(@Hash^.Cache.MRSWLock);
 try
  POCAGarbageCollectorSwapFree(Hash^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,@Hash^.HashRecord,result);
  POCAHashInvalidate(Hash);
 finally
  POCAMRSWLockReadUnlock(@Hash^.Cache.MRSWLock);
 end;
end;

procedure POCAHashLockInvalidate(Hash:PPOCAHash);
var Current:PPOCAHash;
begin
 if assigned(Hash) then begin
  POCAMRSWLockReadLock(@Hash^.Cache.MRSWLock);
  try
   TPasMPInterlocked.Exchange(TPOCAInt32(Hash^.Cache.Ready),0);
   Current:=Hash^.Children.First;
   while assigned(Current) do begin
    POCAHashLockInvalidate(Current);
    Current:=Current^.Children.Next;
   end;
  finally
   POCAMRSWLockReadUnlock(@Hash^.Cache.MRSWLock);
  end;
 end;
end;

procedure POCAHashInvalidate(Hash:PPOCAHash);
var Current:PPOCAHash;
begin
 if assigned(Hash) then begin
  TPasMPInterlocked.Exchange(TPOCAInt32(Hash^.Cache.Ready),0);
  Current:=Hash^.Children.First;
  while assigned(Current) do begin
   POCAHashLockInvalidate(Current);
   Current:=Current^.Children.Next;
  end;
 end;
end;

procedure POCAHashRebuildCache(Hash:PPOCAHash);
var CountItems:TPOCAInt32;
    Cachable:boolean;
 procedure Process(CurrentHash:PPOCAHash);
 var Current:PPOCAHash;
     OldEntities,Entities:PPPOCAHashEntities;
     Index,i:TPOCAInt32;
 begin
  if assigned(CurrentHash) then begin
   if assigned(CurrentHash^.Events) or not Cachable then begin
    Cachable:=false;
    CountItems:=0;
   end else begin
    if assigned(CurrentHash^.HashRecord) then begin
     inc(CountItems,CurrentHash^.HashRecord^.Size);
    end;
   end;
   POCAMRSWLockReadLock(@CurrentHash^.Cache.MRSWLock);
   try
    Process(CurrentHash^.Prototype);
   finally
    POCAMRSWLockReadUnlock(@CurrentHash^.Cache.MRSWLock);
   end;
  end else begin
   OldEntities:=Hash^.Cache.ChainEntities;
   if Cachable then begin
    GetMem(Entities,CountItems*sizeof(PPOCAHashEntity));
    FillChar(Entities^,CountItems*sizeof(PPOCAHashEntity),#0);
    Index:=CountItems;
    Current:=Hash;
    while assigned(Current) do begin
     if assigned(Current^.HashRecord) and (Current^.HashRecord^.Size>0) then begin
      for i:=Current^.HashRecord^.Size-1 downto 0 do begin
       dec(Index);
       Entities^[Index]:=@Current^.HashRecord^.Entities[i];
      end;
     end;
     Current:=Current^.Prototype;
    end;
   end else begin
    Entities:=nil;
   end;
   TPasMPInterlocked.Exchange(TPOCAPointer(Hash^.Cache.ChainEntities),TPOCAPointer(Entities));
   if assigned(OldEntities) then begin
    FreeMem(OldEntities);
   end;
  end;
 end;
begin
 if assigned(Hash) and not Hash^.Cache.Ready then begin
  POCAMRSWLockWriteLock(@Hash^.Cache.MRSWLock);
  try
   if assigned(Hash^.HashRecord) then begin
    CountItems:=Hash^.HashRecord^.Size;
   end else begin
    CountItems:=0;
   end;
   Cachable:=true;
   Process(Hash^.Prototype);
   TPasMPInterlocked.Exchange(Hash^.Cache.ChainCount,CountItems);
   TPasMPInterlocked.Exchange(TPOCAInt32(Hash^.Cache.Ready),TPOCAInt32(TPOCAUInt32($ffffffff)));
  finally
   POCAMRSWLockWriteUnlock(@Hash^.Cache.MRSWLock);
  end;
 end;
end;

procedure POCAHashClearPrototype(Hash:PPOCAHash);
var OldPrototype,Previous,Next:PPOCAHash;
begin
 if assigned(Hash) and assigned(Hash^.Prototype) then begin
  POCAMRSWLockWriteLock(@Hash^.Cache.MRSWLock);
  try
   OldPrototype:=Hash^.Prototype;
   if assigned(OldPrototype) then begin
    POCAMRSWLockWriteLock(@OldPrototype^.Cache.MRSWLock);
    try
     Previous:=Hash^.Children.Previous;
     Next:=Hash^.Children.Next;
     if assigned(Previous) then begin
      POCAMRSWLockWriteLock(@Previous^.Cache.MRSWLock);
     end;
     try
      if assigned(Next) and (Previous<>Next) then begin
       POCAMRSWLockWriteLock(@Next^.Cache.MRSWLock);
      end;
      try
       if assigned(Previous) then begin
        Previous^.Children.Next:=Next;
       end else if OldPrototype^.Children.First=Hash then begin
        OldPrototype^.Children.First:=Next;
       end;
       if assigned(Next) then begin
        Next^.Children.Previous:=Previous;
       end else if OldPrototype^.Children.Last=Hash then begin
        OldPrototype^.Children.Last:=Previous;
       end;
       Hash^.Children.Previous:=nil;
       Hash^.Children.Next:=nil;
      finally
       if assigned(Next) and (Previous<>Next) then begin
        POCAMRSWLockWriteUnlock(@Next^.Cache.MRSWLock);
       end;
      end;
     finally
      if assigned(Previous) then begin
       POCAMRSWLockWriteUnlock(@Previous^.Cache.MRSWLock);
      end;
     end;
    finally
     POCAMRSWLockWriteUnlock(@OldPrototype^.Cache.MRSWLock);
    end;
   end;
   TPasMPInterlocked.Exchange(TPOCAPointer(Hash^.Prototype),nil);
   POCAHashInvalidate(Hash);
  finally
   POCAMRSWLockWriteUnlock(@Hash^.Cache.MRSWLock);
  end;
 end;
end;

function POCAHashSetPrototype(Context:PPOCAContext;const Hash:TPOCAValue;const Prototype:PPOCAHash):TPOCABool32;
var HashPtr,HashInstance,OldPrototype,Previous,Next,First,Last:PPOCAHash;
begin
 result:=POCAIsValueHash(Hash);
 if result then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if HashInstance^.Prototype<>Prototype then begin
   POCAMRSWLockWriteLock(@HashInstance^.Cache.MRSWLock);
   try
    if assigned(Prototype) then begin
     HashPtr:=HashInstance;
     while assigned(HashPtr) do begin
      if HashPtr=Prototype then begin
       POCARuntimeError(Context,'Recursive prototype chains are not allowed');
       result:=false;
       break;
      end;
      HashPtr:=HashPtr^.Prototype;
     end;
    end;
    if result then begin
     OldPrototype:=HashInstance^.Prototype;
     if assigned(OldPrototype) then begin
      POCAMRSWLockWriteLock(@OldPrototype^.Cache.MRSWLock);
      try
       Previous:=HashInstance^.Children.Previous;
       Next:=HashInstance^.Children.Next;
       if assigned(Previous) then begin
        POCAMRSWLockWriteLock(@Previous^.Cache.MRSWLock);
       end;
       try
        if assigned(Next) and (Previous<>Next) then begin
         POCAMRSWLockWriteLock(@Next^.Cache.MRSWLock);
        end;
        try
         if assigned(Previous) then begin
          Previous^.Children.Next:=Next;
         end else if OldPrototype^.Children.First=HashInstance then begin
          OldPrototype^.Children.First:=Next;
         end;
         if assigned(Next) then begin
          Next^.Children.Previous:=Previous;
         end else if OldPrototype^.Children.Last=HashInstance then begin
          OldPrototype^.Children.Last:=Previous;
         end;
         HashInstance^.Children.Previous:=nil;
         HashInstance^.Children.Next:=nil;
        finally
         if assigned(Next) and (Previous<>Next) then begin
          POCAMRSWLockWriteUnlock(@Next^.Cache.MRSWLock);
         end;
        end;
       finally
        if assigned(Previous) then begin
         POCAMRSWLockWriteUnlock(@Previous^.Cache.MRSWLock);
        end;
       end;
      finally
       POCAMRSWLockWriteUnlock(@OldPrototype^.Cache.MRSWLock);
      end;
     end;
     TPasMPInterlocked.Exchange(TPOCAPointer(HashInstance^.Prototype),TPOCAPointer(Prototype));
     if assigned(Prototype) then begin
      POCAMRSWLockWriteLock(@Prototype^.Cache.MRSWLock);
      try
       First:=Prototype^.Children.First;
       Last:=Prototype^.Children.Last;
       if assigned(First) then begin
        POCAMRSWLockWriteLock(@First^.Cache.MRSWLock);
       end;
       try
        if assigned(Last) and (First<>Last) then begin
         POCAMRSWLockWriteLock(@Last^.Cache.MRSWLock);
        end;
        try
         if assigned(Last) then begin
          HashInstance^.Children.Previous:=Last;
          Last^.Children.Next:=HashInstance;
         end else begin
          HashInstance^.Children.Previous:=nil;
          Prototype^.Children.First:=HashInstance;
         end;
         HashInstance^.Children.Next:=nil;
         Prototype^.Children.Last:=HashInstance;
        finally
         if assigned(Last) and (First<>Last) then begin
          POCAMRSWLockWriteUnlock(@Last^.Cache.MRSWLock);
         end;
        end;
       finally
        if assigned(First) then begin
         POCAMRSWLockWriteUnlock(@First^.Cache.MRSWLock);
        end;
       end;
      finally
       POCAMRSWLockWriteUnlock(@Prototype^.Cache.MRSWLock);
      end;
     end;
     POCAHashInvalidate(HashInstance);
    end;
   finally
    POCAMRSWLockWriteUnlock(@HashInstance^.Cache.MRSWLock);
   end;
  end;
 end;
end;

function POCAHashSetPrototypeValue(Context:PPOCAContext;const Hash,Prototype:TPOCAValue):TPOCABool32;
begin
 case POCAGetValueType(Prototype) of
  pvtHASH:begin
   result:=POCAHashSetPrototype(Context,Hash,PPOCAHash(POCAGetValueReferencePointer(Prototype)));
  end;
  pvtNULL:begin
   result:=POCAHashSetPrototype(Context,Hash,nil);
  end;
  else begin
   POCARuntimeError(Context,'Prototype must be hash or null');
   result:=false;
  end;
 end;
end;

function POCAValueSetPrototypeValue(Context:PPOCAContext;const Hash,Prototype:TPOCAValue;const Level:TPOCAInt32):TPOCABool32;
begin
 result:=false;
 if Level<POCA_PROTOTYPE_RECURSION_LIMIT then begin
  case POCAGetValueType(Hash) of
   pvtARRAY:begin
    result:=POCAValueSetPrototypeValue(Context,Context.Instance^.Globals.ArrayHash,Prototype,Level+1);
   end;
   pvtNUMBER:begin
    result:=POCAValueSetPrototypeValue(Context,Context.Instance^.Globals.NumberHash,Prototype,Level+1);
   end;
   pvtSTRING:begin
    result:=POCAValueSetPrototypeValue(Context,Context.Instance^.Globals.StringHash,Prototype,Level+1);
   end;
   pvtHASH:begin
    case POCAGetValueType(Prototype) of
     pvtHASH:begin
      result:=POCAHashSetPrototype(Context,Hash,PPOCAHash(POCAGetValueReferencePointer(Prototype)));
     end;
     pvtNULL:begin
      result:=POCAHashSetPrototype(Context,Hash,nil);
     end;
     else begin
      POCARuntimeError(Context,'Prototype must be hash or null');
      result:=false;
     end;
    end;
   end;
   else begin
    POCARuntimeError(Context,'Prototype must be non null');
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Prototype recursion overflow');
 end;
end;

function POCAHashGetPrototype(const Hash:TPOCAValue):PPOCAHash;
begin
 result:=nil;
 if POCAIsValueHash(Hash) then begin
  result:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Prototype;
 end;
end;

function POCAHashGetPrototypeValue(const Hash:TPOCAValue):TPOCAValue;
var p:TPOCAPointer;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if POCAIsValueHash(Hash) then begin
  p:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Prototype;
  if assigned(p) then begin
   POCASetValueReferencePointer(result,p);
  end;
 end;
end;

function POCAValueGetPrototypeValue(Context:PPOCAContext;const Hash:TPOCAValue;const Level:TPOCAInt32):TPOCAValue;
var p:TPOCAPointer;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if Level<POCA_PROTOTYPE_RECURSION_LIMIT then begin
  case POCAGetValueType(Hash) of
   pvtARRAY:begin
    result:=POCAValueGetPrototypeValue(Context,Context.Instance^.Globals.ArrayHash,Level+1);
   end;
   pvtNUMBER:begin
    result:=POCAValueGetPrototypeValue(Context,Context.Instance^.Globals.NumberHash,Level+1);
   end;
   pvtSTRING:begin
    result:=POCAValueGetPrototypeValue(Context,Context.Instance^.Globals.StringHash,Level+1);
   end;
   pvtHASH:begin
    p:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Prototype;
    if assigned(p) then begin
     POCASetValueReferencePointer(result,p);
    end;
   end;
   pvtGHOST:begin
    result:=POCAValueGetPrototypeValue(Context,POCAGhostGetHashValue(Hash),Level+1);
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Prototype recursion overflow');
 end;
end;

procedure POCAHashClearConstructor(Hash:PPOCAHash);
begin
 if assigned(Hash) and assigned(Hash^.Constructor_) then begin
  POCAMRSWLockWriteLock(@Hash^.Cache.MRSWLock);
  try
   TPasMPInterlocked.Exchange(TPOCAPointer(Hash^.Constructor_),nil);
   POCAHashInvalidate(Hash);
  finally
   POCAMRSWLockWriteUnlock(@Hash^.Cache.MRSWLock);
  end;
 end;
end;

function POCAHashSetConstructor(Context:PPOCAContext;const Hash:TPOCAValue;const Constructor_:PPOCAObject):TPOCABool32;
var HashInstance:PPOCAHash;
begin
 result:=POCAIsValueHash(Hash);
 if result then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if HashInstance^.Constructor_<>Constructor_ then begin
   POCAMRSWLockWriteLock(@HashInstance^.Cache.MRSWLock);
   try
    TPasMPInterlocked.Exchange(TPOCAPointer(HashInstance^.Constructor_),TPOCAPointer(Constructor_));
    POCAHashInvalidate(HashInstance);
   finally
    POCAMRSWLockWriteUnlock(@HashInstance^.Cache.MRSWLock);
   end;
  end;
 end;
end;

function POCAHashSetConstructorValue(Context:PPOCAContext;const Hash,Constructor_:TPOCAValue):TPOCABool32;
begin
 case POCAGetValueType(Constructor_) of
  pvtHASH:begin
   result:=POCAHashSetConstructor(Context,Hash,PPOCAObject(POCAGetValueReferencePointer(Constructor_)));
  end;
  pvtNULL:begin
   result:=POCAHashSetConstructor(Context,Hash,nil);
  end;
  pvtGHOST:begin
   result:=POCAHashSetConstructorValue(Context,Hash,POCAGhostGetHashValue(Constructor_));
  end;
  else begin
   POCARuntimeError(Context,'Constructor must be hash or null');
   result:=false;
  end;
 end;
end;                                                          

function POCAValueSetConstructorValue(Context:PPOCAContext;const Hash,Constructor_:TPOCAValue;const Level:TPOCAInt32):TPOCABool32;
begin
 result:=false;
 if Level<POCA_CONSTRUCTOR_RECURSION_LIMIT then begin
  case POCAGetValueType(Hash) of
   pvtARRAY:begin
    result:=POCAValueSetConstructorValue(Context,Context.Instance^.Globals.ArrayHash,Constructor_,Level+1);
   end;
   pvtNUMBER:begin
    result:=POCAValueSetConstructorValue(Context,Context.Instance^.Globals.NumberHash,Constructor_,Level+1);
   end;
   pvtSTRING:begin
    result:=POCAValueSetConstructorValue(Context,Context.Instance^.Globals.StringHash,Constructor_,Level+1);
   end;
   pvtHASH:begin
    case POCAGetValueType(Constructor_) of
     pvtHASH,pVTGHOST:begin
      result:=POCAHashSetConstructor(Context,Hash,PPOCAObject(POCAGetValueReferencePointer(Constructor_)));
     end;
     pvtNULL:begin
      result:=POCAHashSetConstructor(Context,Hash,nil);
     end;
     else begin
      POCARuntimeError(Context,'Constructor must be hash, ghost or null');
      result:=false;
     end;
    end;
   end;
   pvtGHOST:begin
    result:=POCAValueSetConstructorValue(Context,POCAGhostGetHashValue(Hash),Constructor_,Level+1);
   end;
   else begin
    POCARuntimeError(Context,'Constructor must be non null');
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Constructor recursion overflow');
 end;
end;

function POCAHashGetConstructor(const Hash:TPOCAValue):PPOCAObject;
begin
 result:=nil;
 if POCAIsValueHash(Hash) then begin
  result:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Constructor_;
 end;
end;

function POCAHashGetConstructorValue(const Hash:TPOCAValue):TPOCAValue;
var p:TPOCAPointer;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if POCAIsValueHash(Hash) then begin
  p:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Constructor_;
  if assigned(p) then begin
   POCASetValueReferencePointer(result,p);
  end;
 end;
end;

function POCAValueGetConstructorValue(Context:PPOCAContext;const Hash:TPOCAValue;const Level:TPOCAInt32):TPOCAValue;
var p:TPOCAPointer;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if Level<POCA_CONSTRUCTOR_RECURSION_LIMIT then begin
  case POCAGetValueType(Hash) of
   pvtARRAY:begin
    result:=POCAValueGetConstructorValue(Context,Context.Instance^.Globals.ArrayHash,Level+1);
   end;
   pvtNUMBER:begin
    result:=POCAValueGetConstructorValue(Context,Context.Instance^.Globals.NumberHash,Level+1);
   end;
   pvtSTRING:begin
    result:=POCAValueGetPrototypeValue(Context,Context.Instance^.Globals.StringHash,Level+1);
   end;
   pvtHASH:begin
    p:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Constructor_;
    if assigned(p) then begin
     POCASetValueReferencePointer(result,p);
    end;     
   end;
   pvtGHOST:begin
    result:=POCAValueGetConstructorValue(Context,POCAGhostGetHashValue(Hash),Level+1);
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Constructor recursion overflow');
 end;
end;

function POCAHashSetHashEvents(Context:PPOCAContext;const ToHash,FromHash:TPOCAValue):TPOCABool32;
var Hashs:array[0..1] of PPOCAHash;
begin
 result:=false;
 if POCAIsValueHash(ToHash) then begin
  Hashs[0]:=PPOCAHash(POCAGetValueReferencePointer(ToHash));
  if POCAIsValueHash(FromHash) then begin
   Hashs[1]:=PPOCAHash(POCAGetValueReferencePointer(FromHash));
   if (not assigned(Hashs[1]^.HashRecord)) or not assigned(Hashs[1]^.HashRecord^.Events) then begin
    POCAHashCreateEvents(Context^.Instance,Hashs[1]);
   end;
   POCAHashLockInvalidate(Hashs[0]);
   TPasMPInterlocked.Exchange(TPOCAPointer(Hashs[0]^.Events),TPOCAPointer(Hashs[1]));
   result:=true;
  end else if POCAIsValueNull(FromHash) then begin
   POCAHashLockInvalidate(Hashs[0]);
   TPasMPInterlocked.Exchange(TPOCAPointer(Hashs[0]^.Events),nil);
   result:=true;
  end;
 end;
end;

function POCAHashGetHashEventsHash(const Hash:TPOCAValue):TPOCAValue;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if POCAIsValueHash(Hash) then begin
  POCASetValueReferencePointer(result,PPOCAHash(POCAGetValueReferencePointer(Hash))^.Events);
 end;
end;

function POCAHashGetHashEvents(const Hash:TPOCAValue):PPOCAHashEvents; overload;
var HashInstance:PPOCAHash;
begin
 result:=nil;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord) then begin
   result:=HashInstance^.Events^.HashRecord^.Events;
  end;
 end else if POCAIsValueGhost(Hash) then begin
  result:=POCAHashGetHashEvents(POCAGhostGetHashValue(Hash));
 end;
end;

function POCAHashGetHashEvents(const Hash:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;
var HashInstance:PPOCAHash;
begin
 result:=nil;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord) then begin
   result:=HashInstance^.Events^.HashRecord^.Events;
   if assigned(result) and not POCAIsValueFunctionOrNativeCode(result[Operation]) then begin
    result:=nil;
   end;
  end;
 end else if POCAIsValueGhost(Hash) then begin
  result:=POCAHashGetHashEvents(POCAGhostGetHashValue(Hash),Operation);
 end;
end;

function POCAHashGetHashEvents(const v1,v2:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;
var Hash:PPOCAHash;
begin
 result:=nil;
 if POCAIsValueHash(v1) then begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(v1));
  if assigned(Hash^.Events) and assigned(Hash^.Events^.HashRecord) then begin
   result:=Hash^.Events^.HashRecord^.Events;
   if assigned(result) and POCAIsValueFunctionOrNativeCode(result[Operation]) then begin
    exit;
   end;
  end;
 end else if POCAIsValueGhost(v1) then begin
  result:=POCAHashGetHashEvents(POCAGhostGetHashValue(v1),v2,Operation);
  exit;
 end;
 if POCAIsValueHash(v2) then begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(v2));
  if (assigned(Hash^.Events) and assigned(Hash^.Events^.HashRecord)) and assigned(Hash^.Events^.HashRecord^.Events) then begin
   result:=Hash^.Events^.HashRecord^.Events;
  end;
 end else if POCAIsValueGhost(v2) then begin
  result:=POCAHashGetHashEvents(v1,POCAGhostGetHashValue(v2),Operation);
 end;
end;

function POCAHashGetHashEvents(const v1,v2,v3:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;
var Hash:PPOCAHash;
begin
 result:=nil;
 if POCAIsValueHash(v1) then begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(v1));
  if assigned(Hash^.Events) and assigned(Hash^.Events^.HashRecord) then begin
   result:=Hash^.Events^.HashRecord^.Events;
   if assigned(result) and POCAIsValueFunctionOrNativeCode(result[Operation]) then begin
    exit;
   end;
  end;
 end else if POCAIsValueGhost(v1) then begin
  result:=POCAHashGetHashEvents(POCAGhostGetHashValue(v1),v2,v3,Operation);
  exit;
 end;
 if POCAIsValueHash(v2) then begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(v2));
  if assigned(Hash^.Events) and assigned(Hash^.Events^.HashRecord) then begin
   result:=Hash^.Events^.HashRecord^.Events;
   if assigned(result) and POCAIsValueFunctionOrNativeCode(result[Operation]) then begin
    exit;
   end;
  end;
 end else if POCAIsValueGhost(v2) then begin
  result:=POCAHashGetHashEvents(v1,POCAGhostGetHashValue(v2),v3,Operation);
  exit;
 end;
 if POCAIsValueHash(v3) then begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(v3));
  if (assigned(Hash^.Events) and assigned(Hash^.Events^.HashRecord)) and assigned(Hash^.Events^.HashRecord^.Events) then begin
   result:=Hash^.Events^.HashRecord^.Events;
  end;
 end else if POCAIsValueGhost(v3) then begin
  result:=POCAHashGetHashEvents(v1,v2,POCAGhostGetHashValue(v3),Operation);
 end;
end;

function POCAHashSetGhost(Context:PPOCAContext;const Hash:TPOCAValue;Ghost:PPOCAGhost):TPOCABool32;
var HashPtr:PPOCAHash;
begin
 result:=POCAIsValueHash(Hash);
 if result then begin
  HashPtr:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  TPasMPInterlocked.Exchange(TPOCAPointer(HashPtr^.Ghost),TPOCAPointer(Ghost));
  POCAHashLockInvalidate(HashPtr);
 end;
end;

function POCAHashSetGhostValue(Context:PPOCAContext;const Hash,Ghost:TPOCAValue):TPOCABool32;
begin
 case POCAGetValueType(Ghost) of
  pvtGHOST:begin
   result:=POCAHashSetGhost(Context,Hash,PPOCAGhost(POCAGetValueReferencePointer(Ghost)));
  end;
  pvtNULL:begin
   result:=POCAHashSetGhost(Context,Hash,nil);
  end;
  else begin
   POCARuntimeError(Context,'Ghost must be hash or null');
   result:=false;
  end;
 end;
end;

function POCAHashGetGhost(const Hash:TPOCAValue):PPOCAGhost;
begin
 result:=nil;
 if POCAIsValueHash(Hash) then begin
  result:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Ghost;
 end;
end;

function POCAHashGetGhostValue(const Hash:TPOCAValue):TPOCAValue;
var p:TPOCAPointer;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if POCAIsValueHash(Hash) then begin
  p:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Ghost;
  if assigned(p) then begin
   POCASetValueReferencePointer(result,p);
  end;
 end;
end;

function POCAHashSetKind(Context:PPOCAContext;const Hash:TPOCAValue;Kind:TPOCAInt32):TPOCABool32;
var HashPtr:PPOCAHash;
begin
 result:=POCAIsValueHash(Hash);
 if result then begin
  HashPtr:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  TPasMPInterlocked.Exchange(HashPtr^.Kind,Kind);
  POCAHashLockInvalidate(HashPtr);
 end;
end;

function POCAHashGetKind(const Hash:TPOCAValue):TPOCAInt32;
begin
 result:=0;
 if POCAIsValueHash(Hash) then begin
  result:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Kind;
 end;
end;

procedure POCAHashPutHashEvents(Hash:PPOCAHash;var HashRec:PPOCAHashRecord;const Key,Value:TPOCAValue);
var Instance:PPOCAInstance;
    Str:PPOCAString;
    Op:TPOCAInt32;
begin
 Instance:=Hash^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance;
 if POCAIsValueString(Key) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(Key));
  if (length(Str^.Data)>2) and ((Str^.Data[1]='_') and (Str^.Data[2]='_')) then begin
   Op:=MetaOpNamesHashMap.GetValue(Str^.Data);
   if Op>=0 then begin
    if not assigned(HashRec^.Events) then begin
     HashRec:=POCAHashCreateEvents(Instance,Hash);
    end;
    if assigned(HashRec^.Events) then begin
     HashRec^.Events[TPOCAMetaOp(Op)]:=Value;
    end;
   end;
   POCAHashLockInvalidate(Hash);
  end;
 end;
end;

procedure POCAHashPut(Hash:PPOCAHash;HashRec:PPOCAHashRecord;const Key,Value:TPOCAValue;const Constant:Boolean);
var Entity:TPOCAInt32;
    Cell:TPOCAUInt32;
begin
 Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
 if Cell<>TPOCAUInt32($ffffffff) then begin
  Entity:=HashRec^.CellToEntityIndex^[Cell];
  if Entity>=0 then begin
   HashRec^.Entities^[Entity].Value:=Value;
   TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(Hash)),Value);
   if assigned(HashRec^.Events) then begin
    POCAHashPutHashEvents(Hash,HashRec,Key,Value);
   end;
   exit;
  end;
 end;
 Entity:=HashRec^.Size;
 TPasMPInterlocked.Increment(HashRec^.Size);
 if Entity<(2 shl HashRec^.LogSize) then begin
  TPasMPInterlocked.Exchange(HashRec^.CellToEntityIndex^[Cell],Entity);
  TPasMPInterlocked.Exchange(HashRec^.EntityToCellIndex^[Entity],Cell);
  TPasMPInterlocked.Increment(HashRec^.RealSize);
  HashRec^.Entities^[Entity].Key:=Key;
  HashRec^.Entities^[Entity].Value:=Value;
  HashRec^.Entities^[Entity].Constant:=Constant;
  TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(Hash)),Value);
  if assigned(HashRec^.Events) then begin
   POCAHashPutHashEvents(Hash,HashRec,Key,Value);
  end;
  POCAHashLockInvalidate(Hash);
 end;
end;

procedure POCAHashPutCache(Hash:PPOCAHash;HashRec:PPOCAHashRecord;const Key,Value:TPOCAValue;const Constant:Boolean;var CacheIndex:TPOCAUInt32);
var Entity:TPOCAInt32;
    Cell:TPOCAUInt32;
begin
 Entity:=CacheIndex;
 if ((TPOCAUInt32(Entity)<TPOCAUInt32(HashRec^.Size)) and (HashRec^.EntityToCellIndex^[Entity]>=0)) and (HashRec^.Entities^[Entity].Key.CastedInt64=Key.CastedInt64) then begin
  HashRec^.Entities^[Entity].Value:=Value;
  TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(Hash)),Value);
  if assigned(HashRec^.Events) then begin
   POCAHashPutHashEvents(Hash,HashRec,Key,Value);
  end;
  exit;
 end;
 Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
 if Cell<>TPOCAUInt32($ffffffff) then begin
  Entity:=HashRec^.CellToEntityIndex^[Cell];
  if Entity>=0 then begin
   TPasMPInterlocked.Exchange(TPOCAInt32(CacheIndex),Entity);
   HashRec^.Entities^[Entity].Value:=Value;
   TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(Hash)),Value);
   if assigned(HashRec^.Events) then begin
    POCAHashPutHashEvents(Hash,HashRec,Key,Value);
   end;
   exit;
  end;
 end;
 Entity:=HashRec^.Size;
 TPasMPInterlocked.Increment(HashRec^.Size);
 if Entity<(2 shl HashRec^.LogSize) then begin
  TPasMPInterlocked.Exchange(TPOCAInt32(CacheIndex),Entity);
  TPasMPInterlocked.Exchange(HashRec^.CellToEntityIndex^[Cell],Entity);
  TPasMPInterlocked.Exchange(HashRec^.EntityToCellIndex^[Entity],Cell);
  TPasMPInterlocked.Increment(HashRec^.RealSize);
  HashRec^.Entities^[Entity].Key:=Key;
  HashRec^.Entities^[Entity].Value:=Value;
  HashRec^.Entities^[Entity].Constant:=Constant;
  TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(Hash)),Value);
  if assigned(HashRec^.Events) then begin
   POCAHashPutHashEvents(Hash,HashRec,Key,Value);
  end;
  POCAHashLockInvalidate(Hash);
 end;
end;

function POCAHashResize(Instance:PPOCAInstance;Hash:PPOCAHash;Events:TPOCABool32=false):PPOCAHashRecord;
var HashRec:PPOCAHashRecord;
    LogSize,Size,Cell,Entity:TPOCAInt32;
    i,j:TPOCAUInt32;
begin
 HashRec:=Hash^.HashRecord;
 LogSize:=0;
 if assigned(HashRec) then begin
  Size:=HashRec^.RealSize;
  while Size<>0 do begin
   Size:=Size shr 1;
   inc(LogSize);
  end;
  if assigned(HashRec^.Events) then begin
   Events:=true;
  end;
 end;
 if LogSize<1 then begin
  LogSize:=1;
 end;
 Size:=POCAHashRecordSize(LogSize,Events);
 GetMem(result,Size);
 FillChar(result^,Size,#0);
 result^.Size:=0;
 result^.RealSize:=0;
 result^.LogSize:=LogSize;
 result^.CellToEntityIndex:=TPOCAPointer(@PPOCAUInt8Array(TPOCAPointer(result))^[sizeof(TPOCAHashRecord)]);
 result^.EntityToCellIndex:=TPOCAPointer(@result^.CellToEntityIndex^[2 shl LogSize]);
 result^.Entities:=TPOCAPointer(@result^.EntityToCellIndex^[2 shl LogSize]);
 if Events then begin
  result^.Events:=TPOCAPointer(@result^.Entities^[2 shl LogSize]);
  if (assigned(HashRec) and assigned(HashRec^.Events)) then begin
   result^.Events^:=HashRec^.Events^;
  end;
 end else begin
  result^.Events:=nil;
 end;
 begin
  i:=0;
  j:=2 shl LogSize;
  while i<j do begin
   result^.CellToEntityIndex^[i]:=ENT_EMPTY;
   result^.EntityToCellIndex^[i]:=CELL_EMPTY;
   inc(i);
  end;
 end;
 if assigned(HashRec) then begin
  i:=0;
  j:=2 shl HashRec^.LogSize;
  while i<j do begin
   Cell:=HashRec^.EntityToCellIndex^[i];
   if Cell>=0 then begin
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity>=0 then begin
     POCAHashPut(Hash,result,HashRec^.Entities^[Entity].Key,HashRec^.Entities^[Entity].Value,HashRec^.Entities^[Entity].Constant);
    end;
   end;
   inc(i);
  end;
 end;
 POCAMRSWLockReadLock(@Hash^.Cache.MRSWLock);
 try
  POCAGarbageCollectorSwapFree(Hash^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,@Hash^.HashRecord,result);
  POCAHashInvalidate(Hash);
 finally
  POCAMRSWLockReadUnlock(@Hash^.Cache.MRSWLock);
 end;
end;

function POCAHashRawSize(const Hash:TPOCAValue):TPOCAInt32;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
begin
 result:=0;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    inc(result,HashRec^.RealSize);
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashRawExist(const Hash:TPOCAValue;const Key:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:TPOCAInt32;
    Cell:TPOCAUInt32;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
    if Cell<>TPOCAUInt32($ffffffff) then begin
     Entity:=HashRec^.CellToEntityIndex^[Cell];
     if Entity>=0 then begin
      result:=true;
      break;
     end;
    end;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashRawGet(const Hash:TPOCAValue;const Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:TPOCAInt32;
    Cell:TPOCAUInt32;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
    if Cell<>TPOCAUInt32($ffffffff) then begin
     Entity:=HashRec^.CellToEntityIndex^[Cell];
     if Entity>=0 then begin
      OutValue:=HashRec^.Entities^[Entity].Value;
      result:=true;
      break;
     end;
    end;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashRawSet(const Hash,Key,Value:TPOCAValue;const Constant:Boolean):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  HashRec:=HashInstance^.HashRecord;
  while (not assigned(HashRec)) or (HashRec^.RealSize>=(1 shl HashRec^.LogSize)) do begin
   HashRec:=POCAHashResize(HashInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,HashInstance,false);
  end;
  if assigned(HashRec) then begin
   POCAHashPut(HashInstance,HashRec,Key,Value,Constant);
   result:=true;
  end;
 end;
end;

function POCAHashRawDelete(const Hash,Key:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Cell:TPOCAUInt32;
    Entity:TPOCAInt32;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  HashRec:=HashInstance^.HashRecord;
  if assigned(HashRec) then begin
   Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
   if Cell<>TPOCAUInt32($ffffffff) then begin
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity>=0 then begin
     TPasMPInterlocked.Exchange(HashRec^.EntityToCellIndex^[Entity],CELL_DELETED);
     TPasMPInterlocked.Exchange(HashRec^.CellToEntityIndex^[Cell],ENT_DELETED);
     TPasMPInterlocked.Decrement(HashRec^.RealSize);
     if assigned(HashRec^.Events) then begin
      POCAHashPutHashEvents(HashInstance,HashRec,Key,POCAValueNull);
     end;
     if HashRec^.RealSize<(1 shl (HashRec^.LogSize-1)) then begin
      POCAHashResize(HashInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,HashInstance,false);
     end;
     POCAHashLockInvalidate(HashInstance);
     result:=true;
    end;
   end;
  end;
 end;
end;

procedure POCAHashRawKeys(const Dst,Hash:TPOCAValue);
var HashRec:PPOCAHashRecord;
    Index,Cell,Entity:TPOCAInt32;
begin
 if POCAIsValueHash(Hash) then begin
  HashRec:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.HashRecord;
  if assigned(HashRec) then begin
   for Index:=0 to (2 shl HashRec^.LogSize)-1 do begin
    Cell:=HashRec^.EntityToCellIndex^[Index];
    if Cell>=0 then begin
     Entity:=HashRec^.CellToEntityIndex^[Cell];
     if Entity>=0 then begin
      POCAArrayPush(Dst,HashRec^.Entities^[Entity].Key);
     end;
    end;
   end;
  end;
 end;
end;

function POCAHashSymbol(Hash:PPOCAHash;Sym:PPOCAString;var OutValue:TPOCAValue):boolean;
var HashRec:PPOCAHashRecord;
    HashCode,Cell,Mask,Step:TPOCAUInt32;
    Entity:TPOCAInt32;
    he:PPOCAHashEntity;
begin
 result:=false;
 HashCode:=Sym^.HashCode;
 if HashCode=0 then begin
  HashCode:=POCAHashString(Sym^.Data);
  TPasMPInterlocked.Exchange(TPOCAInt32(Sym^.HashCode),HashCode);
 end;
 while assigned(Hash) do begin
  HashRec:=Hash^.HashRecord;
  if assigned(HashRec) then begin
   Mask:=(2 shl HashRec^.LogSize)-1;
   Step:=((HashCode shl 1)+1) and Mask;
   if HashRec^.LogSize<>0 then begin
    Cell:=HashCode shr (32-HashRec^.LogSize);
   end else begin
    Cell:=0;
   end;
   repeat
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity<0 then begin
     break;
    end;
    he:=@HashRec^.Entities^[Entity];
    if POCAIsValueObject(he^.Key) and (POCAGetValueReferencePointer(he^.Key)=Sym) then begin
     OutValue:=he^.Value;
     result:=true;
     exit;
    end;
    Cell:=(Cell+Step) and Mask;
   until false;
  end;
  Hash:=Hash^.Prototype;
 end;
end;

function POCAHashSymbolCache(Hash:PPOCAHash;const Sym:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:TPOCAUInt32):TPOCAInt32;
var HashRec:PPOCAHashRecord;
    HashCode,Cell,Mask,Step:TPOCAUInt32;
    Entity:TPOCAInt32;
    he:PPOCAHashEntity;
    Str:PPOCAString;
begin
 result:=0;
 HashCode:=0;
 while assigned(Hash) do begin
  if assigned(Hash^.Events) then begin
   result:=2;
   break;
  end;
  HashRec:=Hash^.HashRecord;
  if assigned(HashRec) then begin
   Mask:=(2 shl HashRec^.LogSize)-1;
   Entity:=CacheIndex;
   if (TPOCAUInt32(Entity)<TPOCAUInt32(HashRec^.Size)) and (HashRec^.EntityToCellIndex^[Entity]>=0) then begin
    he:=@HashRec^.Entities^[Entity];
    if he^.Key.CastedInt64=Sym.CastedInt64 then begin
     OutValue:=he^.Value;
     result:=1;
     exit;
    end;
   end;
   if HashCode=0 then begin
{$ifdef cpu32}
    Str:=Sym.Reference.StringObject;
{$else}
    Str:=PPOCAString(TPOCAPointer(TPOCAPtrUInt(Sym.Reference.Ptr) and POCAValueReferenceMask));
{$endif}
/// Str:=PPOCAString(POCAGetValueReferencePointer(Sym));
    HashCode:=Str^.HashCode;
    if HashCode=0 then begin
     HashCode:=POCAHashString(Str^.Data);
     TPasMPInterlocked.Exchange(TPOCAInt32(Str^.HashCode),HashCode);
    end;
   end;
   Step:=((HashCode shl 1)+1) and Mask;
   if HashRec^.LogSize<>0 then begin
    Cell:=HashCode shr (32-HashRec^.LogSize);
   end else begin
    Cell:=0;
   end;
   repeat
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity<0 then begin
     break;
    end;
    he:=@HashRec^.Entities^[Entity];
    if he^.Key.CastedInt64=Sym.CastedInt64 then begin
     OutValue:=he^.Value;
     TPasMPInterlocked.Exchange(TPOCAInt32(CacheIndex),Entity);
     result:=1;
     exit;
    end;
    Cell:=(Cell+Step) and Mask;
   until false;
  end;
  Hash:=Hash^.Prototype;
 end;
end;

function POCAHashSymbolChainCache(Hash:PPOCAHash;const Sym:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:TPOCAUInt32):TPOCAInt32;
var HashRec:PPOCAHashRecord;
    HashCode,Cell,Mask,Step:TPOCAUInt32;
    Entity,Index:TPOCAInt32;
    he:PPOCAHashEntity;
    Str:PPOCAString;
begin
 result:=0;
 if assigned(Hash) then begin
  if assigned(Hash^.Events) then begin
   result:=2;
  end else begin
   if Hash^.Cache.Ready then begin
    if CacheIndex<>$ffffffff then begin
     POCAMRSWLockReadLock(@Hash^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
     try
{$endif}
      if Hash^.Cache.Ready and assigned(Hash^.Cache.ChainEntities) then begin
       Entity:=CacheIndex;
       if TPOCAUInt32(Entity)<TPOCAUInt32(Hash^.Cache.ChainCount) then begin
        he:=Hash^.Cache.ChainEntities^[Entity];
        if he^.Key.CastedInt64=Sym.CastedInt64 then begin
         OutValue:=he^.Value;
{$ifndef POCAUseSafeMRSWLocks}
         POCAMRSWLockReadUnlock(@Hash^.Cache.MRSWLock);
{$endif}
         result:=1;
         exit;
        end;
       end;
      end;
{$ifdef POCAUseSafeMRSWLocks}
     finally
{$endif}
      POCAMRSWLockReadUnlock(@Hash^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
     end;
{$endif}
    end;
   end else begin
    POCAHashRebuildCache(Hash);
   end;
   Index:=Hash^.Cache.ChainCount;
   Str:=PPOCAString(POCAGetValueReferencePointer(Sym));
   HashCode:=Str^.HashCode;
   if HashCode=0 then begin
    HashCode:=POCAHashString(Str^.Data);
    TPasMPInterlocked.Exchange(TPOCAInt32(Str^.HashCode),HashCode);
   end;
   while assigned(Hash) do begin
    HashRec:=Hash^.HashRecord;
    if assigned(HashRec) then begin
     dec(Index,HashRec^.Size);
     Mask:=(2 shl HashRec^.LogSize)-1;
     Entity:=CacheIndex and Mask;
     Step:=((HashCode shl 1)+1) and Mask;
     if HashRec^.LogSize<>0 then begin
      Cell:=HashCode shr (32-HashRec^.LogSize);
     end else begin
      Cell:=0;
     end;
     repeat
      Entity:=HashRec^.CellToEntityIndex^[Cell];
      if Entity<0 then begin
       break;
      end;
      he:=@HashRec^.Entities^[Entity];
      if he^.Key.CastedInt64=Sym.CastedInt64 then begin
       OutValue:=he^.Value;
       TPasMPInterlocked.Exchange(TPOCAInt32(CacheIndex),Index+Entity);
       result:=1;
       exit;
      end;
      Cell:=(Cell+Step) and Mask;
     until false;
    end;
    Hash:=Hash^.Prototype;
   end;
  end;
 end;
end;

function POCAHashNewSymbol(Instance:PPOCAInstance;Hash:PPOCAHash;const Key,Value:TPOCAValue;const Constant:Boolean):boolean;
var HashRec:PPOCAHashRecord;
    Mask,Step,Cell:TPOCAUInt32;
    Entity:TPOCAInt32;
    s:PPOCAString;
    he:PPOCAHashEntity;
begin
 result:=false;
 HashRec:=Hash^.HashRecord;
 s:=PPOCAString(POCAGetValueReferencePointer(Key));
 if s^.HashCode=0 then begin
  TPasMPInterlocked.Exchange(TPOCAInt32(s^.HashCode),POCAHashString(s^.Data));
 end;
 while (not assigned(HashRec)) or (HashRec^.RealSize>=(1 shl HashRec^.LogSize)) do begin
  HashRec:=POCAHashResize(Instance,Hash,false);
 end;
 Mask:=(2 shl HashRec^.LogSize)-1;
 Step:=((s^.HashCode shl 1)+1) and Mask;
 if HashRec^.LogSize<>0 then begin
  Cell:=s^.HashCode shr (32-HashRec^.LogSize);
 end else begin
  Cell:=0;
 end;
 while HashRec^.CellToEntityIndex^[Cell]<>ENT_EMPTY do begin
  Cell:=(Cell+Step) and Mask;
 end;
 Entity:=HashRec^.Size;
 TPasMPInterlocked.Increment(HashRec^.Size);
 if Entity<(2 shl HashRec^.LogSize) then begin
  TPasMPInterlocked.Exchange(HashRec^.EntityToCellIndex^[Entity],Cell);
  TPasMPInterlocked.Exchange(HashRec^.CellToEntityIndex^[Cell],Entity);
  TPasMPInterlocked.Increment(HashRec^.RealSize);
  he:=@HashRec^.Entities^[Entity];
  he^.Key:=Key;
  he^.Value:=Value;
  he^.Constant:=Constant;
  TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(Hash)),Value);
  if assigned(HashRec^.Events) then begin
   POCAHashPutHashEvents(Hash,HashRec,Key,Value);
  end;
  POCAHashLockInvalidate(Hash);
  result:=true;
 end;
end;

function POCAHashTrySet(Context:PPOCAContext;const Hash,Key,Value:TPOCAValue;const Constant:Boolean):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Cell:TPOCAUInt32;
    Entity:TPOCAInt32;
    SubContext:PPOCAContext;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events[pmoSET]) then begin
   SubContext:=POCAContextSub(Context);
   try
    if POCAGetBooleanValue(SubContext,POCACall(SubContext,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],@Key,1,Hash,POCAValueNull)) then begin
     result:=POCAHashSet(SubContext,Hash,Key,Value,Constant);
    end;
   finally
    POCAContextDestroy(SubContext);
   end;
  end else begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
    if Cell<>TPOCAUInt32($ffffffff) then begin
     Entity:=HashRec^.CellToEntityIndex^[Cell];
     if Entity>=0 then begin
      if HashRec^.Entities^[Entity].Constant then begin
       POCARuntimeError(Context,'Constant write access attempt');
      end else begin
       HashRec^.Entities^[Entity].Value:=Value;
       HashRec^.Entities^[Entity].Constant:=Constant;
       TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(HashInstance)),Value);
       if assigned(HashRec^.Events) then begin
        POCAHashPutHashEvents(HashInstance,HashRec,Key,Value);
       end;
       result:=true;
      end;
     end;
    end;
   end;
  end;
 end;
end;

function POCAHashTrySetCache(Context:PPOCAContext;const Hash,Key,Value:TPOCAValue;const Constant:Boolean;var CacheIndex:TPOCAUInt32):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Cell:TPOCAUInt32;
    Entity:TPOCAInt32;
    SubContext:PPOCAContext;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events[pmoSET]) then begin
   SubContext:=POCAContextSub(Context);
   try
    if POCAGetBooleanValue(SubContext,POCACall(SubContext,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],@Key,1,Hash,POCAValueNull)) then begin
     result:=POCAHashSet(SubContext,Hash,Key,Value,Constant);
    end;
   finally
    POCAContextDestroy(SubContext);
   end;
  end else begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    Entity:=CacheIndex;
    if ((TPOCAUInt32(Entity)<TPOCAUInt32(HashRec^.Size)) and (HashRec^.EntityToCellIndex^[Entity]>=0)) and POCAEqual(HashRec^.Entities^[Entity].Key,Key) then begin
     if HashRec^.Entities^[Entity].Constant then begin
      POCARuntimeError(Context,'Constant write access attempt');
     end else begin
      HashRec^.Entities^[Entity].Value:=Value;
      HashRec^.Entities^[Entity].Constant:=Constant;
      TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(HashInstance)),Value);
      if assigned(HashRec^.Events) then begin
       POCAHashPutHashEvents(HashInstance,HashRec,Key,Value);
      end;
      result:=true;
     end;
     exit;
    end;
    Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
    if Cell<>TPOCAUInt32($ffffffff) then begin
     Entity:=HashRec^.CellToEntityIndex^[Cell];
     if Entity>=0 then begin
      TPasMPInterlocked.Exchange(TPOCAInt32(CacheIndex),Entity);
      if HashRec^.Entities^[Entity].Constant then begin
       POCARuntimeError(Context,'Constant write access attempt');
      end else begin
       HashRec^.Entities^[Entity].Value:=Value;
       HashRec^.Entities^[Entity].Constant:=Constant;
       TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(HashInstance)),Value);
       if assigned(HashRec^.Events) then begin
        POCAHashPutHashEvents(HashInstance,HashRec,Key,Value);
       end;
       result:=true;
      end;
     end;
    end;
   end;
  end;
 end;
end;

function POCAHashSize(Context:PPOCAContext;const Hash:TPOCAValue):TPOCAInt32;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    SubContext:PPOCAContext;
begin
 result:=0;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events[pmoSIZE]) then begin
    SubContext:=POCAContextSub(Context);
    try
     inc(result,trunc(POCAGetNumberValue(SubContext,POCACall(SubContext,HashInstance^.Events^.HashRecord^.Events^[pmoSIZE],nil,0,Hash,POCAValueNull))));
    finally
     POCAContextDestroy(SubContext);
    end;
   end else begin
    HashRec:=HashInstance^.HashRecord;
    if assigned(HashRec) then begin
     inc(result,HashRec^.RealSize);
    end;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashExist(Context:PPOCAContext;const Hash,Key:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:TPOCAInt32;
    Cell:TPOCAUInt32;
    SubContext:PPOCAContext;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoEXIST]) then begin
    SubContext:=POCAContextSub(Context);
    try
     result:=POCAGetBooleanValue(SubContext,POCACall(SubContext,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],@Key,1,Hash,POCAValueNull));
    finally
     POCAContextDestroy(SubContext);
    end;
    if result then begin
     break;
    end;
   end else begin
    HashRec:=HashInstance^.HashRecord;
    if assigned(HashRec) then begin
     Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
     if Cell<>TPOCAUInt32($ffffffff) then begin
      Entity:=HashRec^.CellToEntityIndex^[Cell];
      if Entity>=0 then begin
       result:=true;
       break;
      end;
     end;
    end;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashGetEvent(Context:PPOCAContext;const FuncExist,FuncGet,Hash,Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
var SubContext:PPOCAContext;
    Value:TPOCAValue;
begin
 result:=false;
 SubContext:=POCAContextSub(Context);
 try
  if POCAIsValueFunctionOrNativeCode(FuncExist) then begin
   if POCAGetBooleanValue(SubContext,POCACall(SubContext,FuncExist,@Key,1,Hash,POCAValueNull)) then begin
    OutValue:=POCACall(SubContext,FuncGet,@Key,1,Hash,POCAValueNull);
    result:=true;
   end;
  end else begin
   Value:=POCACall(SubContext,FuncGet,@Key,1,Hash,POCAValueNull);
   if POCAIsValueArray(Value) and (POCAArraySize(Value)=2) then begin
    if POCAGetBooleanValue(SubContext,POCAArrayGet(Value,0)) then begin
     OutValue:=POCAArrayGet(Value,1);
     result:=true;
    end;
   end;
  end;
 finally
  POCAContextDestroy(SubContext);
 end;
end;

function POCAHashGet(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:TPOCAInt32;
    Cell:TPOCAUInt32;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoGET]) then begin
    if POCAHashGetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],HashInstance^.Events^.HashRecord^.Events^[pmoGET],Hash,Key,OutValue) then begin
     result:=true;
     break;
    end;
   end else begin
    HashRec:=HashInstance^.HashRecord;
    if assigned(HashRec) then begin
     Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
     if Cell<>TPOCAUInt32($ffffffff) then begin
      Entity:=HashRec^.CellToEntityIndex^[Cell];
      if Entity>=0 then begin
       OutValue:=HashRec^.Entities^[Entity].Value;
       result:=true;
       break;
      end;
     end;
    end;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashGetInherited(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:TPOCAInt32;
    Cell:TPOCAUInt32;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if assigned(HashInstance) then begin
   HashInstance:=HashInstance^.Prototype;
   while assigned(HashInstance) do begin
    if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoGET]) then begin
     if POCAHashGetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],HashInstance^.Events^.HashRecord^.Events^[pmoGET],Hash,Key,OutValue) then begin
      result:=true;
      break;
     end;
    end else begin
     HashRec:=HashInstance^.HashRecord;
     if assigned(HashRec) then begin
      Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
      if Cell<>TPOCAUInt32($ffffffff) then begin
       Entity:=HashRec^.CellToEntityIndex^[Cell];
       if Entity>=0 then begin
        OutValue:=HashRec^.Entities^[Entity].Value;
        result:=true;
        break;
       end;
      end;
     end;
    end;
    HashInstance:=HashInstance^.Prototype;
   end;
  end;
 end;
end;

function POCAHashGetCache(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:TPOCAUInt32):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity,Index:TPOCAInt32;
    Cell:TPOCAUInt32;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if assigned(HashInstance) then begin
   if assigned(HashInstance^.Prototype) then begin
    if HashInstance^.Cache.Ready then begin
     if CacheIndex<>$ffffffff then begin
      POCAMRSWLockReadLock(@HashInstance^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
      try
{$endif}
       if HashInstance^.Cache.Ready and assigned(HashInstance^.Cache.ChainEntities) then begin
        Entity:=CacheIndex;
        if (TPOCAUInt32(Entity)<TPOCAUInt32(HashInstance^.Cache.ChainCount)) and (HashInstance^.Cache.ChainEntities^[Entity]^.Key.CastedInt64=Key.CastedInt64) then begin
         OutValue:=HashInstance^.Cache.ChainEntities^[Entity]^.Value;
{$ifndef POCAUseSafeMRSWLocks}
         POCAMRSWLockReadUnlock(@HashInstance^.Cache.MRSWLock);
{$endif}
         result:=true;
         exit;
        end;
       end;
{$ifdef POCAUseSafeMRSWLocks}
      finally
{$endif}
       POCAMRSWLockReadUnlock(@HashInstance^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
      end;
{$endif}
     end;
    end else begin
     POCAHashRebuildCache(HashInstance);
    end;
    Index:=HashInstance^.Cache.ChainCount;
    repeat
     if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoGET]) then begin
      if POCAHashGetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],HashInstance^.Events^.HashRecord^.Events^[pmoGET],Hash,Key,OutValue) then begin
       result:=true;
       break;
      end;
     end else begin
      HashRec:=HashInstance^.HashRecord;
      if assigned(HashRec) then begin
       dec(Index,HashRec^.Size);
       Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
       if Cell<>TPOCAUInt32($ffffffff) then begin
        Entity:=HashRec^.CellToEntityIndex^[Cell];
        if Entity>=0 then begin
         TPasMPInterlocked.Exchange(TPOCAInt32(CacheIndex),Index+Entity);
         OutValue:=HashRec^.Entities^[Entity].Value;
         result:=true;
         break;
        end;
       end;
      end;
     end;
     HashInstance:=HashInstance^.Prototype;
    until not assigned(HashInstance);
   end else begin
    if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoGET]) then begin
     if POCAHashGetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],HashInstance^.Events^.HashRecord^.Events^[pmoGET],Hash,Key,OutValue) then begin
      result:=true;
     end;
    end else begin
     HashRec:=HashInstance^.HashRecord;
     if assigned(HashRec) then begin
      if CacheIndex<>$ffffffff then begin
       Entity:=CacheIndex;
       if ((TPOCAUInt32(Entity)<TPOCAUInt32(HashRec^.Size)) and (HashRec^.EntityToCellIndex^[Entity]>=0)) and (HashRec^.Entities^[Entity].Key.CastedInt64=Key.CastedInt64) then begin
        OutValue:=HashRec^.Entities^[Entity].Value;
        result:=true;
        exit;
       end;
      end;
      Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
      if Cell<>TPOCAUInt32($ffffffff) then begin
       Entity:=HashRec^.CellToEntityIndex^[Cell];
       if Entity>=0 then begin
        TPasMPInterlocked.Exchange(TPOCAInt32(CacheIndex),Entity);
        OutValue:=HashRec^.Entities^[Entity].Value;
        result:=true;
       end;
      end;
     end;
    end;
   end;
  end;
 end;
end;

function POCAHashGetInheritedCache(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:TPOCAUInt32):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity,Index:TPOCAInt32;
    Cell:TPOCAUInt32;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if assigned(HashInstance) then begin
   if HashInstance^.Cache.Ready then begin
    if CacheIndex<>$ffffffff then begin
     POCAMRSWLockReadLock(@HashInstance^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
     try
{$endif}
      if HashInstance^.Cache.Ready and assigned(HashInstance^.Cache.ChainEntities) then begin
       Entity:=CacheIndex;
       if (TPOCAUInt32(Entity)<TPOCAUInt32(HashInstance^.Cache.ChainCount)) and (HashInstance^.Cache.ChainEntities^[Entity]^.Key.CastedInt64=Key.CastedInt64) then begin
        OutValue:=HashInstance^.Cache.ChainEntities^[Entity]^.Value;
{$ifndef POCAUseSafeMRSWLocks}
        POCAMRSWLockReadUnlock(@HashInstance^.Cache.MRSWLock);
{$endif}
        result:=true;
        exit;
       end;
      end;
{$ifdef POCAUseSafeMRSWLocks}
     finally
{$endif}
      POCAMRSWLockReadUnlock(@HashInstance^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
     end;
{$endif}
    end;
   end else begin
    POCAHashRebuildCache(HashInstance);
   end;
   Index:=HashInstance^.Cache.ChainCount;
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    dec(Index,HashRec^.Size);
   end;
   HashInstance:=HashInstance^.Prototype;
   while assigned(HashInstance) do begin
    if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoGET]) then begin
     if POCAHashGetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],HashInstance^.Events^.HashRecord^.Events^[pmoGET],Hash,Key,OutValue) then begin
      result:=true;
      break;
     end;
    end else begin
     HashRec:=HashInstance^.HashRecord;
     if assigned(HashRec) then begin
      dec(Index,HashRec^.Size);
      Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
      if Cell<>TPOCAUInt32($ffffffff) then begin
       Entity:=HashRec^.CellToEntityIndex^[Cell];
       if Entity>=0 then begin
        TPasMPInterlocked.Exchange(TPOCAInt32(CacheIndex),Index+Entity);
        OutValue:=HashRec^.Entities^[Entity].Value;
        result:=true;
        break;
       end;
      end;
     end;
    end;
    HashInstance:=HashInstance^.Prototype;
   end;
  end;
 end;
end;

function POCAHashSetEvent(Context:PPOCAContext;const FuncSet,Hash,Key,Value:TPOCAValue):boolean;
var SubContext:PPOCAContext;
    Values:array[0..1] of TPOCAValue;
begin
 SubContext:=POCAContextSub(Context);
 try
  Values[0]:=Key;
  Values[1]:=Value;
  result:=POCAGetBooleanValue(SubContext,POCACall(SubContext,FuncSet,@Values[0],2,Hash,POCAValueNull));
 finally
  POCAContextDestroy(SubContext);
 end;
end;

function POCAHashSet(Context:PPOCAContext;const Hash,Key,Value:TPOCAValue;const Constant:Boolean):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoSET]) then begin
   result:=POCAHashSetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoSET],Hash,Key,Value);
  end else begin
   HashRec:=HashInstance^.HashRecord;
   while (not assigned(HashRec)) or (HashRec^.RealSize>=(1 shl HashRec^.LogSize)) do begin
    HashRec:=POCAHashResize(HashInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,HashInstance,false);
   end;
   if assigned(HashRec) then begin
    POCAHashPut(HashInstance,HashRec,Key,Value,Constant);
    result:=true;
   end;
  end;
 end;
end;

function POCAHashSetCache(Context:PPOCAContext;const Hash,Key,Value:TPOCAValue;const Constant:Boolean;var CacheIndex:TPOCAUInt32):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoSET]) then begin
   result:=POCAHashSetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoSET],Hash,Key,Value);
  end else begin
   HashRec:=HashInstance^.HashRecord;
   while (not assigned(HashRec)) or (HashRec^.RealSize>=(1 shl HashRec^.LogSize)) do begin
    HashRec:=POCAHashResize(HashInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,HashInstance,false);
   end;
   if assigned(HashRec) then begin
    POCAHashPutCache(HashInstance,HashRec,Key,Value,Constant,CacheIndex);
    result:=true;
   end;
  end;
 end;
end;

function POCAHashDeleteEvent(Context:PPOCAContext;const FuncDelete,Hash,Key:TPOCAValue):boolean;
var SubContext:PPOCAContext;
begin
 SubContext:=POCAContextSub(Context);
 try
  result:=POCAGetBooleanValue(SubContext,POCACall(SubContext,FuncDelete,@Key,1,Hash,POCAValueNull));
 finally
  POCAContextDestroy(SubContext);
 end;
end;

function POCAHashDelete(Context:PPOCAContext;const Hash,Key:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:TPOCAInt32;
    Cell:TPOCAUInt32;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoDELETE]) then begin
   result:=POCAHashDeleteEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoDELETE],Hash,Key);
  end else begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
    if Cell<>TPOCAUInt32($ffffffff) then begin
     Entity:=HashRec^.CellToEntityIndex^[Cell];
     if Entity>=0 then begin
      TPasMPInterlocked.Exchange(HashRec^.EntityToCellIndex^[Entity],CELL_DELETED);
      TPasMPInterlocked.Exchange(HashRec^.CellToEntityIndex^[Cell],ENT_DELETED);
      TPasMPInterlocked.Decrement(HashRec^.RealSize);
      if assigned(HashRec^.Events) then begin
       POCAHashPutHashEvents(HashInstance,HashRec,Key,POCAValueNull);
      end;
      if HashRec^.RealSize<(1 shl (HashRec^.LogSize-1)) then begin
       POCAHashResize(HashInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,HashInstance,false);
      end else begin
       POCAHashLockInvalidate(HashInstance);
      end;
      result:=true;
     end;
    end;
   end;
  end;
 end;
end;

procedure POCAHashOwnKeys(Context:PPOCAContext;const Dst,Hash:TPOCAValue);
var HashInstance:PPOCAHash;
    SubContext:PPOCAContext;
begin
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoKEYS]) then begin
   SubContext:=POCAContextSub(Context);
   try
    POCACall(SubContext,HashInstance^.Events^.HashRecord^.Events^[pmoKEYS],@Dst,1,Hash,POCAValueNull);
   finally
    POCAContextDestroy(SubContext);
   end;
  end else begin
   POCAHashRawKeys(Dst,Hash);
  end;
 end;
end;

procedure POCAHashKeys(Context:PPOCAContext;const Dst,Hash:TPOCAValue);
 procedure Combine(const DstHash:TPOCAValue;SrcHash:TPOCAValue);
 var i:TPOCAInt32;
     Keys,Key,DstValue,SrcValue:TPOCAValue;
     HashInstance:PPOCAHash;
 begin
  if POCAIsValueHash(DstHash) and POCAIsValueHash(SrcHash) then begin
   Keys:=POCANewArray(Context);
   POCAHashOwnKeys(Context,Keys,SrcHash);
   for i:=0 to POCAArraySize(Keys)-1 do begin
    Key:=POCAArrayGet(Keys,i);
    if (not POCAHashGet(Context,DstHash,Key,DstValue)) and POCAHashGet(Context,SrcHash,Key,SrcValue) then begin
     POCAHashSet(Context,DstHash,Key,SrcValue,false);
    end;
   end;
   HashInstance:=PPOCAHash(POCAGetValueReferencePointer(SrcHash));
   if assigned(HashInstance) then begin
    HashInstance:=HashInstance^.Prototype;
    while assigned(HashInstance) do begin
     POCASetValueReferencePointer(SrcHash,HashInstance);
     Keys:=POCANewArray(Context);
     POCAHashOwnKeys(Context,Keys,SrcHash);
     for i:=0 to POCAArraySize(Keys)-1 do begin
      Key:=POCAArrayGet(Keys,i);
      if (not POCAHashGet(Context,DstHash,Key,DstValue)) and POCAHashGet(Context,SrcHash,Key,SrcValue) then begin
       POCAHashSet(Context,DstHash,Key,SrcValue,false);
      end;
     end;
     HashInstance:=HashInstance^.Prototype;
    end;
   end;
  end;
 end;
var TempHash:TPOCAValue;
begin
 if POCAIsValueHash(Hash) then begin
  TempHash:=POCANewHash(Context);
  Combine(TempHash,Hash);
  POCAHashOwnKeys(Context,Dst,TempHash);
 end;
end;

function POCAHashGetString(Context:PPOCAContext;const Hash:TPOCAValue;const Key:TPOCARawByteString):TPOCAValue;
begin
 if not (POCAIsValueHash(Hash) and POCAHashGet(Context,Hash,POCANewUniqueString(Context,Key),result)) then begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

procedure POCAHashSetString(Context:PPOCAContext;const Hash:TPOCAValue;const Key:TPOCARawByteString;const Value:TPOCAValue;const Constant:Boolean);
begin
 if POCAIsValueHash(Hash) then begin
  POCAHashSet(Context,Hash,POCANewUniqueString(Context,Key),Value,Constant);
 end;
end;

procedure POCAHashDeleteString(Context:PPOCAContext;const Hash:TPOCAValue;const Key:TPOCARawByteString);
begin
 if POCAIsValueHash(Hash) then begin
  POCAHashDelete(Context,Hash,POCANewUniqueString(Context,Key));
 end;
end;

procedure POCAHashCombine(Context:PPOCAContext;const Hash,Source:TPOCAValue);
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    i,Entity:TPOCAInt32;
    Keys,Key,Value:TPOCAValue;
begin
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Source));
  if assigned(HashInstance^.Events) or assigned(HashInstance^.Prototype) then begin
   Keys:=POCANewArray(Context);
   POCAHashKeys(Context,Keys,Source);
   for i:=0 to POCAArraySize(Keys)-1 do begin
    Key:=POCAArrayGet(Keys,i);
    if POCAHashGet(Context,Source,Key,Value) then begin
     POCAHashSet(Context,Hash,Key,Value,false);
    end;
   end;
   if assigned(HashInstance^.Prototype) then begin
    POCAHashSetPrototype(Context,Hash,HashInstance^.Prototype);
   end;
  end else begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    for i:=0 to (2 shl HashRec^.LogSize)-1 do begin
     Entity:=HashRec^.CellToEntityIndex^[i];
     if Entity>=0 then begin
      Key:=HashRec^.Entities^[Entity].Key;
      Value:=HashRec^.Entities^[Entity].Value;
      POCAHashSet(Context,Hash,Key,Value,HashRec^.Entities^[Entity].Constant);
     end;
    end;
   end;
  end;
 end;
end;

function POCAHashInstanceOf(Context:PPOCAContext;const Hash,OfHash:TPOCAValue):TPOCABool32;
var HashInstance,OfHashInstance:PPOCAHash;
begin
 result:=false;
 if POCAIsValueHash(Hash) and POCAIsValueHash(OfHash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  OfHashInstance:=PPOCAHash(POCAGetValueReferencePointer(OfHash));
  while assigned(HashInstance) do begin
   if HashInstance=OfHashInstance then begin
    result:=true;
    break;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashIs(Context:PPOCAContext;const Hash,OfObject:TPOCAValue):TPOCABool32;
var HashInstance:PPOCAHash;
    OfObjectInstance:PPOCAObject;
begin
 result:=false;
 if POCAIsValueHash(Hash) and POCAIsValueObject(OfObject) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  OfObjectInstance:=PPOCAObject(POCAGetValueReferencePointer(OfObject));
  while assigned(HashInstance) do begin
   if HashInstance^.Constructor_=OfObjectInstance then begin
    result:=true;
    break;
   end;
   if assigned(HashInstance^.Constructor_) then begin
    case HashInstance^.Constructor_^.Header.ValueType of
     pvtHASH:begin
      HashInstance:=PPOCAHash(HashInstance^.Constructor_);
     end;
     pvtGHOST:begin
      HashInstance:=PPOCAGhost(HashInstance^.Constructor_)^.Hash;
     end;
     else begin
      break;
     end;
    end;
   end else begin
    break;
   end;
  end;
 end;
end;

function POCAHashArray(Context:PPOCAContext;const Hash:TPOCAValue):TPOCAValue;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    i,Entity:TPOCAInt32;
    Keys,KeyValuePair,Key,Value:TPOCAValue;    
begin
 if POCAIsValueHash(Hash) then begin
  result:=POCANewArray(Context);
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if assigned(HashInstance) then begin
   if assigned(HashInstance^.Events) or assigned(HashInstance^.Prototype) then begin
    Keys:=POCANewArray(Context);
    POCAHashKeys(Context,Keys,Hash);
    for i:=0 to POCAArraySize(Keys)-1 do begin
     Key:=POCAArrayGet(Keys,i);
     if POCAHashGet(Context,Hash,Key,Value) then begin
      KeyValuePair:=POCANewArray(Context);
      POCAArrayPush(KeyValuePair,Key);
      POCAArrayPush(KeyValuePair,Value);
      POCAArrayPush(result,KeyValuePair);
     end;
    end;
   end else begin
    HashRec:=HashInstance^.HashRecord;
    if assigned(HashRec) then begin
     for i:=0 to (2 shl HashRec^.LogSize)-1 do begin
      Key:=POCAValueNull;
      Value:=POCAValueNull;
      Key.CastedUInt64:=i;
      Entity:=HashRec^.CellToEntityIndex^[i];
      if Entity>=0 then begin
       Key:=HashRec^.Entities^[Entity].Key;
       Value:=HashRec^.Entities^[Entity].Value;
       KeyValuePair:=POCANewArray(Context);
       POCAArrayPush(KeyValuePair,Key);
       POCAArrayPush(KeyValuePair,Value);
       POCAArrayPush(result,KeyValuePair);
      end;
     end;
    end;
   end;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end; 
end;

function POCAObjectInstanceOf(Context:PPOCAContext;const Value,OfValue:TPOCAValue):TPOCABool32; {$ifdef caninline}inline;{$endif}
begin
 if POCAIsValueGhost(Value) then begin
  result:=POCAHashInstanceOf(Context,POCAGhostGetHashValue(Value),OfValue);
 end else begin
  result:=POCAHashInstanceOf(Context,Value,OfValue);
 end;
end;

function POCAObjectIs(Context:PPOCAContext;const Value,OfValue:TPOCAValue):TPOCABool32; {$ifdef caninline}inline;{$endif}
begin
 if POCAIsValueGhost(Value) then begin
  result:=POCAHashIs(Context,POCAGhostGetHashValue(Value),OfValue);
 end else begin
  result:=POCAHashIs(Context,Value,OfValue);
 end;
end;

function POCAInternSymbol(Context:PPOCAContext;Instance:PPOCAInstance;const Symbol:TPOCAValue;const Constant:Boolean):TPOCAValue; {$ifdef caninline}inline;{$endif}
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if not POCAHashGet(Context,Instance.Globals.Symbols,Symbol,result) then begin
  POCAHashSet(Context,Instance.Globals.Symbols,Symbol,Symbol,Constant);
  result:=Symbol;
 end;
end;

procedure POCAContextInit(Context:PPOCAContext);
begin
 Context^.Active:=true;
 Context^.FrameTop:=0;
 if assigned(Context^.TemporarySavedObjects) and (Context^.TemporarySavedObjectSize>32) then begin
  FreeMem(Context^.TemporarySavedObjects);
  Context^.TemporarySavedObjects:=nil;
 end;
 Context^.GrayList.Initialize('Context GrayList');
 Context^.CallDepth:=0;
 Context^.CallParent:=nil;
 Context^.CallChild:=nil;
 Context^.CoroutineData:=nil;
 Context^.ThreadData:=nil;
 Context^.UserData:=nil;
end;

procedure POCADefaultUserIOWrite(const aContext:PPOCAContext;const aString:TPOCAUTF8String);
begin
 System.Write(aString);
end;

procedure POCADefaultUserIOWriteLn(const aContext:PPOCAContext;const aString:TPOCAUTF8String);
begin
 System.WriteLn(aString);
end;

procedure POCADefaultUserIOReadLn(const aContext:PPOCAContext;out aString:TPOCAUTF8String;out aNull:Boolean);
begin
 aNull:=false;
 System.ReadLn(aString);
end;

procedure POCADefaultUserIOFlush(const aContext:PPOCAContext);
begin
{$if defined(fpc) and declared(Flush) and declared(StdOut)}
 System.Flush(StdOut);
{$ifend}
end;

function POCAContextCreate(Instance:PPOCAInstance):PPOCAContext;
begin                     
 POCALockEnter(Instance^.Globals.Lock);
 try
  result:=Instance^.Globals.FreeContexts;
  if assigned(result) then begin
   Instance.Globals.FreeContexts:=result^.NextFree;
   result^.NextFree:=nil;
   result^.Instance:=Instance;
   dec(Instance^.Globals.FreeContextCount);
   POCALockLeave(Instance^.Globals.Lock);
   try
    POCAContextInit(result);
   finally
    POCALockEnter(Instance^.Globals.Lock);
   end;
  end else begin
   POCALockLeave(Instance^.Globals.Lock);
   try
    GetMem(result,sizeof(TPOCAContext));
    FillChar(result^,sizeof(TPOCAContext),#0);
    result^.Instance:=Instance;
    result^.GarbageCollectorLockCount:=0;
    POCAContextInit(result);
   finally
    POCALockEnter(Instance^.Globals.Lock);
   end;
   result^.Previous:=Instance^.Globals.LastContext;
   if assigned(result^.Previous) then begin
    result^.Previous^.Next:=result;
   end else begin
    Instance^.Globals.FirstContext:=result;
   end;
   result^.Next:=nil;
   Instance^.Globals.LastContext:=result;
   result^.NextFree:=nil;
  end;
  result^.UserIOWrite:=POCADefaultUserIOWrite;
  result^.UserIOWriteLn:=POCADefaultUserIOWriteLn;
  result^.UserIOReadLn:=POCADefaultUserIOReadLn;
  result^.UserIOFlush:=POCADefaultUserIOFlush;
 finally
  POCALockLeave(Instance^.Globals.Lock);
 end;
end;

{$if defined(POCAMemoryPools)}
procedure POCAContextReleaseObjectPool(Context:PPOCAContext;IgnoreContextObjectPool:PPOCAContextObjectPool);
var ValueType:TPOCAInt32;
    ContextObjectPool:PPOCAContextObjectPool;
    Pool:PPOCAPool;
begin
 if assigned(Context) then begin
  for ValueType:=0 to pvtCOUNT-1 do begin
   ContextObjectPool:=@Context^.ContextObjectPools[ValueType];
   if (ContextObjectPool<>IgnoreContextObjectPool) and assigned(ContextObjectPool^.Objects) and (ContextObjectPool^.Count>0) then begin
    POCALockEnter(Context^.Instance^.Globals.Lock);
    try
     Pool:=@Context^.Instance^.Globals.Pools[ValueType];
     while ContextObjectPool^.Count>0 do begin
      dec(ContextObjectPool^.Count);
      Pool^.FreeObjects^[Pool^.FreeCount]:=ContextObjectPool^.Objects^[ContextObjectPool^.Count];
      inc(Pool^.FreeCount);
     end;
    finally
     POCALockLeave(Context^.Instance^.Globals.Lock);
    end;
   end;
  end;
 end;
end;

procedure POCAReleaseContextObjectPools(Instance:PPOCAInstance;IgnoreContextObjectPool:PPOCAContextObjectPool);
var Context:PPOCAContext;
begin
 Context:=Instance^.Globals.FreeContexts;
 while assigned(Context) do begin
  POCAContextReleaseObjectPool(Context,IgnoreContextObjectPool);
  Context:=Context^.NextFree;
 end;
end;
{$ifend}

procedure POCAContextFree(Context:PPOCAContext);
var i:TPOCAInt32;
{$if defined(POCAMemoryPools)}
    ContextObjectPool:PPOCAContextObjectPool;
{$ifend}
begin
 if assigned(Context^.Previous) then begin
  Context^.Previous^.Next:=Context^.Next;
 end else if Context^.Instance^.Globals.FirstContext=Context then begin
  Context^.Instance^.Globals.FirstContext:=Context^.Next;
 end;
 if assigned(Context^.Next) then begin
  Context^.Next^.Previous:=Context^.Previous;
 end else if Context^.Instance^.Globals.FirstContext=Context then begin
  Context^.Instance^.Globals.LastContext:=Context^.Previous;
 end;
 Context^.Previous:=nil;
 Context^.Next:=nil;
 if assigned(Context^.NextFree) then begin
  Context^.Instance^.Globals.FreeContexts:=Context^.NextFree;
  Context^.NextFree:=nil;
 end;
 if assigned(Context^.TemporarySavedObjects) then begin
  FreeMem(Context^.TemporarySavedObjects);
  Context^.TemporarySavedObjects:=nil;
 end;
 for i:=0 to POCA_MAX_RECURSION-1 do begin
  Context^.FrameStack[i].Registers:=nil;
  Context^.FrameStack[i].Arguments:=nil;
{$ifndef POCAClosureArrayValues}
  Context^.FrameStack[i].LocalValues:=nil;
  Context^.FrameStack[i].OuterValueLevels:=nil;
{$endif}
 end;
{$if defined(POCAMemoryPools)}
 for i:=0 to pvtCOUNT-1 do begin
  ContextObjectPool:=@Context^.ContextObjectPools[i];
  if assigned(ContextObjectPool^.Objects) then begin
   FreeMem(ContextObjectPool^.Objects);
   ContextObjectPool^.Objects:=nil;
  end;
 end;
{$ifend}
 Finalize(Context^);
 FreeMem(Context);
end;

procedure POCAContextDestroy(Context:PPOCAContext);
//var Obj:PPOCAObject;
begin
 if assigned(Context) then begin
  while Context^.GarbageCollectorLockCount>0 do begin
   POCAGarbageCollectorUnlock(Context);
  end;
  if assigned(Context^.GrayList.First) then begin
   POCALockEnter(Context^.Instance^.Globals.Lock);
   try
    Context^.Instance.Globals.GarbageCollector.GrayList.TakeOverAppend(@Context^.GrayList);
   finally
    POCALockLeave(Context^.Instance^.Globals.Lock);
   end;
  end;
  Context^.TemporarySavedObjectCount:=0;
  Context^.CoroutineData:=nil;
  Context^.ThreadData:=nil;
  if assigned(Context^.CallChild) then begin
   POCAContextDestroy(Context^.CallChild);
   Context^.CallChild:=nil;
  end;
  if assigned(Context^.CallParent) then begin
   Context^.CallParent^.CallChild:=nil;
  end;
  Context^.CallDepth:=0;
  POCALockEnter(Context^.Instance^.Globals.Lock);
  try
   if Context^.Instance^.Globals.FreeContextCount<Context^.Instance^.Globals.GarbageCollector.ContextCacheSize then begin
    inc(Context^.Instance^.Globals.FreeContextCount);
    Context^.NextFree:=Context^.Instance^.Globals.FreeContexts;
    Context^.Instance^.Globals.FreeContexts:=Context;
   end else begin
{$if defined(POCAMemoryPools)}
    POCAContextReleaseObjectPool(Context,nil);
{$ifend}
    POCAContextFree(Context);
   end;
  finally
   POCALockLeave(Context^.Instance^.Globals.Lock);
  end;
 end;
end;

function POCAContextSub(Super:PPOCAContext):PPOCAContext;
begin
 if (Super^.CallDepth+1)>=POCA_MAX_RECURSION then begin
  POCARuntimeError(Super,'Call sub context overflow');
 end;
 result:=POCAContextCreate(Super^.Instance);
 if assigned(Super^.CallChild) then begin
  POCAContextDestroy(Super^.CallChild);
 end;
 result^.CallDepth:=Super^.CallDepth+1;
 result^.CallParent:=Super;
 Super^.CallChild:=result;
end;

function POCAStringDump(Context:PPOCAContext;const ToDumpValue:TPOCAValue):TPOCARawByteString;
var OutputString:TPOCARawByteString;
 procedure DumpValue(const Value:TPOCAValue);
 var i:TPOCAInt32;
     Keys,Temp:TPOCAValue;
 begin
  case POCAGetValueType(Value) of
   pvtNULL:begin
    OutputString:=OutputString+'null';
   end;
   pvtREFERENCE:begin
    OutputString:=OutputString+'reference';
   end;
   pvtNUMBER:begin
    OutputString:=OutputString+POCADoubleToString(POCAGetNumberValue(Context,Value));
   end;
   pvtSTRING:begin
    OutputString:=OutputString+'"'+POCAGetStringValue(Context,Value)+'"';
   end;
   pvtARRAY:begin
    OutputString:=OutputString+'[';
    for i:=0 to POCAArraySize(Value)-1 do begin
     if i>0 then begin
      OutputString:=OutputString+',';
     end;
     DumpValue(POCAArrayGet(Value,i));
    end;
    OutputString:=OutputString+']';
   end;
   pvtHASH:begin
    OutputString:=OutputString+'{';
    Keys:=POCANewArray(Context);
    POCAHashKeys(Context,Keys,Value);
    POCAArraySort(Context,Keys);
    if POCAIsValueArray(Keys) then begin
     for i:=0 to POCAArraySize(Keys)-1 do begin
      if i>0 then begin
       OutputString:=OutputString+',';
      end;
      Temp:=POCAArrayGet(Keys,i);
      if Temp.CastedUInt64<>Value.CastedUInt64 then begin
       DumpValue(Temp);
      end else begin
       OutputString:=OutputString+'[self]';
      end;
      OutputString:=OutputString+':';
      Temp.Num:=0;
      POCAHashGet(Context,Value,POCAArrayGet(Keys,i),Temp);
      if Temp.CastedUInt64<>Value.CastedUInt64 then begin
       DumpValue(Temp);
      end else begin
       OutputString:=OutputString+'[self]';
      end;
     end;
     OutputString:=OutputString+'}';
    end;
   end;
   pvtFUNCTION:begin
    OutputString:=OutputString+'function';
   end;
   pvtGHOST:begin
    OutputString:=OutputString+'ghost';
    if assigned(POCAGhostGetHash(Value)) then begin
     DumpValue(POCAGhostGetHashValue(Value));
    end;
   end;
   pvtCODE:begin
    OutputString:=OutputString+'code';
   end;
   pvtNATIVECODE:begin
    OutputString:=OutputString+'nativecode';
   end;
   else begin
    OutputString:=OutputString+'undefined';
   end;
  end;
 end;
begin
 OutputString:='';
 DumpValue(ToDumpValue);
 result:=OutputString;
end;

function POCAGarbageCollectorFunctionGETDYNAMICTHRESHOLD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.DynamicThreshold) and 1;
end;

function POCAGarbageCollectorFunctionGETINCREMENTALCOLLECTIONTHRESHOLDFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.IncrementalCollectionThresholdFactor/256.0;
end;

function POCAGarbageCollectorFunctionGETFULLCOLLECTIONTHRESHOLDFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.FullCollectionThresholdFactor/256.0;
end;

function POCAGarbageCollectorFunctionGETMARKFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.MarkFactor/256.0;
end;

function POCAGarbageCollectorFunctionGETGHOSTFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.GhostFactor/256.0;
end;

function POCAGarbageCollectorFunctionGETSWEEPFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.SweepFactor/256.0;
end;

function POCAGarbageCollectorFunctionGETPERSISTENTINTERVAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.PersistentInterval;
end;

function POCAGarbageCollectorFunctionGETPERSISTENTTHRESHOLD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.PersistentThreshold;
end;

function POCAGarbageCollectorFunctionGETEXHAUSTIONCOLLECT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.ExhaustionCollect) and 1;
end;

function POCAGarbageCollectorFunctionGETEXHAUSTIONINCREMENTALFULLCYCLETHRESHOLD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.ExhaustionIncrementalFullCycleThreshold;
end;

function POCAGarbageCollectorFunctionGETACTIVE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.Active) and 1;
end;

function POCAGarbageCollectorFunctionGETINCREMENTAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.Incremental) and 1;
end;

function POCAGarbageCollectorFunctionGETGENERATIONAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.Generational) and 1;
end;

function POCAGarbageCollectorFunctionGETLOCALCONTEXTPOOLSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.LocalContextPoolSize;
end;

function POCAGarbageCollectorFunctionGETCONTEXTCACHESIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.ContextCacheSize;
end;

function POCAGarbageCollectorFunctionGETMINIMUMBLOCKSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.MinimumBlockSize;
end;

function POCAGarbageCollectorFunctionSETDYNAMICTHRESHOLD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setDynamicThreshold"');
 end;
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.DynamicThreshold) and 1;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.DynamicThreshold,TPasMPBool32(POCAGetBooleanValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETINCREMENTALCOLLECTIONTHRESHOLDFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setIncrementalCollectionThresholdFactor"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.IncrementalCollectionThresholdFactor/256.0;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.IncrementalCollectionThresholdFactor,trunc(POCAGetNumberValue(Context,Arguments^[0])*256.0));
end;

function POCAGarbageCollectorFunctionSETFULLCOLLECTIONTHRESHOLDFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setFullCollectionThresholdFactor"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.FullCollectionThresholdFactor/256.0;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.FullCollectionThresholdFactor,trunc(POCAGetNumberValue(Context,Arguments^[0])*256.0));
end;

function POCAGarbageCollectorFunctionSETMARKFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setMarkFactor"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.MarkFactor/256.0;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.MarkFactor,trunc(POCAGetNumberValue(Context,Arguments^[0])*256.0));
end;

function POCAGarbageCollectorFunctionSETGHOSTFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setGhostFactor"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.GhostFactor/256.0;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.GhostFactor,trunc(POCAGetNumberValue(Context,Arguments^[0])*256.0));
end;

function POCAGarbageCollectorFunctionSETSWEEPFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setSweepFactor"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.SweepFactor/256.0;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.SweepFactor,trunc(POCAGetNumberValue(Context,Arguments^[0])*256.0));
end;

function POCAGarbageCollectorFunctionSETPERSISTENTINTERVAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setPersistentInterval"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.PersistentInterval;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.PersistentInterval,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETPERSISTENTTHRESHOLD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setPersistentThreshold"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.PersistentThreshold;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.PersistentThreshold,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETEXHAUSIONCOLLECT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setExhaustionCollect"');
 end;
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.ExhaustionCollect) and 1;
 TPasMPInterlocked.Exchange(TPOCAInt32(Context^.Instance^.Globals.GarbageCollector.ExhaustionCollect),TPOCAInt32(TPOCABool32(ord(trunc(POCAGetNumberValue(Context,Arguments^[0]))<>0) and 1)));
end;

function POCAGarbageCollectorFunctionSETEXHAUSIONINCREMENTALFULLCYCLETHRESHOLD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setExhaustionIncrementalFullCycleThreshold"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.ExhaustionIncrementalFullCycleThreshold;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.ExhaustionIncrementalFullCycleThreshold,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETACTIVE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setActive"');
 end;
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.Active) and 1;
 TPasMPInterlocked.Exchange(TPOCAInt32(Context^.Instance^.Globals.GarbageCollector.Active),TPOCAInt32(TPOCABool32(ord(trunc(POCAGetNumberValue(Context,Arguments^[0]))<>0) and 1)));
end;

function POCAGarbageCollectorFunctionSETINCREMENTAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setIncremental"');
 end;
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.Incremental) and 1;
 TPasMPInterlocked.Exchange(TPOCAInt32(Context^.Instance^.Globals.GarbageCollector.Incremental),TPOCAInt32(TPOCABool32(ord(trunc(POCAGetNumberValue(Context,Arguments^[0]))<>0) and 1)));
end;

function POCAGarbageCollectorFunctionSETGENERATIONAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setGenerational"');
 end;
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.Generational) and 1;
 TPasMPInterlocked.Exchange(TPOCAInt32(Context^.Instance^.Globals.GarbageCollector.Generational),TPOCAInt32(TPOCABool32(ord(trunc(POCAGetNumberValue(Context,Arguments^[0]))<>0) and 1)));
end;

function POCAGarbageCollectorFunctionSETLOCALCONTEXTPOOLSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setLocalContextSize"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.LocalContextPoolSize;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.LocalContextPoolSize,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETCONTEXTCACHESIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setContextCacheSize"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.ContextCacheSize;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.ContextCacheSize,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETMINIMUMBLOCKSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "garbagecollector.setMinimumBlockSize"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.MinimumBlockSize;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.MinimumBlockSize,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionCOLLECT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 Context^.Instance^.Globals.RequestGarbageCollection:=prgcFULL;
 POCAGarbageCollectorDoBottleneck(Context^.Instance);
 result.Num:=1;
end;

function POCAGarbageCollectorFunctionCYCLE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 Context^.Instance^.Globals.RequestGarbageCollection:=prgcCYCLE;
 POCAGarbageCollectorDoBottleneck(Context^.Instance);
 result.Num:=1;
end;

function POCAGarbageCollectorFunctionALLOCATED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.Allocated;
end;

function POCAGarbageCollectorFunctionUSED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=POCAGarbageCollectorUsed(Context^.Instance);
end;

function POCAGarbageCollectorFunctionFree(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=POCAGarbageCollectorFree(Context^.Instance);
end;

function POCAInitGarbageCollectorNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'getDynamicThreshold',POCAGarbageCollectorFunctionGETDYNAMICTHRESHOLD);
 POCAAddNativeFunction(Context,result,'getIncrementalCollectionThresholdFactor',POCAGarbageCollectorFunctionGETINCREMENTALCOLLECTIONTHRESHOLDFACTOR);
 POCAAddNativeFunction(Context,result,'getFullCollectionThresholdFactor',POCAGarbageCollectorFunctionGETFULLCOLLECTIONTHRESHOLDFACTOR);
 POCAAddNativeFunction(Context,result,'getMarkFactor',POCAGarbageCollectorFunctionGETMARKFACTOR);
 POCAAddNativeFunction(Context,result,'getGhostFactor',POCAGarbageCollectorFunctionGETGHOSTFACTOR);
 POCAAddNativeFunction(Context,result,'getSweepFactor',POCAGarbageCollectorFunctionGETSWEEPFACTOR);
 POCAAddNativeFunction(Context,result,'getPersistentInterval',POCAGarbageCollectorFunctionGETPERSISTENTINTERVAL);
 POCAAddNativeFunction(Context,result,'getPersistentThreshold',POCAGarbageCollectorFunctionGETPERSISTENTTHRESHOLD);
 POCAAddNativeFunction(Context,result,'getExhaustionCollect',POCAGarbageCollectorFunctionGETEXHAUSTIONCOLLECT);
 POCAAddNativeFunction(Context,result,'getExhaustionIncrementalFullCycleThreshold',POCAGarbageCollectorFunctionGETEXHAUSTIONINCREMENTALFULLCYCLETHRESHOLD);
 POCAAddNativeFunction(Context,result,'getActive',POCAGarbageCollectorFunctionGETACTIVE);
 POCAAddNativeFunction(Context,result,'getIncremental',POCAGarbageCollectorFunctionGETINCREMENTAL);
 POCAAddNativeFunction(Context,result,'getGenerational',POCAGarbageCollectorFunctionGETGENERATIONAL);
 POCAAddNativeFunction(Context,result,'getLocalContextPoolSize',POCAGarbageCollectorFunctionGETLOCALCONTEXTPOOLSIZE);
 POCAAddNativeFunction(Context,result,'getContextCacheSize',POCAGarbageCollectorFunctionGETCONTEXTCACHESIZE);
 POCAAddNativeFunction(Context,result,'getMinimumBlockSize',POCAGarbageCollectorFunctionGETMINIMUMBLOCKSIZE);
 POCAAddNativeFunction(Context,result,'setDynamicThreshold',POCAGarbageCollectorFunctionSETDYNAMICTHRESHOLD);
 POCAAddNativeFunction(Context,result,'setIncrementalCollectionThresholdFactor',POCAGarbageCollectorFunctionSETINCREMENTALCOLLECTIONTHRESHOLDFACTOR);
 POCAAddNativeFunction(Context,result,'setFullCollectionThresholdFactor',POCAGarbageCollectorFunctionSETFULLCOLLECTIONTHRESHOLDFACTOR);
 POCAAddNativeFunction(Context,result,'setMarkFactor',POCAGarbageCollectorFunctionSETMARKFACTOR);
 POCAAddNativeFunction(Context,result,'setGhostFactor',POCAGarbageCollectorFunctionSETGHOSTFACTOR);
 POCAAddNativeFunction(Context,result,'setSweepFactor',POCAGarbageCollectorFunctionSETSWEEPFACTOR);
 POCAAddNativeFunction(Context,result,'setPersistentInterval',POCAGarbageCollectorFunctionSETPERSISTENTINTERVAL);
 POCAAddNativeFunction(Context,result,'setPersistentThreshold',POCAGarbageCollectorFunctionSETPERSISTENTTHRESHOLD);
 POCAAddNativeFunction(Context,result,'setExhaustionCollect',POCAGarbageCollectorFunctionSETEXHAUSIONCOLLECT);
 POCAAddNativeFunction(Context,result,'setExhaustionIncrementalFullCycleThreshold',POCAGarbageCollectorFunctionSETEXHAUSIONINCREMENTALFULLCYCLETHRESHOLD);
 POCAAddNativeFunction(Context,result,'setActive',POCAGarbageCollectorFunctionSETACTIVE);
 POCAAddNativeFunction(Context,result,'setIncremental',POCAGarbageCollectorFunctionSETINCREMENTAL);
 POCAAddNativeFunction(Context,result,'setGenerational',POCAGarbageCollectorFunctionSETGENERATIONAL);
 POCAAddNativeFunction(Context,result,'setLocalContextPoolSize',POCAGarbageCollectorFunctionSETLOCALCONTEXTPOOLSIZE);
 POCAAddNativeFunction(Context,result,'setContextCacheSize',POCAGarbageCollectorFunctionSETCONTEXTCACHESIZE);
 POCAAddNativeFunction(Context,result,'setMinimumBlockSize',POCAGarbageCollectorFunctionSETMINIMUMBLOCKSIZE);
 POCAAddNativeFunction(Context,result,'collect',POCAGarbageCollectorFunctionCOLLECT);
 POCAAddNativeFunction(Context,result,'cycle',POCAGarbageCollectorFunctionCYCLE);
 POCAAddNativeFunction(Context,result,'allocated',POCAGarbageCollectorFunctionALLOCATED);
 POCAAddNativeFunction(Context,result,'used',POCAGarbageCollectorFunctionUSED);
 POCAAddNativeFunction(Context,result,'free',POCAGarbageCollectorFunctionFREE);
end;

function POCACleanModuleName(const aModuleFileName:TPOCAUTF8String):TPOCAUTF8String;
begin
 result:=StringReplace(ChangeFileExt(ExtractFileName(aModuleFileName),''),'\','/',[rfReplaceAll]);
end;

function POCAGlobalFunctionIMPORTREQUIRE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer;const IsRequire:Boolean):TPOCAValue;
var ModuleLoaderFunctionIndex:TPOCAInt32;
    Index:TPOCAUInt32;
    SubContext:PPOCAContext;
    Code,Imports,ModuleScope,Import,Value,ExportValue,ModuleValue,ModuleTime:TPOCAValue;
    ModuleName,CleanedModuleName,ModuleFileName,ModuleCode:TPOCAUTF8String;
    ModuleDateTime:TDateTime;
    ImportName:TPOCARawByteString;
    Frame:PPOCAFrame;
    OK,All,AllowReloadIfNewer:Boolean;
begin

 if CountArguments<1 then begin
  if IsRequire then begin
   POCARuntimeError(Context,'Bad arguments to "require"');
  end else begin
   POCARuntimeError(Context,'Bad arguments to "import"');
  end;
 end;

 if (CountArguments>1) and not IsRequire then begin
  Imports:=Arguments^[1];
 end else begin
//Imports:=POCAValueNull;
  Imports.CastedUInt64:=POCAValueNullCastedUInt64;
 end;

 if IsRequire then begin
  if CountArguments>1 then begin
   AllowReloadIfNewer:=POCAGetBooleanValue(Context,Arguments^[1]);
  end else begin
   AllowReloadIfNewer:=false;
  end;
 end else begin
  if CountArguments>2 then begin
   AllowReloadIfNewer:=POCAGetBooleanValue(Context,Arguments^[2]);
  end else begin
   AllowReloadIfNewer:=false;
  end;
 end;

 ModuleName:=POCAGetStringValue(Context,Arguments^[0]);

 CleanedModuleName:=POCACleanModuleName(ModuleName);

 ModuleScope:=POCAHashGetString(Context,Context^.Instance^.Globals.ModuleScopes,CleanedModuleName);
 ModuleValue:=POCAHashGetString(Context,Context^.Instance^.Globals.ModuleValues,CleanedModuleName);
 ModuleTime:=POCAHashGetString(Context,Context^.Instance^.Globals.ModuleTimes,CleanedModuleName);

 OK:=false;

 ModuleFileName:=ModuleName;
 ModuleCode:='';
 ModuleDateTime:=0.0;

 if AllowReloadIfNewer and not (POCAIsValueNull(ModuleScope) and POCAIsValueNull(ModuleValue) and POCAIsValueNull(ModuleTime)) then begin
  for ModuleLoaderFunctionIndex:=0 to Context^.Instance^.Globals.CountModuleLoaderFunctions-1 do begin
   if Context^.Instance^.Globals.ModuleLoaderFunctions[ModuleLoaderFunctionIndex](Context,ModuleName,ModuleCode,ModuleFileName,ModuleDateTime) then begin
    OK:=true;
    break;
   end;
  end;
  if OK then begin
   if POCAGetNumberValue(Context,ModuleTime)<ModuleDateTime then begin
    ModuleScope.CastedUInt64:=POCAValueNullCastedUInt64;
    ModuleValue.CastedUInt64:=POCAValueNullCastedUInt64;
    ModuleTime.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
 end;

 if POCAIsValueNull(ModuleScope) and POCAIsValueNull(ModuleValue) and POCAIsValueNull(ModuleTime) then begin

  if not OK then begin
   for ModuleLoaderFunctionIndex:=0 to Context^.Instance^.Globals.CountModuleLoaderFunctions-1 do begin
    if Context^.Instance^.Globals.ModuleLoaderFunctions[ModuleLoaderFunctionIndex](Context,ModuleName,ModuleCode,ModuleFileName,ModuleDateTime) then begin
     OK:=true;
     break;
    end;
   end;
  end;

  if OK then begin
   SubContext:=POCAContextSub(Context);
   try
    ModuleScope:=POCANewHash(SubContext);
    Code:=POCABindToContext(Context,POCACompile(Context^.Instance,SubContext,ModuleCode,ModuleFileName));
    POCAProtect(Context,ModuleScope);
    try
     POCAHashSetString(Context,ModuleScope,'exports',POCANewHash(SubContext));
     ModuleValue:=POCACall(SubContext,Code,nil,0,POCAValueNull,ModuleScope);
     POCAHashSetString(Context,Context^.Instance^.Globals.ModuleValues,CleanedModuleName,ModuleValue);
     POCAHashSetString(Context,Context^.Instance^.Globals.ModuleScopes,CleanedModuleName,ModuleScope);
     POCAHashSetString(Context,Context^.Instance^.Globals.ModuleTimes,CleanedModuleName,POCANewNumber(Context,ModuleDateTime));
    finally
     POCAUnprotect(Context,ModuleScope);
    end;
   finally
    POCAContextDestroy(SubContext);
   end;
  end else begin
   result.CastedUInt64:=POCAValueNullCastedUInt64;
   POCARuntimeError(Context,'Module "'+ModuleName+'" not found!');
  end;

 end;

 if IsRequire then begin

  result:=ModuleValue;

 end else begin

  Frame:=@Context^.FrameStack[Context^.FrameTop-1];

  if POCAIsValueHash(ModuleScope) and POCAIsValueHash(Frame^.Locals) then begin

   POCAHashSetString(Context,Frame^.Locals,ModuleName,ModuleScope);

   if POCAIsValueArray(Imports) then begin

    All:=false;

    for Index:=1 to POCAArraySize(Imports) do begin
     Import:=POCAArrayGet(Imports,Index-1);
     ImportName:=POCAGetStringValue(Context,Import);
     if (ImportName='*') or (ImportName='all') then begin
      All:=true;
      break;
     end;
    end;

    if All then begin
     Imports:=POCANewArray(Context);
     POCAHashOwnKeys(Context,Imports,ModuleScope);
    end;

    ExportValue:=POCAHashGetString(Context,ModuleScope,'exports');
    if (not POCAIsValueHash(ExportValue)) or (POCAHashRawSize(ExportValue)=0) then begin
     ExportValue:=ModuleScope;
    end;

    for Index:=1 to POCAArraySize(Imports) do begin
     Import:=POCAArrayGet(Imports,Index-1);
     ImportName:=POCAGetStringValue(Context,Import);
     if length(ImportName)>0 then begin
      Value:=POCAHashGetString(Context,ExportValue,ImportName);
      if not POCAIsValueNull(Value) then begin
       POCAHashSetString(Context,Frame^.Locals,ImportName,Value);
      end;
     end;
    end;

    result:=ExportValue;

   end else begin

    result:=ModuleScope;

   end;

  end else begin

   result.CastedUInt64:=POCAValueNullCastedUInt64;
   POCARuntimeError(Context,'Import of module "'+ModuleName+'" failed!');

  end;

 end;

end;

function POCAGlobalFunctionIMPORT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result:=POCAGlobalFunctionIMPORTREQUIRE(Context,This,Arguments,CountArguments,UserData,false);
end;

function POCAGlobalFunctionREQUIRE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result:=POCAGlobalFunctionIMPORTREQUIRE(Context,This,Arguments,CountArguments,UserData,true);
end;

function POCAModuleManagerFunctionLOADED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var ModuleScope,ModuleValue,ModuleTime:TPOCAValue;
    ModuleName,CleanedModuleName:TPOCAUTF8String;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "loaded"');
 end;
 ModuleName:=POCAGetStringValue(Context,Arguments^[0]);
 CleanedModuleName:=POCACleanModuleName(ModuleName);
 ModuleScope:=POCAHashGetString(Context,Context^.Instance^.Globals.ModuleScopes,CleanedModuleName);
 ModuleValue:=POCAHashGetString(Context,Context^.Instance^.Globals.ModuleValues,CleanedModuleName);
 ModuleTime:=POCAHashGetString(Context,Context^.Instance^.Globals.ModuleTimes,CleanedModuleName);
 if POCAIsValueNull(ModuleScope) and POCAIsValueNull(ModuleValue) and POCAIsValueNull(ModuleTime) then begin
  result.Num:=0.0;
 end else begin
  result.Num:=1.0;
 end;
end;

function POCAModuleManagerFunctionREMOVE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var ModuleScope,Value,ModuleValue,ModuleTime:TPOCAValue;
    ModuleName,CleanedModuleName:TPOCAUTF8String;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "remove"');
 end;
 ModuleName:=POCAGetStringValue(Context,Arguments^[0]);
 CleanedModuleName:=POCACleanModuleName(ModuleName);
 ModuleScope:=POCAHashGetString(Context,Context^.Instance^.Globals.ModuleScopes,CleanedModuleName);
 ModuleValue:=POCAHashGetString(Context,Context^.Instance^.Globals.ModuleValues,CleanedModuleName);
 ModuleTime:=POCAHashGetString(Context,Context^.Instance^.Globals.ModuleTimes,CleanedModuleName);
 if POCAIsValueNull(ModuleScope) and POCAIsValueNull(ModuleValue) and POCAIsValueNull(ModuleTime) then begin
  result.Num:=0.0;
 end else begin
  Value:=POCANewUniqueString(Context,CleanedModuleName);
  POCAProtect(Context,Value);
  try
   POCAHashDelete(Context,Context^.Instance^.Globals.ModuleScopes,Value);
   POCAHashDelete(Context,Context^.Instance^.Globals.ModuleValues,Value);
   POCAHashDelete(Context,Context^.Instance^.Globals.ModuleTimes,Value);
  finally
   POCAUnprotect(Context,Value);
  end;
  result.Num:=1.0;
 end;
end;

function POCAModuleManagerFunctionGETMODULEFILETIME(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var ModuleLoaderFunctionIndex:TPOCAInt32;
    ModuleName,ModuleFileName,ModuleCode:TPOCAUTF8String;
    ModuleDateTime:TDateTime;
    OK:Boolean;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "getModuleFileTime"');
 end;
 ModuleName:=POCAGetStringValue(Context,Arguments^[0]);
 OK:=false;
 for ModuleLoaderFunctionIndex:=0 to Context^.Instance^.Globals.CountModuleLoaderFunctions-1 do begin
  if Context^.Instance^.Globals.ModuleLoaderFunctions[ModuleLoaderFunctionIndex](Context,ModuleName,ModuleCode,ModuleFileName,ModuleDateTime) then begin
   OK:=true;
   break;
  end;
 end;
 if OK then begin
  result.Num:=ModuleDateTime;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
  POCARuntimeError(Context,'Module "'+ModuleName+'" not found!');
 end;
end;

function POCAInitModuleManagerNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAHashSetString(Context,result,'moduleScopes',Context^.Instance^.Globals.ModuleScopes);
 POCAHashSetString(Context,result,'moduleValues',Context^.Instance^.Globals.ModuleValues);
 POCAHashSetString(Context,result,'moduleTimes',Context^.Instance^.Globals.ModuleTimes);
 POCAAddNativeFunction(Context,result,'import',POCAGlobalFunctionIMPORT);
 POCAAddNativeFunction(Context,result,'require',POCAGlobalFunctionREQUIRE);
 POCAAddNativeFunction(Context,result,'loaded',POCAModuleManagerFunctionLOADED);
 POCAAddNativeFunction(Context,result,'remove',POCAModuleManagerFunctionREMOVE);
 POCAAddNativeFunction(Context,result,'getModuleFileTime',POCAModuleManagerFunctionGETMODULEFILETIME);
end;

function POCAMathFunctionMIN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.min"');
 end;
 result.Num:=Min(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionMAX(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.max"');
 end;
 result.Num:=Max(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionCLAMP(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<3 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.clamp"');
 end;
 result.Num:=Min(Max(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1])),POCAGetNumberValue(Context,Arguments^[2]));
end;

function POCAMathFunctionABS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.abs"');
 end;
 result.Num:=abs(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionSIN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sin"');
 end;
 result.Num:=sin(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCOS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.cos"');
 end;
 result.Num:=cos(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionTAN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.tan"');
 end;
 result.Num:=tan(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionEXP(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.exp"');
 end;
 result.Num:=exp(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionLN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.ln"');
 end;
 result.Num:=ln(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionLOG(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.log"');
 end;
 result.Num:=ln(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionSQR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sqr"');
 end;
 result.Num:=sqr(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionSQRT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sqrt"');
 end;
 result.Num:=sqrt(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionATAN2(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.atan2"');
 end;
 result.Num:=ArcTan2(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionACOS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acos"');
 end;
 result.Num:=ArcCos(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionASIN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.asin"');
 end;
 result.Num:=ArcSin(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionATAN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.atan"');
 end;
 result.Num:=ArcTan(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCOTAN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.cotan"');
 end;
 result.Num:=Cotan(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionSECANT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.secant"');
 end;
 result.Num:=Secant(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCOSECANT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.cosecant"');
 end;
 result.Num:=Cosecant(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionHYPOT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.hypot"');
 end;
 result.Num:=Hypot(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionCEIL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.ceil"');
 end;
 result.Num:=ceil(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionFLOOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.floor"');
 end;
 result.Num:=floor(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionLOG10(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.log10"');
 end;
 result.Num:=Log10(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionLOG2(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.log2"');
 end;
 result.Num:=Log2(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionLOGN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.logn"');
 end;
 result.Num:=LogN(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionPOW(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.pow"');
 end;
 result.Num:=Math.Power(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionSINH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sinh"');
 end;
 result.Num:=sinh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCOSH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.cosh"');
 end;
 result.Num:=cosh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionTANH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.tanh"');
 end;
 result.Num:=tanh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionASINH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sinh"');
 end;
 result.Num:=arcsinh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionACOSH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acosh"');
 end;
 result.Num:=arccosh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionATANH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.atanh"');
 end;
 result.Num:=arctanh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCOTH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.coth"');
 end;
 result.Num:=1.0/Math.tanh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionSECH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sech"');
 end;
 result.Num:=1.0/Math.cosh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCSCH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.csch"');
 end;
 result.Num:=1.0/Math.sinh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionACOT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acot"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 if SameValue(Value,0) then begin
  result.Num:=pi*0.5;
 end else begin
  result.Num:=ArcTan(1.0/Value);
 end;
end;

function POCAMathFunctionASEC(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.asec"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 if SameValue(Value,0) then begin
  result.Num:=Infinity;
 end else begin
  result.Num:=ArcCos(1.0/Value);
 end;
end;

function POCAMathFunctionACSC(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acsc"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 if SameValue(Value,0) then begin
  result.Num:=Infinity;
 end else begin
  result.Num:=ArcSin(1.0/Value);
 end;
end;

function POCAMathFunctionACOTH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acoth"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 if SameValue(Value,1) then begin
  result.Num:=Infinity;
 end else if SameValue(Value,-1) then begin
  result.Num:=NegInfinity;
 end else begin
  result.Num:=0.5*ln((Value+1.0)/(Value-1.0));
 end;
end;

function POCAMathFunctionASECH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.asech"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 if SameValue(Value,0) then begin
  result.Num:=Infinity;
 end else if SameValue(Value,1) then begin
  result.Num:=0;
 end else begin
  result.Num:=ln((sqrt(1.0-sqr(Value))+1.0)/Value);
 end;
end;

function POCAMathFunctionACSCH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acsch"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 result.Num:=Ln(sqrt(1.0+(1.0/sqr(Value))+(1.0/Value)));
end;

function POCAMathFunctionROUND(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.round"');
 end;
 result.Num:=System.round(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionTRUNC(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.trunc"');
 end;
 result.Num:=System.trunc(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionINT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.int"');
 end;
 double(TPOCAPointer(@result)^):=System.int(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionRANDOM(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=random;
end;

function POCAMathFunctionISNAN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.isNaN"');
 end;
 result.Num:=ord(POCAIsNaN(POCAGetNumberValue(Context,Arguments^[0]))) and 1;
end;

function POCAMathFunctionISINFINITE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.isInfinite"');
 end;
 result.Num:=ord(POCAIsInfinite(POCAGetNumberValue(Context,Arguments^[0]))) and 1;
end;

function POCAMathFunctionISFINITE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.isFinite"');
 end;
 result.Num:=ord(POCAIsFinite(POCAGetNumberValue(Context,Arguments^[0]))) and 1;
end;

function POCAMathFunctionFRAC(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.frac"');
 end;
 result.Num:=frac(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAInitMathNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAHashSetString(Context,result,'PI',POCANumber(3.14159265358979323846));
 POCAHashSetString(Context,result,'E',POCANumber(2.7182818284590452354));
 POCAHashSetString(Context,result,'LN2',POCANumber(ln(2)));
 POCAHashSetString(Context,result,'LN10',POCANumber(ln(10)));
 POCAHashSetString(Context,result,'LOG10E',POCANumber(log10(2.7182818284590452354)));
 POCAHashSetString(Context,result,'LOG2E',POCANumber(log2(2.7182818284590452354)));
 POCAHashSetString(Context,result,'SQRT1_2',POCANumber(sqrt(0.5)));
 POCAHashSetString(Context,result,'SQRT2',POCANumber(sqrt(2)));
 POCAHashSetString(Context,result,'NaN',POCANumber(NaN));
 POCAHashSetString(Context,result,'Infinity',POCANumber(Infinity));
 POCAAddNativeFunction(Context,result,'min',POCAMathFunctionMIN);
 POCAAddNativeFunction(Context,result,'max',POCAMathFunctionMAX);
 POCAAddNativeFunction(Context,result,'clamp',POCAMathFunctionCLAMP);
 POCAAddNativeFunction(Context,result,'abs',POCAMathFunctionABS);
 POCAAddNativeFunction(Context,result,'sin',POCAMathFunctionSIN);
 POCAAddNativeFunction(Context,result,'cos',POCAMathFunctionCOS);
 POCAAddNativeFunction(Context,result,'tan',POCAMathFunctionTAN);
 POCAAddNativeFunction(Context,result,'exp',POCAMathFunctionEXP);
 POCAAddNativeFunction(Context,result,'ln',POCAMathFunctionLN);
 POCAAddNativeFunction(Context,result,'log',POCAMathFunctionLOG);
 POCAAddNativeFunction(Context,result,'sqr',POCAMathFunctionSQR);
 POCAAddNativeFunction(Context,result,'sqrt',POCAMathFunctionSQRT);
 POCAAddNativeFunction(Context,result,'atan2',POCAMathFunctionATAN2);
 POCAAddNativeFunction(Context,result,'acos',POCAMathFunctionACOS);
 POCAAddNativeFunction(Context,result,'asin',POCAMathFunctionASIN);
 POCAAddNativeFunction(Context,result,'atan',POCAMathFunctionATAN);
 POCAAddNativeFunction(Context,result,'cotan',POCAMathFunctionCOTAN);
 POCAAddNativeFunction(Context,result,'secant',POCAMathFunctionSECANT);
 POCAAddNativeFunction(Context,result,'cosecant',POCAMathFunctionCOSECANT);
 POCAAddNativeFunction(Context,result,'hypot',POCAMathFunctionHYPOT);
 POCAAddNativeFunction(Context,result,'ceil',POCAMathFunctionCEIL);
 POCAAddNativeFunction(Context,result,'floor',POCAMathFunctionFLOOR);
 POCAAddNativeFunction(Context,result,'log10',POCAMathFunctionLOG10);
 POCAAddNativeFunction(Context,result,'log2',POCAMathFunctionLOG2);
 POCAAddNativeFunction(Context,result,'logn',POCAMathFunctionLOGN);
 POCAAddNativeFunction(Context,result,'pow',POCAMathFunctionPOW);
 POCAAddNativeFunction(Context,result,'sinh',POCAMathFunctionSINH);
 POCAAddNativeFunction(Context,result,'cosh',POCAMathFunctionCOSH);
 POCAAddNativeFunction(Context,result,'tanh',POCAMathFunctionTANH);
 POCAAddNativeFunction(Context,result,'asinh',POCAMathFunctionASINH);
 POCAAddNativeFunction(Context,result,'acosh',POCAMathFunctionACOSH);
 POCAAddNativeFunction(Context,result,'atanh',POCAMathFunctionATANH);
 POCAAddNativeFunction(Context,result,'coth',POCAMathFunctionCOTH);
 POCAAddNativeFunction(Context,result,'sech',POCAMathFunctionSECH);
 POCAAddNativeFunction(Context,result,'csch',POCAMathFunctionCSCH);
 POCAAddNativeFunction(Context,result,'acot',POCAMathFunctionACOT);
 POCAAddNativeFunction(Context,result,'asec',POCAMathFunctionASEC);
 POCAAddNativeFunction(Context,result,'acsc',POCAMathFunctionACSC);
 POCAAddNativeFunction(Context,result,'acoth',POCAMathFunctionACOTH);
 POCAAddNativeFunction(Context,result,'asech',POCAMathFunctionASECH);
 POCAAddNativeFunction(Context,result,'acsch',POCAMathFunctionACSCH);
 POCAAddNativeFunction(Context,result,'round',POCAMathFunctionROUND);
 POCAAddNativeFunction(Context,result,'trunc',POCAMathFunctionTRUNC);
 POCAAddNativeFunction(Context,result,'int',POCAMathFunctionINT);
 POCAAddNativeFunction(Context,result,'random',POCAMathFunctionRANDOM);
 POCAAddNativeFunction(Context,result,'isNaN',POCAMathFunctionISNAN);
 POCAAddNativeFunction(Context,result,'isInfinite',POCAMathFunctionISINFINITE);
 POCAAddNativeFunction(Context,result,'isFinite',POCAMathFunctionISFINITE);
 POCAAddNativeFunction(Context,result,'frac',POCAMathFunctionFRAC);
end;

type PPOCAIOGhostData=^TPOCAIOGhostData;
     TPOCAIOGhostData=record
      TextHandle:^text;
      BinaryHandle:^file;
      Opened:boolean;
      SystemHandle:boolean;
      Binary:boolean;
     end;

procedure POCAIOGhostDestroy(const Ghost:PPOCAGhost);
var DataCasted:PPOCAIOGhostData;
begin
 if assigned(Ghost) then begin
  DataCasted:=Ghost^.Ptr;
  if assigned(DataCasted) then begin
   if DataCasted^.Opened then begin
    if not DataCasted.SystemHandle then begin
     if DataCasted.Binary then begin
      System.Close(DataCasted^.BinaryHandle^);
     end else begin
      System.Close(DataCasted^.TextHandle^);
     end;
    end;
    DataCasted^.Opened:=false;
   end;
   if DataCasted.Binary then begin
    if assigned(DataCasted^.BinaryHandle) and not DataCasted.SystemHandle then begin
     FreeMem(DataCasted^.BinaryHandle);
     DataCasted^.BinaryHandle:=nil;
    end;
   end else begin
    if assigned(DataCasted^.TextHandle) and not DataCasted.SystemHandle then begin
     FreeMem(DataCasted^.TextHandle);
     DataCasted^.TextHandle:=nil;
    end;
   end;
  end;
 end;
end;

const POCAIOGhost:TPOCAGhostType=(Destroy:POCAIOGhostDestroy;CanDestroy:nil;Mark:nil;ExistKey:nil;GetKey:nil;SetKey:nil;Name:'io');

function POCAIOGhostNew(var t:text;var f:file;SystemHandle:boolean):PPOCAIOGhostData;
begin
 New(result);
 FillChar(result^,sizeof(TPOCAIOGhostData),#0);
 result^.TextHandle:=@t;
 result^.BinaryHandle:=@f;
 result^.Opened:=true;
 result^.SystemHandle:=SystemHandle;
end;

function POCAIOFunctionOPEN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var OldFileMode:TPOCAUInt8;
    fn,fm:TPOCAUTF8String;
    t:^text;
    f:^file;
    DoCreate:boolean;
    Binary:boolean;
begin
 if CountArguments>0 then begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
  t:=nil;
  f:=nil;
  OldFileMode:=FileMode;
  try
   try
    fn:=POCAGetStringValue(Context,Arguments^[0]);
    if CountArguments>1 then begin
     fm:=POCAGetStringValue(Context,Arguments^[1]);
    end else begin
     fm:='';
    end;
    DoCreate:=false;
    if fm='c' then begin
     FileMode:=fmOpenReadWrite;
     DoCreate:=true;
     Binary:=false;     
    end else if fm='r' then begin
     FileMode:=fmOpenRead;
     Binary:=false;
    end else if fm='rw' then begin
     FileMode:=fmOpenReadWrite;
     Binary:=false;
    end else if fm='w' then begin
     Binary:=false;
     if FileExists(String(fn)) then begin
      FileMode:=fmOpenWrite;
     end else begin
      FileMode:=fmOpenReadWrite;
      DoCreate:=true;
     end;
    end else if fm='cb' then begin
     FileMode:=fmOpenReadWrite;
     DoCreate:=true;
     Binary:=true;
    end else if fm='rb' then begin
     FileMode:=fmOpenRead;
     Binary:=true;
    end else if fm='rwb' then begin
     FileMode:=fmOpenReadWrite;
     Binary:=true;
    end else if fm='wb' then begin
     Binary:=true;
     if FileExists(String(fn)) then begin
      FileMode:=fmOpenWrite;
     end else begin
      FileMode:=fmOpenReadWrite;
      DoCreate:=true;
     end;      
    end else begin
     FileMode:=fmOpenRead;
     Binary:=false;
    end;
    if Binary then begin
     New(f);
     AssignFile(f^,String(fn));
     if DoCreate then begin
      {$i-}Rewrite(f^,1);{$i+}
     end else begin
      {$i-}Reset(f^,1);{$i+}
     end;
    end else begin
     New(t);
     AssignFile(t^,String(fn));
     if DoCreate then begin
      {$i-}Rewrite(t^);{$i+}
     end else begin
      {$i-}Reset(t^);{$i+}
     end;
    end;
    if IOResult<>0 then begin
     result.Num:=0;
    end else begin
     result:=POCANewGhost(Context,@POCAIOGhost,POCAIOGhostNew(t^,f^,false));
     POCAGhostSetHashValue(result,Context^.Instance.Globals.IOHash);
    end;
   except
    try
     if assigned(t) then begin
      Dispose(t);
      t:=nil;
     end;
     if assigned(f) then begin
      Dispose(f);
      f:=nil; 
     end;
    except
    end;
    raise;
   end;
  finally
   FileMode:=OldFileMode;
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAIOFunctionCLOSE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var IOData:PPOCAIOGhostData;
begin
 if POCAGhostGetType(This)<>@POCAIOGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 IOData:=PPOCAIOGhostData(POCAGhostGetPointer(This));
 result.Num:=ord(IOData^.Opened) and 1;
 if IOData^.Opened then begin
  if assigned(IOData^.TextHandle) then begin
   if (IOData^.TextHandle<>@System.Input) and (IOData^.TextHandle<>@System.Output) and (IOData^.TextHandle<>@System.ErrOutput) then begin
    System.Close(IOData^.TextHandle^);
   end;
  end; 
  if assigned(IOData^.BinaryHandle) then begin
   System.Close(IOData^.BinaryHandle^);
  end;
  IOData^.Opened:=false;
 end;
 if assigned(IOData^.TextHandle) and ((IOData^.TextHandle<>@System.Input) and (IOData^.TextHandle<>@System.Output) and (IOData^.TextHandle<>@System.ErrOutput)) then begin
  FreeMem(IOData^.TextHandle);
 end;
 if assigned(IOData^.BinaryHandle) then begin
  FreeMem(IOData^.BinaryHandle);
 end;
 IOData^.TextHandle:=nil;
 IOData^.BinaryHandle:=nil;
end;

function POCAIOFunctionEOF(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var IOData:PPOCAIOGhostData;
begin
 if POCAGhostGetType(This)<>@POCAIOGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;                
 IOData:=PPOCAIOGhostData(POCAGhostGetPointer(This));
 if assigned(IOData^.TextHandle) then begin
  result.Num:=ord(eof(IOData^.TextHandle^)) and 1;
 end else if assigned(IOData^.BinaryHandle) then begin
  result.Num:=ord(eof(IOData^.BinaryHandle^)) and 1;
 end else begin
  result.Num:=1;
 end;
end;

function POCAIOFunctionREAD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var IOData:PPOCAIOGhostData;
    s:TPOCARawByteString;
    i,Len:TPOCAInt32;
begin
 if POCAGhostGetType(This)<>@POCAIOGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 IOData:=PPOCAIOGhostData(POCAGhostGetPointer(This));
 if assigned(IOData^.TextHandle) then begin
  if EOF(IOData^.TextHandle^) then begin
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end else begin
   Read(IOData^.TextHandle^,s);
   result:=POCANewString(Context,s);
  end;
 end else if assigned(IOData^.BinaryHandle) then begin
  if EOF(IOData^.BinaryHandle^) then begin
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end else begin
   if (CountArguments>0) and POCAIsValueNumber(Arguments^[0]) then begin
    Len:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   end else begin
    Len:=1;
   end;
   i:=Min(FileSize(IOData^.BinaryHandle^)-FilePos(IOData^.BinaryHandle^),Len);
   SetLength(s,i);
   BlockRead(IOData^.BinaryHandle^,s[1],i);
   result:=POCANewString(Context,s);
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAIOFunctionWRITE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var IOData:PPOCAIOGhostData;
    s:TPOCARawByteString;
begin
 if POCAGhostGetType(This)<>@POCAIOGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 IOData:=PPOCAIOGhostData(POCAGhostGetPointer(This));
 if CountArguments>0 then begin
  if assigned(IOData^.TextHandle) then begin
   s:=POCAGetStringValue(Context,Arguments^[0]);
   Write(IOData^.TextHandle^,s);
   result.Num:=length(s);
  end else if assigned(IOData^.BinaryHandle) then begin
   s:=POCAGetStringValue(Context,Arguments^[0]);
   BlockWrite(IOData^.BinaryHandle^,s[1],length(s));
   result.Num:=length(s);
  end else begin
   result.Num:=0;
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAIOFunctionWRITELN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var IOData:PPOCAIOGhostData;
    s:TPOCARawByteString;
begin
 if POCAGhostGetType(This)<>@POCAIOGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>0 then begin
  IOData:=PPOCAIOGhostData(POCAGhostGetPointer(This));
  if assigned(IOData^.TextHandle) then begin
   s:=POCAGetStringValue(Context,Arguments^[0])+{$ifdef unix}#10{$else}#13#10{$endif};
   Write(IOData^.TextHandle^,s);
   result.Num:=length(s);
  end else if assigned(IOData^.BinaryHandle) then begin
   s:=POCAGetStringValue(Context,Arguments^[0])+{$ifdef unix}#10{$else}#13#10{$endif};
   BlockWrite(IOData^.BinaryHandle^,s[1],length(s));
   result.Num:=length(s);
  end else begin
   result.Num:=0;
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAIOFunctionREADLN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var IOData:PPOCAIOGhostData;
    s:TPOCARawByteString;
begin
 if POCAGhostGetType(This)<>@POCAIOGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 IOData:=PPOCAIOGhostData(POCAGhostGetPointer(This));
 if assigned(IOData^.TextHandle) then begin
  if EOF(IOData^.TextHandle^) then begin
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end else begin
   ReadLn(IOData^.TextHandle^,s);
   result:=POCANewString(Context,s);
  end;
 end else if assigned(IOData^.BinaryHandle) then begin
  result.Num:=0;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

// IO.getDirectoryEntries(path:string):array of list of objects with name, datetime, size and type  
function POCAIOFunctionGETDIRECTORYENTRIES(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
    ListItem:TPOCAValue;
    FindData:TSearchRec;
begin
 if CountArguments>0 then begin
  
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  
  result:=POCANewArray(Context);
  
  if FindFirst(Path,faAnyFile,FindData)=0 then begin

   repeat

    ListItem:=POCANewHash(Context);
    POCAHashSetString(Context,ListItem,'name',POCANewString(Context,FindData.Name));
    POCAHashSetString(Context,ListItem,'datetime',POCANewNumber(Context,{$ifdef fpc}FindData.TimeStampUTC{$else}DateTimeFromLocalTimeToUniversalTime(FindData.TimeStamp){$endif}));
    POCAHashSetString(Context,ListItem,'size',POCANewNumber(Context,FindData.Size));
    if (FindData.Attr and faDirectory)<>0 then begin
     POCAHashSetString(Context,ListItem,'type',POCANewString(Context,'directory'));
    end else begin
     POCAHashSetString(Context,ListItem,'type',POCANewString(Context,'file'));
    end;
    {$if declared(faReadOnly)}POCAHashSetString(Context,ListItem,'readOnly',POCANewNumber(Context,ord((FindData.Attr and faReadOnly)<>0) and 1));{$ifend}
    {$if declared(faHidden)}POCAHashSetString(Context,ListItem,'hidden',POCANewNumber(Context,ord((FindData.Attr and faHidden)<>0) and 1));{$ifend}
    {$if declared(faSysFile)}POCAHashSetString(Context,ListItem,'system',POCANewNumber(Context,ord((FindData.Attr and faSysFile)<>0) and 1));{$ifend}
    {$if declared(faVolumeID)}POCAHashSetString(Context,ListItem,'volumeID',POCANewNumber(Context,ord((FindData.Attr and faVolumeID)<>0) and 1));{$ifend}
    {$if declared(faDirectory)}POCAHashSetString(Context,ListItem,'directory',POCANewNumber(Context,ord((FindData.Attr and faDirectory)<>0) and 1));{$ifend}
    {$if declared(faArchive)}POCAHashSetString(Context,ListItem,'archive',POCANewNumber(Context,ord((FindData.Attr and faArchive)<>0) and 1));{$ifend}
    POCAArrayPush(result,ListItem);

   until FindNext(FindData)<>0;

  end;

  FindClose(FindData);

 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end; 

function POCAInitIONamespace(Context:PPOCAContext):TPOCAValue;
var FileNil:^File;
begin
 FileNil:=nil;
 result:=POCANewHash(Context);
 POCAHashSetString(Context,result,'stdIn',POCANewGhost(Context,@POCAIOGhost,POCAIOGhostNew(System.Input,FileNil^,true)));
 POCAHashSetString(Context,result,'stdOut',POCANewGhost(Context,@POCAIOGhost,POCAIOGhostNew(System.Output,FileNil^,true)));
 POCAHashSetString(Context,result,'stdErr',POCANewGhost(Context,@POCAIOGhost,POCAIOGhostNew(System.ErrOutput,FileNil^,true)));//}
 POCAAddNativeFunction(Context,result,'open',POCAIOFunctionOPEN);
 POCAAddNativeFunction(Context,result,'getDirectoryEntries',POCAIOFunctionGETDIRECTORYENTRIES);
end;

function POCAInitIOHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'close',POCAIOFunctionCLOSE);
 POCAAddNativeFunction(Context,result,'eof',POCAIOFunctionEOF);
 POCAAddNativeFunction(Context,result,'read',POCAIOFunctionREAD);
 POCAAddNativeFunction(Context,result,'write',POCAIOFunctionWRITE);
 POCAAddNativeFunction(Context,result,'writeln',POCAIOFunctionWRITELN);
 POCAAddNativeFunction(Context,result,'readln',POCAIOFunctionREADLN);
end;

//////////

function POCAPathFunctionDIR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  result:=POCANewString(Context,ExcludeTrailingPathDelimiter(ExtractFilePath(Path)));
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;  
end;

function POCAPathFunctionFILENAME(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
begin 
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  result:=POCANewString(Context,ExtractFileName(Path));
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAPathFunctionFILEEXTENSION(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  result:=POCANewString(Context,ExtractFileExt(Path));
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAPathFunctionCURRENTSCRIPTFILE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments>0 then begin
  result:=POCANewString(Context,POCAGetSourceFileName(Context,0,POCAGetBooleanValue(Context,Arguments^[0])));
 end else begin
  result:=POCANewString(Context,POCAGetSourceFileName(Context,0,false));
 end;
end;

function POCAPathFunctionRELATIVE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
    BasePath:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  if CountArguments>1 then begin
   BasePath:=POCAGetStringValue(Context,Arguments^[1]);
  end else begin
   BasePath:='';
  end;
  result:=POCANewString(Context,POCAConvertPathToRelative(Path,BasePath));
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAPathFunctionABSOLUTE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
    BasePath:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  if CountArguments>1 then begin
   BasePath:=POCAGetStringValue(Context,Arguments^[1]);
  end else begin
   BasePath:='';
  end;
  result:=POCANewString(Context,POCAExpandRelativePath(Path,BasePath));
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAPathFunctionSPLIT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Index,Len:TPOCAInt32;
    Path,Part:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  Len:=Length(Path);
  result:=POCANewArray(Context);
  Index:=1;
  while Index<=Len do begin
   Part:='';
   while (Index<=Len) and ((Path[Index]='\') or (Path[Index]='/')) do begin
    Inc(Index);
   end;
   while (Index<=Len) and not ((Path[Index]='\') or (Path[Index]='/')) do begin
    Part:=Part+Path[Index];
    Inc(Index);
   end;
   if length(Part)>0 then begin
    POCAArrayPush(result,POCANewString(Context,Part));
   end;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAPathFunctionJOIN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
const DelimiterChar={$ifdef Windows}'\'{$else}'/'{$endif};
var Index:TPOCAInt32;
    Path,Part:TPOCARawByteString;
    PathList:TPOCAValue;
    PathListCount:TPOCAInt32;
begin
 if CountArguments>0 then begin
  PathList:=Arguments^[0];
  if POCAIsValueArray(PathList) then begin
   PathListCount:=POCAArraySize(PathList);
   Path:='';
   for Index:=0 to PathListCount-1 do begin
    Part:=POCAGetStringValue(Context,POCAArrayGet(PathList,Index));
    if length(Part)>0 then begin
     if length(Path)>0 then begin
      Path:=Path+DelimiterChar;
     end;
     Path:=Path+Part;
    end;
   end; 
   result:=POCANewString(Context,Path);
  end else begin
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAPathFunctionISABSOLUTE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
    IsAbsolute:boolean;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
{$ifdef Windows}
  IsAbsolute:=(length(Path)>1) and (Path[2]=':') and ((Path[1]>='A') and (Path[1]<='Z')) or ((Path[1]>='a') and (Path[1]<='z'));
{$else}
  IsAbsolute:=(length(Path)>0) and ((Path[1]='\') or (Path[1]='/'));
{$endif}
  result.Num:=ord(IsAbsolute) and 1;
 end else begin 
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;

function POCAPathFunctionDELIMITER(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result:=POCANewString(Context,{$ifdef Windows}'\'{$else}'/'{$endif});
end; 

function POCAPathFunctionCURRENT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result:=POCANewString(Context,ExcludeTrailingPathDelimiter(GetCurrentDir));
end;

function POCAPathFunctionGETENTRIES(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
{$if defined(fpc) and defined(Unix)}
// With FpOpendir etc. from BaseUnix
var Path:TPOCARawByteString;
    DirHandle:PDIR;
    FileInfo:PDirent;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  Path:=ExcludeTrailingPathDelimiter(Path);
  result:=POCANewArray(Context);
  DirHandle:=fpOpendir(Path);
  if assigned(DirHandle) then begin
   try
    repeat
     FileInfo:=fpReaddir(DirHandle^);
     if FileInfo<>nil then begin
      POCAArrayPush(result,POCANewString(Context,FileInfo^.d_name));
     end;
    until FileInfo=nil;
   finally
    fpClosedir(DirHandle^);
   end;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;
{$else}
// With FindFirst
var Path:TPOCARawByteString;
    FindData:TSearchRec;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  Path:=IncludeTrailingPathDelimiter(Path)+{$ifdef Windows}'*.*'{$else}'*'{$endif};
  result:=POCANewArray(Context); 
  if FindFirst(Path,faAnyFile,FindData)=0 then begin
   repeat
    POCAArrayPush(result,POCANewString(Context,FindData.Name));
   until FindNext(FindData)<>0;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end; 
{$ifend}

function POCAPathFunctionSTAT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
{$if defined(fpc) and defined(Unix)}
// With FpStat etc. from BaseUnix
var Path:TPOCARawByteString;
    StatData:TStat;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  result:=POCANewHash(Context);
  if fpStat(Path,StatData)=0 then begin
   POCAHashSetString(Context,result,'size',POCANewNumber(Context,StatData.st_size));
   POCAHashSetString(Context,result,'mtime',POCANewNumber(Context,UnixToDateTime(StatData.st_mtime,true)));
   POCAHashSetString(Context,result,'ctime',POCANewNumber(Context,UnixToDateTime(StatData.st_ctime,true)));
   POCAHashSetString(Context,result,'atime',POCANewNumber(Context,UnixToDateTime(StatData.st_atime,true)));
   if (StatData.st_mode and S_IFDIR)<>0 then begin
    POCAHashSetString(Context,result,'type',POCANewString(Context,'directory'));
   end else begin
    POCAHashSetString(Context,result,'type',POCANewString(Context,'file'));
   end;
   if (StatData.st_mode and S_IFLNK)<>0 then begin
    POCAHashSetString(Context,result,'symlink',POCANewNumber(Context,1));
   end else begin
    POCAHashSetString(Context,result,'symlink',POCANewNumber(Context,0));
   end;
  end else begin
   result.CastedUInt64:=POCAValueNullCastedUInt64; 
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;  
{$else}
// With FindFirst and emulating stat
var Path:TPOCARawByteString;
    StatData:TSearchRec;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  result:=POCANewHash(Context);
  if FindFirst(Path,faAnyFile,StatData)=0 then begin
   POCAHashSetString(Context,result,'size',POCANewNumber(Context,StatData.Size));
   POCAHashSetString(Context,result,'mtime',POCANewNumber(Context,{$ifdef fpc}StatData.TimeStampUTC{$else}DateTimeFromLocalTimeToUniversalTime(StatData.TimeStamp){$endif}));
   POCAHashSetString(Context,result,'ctime',POCANewNumber(Context,{$ifdef fpc}StatData.TimeStampUTC{$else}DateTimeFromLocalTimeToUniversalTime(StatData.TimeStamp){$endif}));
   POCAHashSetString(Context,result,'atime',POCANewNumber(Context,{$ifdef fpc}StatData.TimeStampUTC{$else}DateTimeFromLocalTimeToUniversalTime(StatData.TimeStamp){$endif}));
   if (StatData.Attr and faDirectory)<>0 then begin
    POCAHashSetString(Context,result,'type',POCANewString(Context,'directory'));
   end else begin
    POCAHashSetString(Context,result,'type',POCANewString(Context,'file'));
   end;
   POCAHashSetString(Context,result,'symlink',POCANewNumber(Context,0));
  end else begin
   result.CastedUInt64:=POCAValueNullCastedUInt64; 
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;
{$ifend}

function POCAPathFunctionISDIR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  result.Num:=ord(DirectoryExists(Path)) and 1;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;

function POCAPathFunctionISFILE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  result.Num:=ord(FileExists(Path)) and 1;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;

function POCAPathFunctionISSYMLINK(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
{$if defined(fpc) and defined(Unix)}
var Path:TPOCARawByteString;
    StatData:TStat;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  result.Num:=0;
  if fpLStat(Path,StatData)=0 then begin
   if (StatData.st_mode and S_IFLNK)<>0 then begin
    result.Num:=1;
   end;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;
{$else}
var Path:TPOCARawByteString;
    StatData:TSearchRec;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  result.Num:=0;
  if FindFirst(Path,faAnyFile,StatData)=0 then begin
   if (StatData.Attr and faSymLink)<>0 then begin
    result.Num:=1;
   end;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;
{$ifend}

function POCAPathFunctionRESOLVE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
{$if defined(fpc) and defined(Unix)}
var Path:TPOCARawByteString;
    StatData:TStat;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  if fpLStat(Path,StatData)=0 then begin
   if (StatData.st_mode and S_IFLNK)<>0 then begin
    Path:=fpReadlink(Path);
   end;
  end;
  result:=POCANewString(Context,Path);
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;
{$else}
var Path:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  if FileExists(Path) then begin
   result:=POCANewString(Context,Path);
  end else begin
   result.CastedUInt64:=POCAValueNullCastedUInt64; 
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;
{$ifend}
 
function POCAPathFunctionMKDIR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  if not DirectoryExists(Path) then begin
   if CreateDir(Path) then begin
    result.Num:=1;
   end else begin
    result.Num:=0;
   end;
  end else begin
   result.Num:=0;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;

function POCAPathFunctionCHDIR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  if DirectoryExists(Path) then begin
   if SetCurrentDir(Path) then begin
    result.Num:=1;
   end else begin
    result.Num:=0;
   end;
  end else begin
   result.Num:=0;
  end;
 end else begin 
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;

function POCAPathFunctionRMDIR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  if DirectoryExists(Path) then begin
   if RemoveDir(Path) then begin
    result.Num:=1;
   end else begin
    result.Num:=0;
   end;
  end else begin
   result.Num:=0;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;

function POCAPathFunctionEXIST(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  result.Num:=ord(FileExists(Path) or DirectoryExists(Path)) and 1;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;

function POCAPathFunctionREMOVE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Path:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  Path:=POCAGetStringValue(Context,Arguments^[0]);
  if FileExists(Path) then begin
   if DeleteFile(Path) then begin
    result.Num:=1;
   end else begin
    result.Num:=0;
   end;
  end else begin
   result.Num:=0;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;

function POCAPathFunctionCOPY(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var SourcePath,DestPath:TPOCARawByteString;
    StreamSource,StreamDest:TStream;
begin
 if CountArguments>1 then begin
  SourcePath:=POCAGetStringValue(Context,Arguments^[0]);
  DestPath:=POCAGetStringValue(Context,Arguments^[1]);
  if FileExists(SourcePath) then begin
   StreamSource:=TFileStream.Create(SourcePath,fmOpenRead);
   try
    StreamDest:=TFileStream.Create(DestPath,fmCreate);
    try
     StreamDest.CopyFrom(StreamSource,StreamSource.Size);
     result.Num:=1;
    finally
     StreamDest.Free;
    end;
   finally
    StreamSource.Free;
   end;
  end else begin
   result.Num:=0;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;

function POCAPathFunctionMOVE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue; 
var SourcePath,DestPath:TPOCARawByteString;
begin
 if CountArguments>1 then begin
  SourcePath:=POCAGetStringValue(Context,Arguments^[0]);
  DestPath:=POCAGetStringValue(Context,Arguments^[1]);
  if FileExists(SourcePath) then begin
   if RenameFile(SourcePath,DestPath) then begin
    result.Num:=1;
   end else begin
    result.Num:=0;
   end;
  end else begin
   result.Num:=0;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;

function POCAPathFunctionRENAME(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var SourcePath,DestPath:TPOCARawByteString;
begin
 if CountArguments>1 then begin
  SourcePath:=POCAGetStringValue(Context,Arguments^[0]);
  DestPath:=POCAGetStringValue(Context,Arguments^[1]);
  if FileExists(SourcePath) then begin
   if RenameFile(SourcePath,DestPath) then begin
    result.Num:=1;
   end else begin
    result.Num:=0;
   end;
  end else begin
   result.Num:=0;
  end;
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64; 
 end;
end;

function POCAInitPathNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'dir',POCAPathFunctionDIR);
 POCAAddNativeFunction(Context,result,'fileName',POCAPathFunctionFILENAME);
 POCAAddNativeFunction(Context,result,'fileExtension',POCAPathFunctionFILEEXTENSION);
 POCAAddNativeFunction(Context,result,'currentScriptFile',POCAPathFunctionCURRENTSCRIPTFILE);
 POCAAddNativeFunction(Context,result,'relative',POCAPathFunctionRELATIVE);
 POCAAddNativeFunction(Context,result,'absolute',POCAPathFunctionABSOLUTE);
 POCAAddNativeFunction(Context,result,'split',POCAPathFunctionSPLIT);
 POCAAddNativeFunction(Context,result,'join',POCAPathFunctionJOIN);
 POCAAddNativeFunction(Context,result,'isAbsolute',POCAPathFunctionISABSOLUTE);
 POCAAddNativeFunction(Context,result,'delimiter',POCAPathFunctionDELIMITER);
 POCAAddNativeFunction(Context,result,'current',POCAPathFunctionCURRENT);
 POCAAddNativeFunction(Context,result,'getEntries',POCAPathFunctionGETENTRIES);
 POCAAddNativeFunction(Context,result,'stat',POCAPathFunctionSTAT);
 POCAAddNativeFunction(Context,result,'isDir',POCAPathFunctionISDIR);
 POCAAddNativeFunction(Context,result,'isFile',POCAPathFunctionISFILE);
 POCAAddNativeFunction(Context,result,'isSymLink',POCAPathFunctionISSYMLINK);
 POCAAddNativeFunction(Context,result,'resolve',POCAPathFunctionRESOLVE);
 POCAAddNativeFunction(Context,result,'mkdir',POCAPathFunctionMKDIR);
 POCAAddNativeFunction(Context,result,'chdir',POCAPathFunctionCHDIR);
 POCAAddNativeFunction(Context,result,'rmdir',POCAPathFunctionRMDIR);
 POCAAddNativeFunction(Context,result,'exist',POCAPathFunctionEXIST);
 POCAAddNativeFunction(Context,result,'remove',POCAPathFunctionREMOVE);
 POCAAddNativeFunction(Context,result,'copy',POCAPathFunctionCOPY);
 POCAAddNativeFunction(Context,result,'move',POCAPathFunctionMOVE);
 POCAAddNativeFunction(Context,result,'rename',POCAPathFunctionRENAME); 
end;

//////////

procedure POCARegExpGhostDestroy(const Ghost:PPOCAGhost);
begin
 if assigned(Ghost) and assigned(Ghost^.Ptr) then begin
  TFLRE(Ghost^.Ptr).Free;
 end;
end;

const POCARegExpGhost:TPOCAGhostType=(Destroy:POCARegExpGhostDestroy;CanDestroy:nil;Mark:nil;ExistKey:nil;GetKey:nil;SetKey:nil;Name:'RegExp');

function POCARegExpFunctionESCAPE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var a,b:TPOCARawByteString;
    i:TPOCAInt32;
    c:ansichar;
begin
 if CountArguments>0 then begin
  a:=POCAGetStringValue(Context,Arguments^[0]);
  b:='';
  for i:=1 to length(a) do begin
   c:=a[i];
   if c in ['(','|','.','*','?','^','$','-','[','{','}',']',')','\'] then begin
    b:=b+'\';
   end;
   b:=b+c;
  end;
  result:=POCANewString(Context,TPOCARawByteString(b));
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCARegExpFunctionCOMPILE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var s:TPOCARawByteString;
    IsUTF8:TPOCAInt32;
begin
 if CountArguments>0 then begin
  if POCAGhostGetType(Arguments^[0])=@POCARegExpGhost then begin
   s:=TFLRE(POCAGhostGetPointer(Arguments^[0])).RegularExpressionSource;
  end else begin
   s:=POCAGetStringValue(Context,Arguments^[0]);
  end;
  if POCAIsValueString(Arguments^[0]) then begin
   IsUTF8:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]))^.UTF8;
  end else begin
   IsUTF8:=PUCUUTF8Get(s);
  end;
  result:=POCANewGhost(Context,@POCARegExpGhost,POCARegExpCompile(Context,s,IsUTF8));
  POCAGhostSetHashValue(result,Context^.Instance.Globals.RegExpHash);
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCARegExpFunctionEXEC(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var RegExp:TFLRE;
    MultipleCaptures:TFLREMultiCaptures;
    Captures:TFLRECaptures;
    StartCodeUnit,Limit,mi,mc,i:TPOCAInt32;
    s:TPOCARawByteString;
    CapturesArray,v:TPOCAValue;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>0 then begin
  s:=''; 
  if CountArguments>1 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[1])));
  end else begin
   StartCodeUnit:=1;
  end;
  if CountArguments>2 then begin
   Limit:=trunc(POCAGetNumberValue(Context,Arguments^[2]));
  end else begin
   Limit:=1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  try
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
   s:=POCAGetStringValue(Context,Arguments^[0]);
   MultipleCaptures:=nil;
   if RegExp.MatchAll(s,MultipleCaptures,StartCodeUnit,Limit) then begin
    mc:=length(MultipleCaptures);
   end else begin
    mc:=0;
   end;
   for mi:=0 to mc-1 do begin
    Captures:=MultipleCaptures[mi];
    if length(Captures)>0 then begin
     if POCAIsValueNull(result) then begin
      result:=POCANewArray(Context);
     end;
     if rfNAMED in RegExp.RegularExpressionFlags then begin
      CapturesArray:=POCANewHash(Context);
      for i:=0 to length(Captures)-1 do begin
       v:=POCANewArray(Context);
       POCAArraySetSize(v,3);
       POCAArraySet(v,0,POCANumber(POCAStringUTF8GetCodePoint(Context,Arguments^[0],Captures[i].Start)));
       POCAArraySet(v,1,POCANumber(PUCUUTF8Length(copy(s,Captures[i].Start,Captures[i].Length))));
       POCAArraySet(v,2,POCANewString(Context,copy(s,Captures[i].Start,Captures[i].Length)));
       POCAHashSetString(Context,CapturesArray,TPOCAUTF8String(RegExp.NamedGroups[i]),v);
      end;
     end else begin
      CapturesArray:=POCANewArray(Context);
      POCAArraySetSize(CapturesArray,length(Captures));
      for i:=0 to length(Captures)-1 do begin
       v:=POCANewArray(Context);
       POCAArraySetSize(v,4);
       POCAArraySet(v,0,POCANumber(POCAStringUTF8GetCodePoint(Context,Arguments^[0],Captures[i].Start)));
       POCAArraySet(v,1,POCANumber(PUCUUTF8Length(copy(s,Captures[i].Start,Captures[i].Length))));
       POCAArraySet(v,2,POCANewString(Context,copy(s,Captures[i].Start,Captures[i].Length)));
       POCAArraySet(v,3,POCANewString(Context,TPOCAUTF8String(RegExp.NamedGroups[i])));
       POCAArraySet(CapturesArray,i,v);
      end;
     end;
     POCAArrayPush(result,CapturesArray);
    end;
    SetLength(Captures,0);
   end;
  finally
   SetLength(MultipleCaptures,0);
   s:='';
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCARegExpFunctionTEST(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var RegExp:TFLRE;
    StartCodeUnit:TPOCAInt32;
    s:TPOCARawByteString;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>0 then begin
  s:='';
  if CountArguments>1 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[1])));
  end else begin
   StartCodeUnit:=1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  try
   s:=POCAGetStringValue(Context,Arguments^[0]);
   result.Num:=ord(RegExp.Test(s,StartCodeUnit)) and 1;
  finally
   s:='';
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCARegExpFunctionFIND(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var RegExp:TFLRE;
    StartCodeUnit:TPOCAInt32;
    s:TPOCARawByteString;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>0 then begin
  s:='';
  if CountArguments>1 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[1])));
  end else begin
   StartCodeUnit:=1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  try
   s:=POCAGetStringValue(Context,Arguments^[0]);
   result.Num:=POCAStringUTF8GetCodePoint(Context,Arguments^[0],RegExp.Find(s,StartCodeUnit));
  finally
   s:='';
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCARegExpFunctionMATCH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var RegExp:TFLRE;
    MultipleCaptures:TFLREMultiCaptures;
    Captures:TFLRECaptures;
    StartCodeUnit,Limit,mi,mc,i:TPOCAInt32;
    s:TPOCARawByteString;
    CapturesArray:TPOCAValue;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>0 then begin
  s:='';
  if CountArguments>1 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[1])));
  end else begin
   StartCodeUnit:=1;
  end;
  if CountArguments>2 then begin
   Limit:=trunc(POCAGetNumberValue(Context,Arguments^[2]));
  end else begin
   Limit:=1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  Captures:=nil;
  try
   s:=POCAGetStringValue(Context,Arguments^[0]);
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
   MultipleCaptures:=nil;
   if RegExp.MatchAll(s,MultipleCaptures,StartCodeUnit,Limit) then begin
    mc:=length(MultipleCaptures);
   end else begin
    mc:=0;
   end;
   for mi:=0 to mc-1 do begin
    Captures:=MultipleCaptures[mi];
    if length(Captures)>0 then begin
     if POCAIsValueNull(result) then begin
      result:=POCANewArray(Context);
     end;
     if rfNAMED in RegExp.RegularExpressionFlags then begin
      CapturesArray:=POCANewHash(Context);
      for i:=0 to length(Captures)-1 do begin
       POCAHashSetString(Context,CapturesArray,TPOCAUTF8String(RegExp.NamedGroups[i]),POCANewString(Context,copy(s,Captures[i].Start,Captures[i].Length)));
      end;
     end else begin
      CapturesArray:=POCANewArray(Context);
      POCAArraySetSize(CapturesArray,length(Captures));
      for i:=0 to length(Captures)-1 do begin
       POCAArraySet(CapturesArray,i,POCANewString(Context,copy(s,Captures[i].Start,Captures[i].Length)));
      end;
     end;
     POCAArrayPush(result,CapturesArray);
    end;
    SetLength(Captures,0);
   end;
  finally
   SetLength(MultipleCaptures,0);
   s:='';
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCARegExpFunctionSPLIT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var RegExp:TFLRE;
    Strings:TFLREStrings;
    StartCodeUnit,Limit,i:TPOCAInt32;
    s:TPOCARawByteString;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>0 then begin
  s:='';
  if CountArguments>1 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[1])));
  end else begin
   StartCodeUnit:=1;
  end;
  if CountArguments>2 then begin
   Limit:=trunc(POCAGetNumberValue(Context,Arguments^[2]));
  end else begin
   Limit:=-1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  Strings:=nil;
  try
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
   s:=POCAGetStringValue(Context,Arguments^[0]);
   if RegExp.Split(s,Strings,StartCodeUnit,Limit) then begin
    for i:=0 to length(Strings)-1 do begin
     if POCAIsValueNull(result) then begin
      result:=POCANewArray(Context);
     end;
     POCAArrayPush(result,POCANewString(Context,Strings[i]));
    end;
   end;
  finally
   SetLength(Strings,0);
   s:='';
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCARegExpFunctionREPLACE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var RegExp:TFLRE;
    ReplacementStringIsUTF8,ReplacementStringLen,StartCodeUnit,Limit:TPOCAInt32;
    s,ReplacementString,OutputString:TPOCARawByteString;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>1 then begin
  s:='';
  if CountArguments>2 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[2])));
  end else begin
   StartCodeUnit:=1;
  end;
  if CountArguments>3 then begin
   Limit:=trunc(POCAGetNumberValue(Context,Arguments^[3]));
  end else begin
   Limit:=-1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  try
   s:=POCAGetStringValue(Context,Arguments^[0]);
   ReplacementString:=POCAGetStringValue(Context,Arguments^[1]);
   if POCAIsValueString(Arguments^[1]) then begin
    ReplacementStringIsUTF8:=PPOCAString(POCAGetValueReferencePointer(Arguments^[1]))^.UTF8;
    ReplacementStringLen:=PPOCAString(POCAGetValueReferencePointer(Arguments^[1]))^.UTF8Length;
   end else begin
    ReplacementStringIsUTF8:=PUCUUTF8Get(ReplacementString);
    if ReplacementStringIsUTF8 in [suNOUTF8,suPOSSIBLEUTF8] then begin
     ReplacementStringLen:=length(ReplacementString);
    end else begin
     ReplacementStringLen:=POCAGetStringUTF8Length(Context,Arguments^[1]);
    end;
   end;
   if ReplacementStringLen>0 then begin
   end;
{$ifdef pocastrictutf8}
   if ReplacementStringIsUTF8=suNOUTF8 then begin
    ReplacementString:=PUCUUTF8Correct(ReplacementString);
    ReplacementStringIsUTF8:=PUCUUTF8Get(ReplacementString);
   end;
{$else}
   if (rfUTF8 in RegExp.RegularExpressionFlags) and (ReplacementStringIsUTF8=suNOUTF8) then begin
    ReplacementString:=PUCUUTF8Correct(ReplacementString);
    ReplacementStringIsUTF8:=PUCUUTF8Get(ReplacementString);
   end;
{$endif}
   OutputString:=RegExp.Replace(s,ReplacementString,StartCodeUnit,Limit);
   result:=POCANewString(Context,OutputString);
  finally
   s:='';
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAInitRegExpNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'escape',POCARegExpFunctionESCAPE);
 POCAAddNativeFunction(Context,result,'compile',POCARegExpFunctionCOMPILE);
 POCAAddNativeFunction(Context,result,'create',POCARegExpFunctionCOMPILE);
end;

function POCAInitRegExpHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'exec',POCARegExpFunctionEXEC);
 POCAAddNativeFunction(Context,result,'test',POCARegExpFunctionTEST);
 POCAAddNativeFunction(Context,result,'find',POCARegExpFunctionFIND);
 POCAAddNativeFunction(Context,result,'match',POCARegExpFunctionMATCH);
 POCAAddNativeFunction(Context,result,'split',POCARegExpFunctionSPLIT);
 POCAAddNativeFunction(Context,result,'replace',POCARegExpFunctionREPLACE);
end;

procedure POCACoroutineGhostDestroy(const Ghost:PPOCAGhost);
var DataCasted:PPOCACoroutineData;
begin
 if assigned(Ghost) and assigned(Ghost^.Ptr) then begin
  DataCasted:=Ghost^.Ptr;
  if assigned(DataCasted^.Coroutine) then begin
   POCACoroutineDestroy(DataCasted^.Coroutine);
  end;
  if assigned(DataCasted^.Context) then begin
   DataCasted^.Context^.CoroutineData:=nil;
   POCAContextDestroy(DataCasted^.Context);
   DataCasted^.Context:=nil;
  end;
  SetLength(DataCasted^.Arguments,0);
  try
   if assigned(DataCasted^.ExceptionHolder) then begin
    try
     raise DataCasted^.ExceptionHolder;
    finally
     DataCasted^.ExceptionHolder:=nil;
    end;
   end;
  finally
   Finalize(DataCasted^);
   Dispose(DataCasted);
  end;
 end;
end;

function POCACoroutineGhostMarkEx(const Data:TPOCAPointer):TPOCABool32;
var DataCasted:PPOCACoroutineData;
    i:TPOCAInt32;
begin
 result:=false;
 if assigned(Data) then begin
  DataCasted:=Data;
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Data) then begin
   result:=true;
  end;
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Func) then begin
   result:=true;
  end;
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.FromValue) then begin
   result:=true;
  end;
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.ToValue) then begin
   result:=true;
  end;
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.DataValue) then begin
   result:=true;
  end;
  for i:=0 to length(DataCasted^.Arguments)-1 do begin
   if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Arguments[i]) then begin
    result:=true;
   end;
  end;
 end;
end;

function POCACoroutineGhostMark(const Ghost:PPOCAGhost):TPOCABool32;
begin
 if assigned(Ghost) and assigned(Ghost^.Ptr) then begin
  result:=POCACoroutineGhostMarkEx(Ghost^.Ptr);
 end else begin
  result:=false;
 end;
end;

procedure POCACoroutineGhostEntrypoint(Coroutine:PPOCACoroutine);
var CoroutineData:PPOCACoroutineData;
begin
 if assigned(Coroutine) then begin
  CoroutineData:=Coroutine^.Parameter;
  if assigned(CoroutineData) then begin
   try
    if length(CoroutineData^.Arguments)>0 then begin
     POCACall(CoroutineData^.Context,CoroutineData^.Func,@CoroutineData^.Arguments[0],length(CoroutineData^.Arguments),CoroutineData^.DataValue,POCAValueNull);
    end else begin
     POCACall(CoroutineData^.Context,CoroutineData^.Func,nil,0,CoroutineData^.DataValue,POCAValueNull);
    end;
   except
    on e:EPOCACoroutineTerminated do begin
    end;
    else begin
     CoroutineData^.ExceptionHolder:=Exception(AcquireExceptionObject);
    end;
   end;
  end;
 end;
end;

const POCACoroutineGhost:TPOCAGhostType=(Destroy:POCACoroutineGhostDestroy;CanDestroy:nil;Mark:POCACoroutineGhostMark;ExistKey:nil;GetKey:nil;SetKey:nil;Name:'Coroutine');

function POCACoroutineFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
    i:TPOCAInt32;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if (CountArguments<1) or not POCAIsValueFunction(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "Coroutine.create"');
 end;
 begin
  i:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Arguments^[0]))^.Code))^.CountArguments;
  if (CountArguments-1)<TPOCAInt32(i) then begin
   POCARuntimeError(Context,'Too few coroutine function arguments (we have '+TPOCARawByteString(IntToStr(CountArguments-1))+' but we do need '+TPOCARawByteString(IntToStr(i))+')');
  end;
 end;
 New(CoroutineData);
 try
  FillChar(CoroutineData^,sizeof(TPOCACoroutineData),#0);
  CoroutineData^.Context:=POCAContextCreate(Context^.Instance);
  CoroutineData^.Context^.CoroutineData:=CoroutineData;
  CoroutineData^.Func:=Arguments^[0];
  POCATemporarySave(Context,CoroutineData^.Func);
  CoroutineData^.Coroutine:=POCACoroutineCreate(@POCACoroutineGhostEntrypoint,65536,CoroutineData);
  CoroutineData^.Arguments:=nil;
  if CountArguments>1 then begin
   SetLength(CoroutineData^.Arguments,CountArguments-1);
   for i:=1 to CountArguments-1 do begin
    CoroutineData^.Arguments[i-1]:=Arguments^[i];
    POCATemporarySave(Context,CoroutineData^.Arguments[i-1]);
   end;
  end;
{ CoroutineData^.FromValue:=POCAValueNull;
  CoroutineData^.ToValue:=POCAValueNull;}
  CoroutineData^.FromValue.CastedUInt64:=POCAValueNullCastedUInt64;
  CoroutineData^.ToValue.CastedUInt64:=POCAValueNullCastedUInt64;
  CoroutineData^.DataValue:=POCANewHash(Context);
  CoroutineData^.ExceptionHolder:=nil;
  if not assigned(CoroutineData) then begin
   POCARuntimeError(Context,'Coroutine creation failed');
  end;
  result:=POCANewGhost(Context,@POCACoroutineGhost,CoroutineData);
  CoroutineData^.Data:=result;
  POCAGhostSetHashValue(result,Context^.Instance.Globals.CoroutineHash);
 except
  Dispose(CoroutineData);
  raise;
 end;
end;

function POCACoroutineFunctionRESUME(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 if POCAGhostGetType(This)=@POCACoroutineGhost then begin
  CoroutineData:=PPOCACoroutineData(POCAGhostGetPointer(This));
  if CountArguments>0 then begin
   CoroutineData^.ToValue:=Arguments^[0];
  end else begin
// CoroutineData^.ToValue:=POCAValueNull;
   CoroutineData^.ToValue.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
  POCAGarbageCollectorUnlock(Context);
  try
   POCACoroutineResume(CoroutineData^.Coroutine,false);
  finally
   POCAGarbageCollectorLock(Context);
  end;
  if assigned(CoroutineData^.ExceptionHolder) then begin
   try
    raise CoroutineData^.ExceptionHolder;
   finally
    CoroutineData^.ExceptionHolder:=nil;
   end;
  end;
  result:=CoroutineData^.FromValue;
//CoroutineData^.FromValue:=POCAValueNull;
  CoroutineData^.FromValue.CastedUInt64:=POCAValueNullCastedUInt64;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCACoroutineFunctionRESUMED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 if POCAGhostGetType(This)=@POCACoroutineGhost then begin
  CoroutineData:=PPOCACoroutineData(POCAGhostGetPointer(This));
  result.Num:=ord(CoroutineData^.Coroutine^.Resumed) and 1;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCACoroutineFunctionYIELD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if assigned(Context) then begin
  CoroutineData:=Context^.CoroutineData;
  while (not assigned(CoroutineData)) and assigned(Context^.CallParent) do begin
   Context:=Context^.CallParent;
   CoroutineData:=Context^.CoroutineData;
  end;
 end else begin
  CoroutineData:=nil;
 end;
 if assigned(CoroutineData) then begin
  if CountArguments>0 then begin
   CoroutineData^.FromValue:=Arguments^[0];
  end else begin
// CoroutineData^.FromValue:=POCAValueNull;
   CoroutineData^.FromValue.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
  POCAGarbageCollectorUnlock(Context);
  try
   POCACoroutineYield(CoroutineData^.Coroutine);
  finally
   POCAGarbageCollectorLock(Context);
  end;
 end;
end;

function POCACoroutineFunctionGET(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 if assigned(Context) then begin
  CoroutineData:=Context^.CoroutineData;
  while (not assigned(CoroutineData)) and assigned(Context^.CallParent) do begin
   Context:=Context^.CallParent;
   CoroutineData:=Context^.CoroutineData;
  end;
 end else begin
  CoroutineData:=nil;
 end;
 if assigned(CoroutineData) then begin
  result:=CoroutineData^.ToValue;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCACoroutineFunctionDATA(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 if POCAGhostGetType(This)=@POCACoroutineGhost then begin
  CoroutineData:=PPOCACoroutineData(POCAGhostGetPointer(This));
  if assigned(CoroutineData) then begin
   result:=CoroutineData^.DataValue;
  end else begin
// result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCACoroutineFunctionSTATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 if POCAGhostGetType(This)=@POCACoroutineGhost then begin
  CoroutineData:=PPOCACoroutineData(POCAGhostGetPointer(This));
  if assigned(CoroutineData) then begin
   case CoroutineData^.Coroutine^.State of
    pcsOUTSIDE:begin
     result:=POCANewString(Context,'outside');
    end;
    pcsINSIDE:begin
     result:=POCANewString(Context,'inside');
    end;
    pcsINSIDETERMINATED:begin
     result:=POCANewString(Context,'insideterminated');
    end;
    pcsTERMINATED:begin
     result:=POCANewString(Context,'terminated');
    end;
    else begin
     result:=POCANewString(Context,'none');
    end;     
   end;
  end else begin
// result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end else begin
// result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCACoroutineFunctionINSIDE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 if POCAGhostGetType(This)=@POCACoroutineGhost then begin
  CoroutineData:=PPOCACoroutineData(POCAGhostGetPointer(This));
  if assigned(CoroutineData) then begin
   result.Num:=ord((CoroutineData^.Coroutine^.State=pcsINSIDE) or (CoroutineData^.Coroutine^.State=pcsINSIDETERMINATED)) and 1;
  end else begin
// result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end else begin
// result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCACoroutineFunctionOUTSIDE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 if POCAGhostGetType(This)=@POCACoroutineGhost then begin
  CoroutineData:=PPOCACoroutineData(POCAGhostGetPointer(This));
  if assigned(CoroutineData) then begin
   result.Num:=ord(CoroutineData^.Coroutine^.State=pcsOUTSIDE) and 1;
  end else begin
// result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end else begin
// result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCACoroutineFunctionTERMINATED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 if POCAGhostGetType(This)=@POCACoroutineGhost then begin
  CoroutineData:=PPOCACoroutineData(POCAGhostGetPointer(This));
  if assigned(CoroutineData) then begin
   result.Num:=ord((CoroutineData^.Coroutine^.State=pcsINSIDETERMINATED) or (CoroutineData^.Coroutine^.State=pcsTERMINATED)) and 1;
  end else begin
// result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end else begin
// result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCACoroutineFunctionALIVE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 if POCAGhostGetType(This)=@POCACoroutineGhost then begin
  CoroutineData:=PPOCACoroutineData(POCAGhostGetPointer(This));
  if assigned(CoroutineData) then begin
   result.Num:=ord((CoroutineData^.Coroutine^.State=pcsOUTSIDE) or (CoroutineData^.Coroutine^.State=pcsINSIDE)) and 1;
  end else begin
// result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end else begin
// result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAInitCoroutineNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCACoroutineFunctionCREATE);
 POCAAddNativeFunction(Context,result,'yield',POCACoroutineFunctionYIELD);
 POCAAddNativeFunction(Context,result,'get',POCACoroutineFunctionGET);
end;

function POCAInitCoroutineHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'data',POCACoroutineFunctionDATA);
 POCAAddNativeFunction(Context,result,'resume',POCACoroutineFunctionRESUME);
 POCAAddNativeFunction(Context,result,'resumed',POCACoroutineFunctionRESUMED);
 POCAAddNativeFunction(Context,result,'state',POCACoroutineFunctionSTATE);
 POCAAddNativeFunction(Context,result,'inside',POCACoroutineFunctionINSIDE);
 POCAAddNativeFunction(Context,result,'outside',POCACoroutineFunctionOUTSIDE);
 POCAAddNativeFunction(Context,result,'terminated',POCACoroutineFunctionTERMINATED);
 POCAAddNativeFunction(Context,result,'alive',POCACoroutineFunctionALIVE);
end;

procedure POCAThreadDestroy(Data:TPOCAPointer);
var DataCasted:PPOCAThreadData absolute Data;
begin
 if assigned(Data) then begin
  if DataCasted^.Handle<>0 then begin
   if not DataCasted^.Terminated then begin
    try
{$ifdef fpc}
     System.KillThread(DataCasted^.Handle);
{$else}
     TerminateThread(DataCasted^.Handle,0);
{$endif}
    except
    end;
    TPasMPInterlocked.Write(DataCasted^.Terminated,true);
   end;
{$ifdef fpc}
   CloseThread(DataCasted^.Handle);
{$else}
{$ifdef win32}
   CloseHandle(DataCasted^.Handle);
{$endif}
{$endif}
   DataCasted^.Handle:=0;
  end; 
  if assigned(DataCasted^.Context) then begin
   DataCasted^.Context^.ThreadData:=nil;
   POCAContextDestroy(DataCasted^.Context);
   DataCasted^.Context:=nil;
  end;
  if assigned(DataCasted^.StartSemaphore) then begin
   POCASemaphoreDestroy(DataCasted^.StartSemaphore);
   DataCasted^.StartSemaphore:=nil;
  end;
  TPasMPInterlocked.Write(DataCasted^.Started,true);
  DataCasted^.Data.Num:=0;
  DataCasted^.Func.Num:=0;
  SetLength(DataCasted^.Arguments,0);
  DataCasted^.Arguments:=nil;
  DataCasted^.Handle:=0;
  DataCasted^.ThreadID:=0;
  DataCasted^.Context:=nil;
 end;
end;

procedure POCAThreadGhostDestroy(const Ghost:PPOCAGhost);
var DataCasted:PPOCAThreadData;
begin
 if assigned(Ghost) and assigned(Ghost^.Ptr) then begin
  DataCasted:=Ghost^.Ptr;
  try
   POCAThreadDestroy(DataCasted);
  finally
   Dispose(DataCasted);
  end;
 end;
end;

function POCAThreadGhostMarkEx(const Data:TPOCAPointer):TPOCABool32;
var DataCasted:PPOCAThreadData;
    i:TPOCAInt32;
begin
 result:=false;
 if assigned(Data) then begin
  DataCasted:=Data;
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Data) then begin
   result:=true;
  end;
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Func) then begin
   result:=true;
  end;
  for i:=0 to length(DataCasted^.Arguments)-1 do begin
   if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Arguments[i]) then begin
    result:=true;
   end;
  end;
 end;
end;

function POCAThreadGhostMark(const Ghost:PPOCAGhost):TPOCABool32;
begin
 if assigned(Ghost) and assigned(Ghost^.Ptr) then begin
  result:=POCAThreadGhostMarkEx(Ghost^.Ptr);
 end else begin
  result:=false;
 end;
end;

const POCAThreadGhost:TPOCAGhostType=(Destroy:POCAThreadGhostDestroy;CanDestroy:nil;Mark:POCAThreadGhostMark;ExistKey:nil;GetKey:nil;SetKey:nil;Name:'Thread');

function POCAThreadFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
    i:TPOCAInt32;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if (CountArguments<1) or not POCAIsValueFunction(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "Thread.create"');
 end;
 begin
  i:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Arguments^[0]))^.Code))^.CountArguments;
  if (CountArguments-1)<TPOCAInt32(i) then begin
   POCARuntimeError(Context,'Too few thread function arguments (we have '+TPOCARawByteString(IntToStr(CountArguments-1))+' but we do need '+TPOCARawByteString(IntToStr(i))+')');
  end;
 end;
 New(ThreadData);
 try
  FillChar(ThreadData^,sizeof(TPOCAThreadData),#0);
  ThreadData^.Context:=POCAContextCreate(Context^.Instance);
  ThreadData^.Context^.ThreadData:=ThreadData;
  ThreadData^.Func:=Arguments^[0];
  ThreadData^.Arguments:=nil;
  if CountArguments>1 then begin
   SetLength(ThreadData^.Arguments,CountArguments-1);
   for i:=1 to CountArguments-1 do begin
    ThreadData^.Arguments[i-1]:=Arguments^[i];
    POCATemporarySave(Context,ThreadData^.Arguments[i-1]);
   end;
  end;
  POCATemporarySave(Context,ThreadData^.Func);
  TPasMPInterlocked.Write(ThreadData^.Terminated,false);
  ThreadData^.StartSemaphore:=POCASemaphoreCreate;
  TPasMPInterlocked.Write(ThreadData^.Started,false);
{$ifdef fpc}
  ThreadData^.Handle:=BeginThread(POCAThreadProc,ThreadData,ThreadData^.ThreadID);
{$else}
  ThreadData^.Handle:=BeginThread(nil,0,TPOCAPointer(@POCAThreadProc),ThreadData,{$ifdef Windows}CREATE_SUSPENDED{$else}0{$endif},ThreadData^.ThreadID);
{$endif}
  if ThreadData^.Handle=0 then begin
   POCARuntimeError(Context,'Thread creation failed');
  end;
  result:=POCANewGhost(Context,@POCAThreadGhost,ThreadData);
  ThreadData^.Data:=result;
  POCAGhostSetHashValue(result,Context^.Instance.Globals.ThreadHash);
 except
  Dispose(ThreadData);
  raise;
 end;
end;

function POCAThreadFunctionRESUME(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
begin
 if POCAGhostGetType(This)=@POCAThreadGhost then begin
  ThreadData:=PPOCAThreadData(POCAGhostGetPointer(This));
  POCAGarbageCollectorUnlock(Context);
  try
   if not TPasMPInterlocked.CompareExchange(ThreadData^.Started,true,false) then begin
    POCASemaphoreUp(ThreadData^.StartSemaphore,1);
   end;
{$ifdef Windows}
   ResumeThread(ThreadData^.Handle);
{$endif}
  finally
   POCAGarbageCollectorLock(Context);
  end;
  result:=This;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAThreadFunctionSUSPEND(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
begin
 if POCAGhostGetType(This)=@POCAThreadGhost then begin
  ThreadData:=PPOCAThreadData(POCAGhostGetPointer(This));
  POCAGarbageCollectorUnlock(Context);
  try
{$ifdef Windows}
   SuspendThread(ThreadData^.Handle);
{$endif}
  finally
   POCAGarbageCollectorLock(Context);
  end;
  result:=This;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAThreadFunctionKILL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 exit;
 if POCAGhostGetType(This)=@POCAThreadGhost then begin
  ThreadData:=PPOCAThreadData(POCAGhostGetPointer(This));
  POCAGarbageCollectorUnlock(Context);
  try
   try
{$ifdef fpc}
    System.KillThread(ThreadData^.Handle);
{$else}
    TerminateThread(ThreadData^.Handle,0);
{$endif}
   except
   end;
   if assigned(ThreadData^.Context) then begin
    ThreadData^.Context^.CoroutineData:=nil;
    POCAContextDestroy(ThreadData^.Context);
    ThreadData^.Context:=nil;
   end;
   ThreadData^.Data.Num:=0;
   ThreadData^.Terminated:=true;
  finally
   POCAGarbageCollectorLock(Context);
  end;
  result:=This;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAThreadFunctionTERMINATED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
begin
 if POCAGhostGetType(This)=@POCAThreadGhost then begin
  ThreadData:=PPOCAThreadData(POCAGhostGetPointer(This));
  if ThreadData^.Terminated then begin
   result.Num:=1;
  end else begin
   result.Num:=0;
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAThreadFunctionWAIT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
    ms:TPOCAInt32;
begin
 if POCAGhostGetType(This)=@POCAThreadGhost then begin
  ThreadData:=PPOCAThreadData(POCAGhostGetPointer(This));
  if not ThreadData^.Terminated then begin
   if CountArguments<1 then begin
{$ifdef fpc}
    WaitForThreadTerminate(ThreadData^.Handle,0);
{$else}
{$ifdef win32}
    WaitForSingleObject(ThreadData^.Handle,TPOCAUInt32(-1));
{$endif}
{$endif}
    TPasMPInterlocked.Write(ThreadData^.Terminated,true);
   end else begin
    ms:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
{$ifdef fpc}
    WaitForThreadTerminate(ThreadData^.Handle,ms);
{$else}
{$ifdef win32}
    WaitForSingleObject(ThreadData^.Handle,TPOCAUInt32(ms));
{$endif}
{$endif}
   end;
  end;
  if ThreadData^.Terminated then begin
   result.Num:=1;
  end else begin
   result.Num:=0;
  end;
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAInitThreadNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCAThreadFunctionCREATE);
end;

function POCAInitThreadHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'resume',POCAThreadFunctionRESUME);
 POCAAddNativeFunction(Context,result,'suspend',POCAThreadFunctionSUSPEND);
 POCAAddNativeFunction(Context,result,'kill',POCAThreadFunctionKILL);
 POCAAddNativeFunction(Context,result,'terminated',POCAThreadFunctionTERMINATED);
 POCAAddNativeFunction(Context,result,'wait',POCAThreadFunctionWAIT);
 POCAAddNativeFunction(Context,result,'start',POCAThreadFunctionRESUME);
 POCAAddNativeFunction(Context,result,'stop',POCAThreadFunctionKILL);
end;

procedure POCALockGhostDestroy(const Ghost:PPOCAGhost);
begin
 if assigned(Ghost) and assigned(Ghost^.Ptr) then begin
  POCALockDestroy(Ghost^.Ptr);
 end;
end;

const POCALockGhost:TPOCAGhostType=(Destroy:POCALockGhostDestroy;CanDestroy:nil;Mark:nil;ExistKey:nil;GetKey:nil;SetKey:nil;Name:'Lock');

function POCALockFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result:=POCANewGhost(Context,@POCALockGhost,POCALockCreate);
 POCAGhostSetHashValue(result,Context^.Instance.Globals.LockHash);
end;

function POCALockFunctionENTER(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if POCAGhostGetType(This)=@POCALockGhost then begin
  POCAGarbageCollectorUnlock(Context);
  try
   POCALockEnter(POCAGhostGetPointer(This));
  finally
   POCAGarbageCollectorLock(Context);
  end;
  result.Num:=1;
 end else begin
  result.Num:=0;
 end;
end;

function POCALockFunctionLEAVE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if POCAGhostGetType(This)=@POCALockGhost then begin
  POCALockLeave(POCAGhostGetPointer(This));
 end;
end;

function POCAInitLockNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCALockFunctionCREATE);
end;

function POCAInitLockHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'enter',POCALockFunctionENTER);
 POCAAddNativeFunction(Context,result,'leave',POCALockFunctionLEAVE);
end;

procedure POCASemaphoreGhostDestroy(const Ghost:PPOCAGhost);
begin
 if assigned(Ghost) and assigned(Ghost^.Ptr) then begin
  POCASemaphoreDestroy(Ghost^.Ptr);
 end;
end;

const POCASemaphoreGhost:TPOCAGhostType=(Destroy:POCASemaphoreGhostDestroy;CanDestroy:nil;Mark:nil;ExistKey:nil;GetKey:nil;SetKey:nil;Name:'Semaphore');

function POCASemaphoreFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result:=POCANewGhost(Context,@POCASemaphoreGhost,POCASemaphoreCreate);
 POCAGhostSetHashValue(result,Context^.Instance.Globals.SemaphoreHash);
end;

function POCASemaphoreFunctionDOWN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if POCAGhostGetType(This)=@POCASemaphoreGhost then begin
  POCAGarbageCollectorUnlock(Context);
  try
   POCASemaphoreDown(POCAGhostGetPointer(This));
  finally
   POCAGarbageCollectorLock(Context);
  end;
 end;
end;

function POCASemaphoreFunctionUP(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if POCAGhostGetType(This)=@POCASemaphoreGhost then begin
  POCASemaphoreUp(POCAGhostGetPointer(This),1);
 end;
end;

function POCAInitSemaphoreNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCASemaphoreFunctionCREATE);
end;

function POCAInitSemaphoreHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'down',POCASemaphoreFunctionDOWN);
 POCAAddNativeFunction(Context,result,'up',POCASemaphoreFunctionUP);
end;

function POCADateTimeFunctionNOW(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=SysUtils.Now;
end;

function POCADateTimeFunctionNOWUTC(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=NowUTC;
end;

function POCADateTimeFunctionMILLISECONDS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "DateTime.milliseconds"');
 end;
 result.Num:=POCAGetNumberValue(Context,Arguments^[0])*86400000;
end;

function POCADateTimeFunctionUTCOFFSET(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var DateTime:TDateTime;
begin
 if CountArguments>0 then begin
  DateTime:=POCAGetNumberValue(Context,Arguments^[0]);
 end else begin
  DateTime:=SysUtils.Now;
 end;
 result.Num:=GetDateTimeUTCOffset(DateTime);
end;

function POCADateTimeFunctionTOLOCAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "DateTime.toLocal"');
 end;
 result.Num:=DateTimeFromUniversalTimeToLocalTime(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCADateTimeFunctionTOUNIVERSAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "DateTime.toUniversal"');
 end;
 result.Num:=DateTimeFromLocalTimeToUniversalTime(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCADateTimeFunctionFROMUNIXTIME(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "DateTime.fromUnixTime"');
 end;
 result.Num:=DateTimeFromUnixTime(trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCADateTimeFunctionTOUNIXTIME(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "DateTime.toUnixTime"');
 end;
 result.Num:=DateTimeToUnixTime(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCADateTimeFunctionTOSTRING(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var DateTime:TDateTime;
    Format:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  DateTime:=POCAGetNumberValue(Context,Arguments^[0]);
 end else begin
  DateTime:=SysUtils.Now;
 end;
 if CountArguments>1 then begin
  Format:=POCAGetStringValue(Context,Arguments^[1]);
 end else begin
  Format:='yyyy-mm-dd hh:nn:ss.zzz';
 end;
 result:=POCANewString(Context,FormatDateTime(Format,DateTime));
end;

function POCADateTimeFunctionPARSE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var DateTime:TPOCARawByteString;
//  Format:TPOCARawByteString;
begin
 if CountArguments>0 then begin
  DateTime:=POCAGetStringValue(Context,Arguments^[0]);
 end else begin
  DateTime:='';
 end;
{if CountArguments>1 then begin
  Format:=POCAGetStringValue(Context,Arguments^[1]);
 end else begin
  Format:='yyyy-mm-dd hh:nn:ss.zzz';
 end;//}
 result.Num:=ParseDateTime(DateTime);
end;

function POCAInitDateTimeNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'now',POCADateTimeFunctionNOW);
 POCAAddNativeFunction(Context,result,'nowUTC',POCADateTimeFunctionNOWUTC);
 POCAAddNativeFunction(Context,result,'milliseconds',POCADateTimeFunctionMILLISECONDS);
 POCAAddNativeFunction(Context,result,'utcOffset',POCADateTimeFunctionUTCOFFSET);
 POCAAddNativeFunction(Context,result,'toLocal',POCADateTimeFunctionTOLOCAL);
 POCAAddNativeFunction(Context,result,'toUniversal',POCADateTimeFunctionTOUNIVERSAL);
 POCAAddNativeFunction(Context,result,'fromUnixTime',POCADateTimeFunctionFROMUNIXTIME);
 POCAAddNativeFunction(Context,result,'toUnixTime',POCADateTimeFunctionTOUNIXTIME);
 POCAAddNativeFunction(Context,result,'toString',POCADateTimeFunctionTOSTRING);
 POCAAddNativeFunction(Context,result,'parse',POCADateTimeFunctionPARSE);
end;

function POCAArrayFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i:TPOCAInt32;
begin
 result:=POCANewArray(Context);
 if CountArguments>0 then begin
  POCAArraySetSize(result,trunc(POCAGetNumberValue(Context,Arguments^[0])));
  for i:=1 to CountArguments-1 do begin
   POCAArraySet(result,i-1,Arguments^[i]);
  end;       
 end;
end;

function POCAInitArrayNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCAArrayFunctionCREATE);
end;

function POCAStringFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments>0 then begin
  result:=POCAStringValue(Context,Arguments^[0]);
 end else begin
  result:=POCANewString(Context,'');
 end;
end;

function POCAStringFunctionDUMP(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments>0 then begin
  result:=POCANewString(Context,POCAStringDump(Context,Arguments^[0]));
 end else begin
  result:=POCANewString(Context,'');
 end;
end;

function POCAStringFunctionFROMCODEPOINTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var s:TPOCARawByteString;
    i,j:TPOCAInt32;
begin
 if CountArguments>0 then begin
  s:='';
  if (CountArguments=1) and POCAIsValueArray(Arguments^[0]) then begin
   j:=POCAArraySize(Arguments^[0]);
   for i:=1 to j do begin
    s:=s+PUCUUTF32CharToUTF8(trunc(POCAGetNumberValue(Context,POCAArrayGet(Arguments^[0],i-1))));
   end;
  end else begin
   for i:=0 to CountArguments-1 do begin
    s:=s+PUCUUTF32CharToUTF8(trunc(POCAGetNumberValue(Context,Arguments^[i])));
   end;
  end;
  result:=POCANewString(Context,s);
 end else begin
  result:=POCANewString(Context,'');
 end;
end;

function POCAStringFunctionFROMCODEUNITS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var s:TPOCARawByteString;
    i,j:TPOCAInt32;
begin
 if CountArguments>0 then begin
  s:='';
  if (CountArguments=1) and POCAIsValueArray(Arguments^[0]) then begin
   j:=POCAArraySize(Arguments^[0]);
   SetLength(s,j);
   for i:=1 to j do begin
    s[i]:=AnsiChar(TPOCAUInt8(trunc(POCAGetNumberValue(Context,POCAArrayGet(Arguments^[0],i-1)))));
   end;
  end else begin
   SetLength(s,CountArguments);
   for i:=1 to CountArguments do begin
    s[i]:=AnsiChar(TPOCAUInt8(trunc(POCAGetNumberValue(Context,Arguments^[i-1]))));
   end;
  end;
  result:=POCANewString(Context,s);
 end else begin
  result:=POCANewString(Context,'');
 end;
end;

function POCAInitStringNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCAStringFunctionCREATE);
 POCAAddNativeFunction(Context,result,'dump',POCAStringFunctionDUMP);
 POCAAddNativeFunction(Context,result,'fromCodePoints',POCAStringFunctionFROMCODEPOINTS);
 POCAAddNativeFunction(Context,result,'fromCodeUnits',POCAStringFunctionFROMCODEUNITS);
end;

function POCANumberFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments>0 then begin
  if CountArguments>1 then begin
   case POCAGetValueType(Arguments^[0]) of
    pvtNULL:begin
     result.Num:=0;
    end;
    pvtNUMBER:begin
     result:=POCANumberValue(Context,Arguments^[0]);
    end;
    else begin
     result.Num:=ConvertStringToDouble(POCAGetStringValue(Context,Arguments^[0]),rmNearest,nil,trunc(POCAGetNumberValue(Context,Arguments^[1])));
    end;
   end;
  end else begin
   result:=POCANumberValue(Context,Arguments^[0]);
  end;
 end else begin
  result.Num:=0;
 end;
end;

function POCAInitNumberNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCANumberFunctionCREATE);
end;

function POCABooleanFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin                  
 if CountArguments>0 then begin
  result:=POCABooleanValue(Context,Arguments^[0]);
 end else begin
  result.Num:=0;
 end;
end;

function POCAInitBooleanNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCABooleanFunctionCREATE);
end;

function POCAConsoleFunctionLOG(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i:TPOCAInt32;
    Value:TPOCAValue;
    s:TPOCAUTF8String;
begin
 for i:=0 to CountArguments-1 do begin
  Value:=Arguments^[i];
  case POCAGetValueType(Value) of
   pvtNULL:begin
    s:='null';
    if assigned(Context) and assigned(Context^.UserIOWrite) then begin
     Context^.UserIOWrite(Context,s);
    end else begin
     System.Write(s);
    end;
   end;
   pvtSTRING:begin
    s:=TPOCAUTF8String(PPOCAString(POCAGetValueReferencePointer(Value))^.Data);
    if assigned(Context) and assigned(Context^.UserIOWrite) then begin
     Context^.UserIOWrite(Context,s);
    end else begin
     System.Write(s);
    end;
   end;
   pvtNUMBER:begin
    s:=POCADoubleToString(Value.Num);
    if assigned(Context) and assigned(Context^.UserIOWrite) then begin
     Context^.UserIOWrite(Context,s);
    end else begin
     System.Write(s);
    end;
   end;
   else begin
    POCARuntimeError(Context,'Bad arguments to "log"');
   end;
  end;
 end;
 if assigned(Context) and assigned(Context^.UserIOWriteLn) then begin
  Context^.UserIOWriteLn(Context,'');
 end else begin
  System.WriteLn('');
 end;
 if assigned(Context) and assigned(Context^.UserIOFlush) then begin
  Context^.UserIOFlush(Context);
 end;
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
end;

function POCAConsoleFunctionREADLINE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Prompt,Line:TPOCAUTF8String;
    Null:Boolean;
begin
 if CountArguments>0 then begin
  Prompt:=POCAGetStringValue(Context,Arguments^[0]);
 end else begin
  Prompt:='';
 end;
 Line:=ReadLine(Context,Prompt,Null);
 if Null then begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end else begin
  result:=POCANewString(Context,Line);
 end;
end;

function POCAConsoleFunctionINITIALIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 InitializeConsole(Context);
 result.Num:=1.0;
end;

function POCAConsoleFunctionFINALIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 FinalizeConsole(Context);
 result.Num:=1.0;
end;

function POCAConsoleFunctionREADKEY(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=ReadKey(Context);
end;

function POCAInitConsoleNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'log',POCAConsoleFunctionLOG);
 POCAAddNativeFunction(Context,result,'readLine',POCAConsoleFunctionREADLINE);
 POCAAddNativeFunction(Context,result,'readKey',POCAConsoleFunctionREADKEY);
 POCAAddNativeFunction(Context,result,'initialize',POCAConsoleFunctionINITIALIZE);
 POCAAddNativeFunction(Context,result,'finalize',POCAConsoleFunctionFINALIZE);
end;

procedure TPOCANativeObjectDestroy(const Ghost:PPOCAGhost);
begin
 if assigned(Ghost) and assigned(Ghost^.Ptr) then begin
  TPOCANativeObject(Ghost^.Ptr).Free;
 end;
end;

function TPOCANativeObjectCanDestroy(const Ghost:PPOCAGhost):TPOCABool32;
begin
 result:=assigned(Ghost) and assigned(Ghost^.Ptr);
end;

function TPOCANativeObjectFunctionNativeMethodCall(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var PropertyItem:PPOCANativeObjectProperty;
begin
 PropertyItem:=UserData;
 if assigned(PropertyItem) then begin
  result:=PropertyItem^.Method(Context,This,Arguments,CountArguments);
 end else begin 
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function TPOCANativeObjectMark(const Ghost:PPOCAGhost):TPOCABool32;
begin
 if assigned(Ghost) and assigned(Ghost^.Ptr) then begin
  result:=TPOCANativeObject(Ghost^.Ptr).Mark;
 end else begin
  result:=false;
 end;
end;

constructor TPOCANativeObject.Create(const aInstance:PPOCAInstance;const aContext:PPOCAContext;const aPrototype,aConstructor:PPOCAValue;const aExpandable:boolean);
{$ifdef fpc}
type PShortString=^ShortString;
{$endif}
type PMethodNameRec=^TMethodNameRec;
     TMethodNameRec=packed record
{$ifdef fpc}
      Name:PShortString;
      Address:TPOCAPointer;
{$else}
      Size:TPOCAUInt16;
      Address:TPOCAPointer;
      Name:ShortString;
{$endif}
     end;
     TMethodNameRecs=packed array[TPOCAUInt16] of TMethodNameRec;
     PMethodNameTable=^TMethodNameTable;
     TMethodNameTable=packed record
      Count:{$ifdef fpc}TPOCAUInt32{$else}TPOCAUInt16{$endif};
      Methods:TMethodNameRecs;
     end;
var Index,Count:TPOCAInt32;
    Hash,EventsHash:PPOCAHash;
//  HashRec,EventsHashRec:PPOCAHashRecord;
    MethodTable:PMethodNameTable;
    MethodNameRec:PMethodNameRec;
    MethodName:string;
    MethodAddress:TPOCAPointer;
    NativeFunction:TPOCANativeObjectMethod;
    IsEvent:boolean;
    PropertyItem:PPOCANativeObjectProperty;
begin
 inherited Create;

 fInstance:=aInstance;
 fExpandable:=aExpandable;

 fPropList:=nil;
 fPropListLen:=GetPropList(self,fPropList);

 FillChar(fGhostType,SizeOf(TPOCAGhostType),#0);
 fGhostType.Name:=TPOCAUTF8String(ClassName);
 fGhostType.Destroy:=TPOCANativeObjectDestroy;
 fGhostType.CanDestroy:=TPOCANativeObjectCanDestroy;
 fGhostType.Mark:=TPOCANativeObjectMark;

 fHashValue:=POCANewHash(aContext);
 POCAProtect(aContext,fHashValue);
 Hash:=POCAGetValueReferencePointer(fHashValue);

 fGhostValue:=POCANewGhost(aContext,@fGhostType,self,Hash,pgptOBJECT);
 POCAProtect(aContext,fGhostValue);
 POCAGhostSetHashValue(fGhostValue,fHashValue);

 if assigned(aPrototype) and not POCAIsValueNull(aPrototype^) then begin
  POCAHashSetPrototypeValue(aContext,fHashValue,aPrototype^);
 end;

 if assigned(aConstructor) and not POCAIsValueNull(aConstructor^) then begin
  POCAHashSetConstructorValue(aContext,fHashValue,aConstructor^);
 end;

 fEventsHashValue:=POCANewHash(aContext);
 POCAProtect(aContext,fEventsHashValue);
 EventsHash:=POCAGetValueReferencePointer(fEventsHashValue);

//EventsHashRec:=POCAHashCreateEvents(Instance,EventsHash);

 try

  Count:=fPropListLen;
  MethodTable:=TPOCAPointer(TPOCAPointer(TPOCAPtrInt(TPOCAPtrInt(TPOCAPointer(self)^)+vmtMethodTable))^);
  if assigned(MethodTable) then begin
   MethodNameRec:=@MethodTable^.Methods[0];
   for Index:=0 to MethodTable^.Count-1 do begin
{$ifdef fpc}
    MethodName:=String(MethodNameRec^.Name^);
{$else}
    MethodName:=String(MethodNameRec^.Name);
{$endif}
    MethodAddress:=MethodNameRec^.Address;
    if (length(MethodName)>0) and assigned(MethodAddress) then begin
     inc(Count);
    end;
   end;
  end;

  fProperties:=nil;
  fCountProperties:=Count;
  SetLength(fProperties,fCountProperties);

  fPropHashMap:=TPOCAStringHashMap.Create(true);
  for Index:=0 to fPropListLen-1 do begin
   fPropHashMap.SetValue(fPropList^[Index].Name,Index);
   PropertyItem:=@fProperties[Index];
// PropertyItem^.Key:=POCAValueNull;
   PropertyItem^.Key.CastedUInt64:=POCAValueNullCastedUInt64;
   PropertyItem^.PropInfo:=fPropList^[Index];
// PropertyItem^.Value:=POCAValueNull;
   PropertyItem^.Value.CastedUInt64:=POCAValueNullCastedUInt64;
  end;

  Count:=fPropListLen;
  MethodTable:=TPOCAPointer(TPOCAPointer(TPOCAPtrInt(TPOCAPtrInt(TPOCAPointer(self)^)+vmtMethodTable))^);
  if assigned(MethodTable) then begin
   MethodNameRec:=@MethodTable^.Methods[0];
   for Index:=0 to MethodTable^.Count-1 do begin
{$ifdef fpc}
    MethodName:=String(MethodNameRec^.Name^);
{$else}
    MethodName:=String(MethodNameRec^.Name);
{$endif}
    MethodAddress:=MethodNameRec^.Address;
    if (length(MethodName)>0) and assigned(MethodAddress) then begin
     if (length(MethodName)>1) and (MethodName[length(MethodName)]='_') then begin
      Delete(MethodName,length(MethodName),1);
     end;
     IsEvent:=(length(MethodName)>2) and (MethodName[1]='_') and (MethodName[2]='_');
     TMethod(NativeFunction).Code:=MethodAddress;
     TMethod(NativeFunction).Data:=self;
     fPropHashMap.SetValue(TPOCAUTF8String(MethodName),Count);
     PropertyItem:=@fProperties[Count];
//   PropertyItem^.Key:=POCAValueNull;
     PropertyItem^.Key.CastedUInt64:=POCAValueNullCastedUInt64;
     PropertyItem^.PropInfo:=nil;
     PropertyItem^.Method:=NativeFunction;
     PropertyItem^.Value:=POCANewFunction(aContext,POCANewNativeCode(aContext,TPOCANativeObjectFunctionNativeMethodCall,nil,PropertyItem));
     if IsEvent then begin
      POCAHashSet(aContext,fEventsHashValue,POCANewUniqueString(aContext,TPOCAUTF8String(MethodName)),PropertyItem^.Value,false);
     end;
     inc(Count);
    end;
{$ifdef fpc}
    inc(MethodNameRec);
{$else}
    inc(TPOCAPtrUInt(MethodNameRec),MethodNameRec^.Size);
{$endif}
   end;
  end;

  POCAHashLockInvalidate(EventsHash);

  POCAHashSetHashEvents(aContext,fHashValue,fEventsHashValue);

 finally

  POCAUnprotect(aContext,fGhostValue);
  POCAUnprotect(aContext,fHashValue);
  POCAUnprotect(aContext,fEventsHashValue);

  POCATemporarySave(aContext,fHashValue);

 end;

end;

destructor TPOCANativeObject.Destroy;
begin
 fPropHashMap.Free;
 SetLength(fProperties,0);
 if assigned(fPropList) then begin
  FreeMem(fPropList);
  fPropList:=nil;
  fPropListLen:=0;
 end;
 inherited Destroy;
end;

function TPOCANativeObject.Mark:boolean;
var PropertyIndex:TPOCAInt32;
    PropertyItem:PPOCANativeObjectProperty;
    PropInfo:PPropInfo;
    AObject:TObject;
begin
 POCAMarkValue(fInstance,fHashValue);
 for PropertyIndex:=0 to fCountProperties-1 do begin
  PropertyItem:=@fProperties[PropertyIndex];
  POCAMarkValue(fInstance,PropertyItem^.Value);
  PropInfo:=PropertyItem^.PropInfo;
  if assigned(PropInfo) then begin
   if assigned(PropInfo^.PropType) then begin
    case PropInfo^.PropType^.Kind of
     tkClass:begin
      AObject:=GetObjectProp(self,PropInfo);
      if assigned(AObject) and (AObject is TPOCANativeObject) then begin
       TPOCANativeObject(AObject).Mark;
      end;
     end;
    end;
   end;
  end;
 end;
 result:=true;
end;

function TPOCANativeObject.FindPropertyIndex(const Context:PPOCAContext;const Key:TPOCAValue;const CacheIndex:PLongword=nil):TPOCAInt32;
var PropertyItem:PPOCANativeObjectProperty;
begin
 if assigned(CacheIndex) and ((TPOCAInt32(CacheIndex^)>=0) and (TPOCAInt32(CacheIndex^)<fCountProperties)) then begin
  PropertyItem:=@fProperties[CacheIndex^];
  if PropertyItem^.Key.CastedInt64=Key.CastedInt64 then begin
   result:=CacheIndex^;
   exit;
  end;
 end;
 result:=fPropHashMap.GetValue(POCAGetStringValue(Context,Key));
 if assigned(CacheIndex) and (result>=0) and (result<fCountProperties) then begin
  CacheIndex^:=result;
  fProperties[result].Key.CastedInt64:=Key.CastedInt64;
 end;
end;

function TPOCANativeObject.GetPropertyValue(const Context:PPOCAContext;const PropertyIndex:TPOCAInt32;var Value:TPOCAValue):boolean;
var PropInfo:PPropInfo;
    AObject:TObject;
begin
 result:=(PropertyIndex>=0) and (PropertyIndex<fCountProperties);
 if result then begin
  PropInfo:=fProperties[PropertyIndex].PropInfo;
  if assigned(PropInfo) then begin
   if assigned(PropInfo^.PropType) and assigned(PropInfo^.GetProc) then begin
    case PropInfo^.PropType^.Kind of
     tkLString{$ifdef fpc},tkAString,tkSString{$endif}:begin
      Value:=POCANewString(Context,TPOCAUTF8String(GetStrProp(self,PropInfo)));
     end;
     tkWString{$ifdef fpc},tkUString{$endif}{$ifdef POCAEmbarcaderoNextGen},tkUString{$endif}:begin
      Value:=POCANewString(Context,PUCUUTF16ToUTF8({$ifdef POCAEmbarcaderoNextGen}GetStrProp{$else}GetWideStrProp{$endif}(self,PropInfo)));
     end;
     tkEnumeration:begin
      Value:=POCANewString(Context,TPOCAUTF8String(GetEnumProp(self,PropInfo)));
     end;
     tkSet:begin
      Value:=POCANewString(Context,TPOCAUTF8String(GetSetProp(self,PropInfo,false)));
     end;
     tkInteger:begin
      Value.Num:=GetOrdProp(self,PropInfo);
     end;
     tkChar:begin
      Value:=POCANewString(Context,PUCUUTF16ToUTF8(WideChar(TPOCAUInt16(GetOrdProp(self,PropInfo)))));
     end;
     tkWChar{$ifdef fpc},tkUChar{$endif}:begin
      Value:=POCANewString(Context,PUCUUTF16ToUTF8(WideChar(TPOCAUInt16(GetOrdProp(self,PropInfo)))));
     end;
     tkInt64{$ifdef fpc},tkQWORD{$endif}:begin
      Value.Num:=GetOrdProp(self,PropInfo);
     end;
     tkFloat:begin
      Value.Num:=GetFloatProp(self,PropInfo);
     end;
     tkClass:begin
      AObject:=GetObjectProp(self,PropInfo);
      if assigned(AObject) then begin
       if AObject is TPOCANativeObject then begin
        Value:=TPOCANativeObject(AObject).fGhostValue;
       end else begin
        POCARuntimeError(Context,'Unknown native property data type');
       end;
      end else begin
       POCARuntimeError(Context,'Unknown native property data type');
      end;
     end;
     tkVariant:begin
      Value:=POCANewValueFromVariant(Context,GetVariantProp(self,PropInfo));
     end;
     else begin
      POCARuntimeError(Context,'Unknown native property data type');
      exit;
     end;
    end;
   end else begin
    POCARuntimeError(Context,'Read-access from a non-readable member isn''t allowed');
   end;
  end else begin
   Value:=fProperties[PropertyIndex].Value;
  end;
 end;
end;

function TPOCANativeObject.SetPropertyValue(const Context:PPOCAContext;const PropertyIndex:TPOCAInt32;const Value:TPOCAValue):boolean;
var PropInfo:PPropInfo;
//  AObject:TObject;
    Ghost:PPOCAGhost;
    TypeData:PTypeData;
begin
 result:=(PropertyIndex>=0) and (PropertyIndex<fPropListLen);
 if result then begin
  PropInfo:=fProperties[PropertyIndex].PropInfo;
  if assigned(PropInfo) and assigned(PropInfo^.PropType) and assigned(PropInfo^.SetProc) then begin
   case PropInfo^.PropType^.Kind of
    tkLString{$ifdef fpc},tkAString,tkSString{$endif}:begin
     SetStrProp(self,PropInfo,String(POCAGetStringValue(Context,Value)));
    end;
    tkWString{$ifdef fpc},tkUString{$endif}{$ifdef POCAEmbarcaderoNextGen},tkUString{$endif}:begin
     {$ifdef POCAEmbarcaderoNextGen}SetStrProp{$else}SetWideStrProp{$endif}(self,PropInfo,PUCUUTF8ToUTF16(POCAGetStringValue(Context,Value)));
    end;
    tkEnumeration:begin
     SetEnumProp(self,PropInfo,String(POCAGetStringValue(Context,Value)));
    end;
    tkSet:begin
     SetSetProp(self,PropInfo,String(POCAGetStringValue(Context,Value)));
    end;
    tkInteger:begin
     SetOrdProp(self,PropInfo,trunc(POCAGetNumberValue(Context,Value)));
    end;
    tkChar,tkWChar{$ifdef fpc},tkUChar{$endif}:begin
     case POCAGetValueType(Value) of
      pvtNUMBER:begin
       SetOrdProp(self,PropInfo,trunc(POCAGetNumberValue(Context,Value)));
      end;
      else begin
       SetOrdProp(self,PropInfo,PUCUUTF8CodeUnitGetCharFallBack(POCAGetStringValue(Context,Value),0));
      end;
     end;
    end;
    tkInt64{$ifdef fpc},tkQWORD{$endif}:begin
     SetOrdProp(self,PropInfo,trunc(POCAGetNumberValue(Context,Value)));
    end;
    tkFloat:begin
     SetFloatProp(self,PropInfo,POCAGetNumberValue(Context,Value));
    end;
    tkClass:begin
     case POCAGetValueType(Value) of
      pvtGHOST:begin
       Ghost:=POCAHashGetGhost(Value);
       if assigned(Ghost) and (Ghost^.PtrType=pgptOBJECT) and assigned(Ghost^.Ptr) then begin
        TypeData:={$ifdef fpc}GetTypeData(PropInfo^.PropType){$else}GetTypeData(PropInfo^.PropType^){$endif};
        if assigned(TypeData) and (TObject(Ghost^.Ptr) is TypeData^.ClassType) then begin
         SetObjectProp(self,PropInfo,TObject(Ghost^.Ptr));
         exit;
        end;
       end;
      end;
     end;
     POCARuntimeError(Context,'Unknown native property data type');
    end;
    tkVariant:begin
     SetVariantProp(self,PropInfo,POCAGetVariantValue(Context,Value));
    end;
    else begin
     POCARuntimeError(Context,'Unknown native property data type');
     exit;
    end;
   end;
  end else begin
   POCARuntimeError(Context,'Write-access to a non-writable member isn''t allowed');
  end;
 end;
end;

function POCAGlobalFunctionSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "size"');
 end;
 case POCAGetValueType(Arguments^[0]) of
  pvtSTRING:begin
   if PPOCAString(POCAGetValueReferencePointer(Arguments^[0]))^.UTF8=suISUTF8 then begin
    result.Num:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]))^.UTF8Length;
   end else begin
    result.Num:=length(PPOCAString(POCAGetValueReferencePointer(Arguments^[0]))^.Data);
   end;
  end;
  pvtARRAY:begin
   result.Num:=POCAArraySize(Arguments^[0]);
  end;
  pvtHASH:begin
   result.Num:=POCAHashSize(Context,Arguments^[0]);
  end;
  else begin
   result.Num:=0;
  end;
 end;
end;

function POCAGlobalFunctionOWNKEYS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Hash:TPOCAValue;
begin
 if CountArguments>0 then begin
  Hash:=Arguments^[0];
 end else begin
//Hash:=POCAValueNull;
  Hash.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if not POCAIsValueHash(Hash) then begin
  POCARuntimeError(Context,'Bad arguments to "ownKeys"');
 end;
 result:=POCANewArray(Context);
 POCAHashOwnKeys(Context,result,Hash);
 POCAArraySort(Context,result);
end;

function POCAGlobalFunctionKEYS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Hash:TPOCAValue;
begin
 if CountArguments>0 then begin
  Hash:=Arguments^[0];
 end else begin
//Hash:=POCAValueNull;
  Hash.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if not POCAIsValueHash(Hash) then begin
  POCARuntimeError(Context,'Bad arguments to "keys"');
 end;
 result:=POCANewArray(Context);
 POCAHashKeys(Context,result,Hash);
 POCAArraySort(Context,result);
end;

function POCAGlobalFunctionPRINT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i:TPOCAInt32;
    Value:TPOCAValue;
    s:TPOCAUTF8String;
begin
 for i:=0 to CountArguments-1 do begin
  Value:=Arguments^[i];
  case POCAGetValueType(Value) of
   pvtNULL:begin
    s:='null';
    if assigned(Context) and assigned(Context^.UserIOWrite) then begin
     Context^.UserIOWrite(Context,s);
    end else begin
     System.Write(s);
    end;
   end;
   pvtSTRING:begin
    s:=TPOCAUTF8String(PPOCAString(POCAGetValueReferencePointer(Value))^.Data);
    if assigned(Context) and assigned(Context^.UserIOWrite) then begin
     Context^.UserIOWrite(Context,s);
    end else begin
     System.Write(s);
    end;
   end;
   pvtNUMBER:begin
    s:=POCADoubleToString(Value.Num);
    if assigned(Context) and assigned(Context^.UserIOWrite) then begin
     Context^.UserIOWrite(Context,s);
    end else begin
     System.Write(s);
    end;
   end;
   else begin
    POCARuntimeError(Context,'Bad arguments to "print"');
   end;
  end;
 end;
 if assigned(Context) and assigned(Context^.UserIOFlush) then begin
  Context^.UserIOFlush(Context);
 end;
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
end;

function POCAGlobalFunctionPUTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i:TPOCAInt32;
    Value:TPOCAValue;
    s:TPOCAUTF8String;
begin
 for i:=0 to CountArguments-1 do begin
  Value:=Arguments^[i];
  case POCAGetValueType(Value) of
   pvtNULL:begin
    s:='null';
    if assigned(Context) and assigned(Context^.UserIOWrite) then begin
     Context^.UserIOWrite(Context,s);
    end else begin
     System.Write(s);
    end;
   end;
   pvtSTRING:begin
    s:=TPOCAUTF8String(PPOCAString(POCAGetValueReferencePointer(Value))^.Data);
    if assigned(Context) and assigned(Context^.UserIOWrite) then begin
     Context^.UserIOWrite(Context,s);
    end else begin
     System.Write(s);
    end;
   end;
   pvtNUMBER:begin
    s:=POCADoubleToString(Value.Num);
    if assigned(Context) and assigned(Context^.UserIOWrite) then begin
     Context^.UserIOWrite(Context,s);
    end else begin
     System.Write(s);
    end;
   end;
   else begin
    POCARuntimeError(Context,'Bad arguments to "puts"');
   end;
  end;
 end;
 if assigned(Context) and assigned(Context^.UserIOWriteLn) then begin
  Context^.UserIOWriteLn(Context,'');
 end else begin
  System.WriteLn('');
 end;
 if assigned(Context) and assigned(Context^.UserIOFlush) then begin
  Context^.UserIOFlush(Context);
 end;
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
end;

function POCAGlobalFunctionREADLINE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Prompt,Line:TPOCAUTF8String;
    Null:Boolean;
begin
 if CountArguments>0 then begin
  Prompt:=POCAGetStringValue(Context,Arguments^[0]);
 end else begin
  Prompt:='';
 end;
 Line:=ReadLine(Context,Prompt,Null);
 if Null then begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end else begin
  result:=POCANewString(Context,Line);
 end;
end;

function POCAGlobalFunctionSLEEP(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Time:TPOCAInt64;
begin
 if CountArguments>0 then begin
  Time:=Trunc(POCAGetNumberValue(Context,Arguments^[0]));
 end else begin
  Time:=0;
 end;
 Sleep(Time);
 result.CastedUInt64:=POCAValueNullCastedUInt64;
end;

function POCAGlobalFunctionCHR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "chr"');
 end;
 result:=POCANewString(Context,PUCUUTF32CharToUTF8(trunc(POCAGetNumberValue(Context,Arguments^[0]))));
end;

function POCAGlobalFunctionORD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var s:TPOCAUTF8String;
begin
 if CountArguments>0 then begin
  s:=POCAGetStringValue(Context,Arguments^[0]);
 end else begin
  s:='';
 end;
 if length(s)>0 then begin
  result.Num:=ord(s[1]);
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAGlobalFunctionCONTAINS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Hash,Key:TPOCAValue;
begin
 if CountArguments>0 then begin
  Hash:=Arguments^[0];
 end else begin
//Hash:=POCAValueNull;
  Hash.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if CountArguments>1 then begin
  Key:=Arguments^[1];
 end else begin
//Key:=POCAValueNull;
  Key.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if (not POCAIsValueHash(Hash)) or POCAIsValueNull(Key) then begin
  POCARuntimeError(Context,'Bad arguments to "contains"');
 end;
 result.Num:=ord(POCAHashGet(Context,Hash,Key,Key)) and 1;
end;

function POCAGlobalFunctionEVAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var SubContext:PPOCAContext;
    Code,CallArguments,CallThis,CallNamespace:TPOCAValue;
    ArrayRecord:PPOCAArrayRecord;
    Name:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "eval"');
 end;
 if CountArguments>1 then begin
  Name:=POCAGetStringValue(Context,Arguments^[1]);
 end else begin
  Name:='<eval>';
 end;
 if CountArguments>2 then begin
  CallArguments:=Arguments^[2];
 end else begin
//CallArguments:=POCAValueNull;
  CallArguments.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if CountArguments>3 then begin
  CallThis:=Arguments^[3];
 end else begin
//CallThis:=POCAValueNull;
  CallThis.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if CountArguments>4 then begin
  CallNamespace:=Arguments^[4];
 end else begin
//CallNamespace:=POCAValueNull;
  CallNamespace.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if not (POCAIsValueHash(CallThis) or POCAIsValueGhost(CallThis)) then begin
//CallThis:=POCAValueNull;
  CallThis.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if not POCAIsValueHash(CallNamespace) then begin
//CallNamespace:=POCAValueNull;
  CallNamespace.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if (CountArguments=0) or (not (POCAIsValueNull(CallArguments) or POCAIsValueArray(CallArguments))) then begin
  POCARuntimeError(Context,'Bad arguments to "eval"');
 end;
 SubContext:=POCAContextSub(Context);
 try
  if POCAIsValueNull(CallNamespace) then begin
   CallNamespace:=POCANewHash(SubContext);
  end;
  Code:=POCABindToContext(Context,POCACompile(Context^.Instance,SubContext,POCAGetStringValue(Context,Arguments^[0]),Name));
  if POCAIsValueArray(CallArguments) then begin
   ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(CallArguments))^.ArrayRecord;
   if assigned(ArrayRecord) then begin
    result:=POCACall(SubContext,Code,@ArrayRecord^.Data[0],ArrayRecord^.Size,CallThis,CallNamespace);
   end else begin
    result:=POCACall(SubContext,Code,nil,0,CallThis,CallNamespace);
   end;
  end else begin
   result:=POCACall(SubContext,Code,nil,0,CallThis,CallNamespace);
  end;
 finally
  POCAContextDestroy(SubContext);
  Name:='';
 end;
end;

function POCAGlobalFunctionCOMPILE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Name:TPOCARawByteString;
    RawCode:boolean;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "compile"');
 end;
 if CountArguments>1 then begin
  Name:=POCAGetStringValue(Context,Arguments^[1]);
 end else begin
  Name:='<eval>';
 end;
 if CountArguments>2 then begin
  RawCode:=POCAGetBooleanValue(Context,Arguments^[2]);
 end else begin
  RawCode:=false;
 end;
 try
  result:=POCACompile(Context^.Instance,Context,POCAGetStringValue(Context,Arguments^[0]),Name);
  if not RawCode then begin
   result:=POCABindToContext(Context,result);
  end;
 finally
  Name:='';
 end;
end;

function POCAGlobalFunctionCALLER(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var FrameIndex:TPOCAInt32;
    Frame:PPOCAFrame;
    Index:TPOCAValue;
begin
 if CountArguments>0 then begin
  Index:=Arguments^[0];
 end else begin
  Index.Num:=1;
 end;
 FrameIndex:=trunc(POCAGetNumberValue(Context,Index));
 if FrameIndex>(Context^.FrameTop-1) then begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end else begin
  Frame:=@Context^.FrameStack[Context^.FrameTop-(1+FrameIndex)];
  result:=POCANewArray(Context);
  POCAArrayPush(result,Frame^.Locals);
  POCAArrayPush(result,Frame^.Func);
  POCAArrayPush(result,Frame^.Obj);
  if PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code))^.SourceFile>=0 then begin
   POCAArrayPush(result,POCAArrayGet(Context^.Instance^.Globals.SourceFiles,PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code))^.SourceFile));
  end else begin
   POCAArrayPush(result,POCAValueNull);
  end;
  POCAArrayPush(result,POCANumber(POCAGetSourceFile(Context,FrameIndex)));
 end;
end;

function POCAGlobalFunctionCLOSURE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i:TPOCAInt32;
    f:PPOCAFunction;
    Func,Index:TPOCAValue;
begin
 if CountArguments>0 then begin
  Func:=Arguments^[0];
 end else begin
//Func:=POCAValueNull;
  Func.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if CountArguments>0 then begin
  Index:=POCANumberValue(Context,Arguments^[1]);
 end else begin
  Index.Num:=0;
 end;
 if (not POCAIsValueFunction(Func)) or POCAIsValueNull(Index) then begin
  POCARuntimeError(Context,'Bad arguments to "closure"');
 end;
 i:=trunc(Index.Num);
 f:=PPOCAFunction(POCAGetValueReferencePointer(Func));
 while assigned(f) and (i>0) do begin
  f:=PPOCAFunction(POCAGetValueReferencePointer(f^.Next));
  dec(i);
 end;
 if assigned(f) then begin
  result:=POCANewArray(Context);
  POCAArrayPush(result,f^.Namespace);
  POCAArrayPush(result,f^.Obj);
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAGlobalFunctionBIND(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Func,Hash,Obj,Next:TPOCAValue;
begin
 if CountArguments>0 then begin
  Func:=Arguments^[0];
 end else begin
//Func:=POCAValueNull;
  Func.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if CountArguments>1 then begin
  Hash:=Arguments^[1];
 end else begin
  Hash:=POCANewHash(Context);
 end;
 if CountArguments>2 then begin
  Obj:=Arguments^[2];
 end else begin
//Obj:=POCAValueNull;
  Obj.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if CountArguments>3 then begin
  Next:=Arguments^[3];
 end else begin
//Next:=POCAValueNull;
  Next.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if ((not POCAIsValueFunction(Func)) or (not POCAIsValueHash(Hash))) or ((not POCAIsValueNull(Obj)) and (not POCAIsValueFunction(Obj))) or ((not POCAIsValueNull(Next)) and (not POCAIsValueFunction(Next))) then begin
  POCARuntimeError(Context,'Bad arguments to "bind"');
 end;
 result:=POCANewFunction(Context,PPOCAFunction(POCAGetValueReferencePointer(Func))^.Code);
 PPOCAFunction(POCAGetValueReferencePointer(result))^.Namespace:=Hash;
 PPOCAFunction(POCAGetValueReferencePointer(result))^.Obj:=Obj;
 PPOCAFunction(POCAGetValueReferencePointer(result))^.Next:=Next;
end;

function POCAGlobalFunctionCALL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Func,CallArguments,CallThis,CallNamespace:TPOCAValue;
    SubContext:PPOCAContext;
    ArrayRecord:PPOCAArrayRecord;
begin
 if CountArguments>0 then begin
  Func:=Arguments^[0];
 end else begin
//Func:=POCAValueNull;
  Func.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if CountArguments>1 then begin
  CallArguments:=Arguments^[1];
 end else begin
//CallArguments:=POCAValueNull;
  CallArguments.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if CountArguments>2 then begin
  CallThis:=Arguments^[2];
 end else begin
//CallThis:=POCAValueNull;
  CallThis.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if CountArguments>3 then begin
  CallNamespace:=Arguments^[3];
 end else begin
//CallNamespace:=POCAValueNull;
//CallNamespace.CastedUInt64:=POCAValueNullCastedUInt64;
  CallNamespace:=POCANewHash(Context); ///!
  POCATemporarySave(Context,CallNamespace);
 end;
 if not (POCAIsValueHash(CallThis) or POCAIsValueGhost(CallThis)) then begin
//CallThis:=POCAValueNull;
  CallThis.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if not POCAIsValueHash(CallNamespace) then begin
//CallNamespace:=POCAValueNull;
  CallNamespace.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if (CountArguments=0) or (not POCAIsValueFunction(Func)) or (not (POCAIsValueNull(CallArguments) or POCAIsValueArray(CallArguments))) then begin
  POCARuntimeError(Context,'Bad arguments to "call"');
 end;
 SubContext:=POCAContextSub(Context);
 try
  if POCAIsValueArray(CallArguments) then begin
   ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(CallArguments))^.ArrayRecord;
   if assigned(ArrayRecord) then begin
    result:=POCACall(SubContext,Func,@ArrayRecord^.Data[0],ArrayRecord^.Size,CallThis,CallNamespace);
   end else begin
    result:=POCACall(SubContext,Func,nil,0,CallThis,CallNamespace);
   end;
  end else begin
   result:=POCACall(SubContext,Func,nil,0,CallThis,CallNamespace);
  end;
 finally
  POCAContextDestroy(SubContext);
 end;
end;

function POCAGlobalFunctionSETHASHEVENTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if (CountArguments<2) or not POCAHashSetHashEvents(Context,Arguments^[0],Arguments^[1]) then begin
  POCARuntimeError(Context,'Bad arguments to "setHashEvents"');
 end;
 result:=Arguments^[0];
end;

function POCAGlobalFunctionGETHASHEVENTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if (CountArguments<1) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "getHashEvents"');
 end;
 result:=POCAHashGetHashEventsHash(Arguments^[0]);
end;

function POCAGlobalFunctionRAWDELETE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if (CountArguments<2) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "rawDelete"');
 end;
 result.Num:=ord(POCAHashRawDelete(Arguments^[0],Arguments^[1])) and 1;
end;

function POCAGlobalFunctionRAWEXIST(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if (CountArguments<2) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "rawExist"');
 end;
 result.Num:=ord(POCAHashRawExist(Arguments^[0],Arguments^[1])) and 1;
end;

function POCAGlobalFunctionRAWGET(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if (CountArguments<2) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "rawGet"');
 end;
 POCAHashRawGet(Arguments^[0],Arguments^[1],result);
end;

function POCAGlobalFunctionRAWSET(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Constant:Boolean;
begin
 if (CountArguments<3) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "rawSet"');
 end;
 if CountArguments>3 then begin
  Constant:=POCAGetBooleanValue(Context,Arguments^[3]);
 end else begin
  Constant:=false;
 end;
 POCAHashRawSet(Arguments^[0],Arguments^[1],Arguments^[2],Constant);
 result:=Arguments^[0];
end;

function POCAGlobalFunctionRAWSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if (CountArguments<1) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "rawSize"');
 end;
 result.Num:=ord(POCAHashRawSize(Arguments^[0])) and 1;
end;

function POCAGlobalFunctionRAWKEYS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Hash:TPOCAValue;
begin
 if CountArguments>0 then begin
  Hash:=Arguments^[0];
 end else begin
//Hash:=POCAValueNull;
  Hash.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if not POCAIsValueHash(Hash) then begin
  POCARuntimeError(Context,'Bad arguments to "rawKeys"');
 end;
 result:=POCANewArray(Context);
 POCAHashRawKeys(result,Hash);
 POCAArraySort(Context,result);
end;

function POCAInitGlobalNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAHashSetString(Context,result,'GarbageCollector',POCAInitGarbageCollectorNamespace(Context));
 POCAHashSetString(Context,result,'ModuleManager',POCAInitModuleManagerNamespace(Context));
 POCAHashSetString(Context,result,'Math',POCAInitMathNamespace(Context));
 POCAHashSetString(Context,result,'IO',POCAInitIONamespace(Context));
 POCAHashSetString(Context,result,'Path',POCAInitPathNamespace(Context));
 POCAHashSetString(Context,result,'RegExp',POCAInitRegExpNamespace(Context));
 POCAHashSetString(Context,result,'Coroutine',POCAInitCoroutineNamespace(Context));
 POCAHashSetString(Context,result,'Thread',POCAInitThreadNamespace(Context));
 POCAHashSetString(Context,result,'Lock',POCAInitLockNamespace(Context));
 POCAHashSetString(Context,result,'Semaphore',POCAInitSemaphoreNamespace(Context));
 POCAHashSetString(Context,result,'DateTime',POCAInitDateTimeNamespace(Context));
 POCAHashSetString(Context,result,'Array',POCAInitArrayNamespace(Context));
 POCAHashSetString(Context,result,'String',POCAInitStringNamespace(Context));
 POCAHashSetString(Context,result,'Number',POCAInitNumberNamespace(Context));
 POCAHashSetString(Context,result,'Boolean',POCAInitBooleanNamespace(Context));
 POCAHashSetString(Context,result,'Console',POCAInitConsoleNamespace(Context));
 POCAAddNativeFunction(Context,result,'size',POCAGlobalFunctionSIZE);
 POCAAddNativeFunction(Context,result,'ownKeys',POCAGlobalFunctionOWNKEYS);
 POCAAddNativeFunction(Context,result,'keys',POCAGlobalFunctionKEYS);
 POCAAddNativeFunction(Context,result,'print',POCAGlobalFunctionPRINT);
 POCAAddNativeFunction(Context,result,'puts',POCAGlobalFunctionPUTS);
 POCAAddNativeFunction(Context,result,'readLine',POCAGlobalFunctionREADLINE);
 POCAAddNativeFunction(Context,result,'sleep',POCAGlobalFunctionSLEEP);
 POCAAddNativeFunction(Context,result,'chr',POCAGlobalFunctionCHR);
 POCAAddNativeFunction(Context,result,'ord',POCAGlobalFunctionORD);
 POCAAddNativeFunction(Context,result,'contains',POCAGlobalFunctionCONTAINS);
 POCAAddNativeFunction(Context,result,'import',POCAGlobalFunctionIMPORT);
 POCAAddNativeFunction(Context,result,'require',POCAGlobalFunctionREQUIRE);
 POCAAddNativeFunction(Context,result,'eval',POCAGlobalFunctionEVAL);
 POCAAddNativeFunction(Context,result,'compile',POCAGlobalFunctionCOMPILE);
 POCAAddNativeFunction(Context,result,'caller',POCAGlobalFunctionCALLER);
 POCAAddNativeFunction(Context,result,'closure',POCAGlobalFunctionCLOSURE);
 POCAAddNativeFunction(Context,result,'bind',POCAGlobalFunctionBIND);
 POCAAddNativeFunction(Context,result,'call',POCAGlobalFunctionCALL);
 POCAAddNativeFunction(Context,result,'setHashEvents',POCAGlobalFunctionSETHASHEVENTS);
 POCAAddNativeFunction(Context,result,'getHashEvents',POCAGlobalFunctionGETHASHEVENTS);
 POCAAddNativeFunction(Context,result,'rawDelete',POCAGlobalFunctionRAWDELETE);
 POCAAddNativeFunction(Context,result,'rawExist',POCAGlobalFunctionRAWEXIST);
 POCAAddNativeFunction(Context,result,'rawGet',POCAGlobalFunctionRAWGET);
 POCAAddNativeFunction(Context,result,'rawSet',POCAGlobalFunctionRAWSET);
 POCAAddNativeFunction(Context,result,'rawSize',POCAGlobalFunctionRAWSIZE);
 POCAAddNativeFunction(Context,result,'rawKeys',POCAGlobalFunctionRAWKEYS);
end;

function POCABaseClassFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var ConstructorValue:TPOCAValue;                        
    SubContext:PPOCAContext;
begin
 result:=POCANewHash(Context);
 POCATemporarySave(Context,result);
 POCAHashSetPrototypeValue(Context,result,This);
 POCAHashSetConstructorValue(Context,result,This);
 POCAHashSetHashEvents(Context,result,This);
 if POCAHashGet(Context,result,Context^.Instance.Globals.ConstructorValueReference,ConstructorValue) then begin
  if POCAIsValueCode(ConstructorValue) or POCAIsValueFunction(ConstructorValue) or POCAIsValueNativeCode(ConstructorValue) then begin
   SubContext:=POCAContextSub(Context);
   try
    POCACall(SubContext,ConstructorValue,Arguments,CountArguments,result,POCAValueNull);
   finally
    POCAContextDestroy(SubContext);
   end;
  end;
 end;
end;

function POCAInitBaseClass(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCABaseClassFunctionCREATE);
 POCAHashSetString(Context,Context^.Instance.Globals.Namespace,'BaseClass',result);
end;

function POCAArrayFunctionEMPTY(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtARRAY:begin
   result.Num:=ord(POCAArraySize(This)=0) and 1;
  end;
  else begin
   result.Num:=0;
   POCARuntimeError(Context,'Bad this value to "empty"');
  end;
 end;
end;

function POCAArrayFunctionSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtARRAY:begin
   result.Num:=POCAArraySize(This);
  end;
  else begin
   result.Num:=0;
   POCARuntimeError(Context,'Bad this value to "size"');
  end;
 end;
end;

function POCAArrayFunctionRESIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result:=This;
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "resize"');
 end;
 case POCAGetValueType(This) of
  pvtARRAY:begin
   POCAArraySetSize(This,trunc(POCAGetNumberValue(Context,Arguments^[0])));
  end;
  else begin
   POCARuntimeError(Context,'Bad this value to "resize"');
  end;
 end;
end;

function POCAArrayFunctionPUSH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i:TPOCAInt32;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "push"');
 end;
 if not POCAIsValueArray(this) then begin
  POCARuntimeError(Context,'Bad this value to "push"');
 end;
 for i:=0 to CountArguments-1 do begin
  POCAArrayPush(This,Arguments^[i]);
 end;
 result:=This;
end;

function POCAArrayFunctionPOP(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "pop"');
 end;
 result:=POCAArrayPop(This);
end;

function POCAArrayFunctionSLICE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i,Len,Start,Size:TPOCAInt32;
    LenValue:TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "slice"');
 end;
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "slice"');
 end;
 Start:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
 if CountArguments>1 then begin
  LenValue:=POCANumberValue(Context,Arguments^[1]);
 end else begin
//LenValue:=POCAValueNull;
  LenValue.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if POCAIsValueNumber(LenValue) then begin
  Len:=trunc(LenValue.Num);
 end else begin
  Len:=0;
 end;
 Size:=POCAArraySize(This);
 if ((Start<0) or (Start>=Size)) or (Len<0) then begin
  POCARuntimeError(Context,'Bad arguments to "slice"');
 end;
 if (not POCAIsValueNumber(LenValue)) or (Len>(Size-Start)) then begin
  Len:=Size-Start;
 end;
 result:=POCANewArray(Context);
 if Len>0 then begin
  POCAArraySetSize(result,Len);
  for i:=0 to Len-1 do begin
   POCAArraySet(result,i,POCAArrayGet(This,Start+i));
  end;
 end;
end;

function POCAArrayFunctionSPLICE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Start,DeleteCount,InsertionCount,Size,NewSize,i:TPOCAInt32;
begin
 
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "splice"');
 end;
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "splice"');
 end;

 Size:=POCAArraySize(This);
 Start:=trunc(POCAGetNumberValue(Context,Arguments^[0]));

 // Adjust start for negative values
 if Start<0 then begin
  Start:=Size+Start;
  if Start<0 then begin
   Start:=0;
  end;
 end;
 if Start>Size then begin
  Start:=Size;
 end;

 // Determine delete count
 if CountArguments>=2 then begin
  DeleteCount:=trunc(POCAGetNumberValue(Context,Arguments^[1]));
  if DeleteCount<0 then begin
   DeleteCount:=0;
  end;
  if DeleteCount>(Size-Start) then begin
   DeleteCount:=Size-Start;
  end;
 end else begin
  DeleteCount:=Size-Start; // delete all elements from Start to end
 end;

 // Count insertion items
 if CountArguments>2 then begin
  InsertionCount:=CountArguments-2;
 end else begin
  InsertionCount:=0;
 end;

 // Build removed elements array
 result:=POCANewArray(Context);
 if DeleteCount>0 then begin
  POCAArraySetSize(result,DeleteCount);
  for i:=0 to DeleteCount-1 do begin
   POCAArraySet(result,i,POCAArrayGet(This,Start+i));
  end;
 end;

 // Adjust the original array
 NewSize:=(Size+InsertionCount)-DeleteCount;
 if InsertionCount>DeleteCount then begin
  
  // Increase size first
  POCAArraySetSize(This,NewSize);
  
  // Shift trailing elements right
  for i:=Size-1 downto Start+DeleteCount do begin
   POCAArraySet(This,(i+InsertionCount)-DeleteCount,POCAArrayGet(This,i));
  end;

 end else if InsertionCount<DeleteCount then begin
  
  // Shift trailing elements left
  for i:=Start+DeleteCount to Size-1 do begin
   POCAArraySet(This,i-(DeleteCount-InsertionCount),POCAArrayGet(This,i));
  end;

  // Then shrink the array
  POCAArraySetSize(This,NewSize);

 end else begin
  // If InsertionCount equals DeleteCount, no shifting is needed.
 end;

 // Insert new elements
 for i:=0 to InsertionCount-1 do begin
  POCAArraySet(This,Start+i,Arguments^[2+i]);
 end;

end;

function POCAArrayFunctionTOSPLICED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Start,DeleteCount,InsertionCount,Size,NewSize,Index,i:TPOCAInt32;
begin
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "toSpliced"');
 end;
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "toSpliced"');
 end;

 Size:=POCAArraySize(This);
 Start:=trunc(POCAGetNumberValue(Context,Arguments^[0]));

 // Adjust start for negative values
 if Start<0 then begin
  Start:=Size+Start;
  if Start<0 then begin
   Start:=0;
  end;
 end;
 if Start>Size then begin
  Start:=Size;
 end;

 // Determine delete count
 if CountArguments>=2 then begin
  DeleteCount:=trunc(POCAGetNumberValue(Context,Arguments^[1]));
  if DeleteCount<0 then begin
   DeleteCount:=0;
  end;
  if DeleteCount>(Size-Start) then begin
   DeleteCount:=Size-Start;
  end;
 end else begin
  DeleteCount:=Size-Start; // delete all elements from Start to end
 end;

 // Count insertion items
 if CountArguments>2 then begin
  InsertionCount:=CountArguments-2;
 end else begin
  InsertionCount:=0;
 end;

 // Calculate new size 
 NewSize:=(Size+InsertionCount)-DeleteCount;

 // Build output spliced array
 result:=POCANewArray(Context);

 // Set size of the result array
 POCAArraySetSize(result,NewSize);

 // Set start index
 Index:=0;

 // Copy elements before the splice
 if Start>0 then begin
  for i:=0 to Start-1 do begin
   POCAArraySet(result,Index,POCAArrayGet(This,i));
   inc(Index);
  end;
 end;

 // Insert new elements
 for i:=0 to InsertionCount-1 do begin
  POCAArraySet(result,Index,Arguments^[2+i]);
  inc(Index);
 end;

 // Copy elements after the splice
 for i:=Start+DeleteCount to Size-1 do begin
  POCAArraySet(result,Index,POCAArrayGet(This,i));
  inc(Index);
 end;

end;

function POCAArrayFunctionSORT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "sort"');
 end;
 if CountArguments>0 then begin
  if POCAIsValueFunctionOrNativeCode(Arguments^[0]) then begin
   POCAArraySort(Context,This,Arguments^[0]);
  end else if POCAIsValueNumber(Arguments^[0]) then begin
   POCAArraySort(Context,This,trunc(POCAGetNumberValue(Context,Arguments^[0])));
  end else begin
   POCARuntimeError(Context,'Bad arguments to "sort"');
  end;
 end else begin
  POCAArraySort(Context,This);
 end;
 result:=This;
end;

function POCAArrayFunctionTOSORTED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i:TPOCAInt32;
begin
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "toSorted"');
 end;
 result:=POCANewArray(Context);
 POCAArraySetSize(result,POCAArraySize(This));
 for i:=0 to POCAArraySize(This)-1 do begin
  POCAArraySet(result,i,POCAArrayGet(This,i));
 end;
 if CountArguments>0 then begin
  if POCAIsValueFunctionOrNativeCode(Arguments^[0]) then begin
   POCAArraySort(Context,result,Arguments^[0]);
  end else if POCAIsValueNumber(Arguments^[0]) then begin
   POCAArraySort(Context,result,trunc(POCAGetNumberValue(Context,Arguments^[0])));
  end else begin
   POCARuntimeError(Context,'Bad arguments to "toSorted"');
  end;
 end else begin
  POCAArraySort(Context,result);
 end;
end;

function POCAArrayFunctionJOIN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i,Size:TPOCAInt32;
    SeparatorValue:TPOCAValue;
    Separator,StrValue:TPOCAUTF8String;
begin
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "join"');
 end;
 if CountArguments>0 then begin
  SeparatorValue:=POCAStringValue(Context,Arguments^[0]);
 end else begin
//LenValue:=POCAValueNull;
  SeparatorValue.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if POCAIsValueString(SeparatorValue) then begin
  Separator:=POCAGetStringValue(Context,SeparatorValue);
 end else begin
  Separator:=',';
 end;
 Size:=POCAArraySize(This);
 StrValue:='';
 if Size>0 then begin
  for i:=0 to Size-1 do begin
   if i>0 then begin
    StrValue:=StrValue+Separator;
   end;
   StrValue:=StrValue+POCAGetStringValue(Context,POCAArrayGet(This,i));
  end;
 end;
 result:=POCANewString(Context,StrValue);
end;

function POCAArrayFunctionFILL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i,Start,End_,Size:TPOCAInt32;
    FillValue:TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "fill"');
 end;
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "fill"');
 end;
 FillValue:=Arguments^[0];
 if CountArguments>1 then begin
  Start:=trunc(POCAGetNumberValue(Context,Arguments^[1]));
 end else begin
  Start:=0;
 end;
 Size:=POCAArraySize(This);
 if CountArguments>2 then begin
  End_:=trunc(POCAGetNumberValue(Context,Arguments^[2]));
 end else begin
  End_:=Size;
 end;
 if ((Start<0) or (Start>=Size)) or ((End_<0) or (End_>Size)) then begin
  POCARuntimeError(Context,'Bad arguments to "fill"');
 end;
 if Start<End_ then begin
  for i:=Start to End_-1 do begin
   POCAArraySet(This,i,FillValue);
  end;
 end;
 result:=This;
end;

function POCAArrayFunctionTOFILLED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i,Start,End_,Size:TPOCAInt32;
    FillValue:TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "toFilled"');
 end;
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "toFilled"');
 end;
 FillValue:=Arguments^[0];
 if CountArguments>1 then begin
  Start:=trunc(POCAGetNumberValue(Context,Arguments^[1]));
 end else begin
  Start:=0;
 end;
 Size:=POCAArraySize(This);
 if CountArguments>2 then begin
  End_:=trunc(POCAGetNumberValue(Context,Arguments^[2]));
 end else begin
  End_:=Size;
 end;
 if ((Start<0) or (Start>=Size)) or ((End_<0) or (End_>Size)) then begin
  POCARuntimeError(Context,'Bad arguments to "fill"');
 end;
 result:=POCANewArray(Context);
 if Start<End_ then begin
  for i:=0 to Start-1 do begin
   POCAArrayPush(result,POCAArrayGet(This,i));
  end;
  for i:=Start to End_-1 do begin
   POCAArrayPush(result,FillValue);
  end;
  for i:=End_ to Size-1 do begin
   POCAArrayPush(result,POCAArrayGet(This,i));
  end;
 end else begin
  for i:=0 to Size-1 do begin
   POCAArrayPush(result,POCAArrayGet(This,i));
  end;
 end;
end;

function POCAArrayFunctionDELETE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i:TPOCAInt32;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "delete"');
 end;
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "delete"');
 end;
 for i:=0 to CountArguments-1 do begin
  POCAArrayDelete(This,trunc(POCAGetNumberValue(Context,Arguments^[i])));
 end;
 result:=This;
end;

function POCAArrayFunctionREMOVE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i:TPOCAInt32;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "remove"');
 end;
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "remove"');
 end;
 for i:=0 to CountArguments-1 do begin
  POCAArrayRemove(This,Arguments^[i]);
 end;
 result:=This;
end;

function POCAArrayFunctionINDEXOF(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "indexOf"');
 end;
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "indexOf"');
 end;
 result.Num:=POCAArrayIndexOf(This,Arguments^[0]);
end;

function POCAArrayFunctionLASTINDEXOF(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "lastIndexOf"');
 end;
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "lastIndexOf"');
 end;
 result.Num:=POCAArrayLastIndexOf(This,Arguments^[0]);
end;

function POCAArrayFunctionREVERSE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i,j,Size:TPOCAInt32;
    a,b:TPOCAValue; 
begin
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "reverse"');
 end;
 Size:=POCAArraySize(This);
 if Size>0 then begin
  i:=0;
  j:=Size-1;
  while i<j do begin
   a:=POCAArrayGet(This,i);
   b:=POCAArrayGet(This,j);
   POCAArraySet(This,i,b);
   POCAArraySet(This,j,a);
   inc(i);
   dec(j);
  end;
 end;
 result:=This;
end;

function POCAArrayFunctionTOREVERSED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i,Size:TPOCAInt32;
begin
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "toReversed"');
 end;
 result:=POCANewArray(Context);
 Size:=POCAArraySize(This);
 if Size>0 then begin
  for i:=Size-1 downto 0 do begin
   POCAArrayPush(result,POCAArrayGet(This,i));
  end;
 end;
end; 

function POCAArrayFunctionINCLUDES(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "includes"');
 end;
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "includes"');
 end;
 result.Num:=ord(POCAArrayIndexOf(This,Arguments^[0])>=0) and 1;
end;

function POCAArrayFunctionSHIFT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i,Size:TPOCAInt32;
begin
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "shift"');
 end;
 Size:=POCAArraySize(This);
 if Size>0 then begin
  result:=POCAArrayGet(This,0);
  for i:=1 to Size-1 do begin
   POCAArraySet(This,i-1,POCAArrayGet(This,i));
  end;
  POCAArraySetSize(This,Size-1);
 end else begin
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCAArrayFunctionUNSHIFT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i,Size:TPOCAInt32;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "unshift"');
 end;
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "unshift"');
 end;
 Size:=POCAArraySize(This);
 POCAArraySetSize(This,Size+CountArguments);
 for i:=(Size+CountArguments)-1 downto CountArguments do begin
  POCAArraySet(This,i,POCAArrayGet(This,i-CountArguments));
 end;
 for i:=0 to CountArguments-1 do begin
  POCAArraySet(This,i,Arguments^[i]);
 end;
 result:=This;
end;

function POCAInitArrayHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'empty',POCAArrayFunctionEMPTY);
 POCAAddNativeFunction(Context,result,'size',POCAArrayFunctionSIZE);
 POCAAddNativeFunction(Context,result,'resize',POCAArrayFunctionRESIZE);
 POCAAddNativeFunction(Context,result,'push',POCAArrayFunctionPUSH);
 POCAAddNativeFunction(Context,result,'pop',POCAArrayFunctionPOP);
 POCAAddNativeFunction(Context,result,'slice',POCAArrayFunctionSLICE);
 POCAAddNativeFunction(Context,result,'splice',POCAArrayFunctionSPLICE);
 POCAAddNativeFunction(Context,result,'toSpliced',POCAArrayFunctionTOSPLICED);
 POCAAddNativeFunction(Context,result,'sort',POCAArrayFunctionSORT);
 POCAAddNativeFunction(Context,result,'toSorted',POCAArrayFunctionTOSORTED);
 POCAAddNativeFunction(Context,result,'join',POCAArrayFunctionJOIN);
 POCAAddNativeFunction(Context,result,'fill',POCAArrayFunctionFILL);
 POCAAddNativeFunction(Context,result,'toFilled',POCAArrayFunctionTOFILLED);
 POCAAddNativeFunction(Context,result,'delete',POCAArrayFunctionDELETE);
 POCAAddNativeFunction(Context,result,'remove',POCAArrayFunctionREMOVE);
 POCAAddNativeFunction(Context,result,'indexOf',POCAArrayFunctionINDEXOF);
 POCAAddNativeFunction(Context,result,'lastIndexOf',POCAArrayFunctionLASTINDEXOF);
 POCAAddNativeFunction(Context,result,'reverse',POCAArrayFunctionREVERSE);
 POCAAddNativeFunction(Context,result,'toReversed',POCAArrayFunctionTOREVERSED);
 POCAAddNativeFunction(Context,result,'includes',POCAArrayFunctionINCLUDES);
 POCAAddNativeFunction(Context,result,'shift',POCAArrayFunctionSHIFT);
 POCAAddNativeFunction(Context,result,'unshift',POCAArrayFunctionUNSHIFT);
end;

function POCAHashFunctionEMPTY(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtHASH:begin
   result.Num:=ord(POCAHashSize(Context,This)=0) and 1;
  end;
  else begin
   result.Num:=0;
   POCARuntimeError(Context,'Bad this value to "empty"');
  end;
 end;
end;

function POCAHashFunctionSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtHASH:begin
   result.Num:=POCAHashSize(Context,This);
  end;
  else begin
   result.Num:=0;
   POCARuntimeError(Context,'Bad this value to "size"');
  end;
 end;
end;

function POCAHashFunctionMERGE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var i:TPOCAInt32;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "merge"');
 end;
 if not POCAIsValueHash(This) then begin
  POCARuntimeError(Context,'Bad this value to "merge"');
 end;
 for i:=0 to CountArguments-1 do begin
  if POCAIsValueHash(Arguments^[i]) then begin
   POCAHashCombine(Context,This,Arguments^[i]);
  end;
 end;
 result:=This;
end;

function POCAHashFunctionCONTAINS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Hash,Key:TPOCAValue;
begin
 Hash:=This;
 if CountArguments>0 then begin
  Key:=Arguments^[0];
 end else begin
//Key:=POCAValueNull;
  Key.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
 if (not POCAIsValueHash(Hash)) or POCAIsValueNull(Key) then begin
  POCARuntimeError(Context,'Bad arguments to "contains"');
 end;
 result.Num:=ord(POCAHashGet(Context,Hash,Key,Key)) and 1;
end;

function POCAHashFunctionTOARRAY(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if not POCAIsValueHash(This) then begin
  POCARuntimeError(Context,'Bad this value to "toArray"');
 end;
 result:=POCAHashArray(Context,This);
end;

function POCAHashFunctionKEYS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if not POCAIsValueHash(This) then begin
  POCARuntimeError(Context,'Bad this value to "keys"');
 end;
 result:=POCANewArray(Context);
 POCAHashKeys(Context,result,This);
 POCAArraySort(Context,result);
end;

function POCAHashFunctionOWNKEYS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if not POCAIsValueHash(This) then begin
  POCARuntimeError(Context,'Bad this value to "ownKeys"');
 end;
 result:=POCANewArray(Context);
 POCAHashOwnKeys(Context,result,This);
 POCAArraySort(Context,result);
end;

function POCAHashFunctionSETHASHEVENTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if (not POCAIsValueHash(This)) or (CountArguments<1) or not POCAHashSetHashEvents(Context,This,Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "setHashEvents"');
 end;
 result:=This;
end;

function POCAHashFunctionGETHASHEVENTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if not POCAIsValueHash(This) then begin
  POCARuntimeError(Context,'Bad arguments to "getHashEvents"');
 end;
 result:=POCAHashGetHashEventsHash(This);
end;

function POCAHashFunctionRAWDELETE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if (not POCAIsValueHash(This)) or (CountArguments<1) then begin
  POCARuntimeError(Context,'Bad arguments to "rawDelete"');
 end;
 result.Num:=ord(POCAHashRawDelete(This,Arguments^[0])) and 1;
end;

function POCAHashFunctionRAWEXIST(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if (not POCAIsValueHash(This)) or (CountArguments<1) then begin
  POCARuntimeError(Context,'Bad arguments to "rawExist"');
 end;
 result.Num:=ord(POCAHashRawExist(This,Arguments^[0])) and 1;
end;

function POCAHashFunctionRAWGET(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if (not POCAIsValueHash(This)) or (CountArguments<1) then begin
  POCARuntimeError(Context,'Bad arguments to "rawGet"');
 end;
 POCAHashRawGet(This,Arguments^[0],result);
end;

function POCAHashFunctionRAWSET(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Constant:Boolean;
begin
 if (not POCAIsValueHash(This)) or (CountArguments<2) then begin
  POCARuntimeError(Context,'Bad arguments to "rawSet"');
 end;
 if CountArguments>2 then begin
  Constant:=POCAGetBooleanValue(Context,Arguments^[2]);
 end else begin
  Constant:=false;
 end;
 POCAHashRawSet(This,Arguments^[0],Arguments^[1],Constant);
 result:=This;
end;

function POCAHashFunctionRAWSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if (not POCAIsValueHash(This)) or (CountArguments<0) then begin
  POCARuntimeError(Context,'Bad arguments to "rawSize"');
 end;
 result.Num:=POCAHashRawSize(This);
end;

function POCAHashFunctionRAWKEYS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if not POCAIsValueHash(This) then begin
  POCARuntimeError(Context,'Bad arguments to "rawKeys"');
 end;
 result:=POCANewArray(Context);
 POCAHashRawKeys(result,This);
 POCAArraySort(Context,result);
end;

function POCAInitHashHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'empty',POCAHashFunctionEMPTY);
 POCAAddNativeFunction(Context,result,'size',POCAHashFunctionSIZE);
 POCAAddNativeFunction(Context,result,'merge',POCAHashFunctionMERGE);
 POCAAddNativeFunction(Context,result,'contains',POCAHashFunctionCONTAINS);
 POCAAddNativeFunction(Context,result,'toArray',POCAHashFunctionTOARRAY);
 POCAAddNativeFunction(Context,result,'keys',POCAHashFunctionKEYS);
 POCAAddNativeFunction(Context,result,'ownKeys',POCAHashFunctionOWNKEYS);
 POCAAddNativeFunction(Context,result,'setHashEvents',POCAHashFunctionSETHASHEVENTS);
 POCAAddNativeFunction(Context,result,'getHashEvents',POCAHashFunctionGETHASHEVENTS);
 POCAAddNativeFunction(Context,result,'rawDelete',POCAHashFunctionRAWDELETE);
 POCAAddNativeFunction(Context,result,'rawExist',POCAHashFunctionRAWEXIST);
 POCAAddNativeFunction(Context,result,'rawGet',POCAHashFunctionRAWGET);
 POCAAddNativeFunction(Context,result,'rawSet',POCAHashFunctionRAWSET);
 POCAAddNativeFunction(Context,result,'rawSize',POCAHashFunctionRAWSIZE);
 POCAAddNativeFunction(Context,result,'rawKeys',POCAHashFunctionRAWKEYS);
end;

function POCANumberFunctionTOSTRING(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result:=POCAStringValue(Context,This);
end;

function POCANumberFunctionTOEXPONENTIAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "toExponential"');
 end;
 result:=POCANewString(Context,ConvertDoubleToString(POCAGetNumberValue(Context,This),omExponential,trunc(POCAGetNumberValue(Context,Arguments^[0]))+1));
end;

function POCANumberFunctionTOFIXED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "toFixed"');
 end;
 result:=POCANewString(Context,ConvertDoubleToString(POCAGetNumberValue(Context,This),omFixed,trunc(POCAGetNumberValue(Context,Arguments^[0]))));
end;

function POCANumberFunctionTOPRECISION(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "toPrecision"');
 end;
 result:=POCANewString(Context,ConvertDoubleToString(POCAGetNumberValue(Context,This),omPrecision,trunc(POCAGetNumberValue(Context,Arguments^[0]))));
end;

function POCANumberFunctionTORADIX(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "toRadix"');
 end;
 result:=POCANewString(Context,ConvertDoubleToString(POCAGetNumberValue(Context,This),omRadix,trunc(POCAGetNumberValue(Context,Arguments^[0]))));
end;

function POCAInitNumberHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'toString',POCANumberFunctionTOSTRING);
 POCAAddNativeFunction(Context,result,'toExponential',POCANumberFunctionTOEXPONENTIAL);
 POCAAddNativeFunction(Context,result,'toFixed',POCANumberFunctionTOFIXED);
 POCAAddNativeFunction(Context,result,'toPrecision',POCANumberFunctionTOPRECISION);
 POCAAddNativeFunction(Context,result,'toRadix',POCANumberFunctionTORADIX);
end;

function POCAStringFunctionCOUNTCODEPOINTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtSTRING:begin
   if PPOCAString(POCAGetValueReferencePointer(This))^.UTF8=suISUTF8 then begin
    result.Num:=PPOCAString(POCAGetValueReferencePointer(This))^.UTF8Length;
   end else begin
    result.Num:=length(PPOCAString(POCAGetValueReferencePointer(This))^.Data);
   end;
  end;
  else begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
   POCARuntimeError(Context,'Bad this value to "countCodePoints"');
  end;
 end;
end;

function POCAStringFunctionCOUNTCODEUNITS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtSTRING:begin
   result.Num:=length(PPOCAString(POCAGetValueReferencePointer(This))^.Data);
  end;
  else begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
   POCARuntimeError(Context,'Bad this value to "countCodeUnits"');
  end;
 end;
end;

function POCAStringFunctionSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtSTRING:begin
   if PPOCAString(POCAGetValueReferencePointer(This))^.UTF8=suISUTF8 then begin
    result.Num:=PPOCAString(POCAGetValueReferencePointer(This))^.UTF8Length;
   end else begin
    result.Num:=length(PPOCAString(POCAGetValueReferencePointer(This))^.Data);
   end;
  end;
  else begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
   POCARuntimeError(Context,'Bad this value to "size"');
  end;
 end;
end;

function POCAStringFunctionTONUMBER(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var OK:TPasDblStrUtilsBoolean;
begin
 if CountArguments=0 then begin
  result.Num:=POCAGetNumberValue(Context,This);
 end else begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
  OK:=false;
  if POCAGetValueType(This)=pvtSTRING then begin
   POCASetValueNumber(result,ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(This))^.Data,rmNearest,@OK,trunc(POCAGetNumberValue(Context,Arguments^[0]))));
  end;
  if not OK then begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end;
end;

function POCAStringFunctionTOSTRING(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result:=POCAStringValue(Context,This);
end;

function POCAStringFunctionINCLUDES(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var SearchString,InString:TPOCARawByteString;
    SearchStringIsUTF8,InStringIsUTF8:TPOCAInt32;
    p:PPOCAString;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "includes"');
 end;
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "includes"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 InString:=p^.Data;
 InStringIsUTF8:=p^.UTF8;
 if POCAIsValueString(Arguments^[0]) then begin
  p:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]));
  SearchString:=p^.Data;
  SearchStringIsUTF8:=p^.UTF8;
 end else begin
  SearchString:=POCAGetStringValue(Context,Arguments^[0]);
  SearchStringIsUTF8:=PUCUUTF8Get(SearchString);
 end;
 if (SearchStringIsUTF8=suISUTF8) and (InStringIsUTF8=suISUTF8) then begin
  if PUCUUTF8Pos(SearchString,InString)>0 then begin
   result.Num:=1;
  end else begin
   result.Num:=0;
  end;
 end else begin
  if System.Pos(SearchString,InString)>0 then begin
   result.Num:=1;
  end else begin
   result.Num:=0;
  end;
 end;
end;

function POCAStringFunctionINDEXOF(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var SearchString,InString:TPOCARawByteString;
    SearchStringIsUTF8,InStringIsUTF8:TPOCAInt32;
    p:PPOCAString;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "indexOf"');
 end;
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "indexOf"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 InString:=p^.Data;
 InStringIsUTF8:=p^.UTF8;
 if POCAIsValueString(Arguments^[0]) then begin
  p:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]));
  SearchString:=p^.Data;
  SearchStringIsUTF8:=p^.UTF8;
 end else begin
  SearchString:=POCAGetStringValue(Context,Arguments^[0]);
  SearchStringIsUTF8:=PUCUUTF8Get(SearchString);
 end;
 if (SearchStringIsUTF8=suISUTF8) and (InStringIsUTF8=suISUTF8) then begin
  result.Num:=PUCUUTF8Pos(SearchString,InString)-1;
 end else begin
  result.Num:=System.Pos(SearchString,InString)-1;
 end;
end;

function POCAStringFunctionLASTINDEXOF(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var SearchString,InString:TPOCARawByteString;
    SearchStringIsUTF8,InStringIsUTF8,i,j:TPOCAInt32;
    p:PPOCAString;
    OK:boolean;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "lastIndexOf"');
 end;
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "lastIndexOf"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 InString:=p^.Data;
 InStringIsUTF8:=p^.UTF8;
 if POCAIsValueString(Arguments^[0]) then begin
  p:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]));
  SearchString:=p^.Data;
  SearchStringIsUTF8:=p^.UTF8;
 end else begin
  SearchString:=POCAGetStringValue(Context,Arguments^[0]);
  SearchStringIsUTF8:=PUCUUTF8Get(SearchString);
 end;
 if (SearchStringIsUTF8=suISUTF8) and (InStringIsUTF8=suISUTF8) then begin
  result.Num:=PUCUUTF8LastPos(SearchString,InString)-1;
 end else begin
  result.Num:=-1;
  for i:=length(InString)-(length(SearchString)-1) downto 1 do begin
   OK:=true;
   for j:=1 to length(SearchString) do begin
    if InString[(i+j)-1]<>SearchString[j] then begin
     OK:=false;
     break;
    end;
   end;
   if OK then begin
    result.Num:=i-1;
    break;
   end;
  end;
 end;
end;

function POCAStringFunctionSPLIT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var DelimeterString,FromString:TPOCARawByteString;
    FromStringIsUTF8,i,j,l:TPOCAInt32;
    p:PPOCAString;
    SkipEmpty:Boolean;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "split"');
 end;
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "split"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 FromString:=p^.Data;
 FromStringIsUTF8:=p^.UTF8;
 if POCAIsValueString(Arguments^[0]) then begin
  p:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]));
  DelimeterString:=p^.Data;
 end else begin
  DelimeterString:=POCAGetStringValue(Context,Arguments^[0]);
 end;
 if CountArguments>1 then begin
  SkipEmpty:=POCAGetBooleanValue(Context,Arguments^[1]);
 end else begin
  SkipEmpty:=false;
 end;
 result:=POCANewArray(Context);
 if length(DelimeterString)=0 then begin
  if FromStringIsUTF8=suISUTF8 then begin
   i:=1;
   while i<=length(FromString) do begin
    POCAArrayPush(result,POCANewString(Context,PUCUUTF32CharToUTF8(PUCUUTF8CodeUnitGetCharAndInc(FromString,i))));
   end;
  end else begin
   for i:=1 to length(FromString) do begin
    POCAArrayPush(result,POCANewString(Context,FromString[i]));
   end;
  end;
 end else begin
  j:=1;
  while j<=(length(FromString)+1) do begin
   i:=PosEx(DelimeterString,FromString,j);
   if i>0 then begin
    l:=i-j;
    if (l>0) or not SkipEmpty then begin
     POCAArrayPush(result,POCANewString(Context,copy(FromString,j,l)));
    end;
    j:=i+length(DelimeterString);
   end else begin
    l:=(length(FromString)-j)+1;
    if (l>0) or not SkipEmpty then begin
     POCAArrayPush(result,POCANewString(Context,copy(FromString,j,l)));
    end;
    break;
   end;
  end;
 end;
end;

function POCAStringFunctionTRIM(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var s:TPOCARawByteString;
    p:PPOCAString;
begin
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "trim"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 s:=p^.Data;
 if p^.UTF8=suISUTF8 then begin
  result:=POCANewString(Context,TPOCAUTF8String(PUCUUTF8Trim(TPOCAUTF8String(s))));
 end else begin
  result:=POCANewString(Context,TPOCARawByteString(Trim(String(TPOCARawByteString(s)))));
 end;
end;

function POCAStringFunctionTRIMLEFT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var s:TPOCARawByteString;
    p:PPOCAString;
begin
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "trimLeft"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 s:=p^.Data;
 if p^.UTF8=suISUTF8 then begin
  result:=POCANewString(Context,TPOCAUTF8String(PUCUUTF8TrimLeft(TPOCAUTF8String(s))));
 end else begin
  result:=POCANewString(Context,TPOCARawByteString(TrimLeft(String(TPOCARawByteString(s)))));
 end;
end;

function POCAStringFunctionTRIMRIGHT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var s:TPOCARawByteString;
    p:PPOCAString;
begin
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "trimRight"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 s:=p^.Data;
 if p^.UTF8=suISUTF8 then begin
  result:=POCANewString(Context,TPOCAUTF8String(PUCUUTF8TrimRight(TPOCAUTF8String(s))));
 end else begin
  result:=POCANewString(Context,TPOCARawByteString(TrimRight(String(TPOCARawByteString(s)))));
 end;
end;

function POCAStringFunctionTOLOWERCASE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var s:TPOCARawByteString;
    p:PPOCAString;
begin
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "toLowerCase"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 s:=p^.Data;
 if p^.UTF8=suISUTF8 then begin
  result:=POCANewString(Context,PUCUUTF8LowerCase(s));
 end else begin
  result:=POCANewString(Context,TPOCARawByteString(LowerCase(String(TPOCARawByteString(s)))));
 end;
end;

function POCAStringFunctionTOUPPERCASE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var s:TPOCARawByteString;
    p:PPOCAString;
begin
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "toUpperCase"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 s:=p^.Data;
 if p^.UTF8=suISUTF8 then begin
  result:=POCANewString(Context,PUCUUTF8UpperCase(s));
 end else begin
  result:=POCANewString(Context,TPOCARawByteString(UpperCase(String(TPOCARawByteString(s)))));
 end;
end;

function POCAStringFunctionSUBSTR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Len,Start,Size,IsUTF8:TPOCAInt32;
    LenValue:TPOCAValue;
    Str:TPOCARawByteString;
begin
 if CountArguments<1 then begin
//result:=POCAValueNull;
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end else begin
  Start:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
  if CountArguments>1 then begin
   LenValue:=POCANumberValue(Context,Arguments^[1]);
  end else begin
// LenValue:=POCAValueNull;
   LenValue.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
  if POCAIsValueNumber(LenValue) then begin
   Len:=trunc(LenValue.Num);
  end else begin
   Len:=0;
  end;
  if POCAIsValueString(This) then begin
   Str:=PPOCAString(POCAGetValueReferencePointer(This))^.Data;
   IsUTF8:=PPOCAString(POCAGetValueReferencePointer(This))^.UTF8;
   if IsUTF8=suISUTF8 then begin
    Size:=PPOCAString(POCAGetValueReferencePointer(This))^.UTF8Length;
   end else begin
    Size:=length(PPOCAString(POCAGetValueReferencePointer(This))^.Data);
   end;
  end else begin
   Str:=POCAGetStringValue(Context,This);
   IsUTF8:=PUCUUTF8Get(Str);
   if IsUTF8=suISUTF8 then begin
    Size:=PUCUUTF8Length(Str);
   end else begin
    Size:=length(Str);
   end;
  end;
  if ((Start<0) or (Start>=Size)) or (Len<0) then begin
   POCARuntimeError(Context,'Bad arguments to "substr"');
  end;
  if (not POCAIsValueNumber(LenValue)) or (Len>(Size-Start)) then begin
   Len:=Size-Start;
  end;
  IF IsUTF8=suISUTF8 then begin
   if POCAIsValueString(This) then begin
    result:=POCANewString(Context,POCAStringUTF8CopyCodePointRange(Context,This,Start,(Start+Len)-1));
   end else begin
    result:=POCANewString(Context,PUCUUTF8Copy(Str,Start,Len));
   end;
  end else begin
   result:=POCANewString(Context,copy(Str,Start+1,Len));
  end;
 end;
end;

{$ifdef pocastrictutf8}
function POCAStringFunctionTOLATIN1(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 POCARuntimeError(Context,'"toLatin1" isn''t allowed in a strict-UTF8 Poca build');
end;

function POCAStringFunctionISLATIN1(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 result.Num:=0;
end;
{$else}
function POCAStringFunctionTOLATIN1(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var d,s:TPOCARawByteString;
    CodeUnit:TPOCAInt32;
    CharValue:TPOCAUInt32;
begin
 if POCAIsValueString(This) then begin
  if PPOCAString(POCAGetValueReferencePointer(This))^.UTF8<>suNOUTF8 then begin
   s:=PPOCAString(POCAGetValueReferencePointer(This))^.Data;
   d:='';
   CodeUnit:=1;
   while CodeUnit<=length(s) do begin
    CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(s,CodeUnit);
    if CharValue>255 then begin
     CharValue:=128;
    end;
    d:=d+ansichar(TPOCAUInt8(CharValue));
   end;
   result:=POCANewString(Context,d);
   PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suNOUTF8;
  end else begin
   result:=This;
  end;
 end else begin
  result:=POCANewString(Context,ansichar(TPOCAUInt8(trunc(POCAGetNumberValue(Context,This)))));
 end;
end;

function POCAStringFunctionISLATIN1(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if POCAIsValueString(This) then begin
  result.Num:=2-PPOCAString(POCAGetValueReferencePointer(This))^.UTF8;
 end else begin
  result.Num:=2-PUCUUTF8Get(POCAGetStringValue(Context,This));
 end;
end;
{$endif}

function POCAStringFunctionTOUTF8(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if POCAIsValueString(This) then begin
  if PPOCAString(POCAGetValueReferencePointer(This))^.UTF8=suNOUTF8 then begin
   result:=POCANewString(Context,PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(This))^.Data));
  end else begin
   result:=This;
  end;
 end else begin
  result:=POCANewString(Context,PUCUUTF32CharToUTF8(trunc(POCAGetNumberValue(Context,This))));
 end;
end;

function POCAStringFunctionISUTF8(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
begin
 if POCAIsValueString(This) then begin
  result.Num:=PPOCAString(POCAGetValueReferencePointer(This))^.UTF8;
 end else begin
  result.Num:=PUCUUTF8Get(POCAGetStringValue(Context,This));
 end;
end;

function POCAStringFunctionCHARAT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Str:PPOCAString;
    CodePoint,CodeUnit,Len:TPOCAInt32;
    s:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "charAt"');
 end;
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  if Str^.UTF8=suISUTF8 then begin
   Len:=Str^.UTF8Length;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    CodeUnit:=POCAStringUTF8GetCodeUnit(Context,This,CodePoint);
    if (CodeUnit>0) and (CodeUnit<=length(Str^.Data)) then begin
     result:=POCANewString(Context,PUCUUTF32CharToUTF8(PUCUUTF8CodeUnitGetChar(Str^.Data,CodeUnit)));
    end else begin
     result:=POCANewString(Context,PUCUUTF32CharToUTF8(PUCUUTF8CodePointGetChar(Str^.Data,CodePoint)));
    end;
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end else begin
   Len:=Str^.DataLength;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result:=POCANewString(Context,PUCUUTF32CharToUTF8(TPOCAUInt8(ansichar(Str^.Data[CodePoint+1]))));
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  if PUCUIsUTF8(s) then begin
   Len:=PUCUUTF8Length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result:=POCANewString(Context,PUCUUTF32CharToUTF8(PUCUUTF8CodePointGetChar(s,CodePoint)));
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end else begin
   Len:=length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result:=POCANewString(Context,PUCUUTF32CharToUTF8(TPOCAUInt8(ansichar(s[CodePoint+1]))));
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
 end;
end;

function POCAStringFunctionCODEPOINTAT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Str:PPOCAString;
    CodePoint,CodeUnit,Len:TPOCAInt32;
    s:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "codePointAt"');
 end;
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  if Str^.UTF8=suISUTF8 then begin
   Len:=Str^.UTF8Length;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    CodeUnit:=POCAStringUTF8GetCodeUnit(Context,This,CodePoint);
    if (CodeUnit>0) and (CodeUnit<=length(Str^.Data)) then begin
     result.Num:=PUCUUTF8CodeUnitGetChar(Str^.Data,CodeUnit);
    end else begin
     result.Num:=PUCUUTF8CodePointGetChar(Str^.Data,CodePoint);
    end;
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end else begin
   Len:=Str^.DataLength;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=TPOCAUInt8(ansichar(Str^.Data[CodePoint+1]));
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  if PUCUIsUTF8(s) then begin
   Len:=PUCUUTF8Length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=PUCUUTF8CodePointGetChar(s,CodePoint);
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end else begin
   Len:=length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=TPOCAUInt8(ansichar(s[CodePoint+1]));
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
 end;
end;

function POCAStringFunctionCODEUNITAT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Str:PPOCAString;
    CodePoint,Len:TPOCAInt32;
    s:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "codeUnitAt"');
 end;
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  Len:=Str^.DataLength;
  CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
  if CodePoint<0 then begin
   inc(CodePoint,Len);
  end;
  if (CodePoint>=0) and (CodePoint<Len) then begin
   result.Num:=TPOCAUInt8(ansichar(Str^.Data[CodePoint+1]));
  end else begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  Len:=length(s);
  CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
  if CodePoint<0 then begin
   inc(CodePoint,Len);
  end;
  if (CodePoint>=0) and (CodePoint<Len) then begin
   result.Num:=TPOCAUInt8(ansichar(s[CodePoint+1]));
  end else begin
 //result:=POCAValueNull;
   result.CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end;
end;

function POCAStringFunctionCODEPOINTTOCODEUNIT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Str:PPOCAString;
    CodePoint,Len:TPOCAInt32;
    s:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "codePointToCodeUnit"');
 end;
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  if Str^.UTF8=suISUTF8 then begin
   Len:=Str^.UTF8Length;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=POCAStringUTF8GetCodeUnit(Context,This,CodePoint)-1;
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end else begin
   Len:=Str^.DataLength;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=CodePoint;
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  if PUCUIsUTF8(s) then begin
   Len:=PUCUUTF8Length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=PUCUUTF8GetCodeUnit(s,CodePoint)-1;
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end else begin
   Len:=length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=CodePoint;
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
 end;
end;

function POCAStringFunctionCODEUNITTOCODEPOINT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Str:PPOCAString;
    CodeUnit,Len:TPOCAInt32;
    s:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "codeUnitToCodePoint"');
 end;
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  if Str^.UTF8=suISUTF8 then begin
   Len:=Str^.DataLength;
   CodeUnit:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodeUnit<0 then begin
    inc(CodeUnit,Len);
   end;
   if (CodeUnit>=0) and (CodeUnit<Len) then begin
    result.Num:=POCAStringUTF8GetCodePoint(Context,This,CodeUnit+1);
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end else begin
   Len:=Str^.DataLength;
   CodeUnit:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodeUnit<0 then begin
    inc(CodeUnit,Len);
   end;
   if (CodeUnit>=0) and (CodeUnit<Len) then begin
    result.Num:=CodeUnit;
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  if PUCUIsUTF8(s) then begin
   Len:=length(s);
   CodeUnit:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodeUnit<0 then begin
    inc(CodeUnit,Len);
   end;
   if (CodeUnit>=0) and (CodeUnit<Len) then begin
    result.Num:=PUCUUTF8GetCodePoint(s,CodeUnit+1);
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end else begin
   Len:=length(s);
   CodeUnit:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodeUnit<0 then begin
    inc(CodeUnit,Len);
   end;
   if (CodeUnit>=0) and (CodeUnit<Len) then begin
    result.Num:=CodeUnit;
   end else begin
  //result:=POCAValueNull;
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
 end;
end;

function POCAStringFunctionCODEPOINTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Str:PPOCAString;
    CodePoint,CodeUnit,Len:TPOCAInt32;
    s:TPOCARawByteString;
begin
 result:=POCANewArray(Context);
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  if Str^.UTF8=suISUTF8 then begin
   Len:=Str^.UTF8Length;
   for CodePoint:=0 to Len-1 do begin
    CodeUnit:=POCAStringUTF8GetCodeUnit(Context,This,CodePoint);
    if (CodeUnit>0) and (CodeUnit<=length(Str^.Data)) then begin
     POCAArrayPush(result,POCANewNumber(Context,PUCUUTF8CodeUnitGetChar(Str^.Data,CodeUnit)));
    end else begin
     POCAArrayPush(result,POCANewNumber(Context,PUCUUTF8CodePointGetChar(Str^.Data,CodePoint)));
    end;
   end;
  end else begin
   Len:=Str^.DataLength;
   for CodeUnit:=1 to Len do begin
    POCAArrayPush(result,POCANewNumber(Context,TPOCAUInt8(ansichar(Str^.Data[CodeUnit]))));
   end;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  if PUCUIsUTF8(s) then begin
   Len:=PUCUUTF8Length(s);
   for CodePoint:=0 to Len-1 do begin
    CodeUnit:=PUCUUTF8GetCodeUnit(s,CodePoint);
    if (CodeUnit>0) and (CodeUnit<=length(s)) then begin
     POCAArrayPush(result,POCANewNumber(Context,PUCUUTF8CodeUnitGetChar(s,CodeUnit)));
    end else begin
     POCAArrayPush(result,POCANewNumber(Context,PUCUUTF8CodePointGetChar(s,CodePoint)));
    end;
   end;
  end else begin
   Len:=length(s);
   for CodeUnit:=1 to Len do begin
    POCAArrayPush(result,POCANewNumber(Context,TPOCAUInt8(ansichar(s[CodeUnit]))));
   end;
  end;
 end;
end;

function POCAStringFunctionCODEUNITS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var Str:PPOCAString;
    CodeUnit,Len:TPOCAInt32;
    s:TPOCARawByteString;
begin
 result:=POCANewArray(Context);
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  Len:=Str^.DataLength;
  for CodeUnit:=1 to Len do begin
   POCAArrayPush(result,POCANewNumber(Context,TPOCAUInt8(ansichar(Str^.Data[CodeUnit]))));
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  Len:=length(s);
  for CodeUnit:=1 to Len do begin
   POCAArrayPush(result,POCANewNumber(Context,TPOCAUInt8(ansichar(s[CodeUnit]))));
  end;
 end;
end;

function POCAStringFunctionCONCAT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var s:TPOCARawByteString;
    i,j:TPOCAInt32;
begin
 if POCAIsValueString(This) then begin
  s:=PPOCAString(POCAGetValueReferencePointer(This))^.Data;
 end else begin
  s:=POCAGetStringValue(Context,This);
 end;
 if CountArguments>0 then begin
  if (CountArguments=1) and POCAIsValueArray(Arguments^[0]) then begin
   j:=POCAArraySize(Arguments^[0]);
   for i:=1 to j do begin
    s:=s+POCAGetStringValue(Context,POCAArrayGet(Arguments^[0],i-1));
   end;
  end else begin
   for i:=0 to CountArguments-1 do begin
    s:=s+POCAGetStringValue(Context,Arguments^[i]);
   end;
  end;
 end;
 result:=POCANewString(Context,s);
end;

function POCAStringFunctionREPEAT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:TPOCAInt32;const UserData:TPOCAPointer):TPOCAValue;
var s,Src:TPOCARawByteString;
    i,j:TPOCAInt32;
begin
 if POCAIsValueString(This) then begin
  Src:=PPOCAString(POCAGetValueReferencePointer(This))^.Data;
 end else begin
  Src:=POCAGetStringValue(Context,This);
 end;
 s:='';
 if CountArguments>0 then begin
  j:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
  for i:=1 to j do begin
   s:=s+Src;
  end;
 end;
 result:=POCANewString(Context,s);
end;

function POCAInitStringHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'countCodePoints',POCAStringFunctionCOUNTCODEPOINTS);
 POCAAddNativeFunction(Context,result,'countCodeUnits',POCAStringFunctionCOUNTCODEUNITS);
 POCAAddNativeFunction(Context,result,'size',POCAStringFunctionSIZE);
 POCAAddNativeFunction(Context,result,'toNumber',POCAStringFunctionTONUMBER);
 POCAAddNativeFunction(Context,result,'toString',POCAStringFunctionTOSTRING);
 POCAAddNativeFunction(Context,result,'includes',POCAStringFunctionINCLUDES);
 POCAAddNativeFunction(Context,result,'indexOf',POCAStringFunctionINDEXOF);
 POCAAddNativeFunction(Context,result,'lastIndexOf',POCAStringFunctionLASTINDEXOF);
 POCAAddNativeFunction(Context,result,'split',POCAStringFunctionSPLIT);
 POCAAddNativeFunction(Context,result,'trim',POCAStringFunctionTRIM);
 POCAAddNativeFunction(Context,result,'trimLeft',POCAStringFunctionTRIMLEFT);
 POCAAddNativeFunction(Context,result,'trimRight',POCAStringFunctionTRIMRIGHT);
 POCAAddNativeFunction(Context,result,'toLowerCase',POCAStringFunctionTOLOWERCASE);
 POCAAddNativeFunction(Context,result,'toUpperCase',POCAStringFunctionTOUPPERCASE);
 POCAAddNativeFunction(Context,result,'substr',POCAStringFunctionSUBSTR);
 POCAAddNativeFunction(Context,result,'toLatin1',POCAStringFunctionTOLATIN1);
 POCAAddNativeFunction(Context,result,'isLatin1',POCAStringFunctionISLATIN1);
 POCAAddNativeFunction(Context,result,'toUTF8',POCAStringFunctionTOUTF8);
 POCAAddNativeFunction(Context,result,'isUTF8',POCAStringFunctionISUTF8);
 POCAAddNativeFunction(Context,result,'charAt',POCAStringFunctionCHARAT);
 POCAAddNativeFunction(Context,result,'codePointAt',POCAStringFunctionCODEPOINTAT);
 POCAAddNativeFunction(Context,result,'codeUnitAt',POCAStringFunctionCODEUNITAT);
 POCAAddNativeFunction(Context,result,'codePointToCodeUnit',POCAStringFunctionCODEPOINTTOCODEUNIT);
 POCAAddNativeFunction(Context,result,'codeUnitToCodePoint',POCAStringFunctionCODEUNITTOCODEPOINT);
 POCAAddNativeFunction(Context,result,'codePoints',POCAStringFunctionCODEPOINTS);
 POCAAddNativeFunction(Context,result,'codeUnits',POCAStringFunctionCODEUNITS);
 POCAAddNativeFunction(Context,result,'concat',POCAStringFunctionCONCAT);
 POCAAddNativeFunction(Context,result,'repeat',POCAStringFunctionREPEAT);
end;

function POCADefaultModuleFunction(const aContext:PPOCAContext;const aModuleName:TPOCAUTF8String;out aModuleCode,aModuleFileName:TPOCAUTF8String;out aModuleDateTime:TDateTime):Boolean;
var Index:TPOCAInt32;
    Path,FileName:TPOCAUTF8String;
begin

 for Index:=-3 to aContext^.Instance^.IncludeDirectories.Count-1 do begin

  case Index of
   -3:begin
    Path:='';
   end;
   -2:begin
    Path:=IncludeTrailingPathDelimiter(ExtractFilePath(ParamStr(0)));
   end;
   -1:begin
    Path:=IncludeTrailingPathDelimiter(GetCurrentDir);
   end;
   else begin
    Path:=IncludeTrailingPathDelimiter(aContext^.Instance^.IncludeDirectories[Index]);
   end;
  end;

  FileName:=Path+aModuleName;
  if FileExists(FileName) then begin
   aModuleCode:=POCAGetFileContent(FileName);
   aModuleFileName:=FileName;
   if not FileAgeUTC(aModuleFileName,aModuleDateTime,true) then begin
    aModuleDateTime:=NowUTC;
   end;
   result:=true;
   exit;
  end;

  FileName:=Path+aModuleName+'.poca';
  if FileExists(FileName) then begin
   aModuleCode:=POCAGetFileContent(FileName);
   aModuleFileName:=FileName;
   if not FileAgeUTC(aModuleFileName,aModuleDateTime,true) then begin
    aModuleDateTime:=NowUTC;
   end;
   result:=true;
   exit;
  end;

 end;

 result:=false;

end;

function POCAInstanceCreate:PPOCAInstance;
var i:TPOCAInt32;
    Context:PPOCAContext;
    Ghost:boolean;
begin
 New(result);
 FillChar(result^,sizeof(TPOCAInstance),#0);
 result^.AutomaticSemicolonInsertion:=false;
 begin
  result^.Globals.Lock:=POCALockCreate;
  result^.Globals.Semaphore:=POCASemaphoreCreate;
 end;
{$ifdef POCAHasJIT}
 result^.Globals.NativeCodeMemoryManager:=POCANativeCodeMemoryManagerCreate(result);
{$endif}
 result^.SourceFiles:=TStringList.Create;
 result^.IncludeDirectories:=TStringList.Create;
 begin
  result^.Globals.StrictMode:=true;
 end;
 begin
  result^.Globals.GarbageCollector.Instance:=result;
  result^.Globals.GarbageCollector.Lock:=POCALockCreate;
  result^.Globals.GarbageCollector.ProtectList:=TPOCAPointerList.Create;
  result^.Globals.GarbageCollector.WhiteMask:=pgcbWHITE;
  result^.Globals.GarbageCollector.BlackMask:=pgcbBLACK;
  for Ghost:=false to true do begin
   GetMem(result^.Globals.GarbageCollector.WhiteLists[Ghost],SizeOf(TPOCAGarbageCollectorLinkedList));
   Initialize(result^.Globals.GarbageCollector.WhiteLists[Ghost]^);
   GetMem(result^.Globals.GarbageCollector.BlackLists[Ghost],SizeOf(TPOCAGarbageCollectorLinkedList));
   Initialize(result^.Globals.GarbageCollector.BlackLists[Ghost]^);
   result^.Globals.GarbageCollector.WhiteLists[Ghost]^.Initialize('WhiteLists['+IntToStr(Ord(Ghost) and 1)+']');
   result^.Globals.GarbageCollector.BlackLists[Ghost]^.Initialize('BlackLists['+IntToStr(Ord(Ghost) and 1)+']');
   result^.Globals.GarbageCollector.PersistentLists[Ghost].Initialize('PersistentLists['+IntToStr(Ord(Ghost) and 1)+']');
   result^.Globals.GarbageCollector.PersistentRootLists[Ghost].Initialize('PersistentRootLists['+IntToStr(Ord(Ghost) and 1)+']');
   result^.Globals.GarbageCollector.SweepLists[Ghost].Initialize('SweepLists['+IntToStr(Ord(Ghost) and 1)+']');
  end;
  result^.Globals.GarbageCollector.GrayList.Initialize('GrayList');
  result^.Globals.GarbageCollector.WhiteGhostList.Initialize('WhiteGhostList');
  result^.Globals.GarbageCollector.State:=pgcsINIT;
  result^.Globals.GarbageCollector.LastFullCycleCounter:=0;
  result^.Globals.GarbageCollector.FullCycleCounter:=0;
  result^.Globals.GarbageCollector.FullAllocationCounter:=0;
  result^.Globals.GarbageCollector.AllocationCounter:=0;
  result^.Globals.GarbageCollector.PersistentCycleCounter:=0;
  result^.Globals.GarbageCollector.PersistentForceScan:=false;
  result^.Globals.GarbageCollector.DynamicThreshold:=true;
  result^.Globals.GarbageCollector.FullCollectionThresholdFactor:=240;
  result^.Globals.GarbageCollector.IncrementalCollectionThresholdFactor:=16;
  result^.Globals.GarbageCollector.MarkFactor:=64;
  result^.Globals.GarbageCollector.GhostFactor:=64;
  result^.Globals.GarbageCollector.SweepFactor:=64;
  result^.Globals.GarbageCollector.PersistentThreshold:=16;
  result^.Globals.GarbageCollector.PersistentInterval:=0;
  result^.Globals.GarbageCollector.ExhaustionCollect:=false;
  result^.Globals.GarbageCollector.ExhaustionIncrementalFullCycleThreshold:=0;
  result^.Globals.GarbageCollector.ExhaustionIncrementalFullCycleCounter:=0;
  result^.Globals.GarbageCollector.Active:=true;
  result^.Globals.GarbageCollector.Incremental:=true;
  result^.Globals.GarbageCollector.Generational:=false;
  result^.Globals.GarbageCollector.LocalContextPoolSize:=256;
  result^.Globals.GarbageCollector.ContextCacheSize:=128;
  result^.Globals.GarbageCollector.MinimumBlockSize:=1024;
  result^.Globals.GarbageCollector.ScanContextGrays:=false;
 end;
 begin
  result^.Globals.DeadAllocationCount:=256;
{$ifdef POCAMemoryPools}
  for i:=0 to pvtCOUNT-1 do begin
   POCAPoolInit(result,@result^.Globals.Pools[i],i);
  end;
{$endif}
  result^.Globals.DeadSize:=256;
  result^.Globals.DeadCount:=0;
  GetMem(result^.Globals.DeadBlocks,result^.Globals.DeadSize*sizeof(TPOCAPointer));
  FillChar(result^.Globals.DeadBlocks^,result^.Globals.DeadSize*sizeof(TPOCAPointer),#0);
 end;
 begin
  result^.Globals.FreeContexts:=nil;
  result^.Globals.FirstContext:=nil;
  result^.Globals.LastContext:=nil;
 end;
 begin
  result^.Globals.ModuleLoaderFunctions:=nil;
  SetLength(result^.Globals.ModuleLoaderFunctions,1);
  result^.Globals.ModuleLoaderFunctions[0]:=POCADefaultModuleFunction;
  result^.Globals.CountModuleLoaderFunctions:=1;
 end;
 begin
  Context:=POCAContextCreate(result);
  try
   begin
    result^.Globals.SourceFiles:=POCANewArray(Context);
   end;
   begin
    result^.Globals.UniqueStringArray:=POCANewArray(Context);
    result^.Globals.UniqueStringHashMap:=TPOCAStringHashMap.Create(true);
    result^.Globals.UniqueStringLock:=POCALockCreate;
   end;
   begin
    result^.Globals.Symbols:=POCANewHash(Context);
    result^.Globals.Save:=POCANewArray(Context);
   end;
   begin
    result^.Globals.ArgumentsValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'arguments'));
    result^.Globals.ConstructorValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,ConstructorValueSymbolString));
    begin                    
     result^.Globals.NullValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Null'));
     result^.Globals.ReferenceValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Reference'));
     result^.Globals.NumberValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Number'));
     result^.Globals.StringValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'String'));
     result^.Globals.ArrayValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Array'));
     result^.Globals.GhostClassValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'GhostClass'));
     result^.Globals.ClassValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Class'));
     result^.Globals.GhostModuleValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'GhostModule'));
     result^.Globals.ModuleValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Module'));
     result^.Globals.GhostHashValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'GhostHash'));
     result^.Globals.HashValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Hash'));
     result^.Globals.FunctionValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Function'));
     result^.Globals.ClassGhostValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'ClassGhost'));
     result^.Globals.ModuleGhostValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'ModuleGhost'));
     result^.Globals.HashGhostValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'HashGhost'));
     result^.Globals.GhostValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Ghost'));
     result^.Globals.CodeValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Code'));
     result^.Globals.NativeCodeValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'NativeCode'));
     result^.Globals.UnknownValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Unknown'));
     result^.Globals.LengthStringReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'length'));
    end;
   end;
   result^.Globals.ModuleScopes:=POCANewHash(Context);
   result^.Globals.ModuleValues:=POCANewHash(Context);
   result^.Globals.ModuleTimes:=POCANewHash(Context);
   result^.Globals.RootArray:=POCANewArray(Context);
   result^.Globals.RootHash:=POCANewHash(Context);
   result^.Globals.HiddenNamespace:=POCANewHash(Context);
   result^.Globals.Namespace:=POCAInitGlobalNamespace(Context);
   result^.Globals.BaseClass:=POCAInitBaseClass(Context);
   begin
    result^.Globals.ArrayHash:=POCAInitArrayHash(Context);
    result^.Globals.HashHash:=POCAInitHashHash(Context);
    result^.Globals.NumberHash:=POCAInitNumberHash(Context);
    result^.Globals.StringHash:=POCAInitStringHash(Context);
    result^.Globals.IOHash:=POCAInitIOHash(Context);
    result^.Globals.RegExpHash:=POCAInitRegExpHash(Context);
    result^.Globals.CoroutineHash:=POCAInitCoroutineHash(Context);
    result^.Globals.ThreadHash:=POCAInitThreadHash(Context);
    result^.Globals.LockHash:=POCAInitLockHash(Context);
    result^.Globals.SemaphoreHash:=POCAInitSemaphoreHash(Context);
    begin
     POCAHashSetString(Context,result^.Globals.Namespace,'ArrayHash',result^.Globals.ArrayHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'HashHash',result^.Globals.HashHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'NumberHash',result^.Globals.NumberHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'StringHash',result^.Globals.StringHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'IOHash',result^.Globals.IOHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'RegExpHash',result^.Globals.RegExpHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'CoroutineHash',result^.Globals.CoroutineHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'ThreadHash',result^.Globals.ThreadHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'LockHash',result^.Globals.LockHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'SemaphoreHash',result^.Globals.SemaphoreHash);
    end;
   end;
  finally
   POCAContextDestroy(Context);
  end;
 end;
 begin
  result^.Globals.HostData:=nil;
  result^.Globals.HostDataFreeable:=true;
 end;
end;

procedure POCAInstanceDestroy(var Instance:PPOCAInstance);
var CurrentContext{,NextContext}:PPOCAContext;
    //i:TPOCAInt32;
    Ghost:boolean;
begin
 if assigned(Instance) then begin
  try
   if assigned(Instance^.Globals.FirstContext) then begin

    CurrentContext:=Instance^.Globals.FirstContext;
    while assigned(CurrentContext) do begin
     if assigned(PPOCAThreadData(CurrentContext^.ThreadData)) then begin
      POCAThreadDestroy(PPOCAThreadData(CurrentContext^.ThreadData));
      CurrentContext^.ThreadData:=nil;
     end;
     CurrentContext:=CurrentContext^.Next;
    end;

    CurrentContext:=Instance^.Globals.FirstContext;
    while assigned(CurrentContext) do begin
     if assigned(CurrentContext^.CoroutineData) then begin
      if assigned(PPOCACoroutineData(CurrentContext^.CoroutineData)^.Coroutine) then begin
       POCACoroutineDestroy(PPOCACoroutineData(CurrentContext^.CoroutineData)^.Coroutine);
       PPOCACoroutineData(CurrentContext^.CoroutineData)^.Coroutine:=nil;
      end;
      PPOCACoroutineData(CurrentContext^.CoroutineData)^.Context:=nil;
      SetLength(PPOCACoroutineData(CurrentContext^.CoroutineData)^.Arguments,0);
      if assigned(PPOCACoroutineData(CurrentContext^.CoroutineData)^.ExceptionHolder) then begin
       FreeAndNil(PPOCACoroutineData(CurrentContext^.CoroutineData)^.ExceptionHolder);
      end;
      if POCAIsValueGhost(PPOCAThreadData(CurrentContext^.CoroutineData)^.Data) then begin
       PPOCAGhost(POCAGetValueReferencePointer(PPOCAThreadData(CurrentContext^.CoroutineData)^.Data))^.Ptr:=nil;
      end;
      PPOCAThreadData(CurrentContext^.CoroutineData)^.Data.Num:=0;
      Finalize(PPOCACoroutineData(CurrentContext^.CoroutineData)^);
      FillChar(PPOCAThreadData(CurrentContext^.CoroutineData)^,SizeOf(TPOCACoroutineData),#0);
      CurrentContext^.CoroutineData:=nil;
     end;
     CurrentContext:=CurrentContext^.Next;
    end;

    while assigned(Instance^.Globals.FirstContext) do begin
     POCAContextFree(Instance^.Globals.FirstContext);
    end;

   end;

   if assigned(Instance^.Globals.DeadBlocks) then begin
    FreeMem(Instance^.Globals.DeadBlocks);
    Instance^.Globals.DeadBlocks:=nil;
   end;

   for Ghost:=false to true do begin
    Instance^.Globals.GarbageCollector.WhiteLists[Ghost]^.Finalize;
    Instance^.Globals.GarbageCollector.BlackLists[Ghost]^.Finalize;
    Instance^.Globals.GarbageCollector.PersistentLists[Ghost].Finalize;
    Instance^.Globals.GarbageCollector.PersistentRootLists[Ghost].Finalize;
    Instance^.Globals.GarbageCollector.SweepLists[Ghost].Finalize;
    Finalize(Instance^.Globals.GarbageCollector.WhiteLists[Ghost]^);
    FreeMem(Instance^.Globals.GarbageCollector.WhiteLists[Ghost]);
    Finalize(Instance^.Globals.GarbageCollector.BlackLists[Ghost]^);
    FreeMem(Instance^.Globals.GarbageCollector.BlackLists[Ghost]);
   end;
   Instance^.Globals.GarbageCollector.GrayList.Finalize;
   Instance^.Globals.GarbageCollector.WhiteGhostList.Finalize;

   FreeAndNil(Instance^.Globals.GarbageCollector.ProtectList);

{$ifdef POCAHasJIT}
   POCANativeCodeMemoryManagerDestroy(Instance^.Globals.NativeCodeMemoryManager);
{$endif}

   POCALockDestroy(Instance^.Globals.GarbageCollector.Lock);

   POCALockDestroy(Instance^.Globals.Lock);

   POCALockDestroy(Instance^.Globals.UniqueStringLock);

   POCASemaphoreDestroy(Instance^.Globals.Semaphore);

   FreeAndNil(Instance^.Globals.UniqueStringHashMap);

   FreeAndNil(Instance^.IncludeDirectories);

   FreeAndNil(Instance^.SourceFiles);

   Instance^.Globals.ModuleLoaderFunctions:=nil;

   if assigned(Instance^.Globals.HostData) then begin
    if Instance^.Globals.HostDataFreeable then begin
     FreeMem(Instance^.Globals.HostData);
    end;
    Instance^.Globals.HostData:=nil;
   end;

  finally
   Finalize(Instance^);
   Dispose(Instance);
   Instance:=nil;
  end;
 end;
end;

{$ifdef POCAHasJIT}
function POCAGenerateNativeCode(Context:PPOCAContext;Code:PPOCACode):boolean; forward;
{$endif}

type TPOCATokenPrecedenceRule=(prNONE,prBINARY,prREVERSE,prPREFIX,prSUFFIX);
     PPOCATokenPrecedence=^TPOCATokenPrecedence;
     TPOCATokenPrecedence=record
      Tokens:TPOCATokenTypes;
      Rule:TPOCATokenPrecedenceRule;
     end;
     PPOCATokenBinaryPrefix=^TPOCATokenBinaryPrefix;
     TPOCATokenBinaryPrefix=record
      BinaryToken:TPOCATokenType;
      PrefixToken:TPOCATokenType;
     end;
     PPOCABinaryToPrefixUnaryTokenCorrectionMap=^TPOCABinaryToPrefixUnaryTokenCorrectionMap;
     TPOCABinaryToPrefixUnaryTokenCorrectionMap=array[TPOCATokenType] of TPOCATokenType;
const POCATokenPrecedences:array[0..31] of TPOCATokenPrecedence=((Tokens:[ptSEMI,ptCOMMA,ptAUTOSEMI];Rule:prREVERSE),
                                                                 (Tokens:[ptELLIPSIS];Rule:prSUFFIX),
                                                                 (Tokens:[ptREGEXP];Rule:prPREFIX),
                                                                 (Tokens:[ptRETURN,ptBREAK,ptCONTINUE,ptTHROW,ptBREAKPOINT,ptDELETE];Rule:prPREFIX),
                                                                 (Tokens:[ptASSIGN,ptPLUSEQ,ptMINUSEQ,ptMULEQ,ptDIVEQ,ptCATEQ,ptBANDEQ,ptBOREQ,ptBXOREQ,ptBSHLEQ,ptBSHREQ,ptBUSHREQ,ptMODEQ,ptPOWEQ,ptELVISEQ];Rule:prREVERSE),
                                                                 (Tokens:[ptCOLON,ptQUESTION];Rule:prREVERSE),
                                                                 (Tokens:[ptINSTANCEOF,ptIN,ptIS];Rule:prBINARY),
                                                                 (Tokens:[ptDOTDOT];Rule:prREVERSE),
                                                                 (Tokens:[ptVAR,ptLET,ptCONST];Rule:prPREFIX),
                                                                 (Tokens:[ptELVIS];Rule:prBINARY),
                                                                 (Tokens:[ptNULLISHOR];Rule:prBINARY),
                                                                 (Tokens:[ptOR];Rule:prBINARY),
                                                                 (Tokens:[ptAND];Rule:prBINARY),
                                                                 (Tokens:[ptBOR];Rule:prBINARY),
                                                                 (Tokens:[ptBXOR];Rule:prBINARY),
                                                                 (Tokens:[ptBAND];Rule:prBINARY),
                                                                 (Tokens:[ptSEQ,ptSNEQ];Rule:prBINARY),
                                                                 (Tokens:[ptEQ,ptNEQ];Rule:prBINARY),
                                                                 (Tokens:[ptLT,ptLTEQ,ptGT,ptGTEQ];Rule:prBINARY),
                                                                 (Tokens:[ptREGEXPEQ,ptREGEXPNEQ];Rule:prBINARY),
                                                                 (Tokens:[ptBSHL,ptbSHR,ptBUSHR];Rule:prBINARY),
                                                                 (Tokens:[ptPLUS,ptMINUS,ptCAT];Rule:prBINARY),
                                                                 (Tokens:[ptCMP];Rule:prBINARY),
                                                                 (Tokens:[ptMUL,ptDIV,ptMOD,ptPOW];Rule:prBINARY),
                                                                 (Tokens:[ptNEW];Rule:prPREFIX),
                                                                 (Tokens:[ptMINUS,ptPLUS,ptNEG,ptNUM,ptNOT,ptCAT,ptBNOT];Rule:prPREFIX),
                                                                 (Tokens:[ptPREDEC,ptPREINC];Rule:prPREFIX),
                                                                 (Tokens:[ptPOSTDEC,ptPOSTINC];Rule:prSUFFIX),
                                                                 (Tokens:[ptLPAR,ptLBRA,ptSAFELBRA];Rule:prSUFFIX),
                                                                 (Tokens:[ptDOT,ptATDOT,ptSAFEDOT];Rule:prBINARY),
                                                                 (Tokens:[ptSYMBOLNAME];Rule:prSUFFIX),
                                                                 (Tokens:[ptAT];Rule:prBINARY));
      POCATokenBinaryPrefixes:array[0..2] of TPOCATokenBinaryPrefix=((BinaryToken:ptMINUS;PrefixToken:ptNEG),
                                                                     (BinaryToken:ptPLUS;PrefixToken:ptNUM),
                                                                     (BinaryToken:ptCAT;PrefixToken:ptBNOT));
var POCABinaryTokens:TPOCATokenTypes=[];
    POCAReverseTokens:TPOCATokenTypes=[];
    POCAPrefixTokens:TPOCATokenTypes=[];
    POCASuffixTokens:TPOCATokenTypes=[];
    POCABinaryOrPrefixTokens:TPOCATokenTypes=[];
    POCABinaryToPrefixUnaryTokenCorrectionMap:TPOCABinaryToPrefixUnaryTokenCorrectionMap;

function POCACompile(Instance:PPOCAInstance;Context:PPOCAContext;const Source:TPOCARawByteString;const SourceFileName:TPOCARawByteString=''):TPOCAValue;
type PPPOCAToken=^PPOCAToken;
     PPOCAToken=^TPOCAToken;
     TPOCAToken=packed record
      Token:TPOCATokenType;
      Visited:boolean;
      SourceFile,SourceLine,SourceColumn:TPOCAInt32;
      Str:TPOCARawByteString;
      Rule:TPOCATokenPrecedenceRule;
      Num:double;
      TokenListNext,Parent,Next,Previous:PPOCAToken;
      case TPOCAUInt8 of
       0:(Children,LastChild:PPOCAToken;);
       1:(Left,Right:PPOCAToken;);
     end;
     //PPOCAParser=^TPOCAParser;
     TPOCAParser=packed record
      Context:PPOCAContext;
      Error:TPOCARawByteString;
      ErrorLine:TPOCAInt32;
      Tree:TPOCAToken;
      SrcFile:TPOCAValue;
      SourceFile:TPOCAInt32;
     end;
     TPOCAPreprocessorInputSourceKind=(iskNONE,iskFILE,iskMACRO);
     TPOCAPreprocessorInputSource=record
      Kind:TPOCAPreprocessorInputSourceKind;
      Name:TPOCARawByteString;
      Index:TPOCAInt32;
     end;
     TPOCAPreprocessorInputSources=array of TPOCAPreprocessorInputSource;
     TPOCAPreprocessorPragmaInfoItem=record
      CharPos:TPOCAInt32;
      Pragma:TPOCARawByteString;
     end;
     TPOCAPreprocessorPragmaInfo=array of TPOCAPreprocessorPragmaInfoItem;
     TPOCAPreprocessorOutputInfoItem=record
      FirstCharPos,LastCharPos,Source,Line:TPOCAInt32;
     end;
     TPOCAPreprocessorOutputInfo=array of TPOCAPreprocessorOutputInfoItem;
     TPOCAPreprocessor=record
      InputKind:TPOCAPreprocessorInputSourceKind;
      InputName:TPOCARawByteString;
      InputText:TPOCARawByteString;
      InputSources:TPOCAPreprocessorInputSources;
      InputSourcesCount:TPOCAInt32;
      PragmaInfo:TPOCAPreprocessorPragmaInfo;
      PragmaInfoCount:TPOCAInt32;
      OutputInfo:TPOCAPreprocessorOutputInfo;
      OutputInfoCount:TPOCAInt32;
      OutputText:TPOCARawByteString;
      OutputTextLength:TPOCAInt32;
     end;
     TPOCAPreprocessorInstance=record
      Preprocessor:TPOCAPreprocessor;
      Source:TPOCAInt32;
      Line:TPOCAInt32;
     end;
var TokenList:PPOCAToken;
    PreprocessorInstance:TPOCAPreprocessorInstance;
 procedure ResetTokenVisited;
 var CurrentToken:PPOCAToken;
 begin
  CurrentToken:=TokenList;
  while assigned(CurrentToken) do begin
   CurrentToken^.Visited:=false;
   CurrentToken:=CurrentToken^.TokenListNext;
  end;
 end;
 procedure SyntaxError(const AMessage:TPOCAUTF8String;SourceFile,SourceLine,SourceColumn:TPOCAInt32);
 begin
  raise EPOCASyntaxError.Create(SourceFile,SourceLine,SourceColumn,AMessage);
 end;
 procedure ProcessPreprocessor(var ParserInstance:TPOCAPreprocessorInstance;var Parser:TPOCAParser);
 type //TChars=set of ansichar;
      TToken=(tNONE,tCHAR,tNUMBER,tNAME,tSTRING,TSTRINGLONG);
      TInputStackItem=record
       Source:TPOCAInt32;
       Buffer:TPOCARawByteString;
       BufferPosition,BufferLine:TPOCAInt32;
      end;
      TInputStack=array of TInputStackItem;
      TMacroFunction=(mfNONE,mfFILE,mfLINE,mfTIME,mfDATE,mfPRAGMA);
      TMacroBodyItemKind=(mbikTEXT,mbikPARAMETER,mbikVAARGS,mbikSPLITTER);
      TMacroBodyItem=record
       Kind:TMacroBodyItemKind;
       Value:TPOCAInt32;
       Text:TPOCARawByteString;
       Quote:boolean;
      end;
      TMacroBody=array of TMacroBodyItem;
      TMacro=record
       Defined:boolean;
       Name:TPOCARawByteString;
       Body:TMacroBody;
       Parameters:TPOCAInt32;
       VaArgs:boolean;
       MacroFunction:TMacroFunction;
      end;
      TMacros=array of TMacro;
 const{WhiteSpace:TChars=[#9,#11..#13,#32,#255];
       WhiteSpaceEx:TChars=[#9,#10..#13,#32,#255];}
       UCS4WhiteSpace=[9,11..13,32,255];
       UCS4WhiteSpaceEx=[9,10..13,32,255];
       kwNONE=0;
       kwINCLUDE=1;
       kwINCLUDENEXT=2;
       kwINCLUDEONCE=3;
       kwINCLUDENEXTONCE=4;
       kwDEFINE=5;
       kwUNDEF=6;
       kwIF=7;
       kwIFDEF=8;
       kwIFNDEF=9;
       kwELIF=10;
       kwELSE=11;
       kwENDIF=12;
       kwLINE=13;
       kwPRAGMA=14;
       kwERROR=15;
       kwWARNING=16;
 var InputStack:TInputStack;
     CurrentToken:TToken;
     CurrentTokenChar:TPOCAUCS4Char;
     CurrentTokenString:TPOCARawByteString;
     Macros:TMacros;
     IFNestedLevel,MacroLevel:TPOCAInt32;
     LastSource,LastLine:TPOCAInt32;
     InEval:boolean;
     MacroStringTree:TPOCAStringTree;
     KeywordStringTree:TPOCAStringTree;
  procedure AddWarning(const s:TPOCAUTF8String); forward;
  function GetInputSourceIndex(Kind:TPOCAPreprocessorInputSourceKind;Name:TPOCARawByteString):TPOCAInt32; forward;
  function hex2byte(c:TPOCAUCS4Char):TPOCAInt32;
  begin
   case c of
    ord('0')..ord('9'):begin
     result:=c-TPOCAUInt8('0');
    end;
    ord('a')..ord('f'):begin
     result:=c-TPOCAUInt8('a')+$a;
    end;
    ord('A')..ord('F'):begin
     result:=c-TPOCAUInt8('F')+$a;
    end;
    else begin
     result:=0;
    end;
   end;
  end;
  function ProprocessInputSourceChars(Kind:TPOCAPreprocessorInputSourceKind;const Name,Body:TPOCARawByteString):TPOCAUTF8String;
  var i,OutLen,ls,ll:TPOCAInt32;
      sc:ansichar;
      OutStr,s:TPOCARawByteString;
   procedure AddChar(NewChar:ansichar);
   var NewLen:TPOCAInt32;
   begin
    NewLen:=OutLen+1;
    if NewLen>=length(OutStr) then begin
     SetLength(OutStr,POCARoundUpToPowerOfTwo(NewLen+1));
    end;
    OutStr[NewLen]:=NewChar;
    OutLen:=NewLen;
   end;
   procedure AddString(const NewString:TPOCARawByteString);
   var i:TPOCAInt32;
   begin
    for i:=1 to length(NewString) do begin
     AddChar(NewString[i]);
    end;
   end;
  begin
   result:='';
   ls:=LastSource;
   ll:=LastLine;
   try
    LastSource:=GetInputSourceIndex(Kind,Name);
    LastLine:=0;
    s:=Body;
    if (length(s)>=3) and ((s[1]=#$ef) and (s[2]=#$bb) and (s[3]=#$bf)) then begin
     delete(s,1,3);
    end;
    OutStr:='';
    SetLength(OutStr,4096);
    OutLen:=0;
    i:=1;
    while i<=length(s) do begin
     sc:=s[i];
     case sc of
      #10:begin
       if ((i+1)<=length(s)) and (s[i+1]=#13) then begin
        inc(i,2);
       end else begin
        inc(i);
       end;
       inc(LastLine);
       AddChar(#10);
      end;
      #13:begin
       if ((i+1)<=length(s)) and (s[i+1]=#10) then begin
        inc(i,2);
       end else begin
        inc(i);
       end;
       inc(LastLine);
       AddChar(#10);
      end;
      '\':begin
       if ((i+1)<=length(s)) and (s[i+1]='U') then begin
        if ((i+9)<=length(s)) and
           (s[i+2] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+3] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+4] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+5] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+6] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+7] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+8] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+9] in ['0'..'9','A'..'F','a'..'f']) then begin
         AddString(PUCUUTF32CharToUTF8((hex2byte(ord(s[i+2])) shl 28) or (hex2byte(ord(s[i+3])) shl 24) or (hex2byte(ord(s[i+4])) shl 20) or (hex2byte(ord(s[i+5])) shl 16) or (hex2byte(ord(s[i+6])) shl 12) or (hex2byte(ord(s[i+7])) shl 8) or (hex2byte(ord(s[i+8])) shl 4) or (hex2byte(ord(s[i+9])) shl 0)));
         inc(i,10);
        end else begin
         AddString('\U');
         inc(i,2);
        end;
       end else if ((i+1)<=length(s)) and (s[i+1]='u') then begin
        if ((i+5)<=length(s)) and
           (s[i+2] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+3] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+4] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+5] in ['0'..'9','A'..'F','a'..'f']) then begin
         AddString(PUCUUTF32CharToUTF8((hex2byte(ord(s[i+2])) shl 12) or (hex2byte(ord(s[i+3])) shl 8) or (hex2byte(ord(s[i+4])) shl 4) or (hex2byte(ord(s[i+5])) shl 0)));
         inc(i,6);
        end else begin
         AddString('\u');
         inc(i,2);
        end;
       end else if ((i+1)<=length(s)) and (s[i+1]=#13) then begin
        AddChar('\');
        inc(i);
       end else begin
        AddChar('\');
        AddChar(s[i+1]);
        inc(i,2);
       end;
      end;
      else begin
       AddChar(sc);
       inc(i);
      end;
     end;
    end;
    result:=copy(OutStr,1,OutLen);
   finally
    OutStr:='';
    LastSource:=ls;
    LastLine:=ll;
   end;
  end;
  function LookUpKeyword(const Name:TPOCARawByteString):TPOCAInt32;
  var d:TPOCAStringTreeData;
  begin
   result:=kwNONE;
   d:=0;
   if KeywordStringTree.Find(Name,d) then begin
    result:=TPOCAPtrInt(d);
   end;
  end;
  function LookUpEx(const Name:TPOCARawByteString):TPOCAInt32;
  var d:TPOCAStringTreeData;
  begin
   result:=-1;
   d:=0;
   if MacroStringTree.Find(Name,d) then begin
    result:=TPOCAPtrInt(d);
   end;
  end;
  function LookUp(const Name:TPOCARawByteString):TPOCAInt32;
  begin
   result:=LookUpEx(Name);
   if result>=0 then begin
    if not Macros[result].Defined then begin
     result:=-1;
    end;
   end;
  end;
  procedure AddDefine(const Name:TPOCARawByteString;Body:TMacroBody;Parameters:TPOCAInt32;VaArgs:boolean;MacroFunction:TMacroFunction);
  var i:TPOCAInt32;
  begin
   i:=LookUpEx(Name);
   if i<0 then begin
    i:=length(Macros);
    SetLength(Macros,i+1);
   end;
   Macros[i].Defined:=true;
   Macros[i].Name:=Name;
   Macros[i].Body:=copy(Body,0,length(Body));
   Macros[i].Parameters:=Parameters;
   Macros[i].VaArgs:=VaArgs;
   Macros[i].MacroFunction:=MacroFunction;
   MacroStringTree.Add(Name,i,true);
  end;
  procedure RemoveDefine(const Name:TPOCARawByteString);
  var i:TPOCAInt32;
  begin
   i:=LookUpEx(Name);
   if i>=0 then begin
    Macros[i].Defined:=false;
   end;
  end;
  function GetInputSourceIndex(Kind:TPOCAPreprocessorInputSourceKind;Name:TPOCARawByteString):TPOCAInt32;
  var i,j:TPOCAInt32;
  begin
   for i:=0 to ParserInstance.Preprocessor.InputSourcesCount-1 do begin
    if (ParserInstance.Preprocessor.InputSources[i].Kind=Kind) and (ParserInstance.Preprocessor.InputSources[i].Name=Name) then begin
     result:=i;
     exit;
    end;
   end;
   result:=ParserInstance.Preprocessor.InputSourcesCount;
   inc(ParserInstance.Preprocessor.InputSourcesCount);
   if (result+1)>length(ParserInstance.Preprocessor.InputSources) then begin
    SetLength(ParserInstance.Preprocessor.InputSources,POCARoundUpToPowerOfTwo(result+2));
   end;
   ParserInstance.Preprocessor.InputSources[result].Kind:=Kind;
   ParserInstance.Preprocessor.InputSources[result].Name:=Name;
   case Kind of
    iskMACRO:begin
     Name:='MACRO('+Name+')';
    end;
   end;
   j:=Instance^.SourceFiles.IndexOf(String(Name));
   if j<0 then begin
    j:=Instance^.SourceFiles.Add(String(Name));
    if j=TPOCAInt32(POCAArraySize(Context^.Instance.Globals.SourceFiles)) then begin
     POCAArrayPush(Context^.Instance.Globals.SourceFiles,POCANewString(Context,Name));
    end else begin
     POCAArraySetSize(Context^.Instance.Globals.SourceFiles,Instance^.SourceFiles.Count);
     for i:=0 to Instance^.SourceFiles.Count-1 do begin
      POCAArraySet(Context^.Instance.Globals.SourceFiles,i,POCANewString(Context,TPOCARawByteString(Instance^.SourceFiles[i])));
     end;
    end;
   end;
   ParserInstance.Preprocessor.InputSources[result].Index:=j;
  end;
  procedure PushInputSource(Kind:TPOCAPreprocessorInputSourceKind;const Name,Text:TPOCARawByteString);
  var i:TPOCAInt32;
  begin
   i:=length(InputStack);
   SetLength(InputStack,i+1);
   InputStack[i].Source:=GetInputSourceIndex(Kind,Name);
   InputStack[i].Buffer:=Text;
   InputStack[i].BufferPosition:=1;
   InputStack[i].BufferLine:=0;
  end;
  procedure PopInputSource;
  var i:TPOCAInt32;
  begin
   if length(InputStack)>0 then begin
    i:=length(InputStack)-1;
    SetLength(InputStack,i);
   end;
  end;
  function NextChar:TPOCAUCS4Char;
  var i:TPOCAInt32;
  begin
   result:=0;
   i:=length(InputStack)-1;
   while i>=0 do begin
    if InputStack[i].BufferPosition<=length(InputStack[i].Buffer) then begin
     if (InputStack[i].Source>=0) and (ParserInstance.Preprocessor.InputSources[InputStack[i].Source].Kind=iskFILE) then begin
      LastSource:=InputStack[i].Source;
      LastLine:=InputStack[i].BufferLine;
      ParserInstance.Source:=LastSource;
      ParserInstance.Line:=LastLine;
     end;
     if ((InputStack[i].BufferPosition+2)<=length(InputStack[i].Buffer)) and
        (InputStack[i].Buffer[InputStack[i].BufferPosition+0]=#$ef) and
        (InputStack[i].Buffer[InputStack[i].BufferPosition+1]=#$bf) and
        (InputStack[i].Buffer[InputStack[i].BufferPosition+2]=#$bd) then begin
      result:=-1;
      inc(InputStack[i].BufferPosition,3);
     end else begin
      result:=PUCUUTF8CodeUnitGetCharAndIncFallback(InputStack[i].Buffer,InputStack[i].BufferPosition);
      if result=10 then begin
       inc(InputStack[i].BufferLine);
      end;
     end;
     if InputStack[i].BufferPosition>length(InputStack[i].Buffer) then begin
      PopInputSource;
     end;
     break;
    end else begin
     PopInputSource;
     i:=length(InputStack)-1;
    end;
   end;
  end;
  function GetCharAt(j:TPOCAInt32=0):TPOCAUCS4Char;
  var i,p:TPOCAInt32;
  begin
   result:=0;
   i:=length(InputStack)-1;
   while (i>=0) and (j>=0) do begin
    p:=InputStack[i].BufferPosition;
    while (p<=length(InputStack[i].Buffer)) and (j>=0) do begin
     if ((p+2)<=length(InputStack[i].Buffer)) and
         (InputStack[i].Buffer[p+0]=#$ef) and
         (InputStack[i].Buffer[p+1]=#$bf) and
         (InputStack[i].Buffer[p+2]=#$bd) then begin
      result:=-1;
      inc(p,3);
     end else begin
      result:=PUCUUTF8CodeUnitGetCharAndIncFallback(InputStack[i].Buffer,p);
     end;
     dec(j);
    end;
    dec(i);
   end;
   if j>0 then begin
    result:=0;
   end;
  end;
  function GetToken:TToken;
  var lc,c,sc:TPOCAUCS4Char;
      cc,i,j:TPOCAInt32;
  begin
   result:=tNONE;
   c:=NextChar;
   case c of
    ord('/'):begin
     if MacroLevel=0 then begin
      c:=GetCharAt(0);
      case c of
       ord('/'):begin
        NextChar;
        c:=NextChar;
        while not (c in [0,10]) do begin
         c:=NextChar;
        end;
        result:=tCHAR;
        CurrentToken:=tCHAR;
        CurrentTokenChar:=c;
        CurrentTokenString:=PUCUUTF32CharToUTF8(c);
       end;
       ord('*'):begin
        NextChar;
        lc:=0;
        c:=NextChar;
        cc:=1;
        repeat
         if (lc=ord('/')) and (c=ord('*')) then begin
          inc(cc);
          c:=0;
         end else if (lc=ord('*')) and (c=ord('/')) then begin
          dec(cc);
          if cc=0 then begin
           break;
          end;
         end;
         lc:=c;
         c:=NextChar;
        until false;
        c:=ord(' ');
        result:=tCHAR;
        CurrentToken:=tCHAR;
        CurrentTokenChar:=c;
        CurrentTokenString:=PUCUUTF32CharToUTF8(c);
       end;
       else begin
        c:=ord('/');
        result:=tCHAR;
        CurrentToken:=tCHAR;
        CurrentTokenChar:=c;
        CurrentTokenString:=PUCUUTF32CharToUTF8(c);
       end;
      end;
     end else begin
      c:=ord('/');
      result:=tCHAR;
      CurrentToken:=tCHAR;
      CurrentTokenChar:=c;
      CurrentTokenString:=PUCUUTF32CharToUTF8(c);
     end;
    end;
    ord('0')..ord('9'):begin
     result:=tNUMBER;
     CurrentToken:=result;
     CurrentTokenString:=PUCUUTF32CharToUTF8(c);
     i:=0;
     while GetCharAt(i) in [ord('A')..ord('Z'),ord('a')..ord('z'),ord('_'),ord('0')..ord('9')] do begin
      inc(i);
     end;
     while i>0 do begin
      CurrentTokenString:=CurrentTokenString+PUCUUTF32CharToUTF8(NextChar);
      dec(i);
     end;
    end;
    ord('"'):begin
     CurrentTokenString:='"';
     i:=0;
     repeat
      c:=GetCharAt(i);
      if (c=ord('"')) or (c=0) then begin
       inc(i);
       break;
      end else if c=ord('\') then begin
       if (GetCharAt(i+1)=ord('{')) then begin
        inc(i,2);
        j:=0;
        repeat
         c:=GetCharAt(i);
         if c=ord('{') then begin
          inc(j);
         end else if c=ord('}') then begin
          if j=0 then begin
           break;
          end else begin
           dec(j);
          end;
         end else if c=0 then begin
          break;
         end else begin
          inc(i);
         end;
        until false;
       end else begin
        inc(i,2);
       end;
      end else begin
       inc(i);
      end;
     until false;
     while i>0 do begin
      CurrentTokenString:=CurrentTokenString+PUCUUTF32CharToUTF8(NextChar);
      dec(i);
     end;
     result:=tSTRING;
     CurrentToken:=tSTRING;
    end;
    ord(''''):begin
     CurrentTokenString:='''';
     i:=0;
     repeat
      c:=GetCharAt(i);
      if (c=ord('''')) and (GetCharAt(i+1)=ord('''')) then begin
       inc(i,2);
      end else if (c=ord('''')) or (c=0) then begin
       inc(i);
       break;
      end else begin
       inc(i);
      end;
     until false;
     while i>0 do begin
      CurrentTokenString:=CurrentTokenString+PUCUUTF32CharToUTF8(NextChar);
      dec(i);
     end;
     result:=tSTRING;
     CurrentToken:=tSTRING;
    end;
    else begin
     if (c=ord('L')) and (GetCharAt(0) in [ord(''''),ord('"')]) then begin
      c:=NextChar;
      sc:=c;
      CurrentTokenString:=PUCUUTF32CharToUTF8(sc);
      i:=0;
      repeat
       c:=GetCharAt(i);
       if (c=sc) or (c=0) then begin
        inc(i);
        break;
       end else if c=10 then begin
        break;
       end else if c=ord('\') then begin
        inc(i,2);
       end else begin
        inc(i);
       end;
      until false;
      while i>0 do begin
       CurrentTokenString:=CurrentTokenString+PUCUUTF32CharToUTF8(NextChar);
       dec(i);
      end;
      result:=tSTRINGLONG;
      CurrentToken:=tSTRINGLONG;
     end else if (c in [ord('A')..ord('Z'),ord('a')..ord('z'),ord('_')]) or (c>255) then begin
      result:=tNAME;
      CurrentToken:=result;
      CurrentTokenString:=PUCUUTF32CharToUTF8(c);
      i:=0;
      c:=GetCharAt(i);
      while (c in [ord('A')..ord('Z'),ord('a')..ord('z'),ord('_'),ord('0')..ord('9')]) or (c>255) do begin
       inc(i);
       c:=GetCharAt(i);
      end;
      while i>0 do begin
       CurrentTokenString:=CurrentTokenString+PUCUUTF32CharToUTF8(NextChar);
       dec(i);
      end;
     end else begin
      result:=tCHAR;
      CurrentToken:=tCHAR;
      CurrentTokenChar:=c;
      CurrentTokenString:=PUCUUTF32CharToUTF8(c);
     end;
    end;
   end;
  end;
  procedure SkipGetToken; forward;
  procedure SkipExtGetToken; forward;
  procedure AddError(const s:TPOCAUTF8String); forward;
  procedure SkipBlankEx; forward;
  function Destringize(const s:TPOCARawByteString):TPOCARawByteString;
  var i:TPOCAInt32;
      c,sc,nc:TPOCAUCS4Char;
  begin
   result:='';
   i:=1;
   while i<=length(s) do begin
    sc:=PUCUUTF8CodeUnitGetCharAndIncFallback(s,i);
    case sc of
     ord('\'):begin
      if i<=length(s) then begin
       nc:=PUCUUTF8CodeUnitGetCharAndIncFallback(s,i);
       case nc of
        ord('a'):begin
         result:=result+#7;
        end;
        ord('b'):begin
         result:=result+#8;
        end;
        ord('t'):begin
         result:=result+#9;
        end;
        ord('n'):begin
         result:=result+#10;
        end;
        ord('v'):begin
         result:=result+#11;
        end;
        ord('f'):begin
         result:=result+#12;
        end;
        ord('r'):begin
         result:=result+#13;
        end;
        ord('\'):begin
         result:=result+'\';
        end;
        ord(''''):begin
         result:=result+'''';
        end;
        ord('"'):begin
         result:=result+'"';
        end;
        ord('?'):begin
         result:=result+'?';
        end;
        ord('U'):begin
         if ((i+7)<=length(s)) and
            (s[i+0] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+1] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+2] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+3] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+4] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+5] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+6] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+7] in ['0'..'9','A'..'F','a'..'f']) then begin
          c:=(hex2byte(ord(s[i+0])) shl 28) or (hex2byte(ord(s[i+1])) shl 24) or (hex2byte(ord(s[i+2])) shl 20) or (hex2byte(ord(s[i+3])) shl 16) or (hex2byte(ord(s[i+4])) shl 12) or (hex2byte(ord(s[i+5])) shl 8) or (hex2byte(ord(s[i+6])) shl 4) or (hex2byte(ord(s[i+7])) shl 0);
          inc(i,8);
          result:=result+PUCUUTF32CharToUTF8(c);
         end else begin
          result:=result+'\U';
         end;
        end;
        ord('u'):begin
         if ((i+4)<=length(s)) and
            (s[i+0] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+1] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+2] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+3] in ['0'..'9','A'..'F','a'..'f']) then begin
          c:=(hex2byte(ord(s[i+0])) shl 12) or (hex2byte(ord(s[i+1])) shl 8) or (hex2byte(ord(s[i+2])) shl 4) or (hex2byte(ord(s[i+3])) shl 0);
          inc(i,4);
          result:=result+PUCUUTF32CharToUTF8(c);
         end else begin
          result:=result+'\u';
         end;
        end;
        ord('x'),ord('X'):begin
         if ((i+2)<length(s)) and
            (s[i+0] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+1] in ['0'..'9','A'..'F','a'..'f']) then begin
          c:=(hex2byte(ord(s[i+0])) shl 4) or (hex2byte(ord(s[i+1])) shl 0);
          inc(i,2);
          result:=result+PUCUUTF32CharToUTF8(c);
         end else begin
          result:=result+('\'+PUCUUTF32CharToUTF8(nc));
         end;
        end;
        ord('0')..ord('7'):begin
         c:=nc-ord('0');
         while (i<=length(s)) and (s[i] in ['0'..'7']) do begin
          c:=(c*8)+(ord(s[i])-ord('0'));
          inc(i);
         end;
         result:=result+PUCUUTF32CharToUTF8(c);
        end;
        else begin
         result:=result+PUCUUTF32CharToUTF8(nc);
        end;
       end;
      end;
     end;
     else begin
      result:=result+PUCUUTF32CharToUTF8(sc);
     end;
    end;
   end;
  end;
  function Stringize(const s:TPOCARawByteString;q:boolean):TPOCARawByteString;
  const hexchars:array[0..$f] of ansichar='0123456789ABCDEF';
  var i:TPOCAInt32;
      c:TPOCAUCS4Char;
  begin
  result:='';
   if q then begin
    i:=1;
    while i<=length(s) do begin
     c:=PUCUUTF8CodeUnitGetCharAndIncFallback(s,i);
     case c of
      0:begin
       result:=result+'\0';
      end;
      7:begin
       result:=result+'\a';
      end;
      8:begin
       result:=result+'\b';
      end;
      9:begin
       result:=result+'\t';
      end;
      10:begin
       result:=result+'\n';
      end;
      11:begin
       result:=result+'\v';
      end;
      12:begin
       result:=result+'\f';
      end;
      13:begin
       result:=result+'\r';
      end;
      ord('\'):begin
       result:=result+'\\';
      end;
      ord(''''):begin
       result:=result+'\''';
      end;
      ord('"'):begin
       result:=result+'\"';
      end;
      ord('?'):begin
       result:=result+'\?';
      end;
      else begin
       if c<128 then begin
        result:=result+PUCUUTF32CharToUTF8(c);
       end else if c<=$ffff then begin
        result:=result+'\u'+hexchars[(c shr 12) and $f]+hexchars[(c shr 8) and $f]+hexchars[(c shr 4) and $f]+hexchars[c and $f];
       end else begin
        result:=result+'\U'+hexchars[(c shr 28) and $f]+hexchars[(c shr 24) and $f]+hexchars[(c shr 20) and $f]+hexchars[(c shr 16) and $f]+hexchars[(c shr 12) and $f]+hexchars[(c shr 8) and $f]+hexchars[(c shr 4) and $f]+hexchars[c and $f];
       end;
      end;
     end;
    end;
   end else begin
    result:=s;
   end;
  end;
  procedure ExtGetToken;
  var mi,i,j,k,NestedLevel,pc:TPOCAInt32;
      b:TPOCARawByteString;
      Parameters:array of TPOCARawByteString;
      InputStackItem:TInputStackItem;
  begin
   b:='';
   Parameters:=nil;
   repeat
    if length(InputStack)>0 then begin
     InputStackItem:=InputStack[length(InputStack)-1];
    end else begin
     InputStackItem.Source:=-1;
    end;
    if GetToken<>tNAME then begin
     break;
    end;
    mi:=LookUp(CurrentTokenString);
    if mi<0 then begin
     break;
    end;
    if Macros[mi].MacroFunction<>mfNONE then begin
     case Macros[mi].MacroFunction of
      mfFILE:begin
       if InputStackItem.Source>=0 then begin
        PushInputSource(iskMACRO,Macros[mi].Name,'"'+Stringize(ParserInstance.Preprocessor.InputSources[InputStackItem.Source].Name,true)+'"');
       end else begin
        AddError(Macros[mi].Name+': Unknown file');
        continue;
       end;
      end;
      mfLINE:begin
       if InputStackItem.Source>=0 then begin
        PushInputSource(iskMACRO,Macros[mi].Name,TPOCARawByteString(IntToStr(InputStackItem.BufferLine+1)));
       end else begin
        AddError(Macros[mi].Name+': Unknown line number');
        continue;
       end;
      end;
      mfTIME:begin
       PushInputSource(iskMACRO,Macros[mi].Name,'"'+TPOCAUTF8String(FormatDateTime('hh:nn:ss',Now))+'"');
      end;
      mfDATE:begin
       PushInputSource(iskMACRO,Macros[mi].Name,'"'+TPOCAUTF8String(FormatDateTime('mmm dd yyyy',Now))+'"');
      end;
      mfPRAGMA:begin
       SkipGetToken;
       if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('('))) then begin
        AddError(Macros[mi].Name+': missing (');
        exit;
       end;
       SkipGetToken;
       if CurrentToken<>tSTRING then begin
        AddError(Macros[mi].Name+': string was expected');
        exit;
       end;
       i:=ParserInstance.Preprocessor.PragmaInfoCount;
       inc(ParserInstance.Preprocessor.PragmaInfoCount);
       if (i+1)>length(ParserInstance.Preprocessor.PragmaInfo) then begin
        SetLength(ParserInstance.Preprocessor.PragmaInfo,POCARoundUpToPowerOfTwo(i+2));
       end;
       ParserInstance.Preprocessor.PragmaInfo[i].CharPos:=ParserInstance.Preprocessor.OutputTextLength+1;
       if length(CurrentTokenString)<2 then begin
        AddError(Macros[mi].Name+': string not closed');
        exit;
       end;
       if CurrentTokenString[1]<>CurrentTokenString[length(CurrentTokenString)] then begin
        AddError(Macros[mi].Name+': invalid string');
        exit;
       end;
       ParserInstance.Preprocessor.PragmaInfo[i].Pragma:=Destringize(copy(CurrentTokenString,2,length(CurrentTokenString)-2));
       SkipGetToken;
       if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord(')'))) then begin
        AddError(Macros[mi].Name+': missing )');
        exit;
       end;
      end;
      else begin
       AddError(Macros[mi].Name+': Unknown macro function');
       continue;
      end;
     end;
    end else if (Macros[mi].Parameters=0) and not Macros[mi].VaArgs then begin
     b:='';
     for i:=0 to length(Macros[mi].Body)-1 do begin
      case Macros[mi].Body[i].Kind of
       mbikTEXT:begin
        b:=b+Stringize(Macros[mi].Body[i].Text,Macros[mi].Body[i].Quote);
       end;
      end;
     end;
     inc(MacroLevel);
     PushInputSource(iskMACRO,Macros[mi].Name,b);
     dec(MacroLevel);
    end else if (Macros[mi].Parameters>0) or Macros[mi].VaArgs then begin
     SkipGetToken;
     if (Macros[mi].Parameters>0) and not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('('))) then begin
      AddError(Macros[mi].Name+': missing (');
      exit;
     end else if (Macros[mi].Parameters=0) and Macros[mi].VaArgs and not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('('))) then begin
 {    exit;}
     end;
     SetLength(Parameters,0);
     if (Macros[mi].Parameters>0) or ((Macros[mi].Parameters=0) and ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('(')))) then begin
      SkipGetToken;
      while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,ord(')')])) do begin
       while (CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpaceEx) do begin
        GetToken;
       end;
       SetLength(b,0);
       NestedLevel:=0;
       repeat
        if (CurrentToken=tCHAR) and (CurrentTokenChar=0) then begin
         break;
        end else if (NestedLevel=0) and ((CurrentToken=tCHAR) and (CurrentTokenChar in [ord(','),ord(')')])) then begin
         break;
        end else if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('(')) then begin
         b:=b+'(';
         inc(NestedLevel);
        end else if (CurrentToken=tCHAR) and (CurrentTokenChar=ord(')')) then begin
         b:=b+')';
         dec(NestedLevel);
        end else begin
         b:=b+CurrentTokenString;
        end;
        ExtGetToken;
       until false;
       if (CurrentToken=tCHAR) and (CurrentTokenChar=ord(',')) then begin
        SkipGetToken;
       end;
       pc:=length(Parameters);
       SetLength(Parameters,pc+1);
       Parameters[pc]:=copy(b,0,length(b));
      end;
      if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord(')'))) then begin
       AddError(Macros[mi].Name+': missing )');
       continue;
      end;
     end;
     if (length(Parameters)<Macros[mi].Parameters) or ((length(Parameters)>Macros[mi].Parameters) and not Macros[mi].VaArgs) then begin
      AddError(Macros[mi].Name+': Wrong amount of parameters');
      continue;
     end;
     k:=1;
     b:='';
     for i:=0 to length(Macros[mi].Body)-1 do begin
      if Macros[mi].Body[i].Quote then begin
       b:=b+'"';
      end;
      case Macros[mi].Body[i].Kind of
       mbikTEXT:begin
        if (i>1) and (Macros[mi].Body[i].Kind<>mbikTEXT) then begin
         k:=length(b);
        end;
        b:=b+Stringize(Macros[mi].Body[i].Text,Macros[mi].Body[i].Quote);
       end;
       mbikPARAMETER:begin
        if Macros[mi].Body[i].Value<length(Parameters) then begin
         b:=b+Stringize(Parameters[Macros[mi].Body[i].Value],Macros[mi].Body[i].Quote);
         k:=length(b)+1;
        end;
       end;
       mbikVAARGS:begin
        if length(Parameters)<=Macros[mi].Parameters then begin
         for j:=length(b) downto k+1 do begin
          if (ord(b[j]) in UCS4WhiteSpaceEx) then begin
          end else begin
           case b[j] of
            ',':begin
             b:=copy(b,1,j-1);
             break;
            end;
            else begin
             break;
            end;
           end;
          end;
         end;
        end else begin
         for j:=Macros[mi].Parameters to length(Parameters)-1 do begin
          b:=b+Stringize(Parameters[j],Macros[mi].Body[i].Quote);
          if ((j+1)<length(Parameters)) then begin
           b:=b+',';
          end;
         end;
         k:=length(b)+1;
        end;
       end;
       mbikSPLITTER:begin
        b:=b+#$ef#$bf#$bd; // UCS4AddChar(b,-1);
       end;
      end;
      if Macros[mi].Body[i].Quote then begin
       b:=b+'"';
      end;
     end;
     inc(MacroLevel);
     PushInputSource(iskMACRO,Macros[mi].Name,b);
     dec(MacroLevel);
    end;
   until false;
   SetLength(Parameters,0);
  end;
  procedure SkipGetToken;
  begin
   repeat
    GetToken;
    if (CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpace) then begin
     continue;
    end;
    break;
   until false;
  end;
  procedure SkipEOL;
  var i:TPOCAInt32;
  begin
   i:=0;
   while not (GetCharAt(i) in [0,10]) do begin
    inc(i);
   end;
   while i>0 do begin
    NextChar;
    dec(i);
   end;
  end;
  procedure SkipBlankEx;
  var i:TPOCAInt32;
  begin
   i:=0;
   while GetCharAt(i) in UCS4WhiteSpaceEx do begin
    inc(i);
   end;
   while i>0 do begin
    NextChar;
    dec(i);
   end;
  end;
  procedure SkipBlank;
  var i:TPOCAInt32;
  begin
   i:=0;
   while GetCharAt(i) in UCS4WhiteSpaceEx do begin
    inc(i);
   end;
   while i>0 do begin
    NextChar;
    dec(i);
   end;
  end;
  procedure SkipExtGetToken;
  begin
   repeat
    ExtGetToken;
    if (CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpace) then begin
     continue;
    end;
    break;
   until false;
  end;
  procedure AddError(const s:TPOCAUTF8String);
  begin
   SyntaxError(s,-1,-1,-1);
  end;
  procedure AddWarning(const s:TPOCAUTF8String);
  begin
  end;
  procedure AddToOutput(const s:TPOCARawByteString);
  var l,i:TPOCAInt32;
  begin
   l:=length(s);
   if l>0 then begin
    if (ParserInstance.Preprocessor.OutputInfoCount>0) then begin
     if ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].LastCharPos<>(ParserInstance.Preprocessor.OutputTextLength-1) then begin
      ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].LastCharPos:=(ParserInstance.Preprocessor.OutputTextLength-1);
     end;
     if (ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].Source<>LastSource) or
        (ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].Line<>LastLine) then begin
      i:=ParserInstance.Preprocessor.OutputInfoCount;
      inc(ParserInstance.Preprocessor.OutputInfoCount);
      if (i+1)>length(ParserInstance.Preprocessor.OutputInfo) then begin
       SetLength(ParserInstance.Preprocessor.OutputInfo,POCARoundUpToPowerOfTwo(i+2));
      end;
      ParserInstance.Preprocessor.OutputInfo[i].FirstCharPos:=ParserInstance.Preprocessor.OutputTextLength;
      ParserInstance.Preprocessor.OutputInfo[i].LastCharPos:=ParserInstance.Preprocessor.OutputTextLength;
      ParserInstance.Preprocessor.OutputInfo[i].Source:=LastSource;
      ParserInstance.Preprocessor.OutputInfo[i].Line:=LastLine;
     end;
    end else begin
     i:=ParserInstance.Preprocessor.OutputInfoCount;
     inc(ParserInstance.Preprocessor.OutputInfoCount);
     if (i+1)>length(ParserInstance.Preprocessor.OutputInfo) then begin
      SetLength(ParserInstance.Preprocessor.OutputInfo,POCARoundUpToPowerOfTwo(i+2));
     end;
     ParserInstance.Preprocessor.OutputInfo[i].FirstCharPos:=ParserInstance.Preprocessor.OutputTextLength;
     ParserInstance.Preprocessor.OutputInfo[i].LastCharPos:=ParserInstance.Preprocessor.OutputTextLength;
     ParserInstance.Preprocessor.OutputInfo[i].Source:=LastSource;
     ParserInstance.Preprocessor.OutputInfo[i].Line:=LastLine;
    end;
    begin
     i:=ParserInstance.Preprocessor.OutputTextLength+l;
     if length(ParserInstance.Preprocessor.OutputText)<=i then begin
      SetLength(ParserInstance.Preprocessor.OutputText,POCARoundUpToPowerOfTwo(i+1));
     end;
     Move(s[1],ParserInstance.Preprocessor.OutputText[ParserInstance.Preprocessor.OutputTextLength+1],l);
     ParserInstance.Preprocessor.OutputTextLength:=i;
    end;
   end;
  end;
  function ParseNumber(s:TPOCARawByteString):TPOCAInt32;
  var i:TPOCAInt32;
      sv:TPOCAInt32;
      b:boolean;
  begin
   b:=false;
   while (length(s)>0) and (s[length(s)] in ['l','L','u','U']) do begin
    Delete(s,length(s),1);
   end;
   if (length(s)>0) and (s[1]='0') then begin
    if (length(s)>1) and (s[2] in ['x','X']) then begin
     result:=0;
     for i:=3 to length(s) do begin
      if (not b) and (((result*16) div 16)<>result) then begin
       b:=true;
       AddWarning('TERM: constant too large for destination type');
      end;
      case s[i] of
       '0'..'9':begin
        sv:=ord(s[i])-ord('0');
       end;
       'a'..'f':begin
        sv:=(ord(s[i])-ord('a'))+$a;
       end;
       'A'..'F':begin
        sv:=(ord(s[i])-ord('A'))+$a;
       end;
       else begin
        sv:=0;
       end;
      end;
      result:=(result*16)+sv;
     end;
    end else begin
     result:=0;
     for i:=2 to length(s) do begin
      if (not b) and (((result*8) div 8)<>result) then begin
       b:=true;
       AddWarning('TERM: constant too large for destination type');
      end;
      result:=(result*8)+(ord(s[i])-ord('0'));
     end;
    end;
   end else begin
    result:=0;
    for i:=1 to length(s) do begin
     if (not b) and (((result*10) div 10)<>result) then begin
      b:=true;
      AddWarning('TERM: constant too large for destination type');
     end;
     result:=(result*10)+(ord(s[i])-ord('0'));
    end;
   end;
  end;
  procedure DoINCLUDE(DoIncludeNext,DoIncludeOnce:boolean);
  var cfn,fn,ffn,d,t2:TPOCARawByteString;
      c,m:TPOCAUCS4Char;
      OK:boolean;
      t:TPOCARawByteString;
      f:file;
      fm:TPOCAUInt8;
      i:TPOCAInt32;
  begin
   cfn:='';
   if DoIncludeNext then begin
    AddWarning('#include_next is a GCC extension!');
    if (LastSource>=0) and (LastSource<ParserInstance.Preprocessor.InputSourcesCount) then begin
     cfn:=copy(ParserInstance.Preprocessor.InputSources[LastSource].Name,0,length(ParserInstance.Preprocessor.InputSources[LastSource].Name));
    end;
   end;
   d:='';
   t2:='';
   fn:='';
   ffn:='';
   SkipExtGetToken;
   if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('<')) then begin
    OK:=false;
    repeat
     c:=NextChar;
     if c=ord('>') then begin
      OK:=true;
      break;
     end else if c in [0,10] then begin
      break;
     end else begin
      fn:=fn+PUCUUTF32CharToUTF8(c);
     end;
    until false;
    if not OK then begin
     AddError('#include: missing >');
     exit;
    end;
    m:=ord('<');
   end else if (CurrentToken=tSTRING) and (length(CurrentTokenString)>1) and (CurrentTokenString[1]='"') then begin
    if CurrentTokenString[length(CurrentTokenString)]<>'"' then begin
     AddError('#include: missing "');
     exit;
    end;
    fn:=copy(CurrentTokenString,2,length(CurrentTokenString)-2);
    m:=ord('"');
   end else begin
    AddError('#include: missing filename');
    exit;
   end;
   ffn:='';
   if (m=ord('"')) and (ParserInstance.Preprocessor.InputSourcesCount>0) and fileexists(String(ExtractFilePath(String(ParserInstance.Preprocessor.InputSources[0].Name))+String(fn))) then begin
    ffn:=TPOCAUTF8String(ExtractFilePath(String(ParserInstance.Preprocessor.InputSources[0].Name))+String(fn));
    if ffn=cfn then begin
     ffn:='';
    end;
   end;
   if (length(ffn)=0) or not fileexists(String(ffn)) then begin
    for i:=0 to Instance^.IncludeDirectories.Count-1 do begin
     d:=TPOCAUTF8String(Instance^.IncludeDirectories[i]);
     if fileexists(String(String(d)+String(fn))) then begin
      ffn:=d+fn;
      if ffn=cfn then begin
       ffn:='';
      end else begin
       break;
      end;
     end;
    end;
   end;
   if (length(ffn)=0) or not fileexists(String(ffn)) then begin
    if fileexists(String(fn)) then begin
     ffn:=fn;
     if ffn=cfn then begin
      ffn:='';
     end;
    end;
   end;
   if (length(ffn)=0) or not fileexists(String(ffn)) then begin
    if m=ord('"') then begin
     AddError('#include: File "'+fn+'" not found');
    end else begin
     AddError('#include: File <'+fn+'> not found');
    end;
    exit;
   end;
   fm:=filemode;
   filemode:=0;
   assignfile(f,String(ffn));
   {$i-}reset(f,1);{$i+};
   if ioresult=0 then begin
    SetLength(t,filesize(f));
    if length(t)>0 then begin
     {$i-}blockread(f,t[1],length(t));{$i+}
     t2:=ProprocessInputSourceChars(iskFILE,fn,t);
     if ioresult<>0 then begin
      if m=ord('"') then begin
       AddError('#include: File "'+fn+'" I/O error');
      end else begin
       AddError('#include: File <'+fn+'> I/O error');
      end;
      {$i-}closefile(f);{$i+}
      filemode:=fm;
      exit;
     end;
    end;
    {$i-}closefile(f);{$i+}
   end else begin
    if m=ord('"') then begin
     AddError('#include: File "'+fn+'" I/O error');
    end else begin
     AddError('#include: File <'+fn+'> I/O error');
    end;
   end;
   filemode:=fm;
   if DoIncludeOnce then begin
    for i:=0 to ParserInstance.Preprocessor.InputSourcesCount-1 do begin
     if (ParserInstance.Preprocessor.InputSources[i].Kind=iskFILE) and (ParserInstance.Preprocessor.InputSources[i].Name=fn) then begin
      exit;
     end;
    end;
   end;
   PushInputSource(iskFILE,fn,t2);
  end;
  procedure DoDEFINE;
  var Name:TPOCARawByteString;
      Parameters:array of TPOCARawByteString;
      Body:TMacroBody;
      Quote:boolean;
      i,j,p,b:TPOCAInt32;
      VaArgs:boolean;
  begin
   Name:='';
   SkipGetToken;
   if CurrentToken<>tNAME then begin
    AddWarning('#define: missing macro name');
    SkipEOL;
    exit;
   end;
   VaArgs:=false;
   Name:=CurrentTokenString;
   GetToken;
   Parameters:=nil;
   if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('(')) then begin
    Parameters:=nil;
    repeat
     SkipGetToken;
     if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('.')) and (GetCharAt(0)=ord('.')) and (GetCharAt(1)=ord('.')) then begin
      GetToken;
      GetToken;
      GetToken;
      VaArgs:=true;
      break;
     end;
     if CurrentToken<>tNAME then begin
      break;
     end;
     p:=length(Parameters);
     SetLength(Parameters,p+1);
     Parameters[p]:=copy(CurrentTokenString,0,length(CurrentTokenString));
     GetToken;
     if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord(','))) then begin
      break;
     end;
    until false;
    if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord(')'))) then begin
     AddWarning('#define: bad macro parameter');
     SkipEOL;
     exit;
    end;
    CurrentToken:=tCHAR;
    CurrentTokenChar:=ord(' ');
   end;
   while (CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpace) do begin
    GetToken;
   end;
   Body:=nil;
   Quote:=false;
   while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,10])) do begin
    if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('\')) and (GetCharAt(0) in [0,10]) then begin
     GetToken;
     GetToken;
     b:=length(Body);
     SetLength(Body,b+1);
     Body[b].Kind:=mbikTEXT;
     Body[b].Text:=#10;
     Body[b].Quote:=false;
 {   while (CurrentToken=tCHAR) and (CurrentTokenChar in WhiteSpaceEx) do begin
      GetToken;
     end;}
     continue;
    end else if ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('#'))) or
                ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':'))) then begin
     if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':')) then begin
      NextChar;
     end;
     b:=length(Body);
     SetLength(Body,b+1);
     Body[b].Kind:=mbikSPLITTER;
     Body[b].Quote:=false;
     GetToken;
     if ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('#'))) or
        ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':'))) then begin
      if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':')) then begin
       NextChar;
      end;
      GetToken;
      if length(Body)>0 then begin
       if Body[length(Body)-1].Kind=mbikTEXT then begin
        while (length(Body[length(Body)-1].Text)>0) and (ord(Body[length(Body)-1].Text[length(Body[length(Body)-1].Text)]) in UCS4WhiteSpaceEx) do begin
         Delete(Body[length(Body)-1].Text,length(Body[length(Body)-1].Text),1);
        end;
       end else if length(Body)>1 then begin
        if Body[length(Body)-1].Kind=mbikSPLITTER then begin
         if Body[length(Body)-2].Kind=mbikTEXT then begin
          while (length(Body[length(Body)-2].Text)>0) and (ord(Body[length(Body)-2].Text[length(Body[length(Body)-2].Text)]) in UCS4WhiteSpaceEx) do begin
           Delete(Body[length(Body)-2].Text,length(Body[length(Body)-2].Text),1);
          end;
         end;
        end;
       end;
      end;
     end else begin
      Quote:=true;
     end;
     while (CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpaceEx) do begin
      GetToken;
     end;
     continue;
    end;
    if CurrentToken=tNAME then begin
     if CurrentTokenString='__VA_ARGS__' then begin
      if VaArgs then begin
       b:=length(Body);
       SetLength(Body,b+1);
       Body[b].Kind:=mbikVAARGS;
       Body[b].Quote:=Quote;
      end else begin
       AddWarning('#define: __VA_ARGS__ not allowed here');
       exit;
      end;
     end else begin
      j:=-1;
      for i:=0 to length(Parameters)-1 do begin
       if Parameters[i]=CurrentTokenString then begin
        j:=i;
        break;
       end;
      end;
      if j<0 then begin
       b:=length(Body);
       SetLength(Body,b+1);
       Body[b].Kind:=mbikTEXT;
       Body[b].Text:=CurrentTokenString;
       Body[b].Quote:=Quote;
      end else begin
       b:=length(Body);
       SetLength(Body,b+1);
       Body[b].Kind:=mbikParameter;
       Body[b].Value:=i;
       Body[b].Quote:=Quote;
      end;
     end;
    end else begin
     if CurrentToken=tCHAR then begin
      if not (CurrentTokenChar in [13,10]) then begin
       b:=length(Body);
       SetLength(Body,b+1);
       Body[b].Kind:=mbikTEXT;
       Body[b].Text:=PUCUUTF32CharToUTF8(CurrentTokenChar);
       Body[b].Quote:=Quote;
      end;
     end else begin
      b:=length(Body);
      SetLength(Body,b+1);
      Body[b].Kind:=mbikTEXT;
      Body[b].Text:=CurrentTokenString;
      Body[b].Quote:=Quote;
     end;
    end;
    Quote:=false;
    GetToken;
   end;
   AddDefine(Name,Body,length(Parameters),VaArgs,mfNONE);
  end;
  procedure DoUNDEF;
  begin
   SkipGetToken;
   if CurrentToken<>tNAME then begin
    AddWarning('#undef: missing macro name');
    SkipEOL;
    exit;
   end;
   RemoveDefine(CurrentTokenString);
   SkipEOL;
  end;
  function SearchELSEENDIF(var Keyword:TPOCAInt32):boolean;
  var NestedLevel:TPOCAInt32;
  begin
   Keyword:=kwNONE;
   CurrentToken:=tCHAR;
   CurrentTokenChar:=10;
   NestedLevel:=1;
   repeat
    while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,10])) do begin
     GetToken;
    end;
    SkipGetToken;
    if ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('#'))) or
       ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':'))) then begin
     if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':')) then begin
      NextChar;
     end;
     SkipExtGetToken;
     Keyword:=LookUpKeyword(CurrentTokenString);
     if CurrentToken=tNAME then begin
      if Keyword in [kwIF,kwIFDEF,kwIFNDEF] then begin
       inc(NestedLevel);
      end else if Keyword=kwENDIF then begin
       dec(NestedLevel);
       if NestedLevel=0 then begin
        dec(IFNestedLevel);
        result:=false;
        exit;
       end;
      end else if (NestedLevel=1) and (Keyword in [kwELSE,kwELIF]) then begin
       result:=true;
       exit;
      end;
     end;
    end else if (CurrentToken=tCHAR) and (CurrentTokenCHAR=0) then begin
     AddError('missing #endif');
     result:=true;
     exit;
    end;
   until false;
  end;
  function EvalString(s:TPOCARawByteString):boolean;
  type TEvalToken=(etNONE,etCHAR,etNAME,etNUMBER,etDIV,etMINUS,etPLUS,etLT,
                   etLEQ,etLSH,etGT,etGEQ,etRSH,etEQ,etNOT,etNEQ,etAND,etLAND,
                   etOR,etLOR,etMOD,etMUL,etXOR,etLNOT,etLPAR,etRPAR,etCOMMA,
                   etQUEST,etCOLON,etUMINUS,etUPLUS,etASSIGN);
       TEvalTokenItem=record
        Token:TEvalToken;
        s:TPOCARawByteString;
       end;
       TEvalTokenFIFO=record
        Tokens:array of TEvalTokenItem;
        Index:TPOCAInt32;
       end;
       TValue=record
        case Sign:boolean of
         false:(us:TPOCAUInt32);
         true:(s:TPOCAInt32);
       end;
       TEvalTokenPrecLUT=array[TEvalToken] of TPOCAInt32;
  const TokenUnary=[etLNOT,etNOT,etUPLUS,etUMINUS];
        TokenBinary=[etMUL,etDIV,etMOD,etPLUS,etMINUS,etLSH,etRSH,etLT,etLEQ,etGT,
               etGEQ,etEQ,etNEQ,etAND,etXOR,etOR,etLAND,etLOR,etCOMMA];
        WrongToken=TokenUnary+TokenBinary+[etQUEST,etCOLON];
        OpPrecLUT:TEvalTokenPrecLUT=(666, // etNONE
                                     666, // etCHAR
                                     666, // etNAME
                                     666, // etNUMBER
                                     12,  // etDIV
                                     11,  // etMINUS
                                     11,  // etPLUS
                                     9,   // etLT
                                     9,   // etLEQ
                                     10,  // etLSH
                                     9,   // etGT
                                     9,   // etGEQ
                                     10,  // etRSH
                                     8,   // etEQ
                                     13,  // etNOT
                                     8,   // etNEQ
                                     7,   // etAND,
                                     4,   // etLAND
                                     5,   // etOR
                                     3,   // etLOR
                                     12,  // etMOD
                                     12,  // etMUL
                                     6,   // etXOR
                                     13,  // etLNOT
                                     666, // etLPAR
                                     666, // etRPAR
                                     1,   // etCOMMA
                                     2,   // etQUEST
                                     666, // etCOLON
                                     13,  // etUMINUS
                                     13,  // etUPLUS
                                     666  // etASSIGN
                                    );
  var FIFO:TEvalTokenFIFO;
   procedure AddToken(Token:TEvalToken;const s:TPOCARawByteString);
   var i:TPOCAInt32;
   begin
    i:=length(FIFO.Tokens);
    SetLength(FIFO.Tokens,i+1);
    FIFO.Tokens[i].Token:=Token;
    FIFO.Tokens[i].s:=s;
   end;
   procedure Tokenize(s:TPOCARawByteString);
   var i:TPOCAInt32;
       c:TPOCAUCS4Char;
       ns:TPOCARawByteString;
   begin
    i:=1;
    while i<=length(s) do begin
     c:=PUCUUTF8CodeUnitGetCharAndIncFallback(s,i);
     case c of
      ord('/'):begin
       AddToken(etDIV,'/');
      end;
      ord('-'):begin
       AddToken(etMINUS,'-');
      end;
      ord('+'):begin
       AddToken(etPLUS,'+');
      end;
      ord('<'):begin
       if (i<=length(s)) and (s[i]='=') then begin
        AddToken(etLEQ,'<=');
        inc(i);
       end else if (i<=length(s)) and (s[i]='<') then begin
        AddToken(etLSH,'<<');
        inc(i);
       end else begin
        AddToken(etLT,'<');
       end;
      end;
      ord('>'):begin
       if (i<=length(s)) and (s[i]='=') then begin
        AddToken(etGEQ,'>=');
        inc(i);
       end else if (i<=length(s)) and (s[i]='>') then begin
        AddToken(etRSH,'>>');
        inc(i);
       end else begin
        AddToken(etGT,'>');
       end;
      end;
      ord('='):begin
       if (i<=length(s)) and (s[i]='=') then begin
        AddToken(etEQ,'==');
        inc(i);
       end else begin
        AddToken(etASSIGN,'=');
       end;
      end;
      ord('~'):begin
       AddToken(etNOT,'~');
      end;
      ord('!'):begin
       if (i<=length(s)) and (s[i]='=') then begin
        AddToken(etNEQ,'!=');
        inc(i);
       end else begin
        AddToken(etLNOT,'!');
       end;
      end;
      ord('&'):begin
       if (i<=length(s)) and (s[i]='&') then begin
        AddToken(etLAND,'&&');
        inc(i);
       end else begin
        AddToken(etAND,'&');
       end;
      end;
      ord('|'):begin
       if (i<=length(s)) and (s[i]='|') then begin
        AddToken(etLOR,'||');
        inc(i);
       end else begin
        AddToken(etOR,'|');
       end;
      end;
      ord('%'):begin
       AddToken(etMOD,'%');
      end;
      ord('*'):begin
       AddToken(etMUL,'*');
      end;
      ord('^'):begin
       AddToken(etXOR,'^');
      end;
      ord('('):begin
       AddToken(etLPAR,'(');
      end;
      ord(')'):begin
       AddToken(etRPAR,')');
      end;
      ord(','):begin
       AddToken(etCOMMA,',');
      end;
      ord('?'):begin
       AddToken(etQUEST,'?');
      end;
      ord(':'):begin
       AddToken(etCOLON,':');
      end;
      ord('0')..ord('9'):begin
       ns:=PUCUUTF32CharToUTF8(c);
       while (i<=length(s)) and (s[i] in ['0'..'9','a'..'z','A'..'Z']) do begin
        ns:=ns+TPOCARawByteString(s[i]);
        inc(i);
       end;
       AddToken(etNUMBER,ns);
      end;
      else begin
       AddToken(etCHAR,PUCUUTF32CharToUTF8(c));
      end;
     end;
    end;
   end;
   procedure PreprocessTokens;
   var i:TPOCAInt32;
   begin
    i:=0;
    while i<length(FIFO.Tokens) do begin
     if FIFO.Tokens[i].Token=etPLUS then begin
      if (i>0) and not (FIFO.Tokens[i-1].Token in [etNUMBER,etNAME,etCHAR,etRPAR]) then begin
       FIFO.Tokens[i].Token:=etUPLUS;
      end;
     end else if FIFO.Tokens[i].Token=etMINUS then begin
      if (i>0) and not (FIFO.Tokens[i-1].Token in [etNUMBER,etNAME,etCHAR,etRPAR]) then begin
       FIFO.Tokens[i].Token:=etUMINUS;
      end;
     end;
     inc(i);
    end;
   end;
   function OpPrec(Token:TEvalToken):TPOCAInt32;
   begin
    result:=OpPrecLUT[Token];
 {  case Token of
     etLNOT,etNOT,etUPLUS,etUMINUS:begin
      result:=13;
     end;
     etMUL,etDIV,etMOD:begin
      result:=12;
     end;
     etPLUS,etMINUS:begin
      result:=11;
     end;
     etLSH,etRSH:begin
      result:=10;
     end;
     etLT,etLEQ,etGT,etGEQ:begin
      result:=9;
     end;
     etEQ,etLNEQ:begin
      result:=8;
     end;
     etAND:begin
      result:=7;
     end;
     etXOR:begin
      result:=6;
     end;
     etOR:begin
      result:=5;
     end;
     etLAND:begin
      result:=4;
     end;
     etLOR:begin
      result:=3;
     end;
     etQUEST:begin
      result:=2;
     end;
     etCOMMA:begin
      result:=1;
     end;
     else begin
      result:=666;
     end;
    end;}
   end;
   function BoolVal(v:TValue):boolean;
   begin
    if v.Sign then begin
     result:=v.s<>0;
    end else begin
     result:=v.us<>0;
    end;
   end;
   function ParseNumber(s:TPOCARawByteString):TValue;
   var i:TPOCAInt32;
       sv:TPOCAInt32;
       usv:TPOCAUInt32;
       b:boolean;
   begin
    b:=false;
    fillchar(result,sizeof(TValue),#0);
    result.Sign:=true;
    while (length(s)>0) and (s[length(s)] in ['l','L','u','U']) do begin
     if (length(s)>0) and (s[length(s)] in ['u','U']) then begin
      result.Sign:=false;
     end;
     Delete(s,length(s),1);
    end;
    if result.Sign then begin
     if (length(s)>0) and (s[1]='0') then begin
      if (length(s)>1) and (s[2] in ['x','X']) then begin
       result.s:=0;
       for i:=3 to length(s) do begin
        if (not b) and (((result.s*16) div 16)<>result.s) then begin
         b:=true;
         AddWarning('TERM: constant too large for destination type');
        end;
        case s[i] of
         '0'..'9':begin
          sv:=ord(s[i])-ord('0');
         end;
         'a'..'f':begin
          sv:=(ord(s[i])-ord('a'))+$a;
         end;
         'A'..'F':begin
          sv:=(ord(s[i])-ord('A'))+$a;
         end;
         else begin
          sv:=0;
         end;
        end;
        result.s:=(result.s*16)+sv;
       end;
      end else begin
       result.s:=0;
       for i:=2 to length(s) do begin
        if (not b) and (((result.s*8) div 8)<>result.s) then begin
         b:=true;
         AddWarning('TERM: constant too large for destination type');
        end;
        result.s:=(result.s*8)+(ord(s[i])-ord('0'));
       end;
      end;
     end else begin
      result.s:=0;
      for i:=1 to length(s) do begin
       if (not b) and (((result.s*10) div 10)<>result.s) then begin
        b:=true;
        AddWarning('TERM: constant too large for destination type');
       end;
       result.s:=(result.s*10)+(ord(s[i])-ord('0'));
      end;
     end;
    end else begin
     if (length(s)>0) and (s[1]='0') then begin
      if (length(s)>1) and (s[2] in ['x','X']) then begin
       result.us:=0;
       for i:=3 to length(s) do begin
        if (not b) and (((result.us*16) div 16)<>result.us) then begin
         b:=true;
         AddWarning('TERM: constant too large for destination type');
        end;
        case s[i] of
         '0'..'9':begin
          usv:=ord(s[i])-ord('0');
         end;
         'a'..'f':begin
          usv:=(ord(s[i])-ord('a'))+$a;
         end;
         'A'..'F':begin
          usv:=(ord(s[i])-ord('A'))+$a;
         end;
         else begin
          usv:=0;
         end;
        end;
        result.us:=(result.us*16)+usv;
       end;
      end else begin
       result.us:=0;
       for i:=2 to length(s) do begin
        if (not b) and (((result.us*8) div 8)<>result.us) then begin
         b:=true;
         AddWarning('TERM: constant too large for destination type');
        end;
        result.us:=(result.us*8)+TPOCAUInt32(ord(s[i])-ord('0'));
       end;
      end;
     end else begin
      result.us:=0;
      for i:=1 to length(s) do begin
       if (not b) and (((result.us*10) div 10)<>result.us) then begin
        b:=true;
        AddWarning('TERM: constant too large for destination type');
       end;
       result.us:=(result.us*10)+TPOCAUInt32(ord(s[i])-ord('0'));
      end;
     end;
    end;
   end;
   function DoTokenUnary(Token:TEvalToken;v:TValue):TValue;
   begin
    case Token of
     etLNOT:begin
      result.sign:=true;
      result.s:=ord(v.s=0);
     end;
     etNOT:begin
      result.sign:=v.sign;
      if result.sign then begin
       result.s:=not v.s;
      end else begin
       result.us:=not v.us;
      end;
     end;
     etPLUS:begin
      result:=v;
     end;
     etMINUS:begin
      result.sign:=v.sign;
      if result.sign then begin
       result.s:=-v.s;
      end else begin
       result.us:=-v.us;
      end;
     end;
     else begin
      result:=v;
     end;
    end;
   end;
   {$hints off}
   function DoTokenBinary(Token:TEvalToken;v1,v2:TValue):TValue;
   var iv2:TPOCAInt32;
   begin
    fillchar(result,sizeof(TValue),#0);
    iv2:=0;
    case Token of
     etMUL,etDIV,etMOD,etPLUS,etMINUS,etAND,etXOR,etOR:begin
      if (not v1.Sign) or (not v2.Sign) then begin
       if v1.Sign then begin
        v1.Sign:=false;
        v1.us:=v1.s;
       end else if v2.Sign then begin
        v2.Sign:=false;
        v2.us:=v2.s;
       end;
       result.Sign:=false;
      end else begin
       result.Sign:=true;
      end;
     end;
     etLT,etLEQ,etGT,etGEQ,etEQ,etNEQ:begin
      if (not v1.Sign) or (not v2.Sign) then begin
       if v1.Sign then begin
        v1.Sign:=false;
        v1.us:=v1.s;
       end else if v2.Sign then begin
        v2.Sign:=false;
        v2.us:=v2.s;
       end
      end;
      result.Sign:=true;
     end;
     etLAND,etLOR:begin
      result.Sign:=true;
     end;
     etLSH,etRSH:begin
      result.Sign:=v1.Sign;
      if v2.Sign then begin
       iv2:=v2.s;
      end else begin
       iv2:=v2.us;
      end;
     end;
     etCOMMA:begin
      result.Sign:=v2.Sign;
     end;
    end;
    case Token of
     etMUL:begin
      if result.Sign then begin
       result.s:=v1.s*v2.s;
      end else begin
       result.us:=v1.us*v2.us;
      end;
     end;
     etDIV:begin
      if result.Sign then begin
       if v2.s=0 then begin
        AddError('TERM: divide by zero');
        result.s:=0;
       end else begin
        result.s:=v1.s div v2.s;
       end;
      end else begin
       if v2.s=0 then begin
        AddError('TERM: divide by zero');
        result.us:=0;
       end else begin
        result.us:=v1.us div v2.us;
       end;
      end;
     end;
     etMOD:begin
      if result.Sign then begin
       if v2.s=0 then begin
        AddError('TERM: divide by zero');
        result.s:=0;
       end else begin
        result.s:=v1.s mod v2.s;
       end;
      end else begin
       if v2.s=0 then begin
        AddError('TERM: divide by zero');
        result.us:=0;
       end else begin
        result.us:=v1.us mod v2.us;
       end;
      end;
     end;
     etPLUS:begin
      if result.Sign then begin
       result.s:=v1.s+v2.s;
      end else begin
       result.us:=v1.us+v2.us;
      end;
     end;
     etMINUS:begin
      if result.Sign then begin
       result.s:=v1.s-v2.s;
      end else begin
       result.us:=v1.us-v2.us;
      end;
     end;
     etLSH:begin
      if result.Sign then begin
       result.s:=v1.s*(1 shl iv2);
      end else begin
       result.us:=v1.us shl iv2;
      end;
     end;
     etRSH:begin
      if result.Sign then begin
       result.s:=v1.s div (1 shl iv2);
      end else begin
       result.us:=v1.us shr iv2;
      end;
     end;
     etLT:begin
      if v1.Sign then begin
       if v1.s<v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us<v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etLEQ:begin
      if v1.Sign then begin
       if v1.s<=v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us<=v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etGT:begin
      if v1.Sign then begin
       if v1.s>v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us>v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etGEQ:begin
      if v1.Sign then begin
       if v1.s>=v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us>=v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etEQ:begin
      if v1.Sign then begin
       if v1.s=v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us=v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etNEQ:begin
      if v1.Sign then begin
       if v1.s<>v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us<>v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etAND:begin
      if result.Sign then begin
       result.s:=v1.s and v2.s;
      end else begin
       result.us:=v1.us and v2.us;
      end;
     end;
     etXOR:begin
      if result.Sign then begin
       result.s:=v1.s xor v2.s;
      end else begin
       result.us:=v1.us xor v2.us;
      end;
     end;
     etOR:begin
      if result.Sign then begin
       result.s:=v1.s or v2.s;
      end else begin
       result.us:=v1.us or v2.us;
      end;
     end;
     etLAND:begin
      if v1.Sign then begin
       if (v1.s<>0) and (v2.s<>0) then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if (v1.us<>0) and (v2.us<>0) then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etLOR:begin
      if v1.Sign then begin
       if (v1.s<>0) or (v2.s<>0) then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if (v1.us<>0) or (v2.us<>0) then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etCOMMA:begin
      result:=v2;
     end;
    end;
   end;
   function DoLevel(MinPrec:TPOCAInt32;DoEval:boolean):TValue;
   var at:TEvalTokenItem;
       bp:TPOCAInt32;
       r1,r2,tr:TValue;
       qb:boolean;
   begin
    fillchar(result,sizeof(TValue),#0);
    result.Sign:=true;
    if FIFO.Index>=length(FIFO.Tokens) then begin
     AddError('TERM: truncated constant integral expression');
     exit;
    end;
    at:=FIFO.Tokens[FIFO.Index];
    inc(FIFO.Index);
    case at.Token of
     etLPAR:begin
      result:=DoLevel(0,DoEval);
      if FIFO.Index>=length(FIFO.Tokens) then begin
       AddError('TERM: truncated constant integral expression');
       exit;
      end;
      at:=FIFO.Tokens[FIFO.Index];
      inc(FIFO.Index);
      if at.Token<>etRPAR then begin
       AddError('TERM: a right parenthesis was expected');
       exit;
      end;
     end;
     etNUMBER:begin
      result:=ParseNumber(at.s);
     end;
     else begin
      if at.Token in TokenUnary then begin
       result:=DoTokenUnary(at.Token,DoLevel(OpPrec(at.Token),DoEval));
      end else if at.Token in WrongToken then begin
       AddError('TERM: rogue operator '''+at.s+''' in constant integral');
       exit;
      end else begin
       AddError('TERM: invalid token in constant integral expression');
       exit;
      end;
     end;
    end;
    repeat
     if FIFO.Index>=length(FIFO.Tokens) then begin
      exit;
     end;
     at:=FIFO.Tokens[FIFO.Index];
     inc(FIFO.Index);
     if at.Token in TokenBinary then begin
      bp:=OpPrec(at.Token);
      if bp>MinPrec then begin
       if ((at.Token=etLOR) and BoolVal(result)) or ((at.Token=etLAND) and not BoolVal(result)) then begin
        tr:=DoLevel(bp,false);
        if DoEval then begin
         result.Sign:=true;
         case at.Token of
          etLOR:result.s:=1;
          etLAND:result.s:=0;
         end;
        end;
       end else begin
        tr:=DoLevel(bp,DoEval);
        result:=DoTokenBinary(at.Token,result,tr);
       end;
       continue;
      end;
     end else if at.Token=etQUEST then begin
      bp:=OpPrec(etQUEST);
      if bp>=MinPrec then begin
       qb:=BoolVal(result);
       r1:=DoLevel(bp,DoEval and qb);
       if FIFO.Index>=length(FIFO.Tokens) then begin
        AddError('TERM: truncated constant integral expression');
        exit;
       end;
       at:=FIFO.Tokens[FIFO.Index];
       inc(FIFO.Index);
       if at.Token<>etCOLON then begin
        AddError('TERM: a colon was expected');
        exit;
       end;
       r2:=DoLevel(bp,DoEval and not qb);
       if DoEval then begin
        if qb then begin
         result:=r1;
        end else begin
         result:=r2;
        end;
       end;
       continue;
      end;
     end;
     dec(FIFO.Index);
     break;
    until false;
   end;
  var v:TValue;
  begin
   fillchar(FIFO,sizeof(TEvalTokenFIFO),#0);
   Tokenize(s);
   PreprocessTokens;
   v:=DoLevel(0,true);
   result:=v.us<>0;
   SetLength(FIFO.Tokens,0);
  end;
  function Eval:boolean;
  var s,mn:TPOCARawByteString;
      i,j,l:TPOCAInt32;
      OldInEval:boolean;
  begin
   s:='';
   mn:='';
   OldInEval:=InEval;
   InEval:=true;
   result:=false;
   l:=length(InputStack);
   while (length(InputStack)>l) or not (GetCharAt(0) in [0,10]) do begin
    ExtGetToken;
    if CurrentToken=tNAME then begin
     if CurrentTokenString='defined' then begin
      SkipGetToken;
      if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('(')) then begin
       SkipGetToken;
       if CurrentToken<>tNAME then begin
        AddError('TERM: missing macro name');
        SkipEOL;
        exit;
       end;
       mn:=copy(CurrentTokenString,0,length(CurrentTokenString));
       SkipExtGetToken;
       if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord(')'))) then begin
        AddError('TERM: missing )');
        SkipEOL;
        exit;
       end;
      end else begin
       if CurrentToken<>tNAME then begin
        AddError('TERM: missing macro name');
        SkipEOL;
        exit;
       end;
       mn:=copy(CurrentTokenString,0,length(CurrentTokenString));
      end;
      if LookUp(mn)>=0 then begin
       s:=s+'1L';
      end else begin
       s:=s+'0L';
      end;
     end else begin
      s:=s+'0';
     end;
    end else if CurrentToken in [tSTRING,tSTRINGLONG] then begin
     j:=0;
     for i:=length(CurrentTokenString) downto 1 do begin
      j:=(j*256)+ord(CurrentTokenString[1]);
     end;
     s:=s+TPOCARawByteString(IntToStr(j));
     if CurrentToken=tSTRINGLONG then begin
      s:=s+'L';
     end;
    end else if CurrentToken=tNUMBER then begin
     s:=s+CurrentTokenString;
    end else begin
     if not ((CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpaceEx)) then begin
      s:=s+CurrentTokenString;
     end;
    end;
   end;
   result:=EvalString(s);
   InEval:=OldInEval;
  end;
  procedure DoIF;
  var Keyword:TPOCAInt32;
  begin
   inc(IFNestedLevel);
   if not Eval then begin
    repeat
     Keyword:=kwNONE;
     SearchELSEENDIF(Keyword);
     if not ((CurrentToken=tNAME) and (Keyword=kwELIF)) then begin
      SkipEOL;
      exit;
     end;
    until Eval;
   end;
  end;
  procedure DoIFDEF(ShouldResultValue:boolean);
  var Keyword:TPOCAInt32;
  begin
   SkipGetToken;
   if CurrentToken<>tNAME then begin
    if ShouldResultValue then begin
     AddWarning('#ifdef: missing identifier');
    end else begin
     AddWarning('#ifndef: missing identifier');
    end;
    SkipEOL;
    exit;
   end;
   inc(IFNestedLevel);
   if (LookUp(CurrentTokenString)>=0)<>ShouldResultValue then begin
    repeat
     Keyword:=kwNONE;
     SearchELSEENDIF(Keyword);
     if not ((CurrentToken=tNAME) and (Keyword=kwELIF)) then begin
      SkipEOL;
      exit;
     end;
    until Eval;
   end;
  end;
  procedure DoELSEELIF;
  var Keyword:TPOCAInt32;
  begin
   if IFNestedLevel=0 then begin
    AddError('missing #if');
   end else begin
    Keyword:=kwNONE;
    while SearchELSEENDIF(Keyword) do begin
     Keyword:=kwNONE;
    end;
   end;
   SkipEOL;
  end;
  procedure DoENDIF;
  begin
   if IFNestedLevel=0 then begin
    AddError('missing #if');
   end else begin
    dec(IFNestedLevel);
   end;
   SkipEOL;
  end;
  procedure DoLINE;
  var l,s:TPOCAInt32;
  begin
   SkipExtGetToken;
   if CurrentToken<>tNUMBER then begin
    AddWarning('#line: missing number');
    SkipEOL;
    exit;
   end;
 //l:=LastLine;
   s:=LastSource;
   l:=ParseNumber(CurrentTokenString);
   SkipExtGetToken;
   if (CurrentToken=tCHAR) and (CurrentTokenChar in [0,10]) then begin
    LastLine:=l;
    if length(InputStack)>0 then begin
     InputStack[length(InputStack)-1].BufferLine:=LastLine-1;
    end;
    PushInputSource(iskNONE,'',#10);
    exit;
   end else if CurrentToken=tSTRING then begin
    if length(CurrentTokenString)<2 then begin
     AddError('#line: string not closed');
     exit;
    end;
    if CurrentTokenString[1]<>CurrentTokenString[length(CurrentTokenString)] then begin
     AddError('#line: invalid string');
     exit;
    end;
    s:=GetInputSourceIndex(iskFILE,Destringize(copy(CurrentTokenString,2,length(CurrentTokenString)-2)));
   end else if CurrentToken=tNAME then begin
    s:=GetInputSourceIndex(iskFILE,CurrentTokenString);
   end;
   while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,10])) do begin
    GetToken;
   end;
   if length(InputStack)>0 then begin
    LastSource:=s;
    LastLine:=l;
    InputStack[length(InputStack)-1].BufferLine:=LastLine-1;
    InputStack[length(InputStack)-1].Source:=LastSource;
   end;
   PushInputSource(iskNONE,'',#10);
  end;
  procedure DoPRAGMA;
  var s:TPOCARawByteString;
      i:TPOCAInt32;
  begin
   s:='';
   repeat
    i:=NextChar;
    if (CurrentTokenChar<0) or (i in [0,10]) then begin
     break;
    end;
    s:=s+PUCUUTF32CharToUTF8(i);
   until false;
   i:=ParserInstance.Preprocessor.PragmaInfoCount;
   inc(ParserInstance.Preprocessor.PragmaInfoCount);
   if (i+1)>length(ParserInstance.Preprocessor.PragmaInfo) then begin
    SetLength(ParserInstance.Preprocessor.PragmaInfo,POCARoundUpToPowerOfTwo(i+2));
   end;
   ParserInstance.Preprocessor.PragmaInfo[i].CharPos:=ParserInstance.Preprocessor.OutputTextLength+1;
   ParserInstance.Preprocessor.PragmaInfo[i].Pragma:=s;
  end;
  procedure DoERROR;
  var s:TPOCARawByteString;
  begin
   s:='';
   CurrentTokenString:='';
   SkipBlank;
   while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,10])) do begin
    s:=s+CurrentTokenString;
    GetToken;
   end;
   AddError(s);
  end;
  procedure DoWARNING;
  var s:TPOCARawByteString;
  begin
   s:='';
   CurrentTokenString:='';
   SkipBlank;
   while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,10])) do begin
    s:=s+CurrentTokenString;
    GetToken;
   end;
   AddError(s);
  end;
 var NewLine:boolean;
     MacroBody:TMacroBody;
 begin
  MacroStringTree:=TPOCAStringTree.Create;
  try
   MacroStringTree.Hashing:=true;
   KeywordStringTree:=TPOCAStringTree.Create;
   try
    InputStack:=nil;
    Macros:=nil;
    MacroBody:=nil;
    try
     KeywordStringTree.Hashing:=true;
     KeywordStringTree.Add('include',kwINCLUDE);
     KeywordStringTree.Add('include_next',kwINCLUDENEXT);
     KeywordStringTree.Add('include_once',kwINCLUDEONCE);
     KeywordStringTree.Add('includeonce',kwINCLUDEONCE);
     KeywordStringTree.Add('import',kwINCLUDEONCE);
     KeywordStringTree.Add('include_next_once',kwINCLUDENEXTONCE);
     KeywordStringTree.Add('import_next',kwINCLUDENEXTONCE);
     KeywordStringTree.Add('define',kwDEFINE);
     KeywordStringTree.Add('undef',kwUNDEF);
     KeywordStringTree.Add('if',kwIF);
     KeywordStringTree.Add('ifdef',kwIFDEF);
     KeywordStringTree.Add('ifndef',kwIFNDEF);
     KeywordStringTree.Add('elif',kwELIF);
     KeywordStringTree.Add('else',kwELSE);
     KeywordStringTree.Add('endif',kwENDIF);
     KeywordStringTree.Add('line',kwLINE);
     KeywordStringTree.Add('pragma',kwPRAGMA);
     KeywordStringTree.Add('error',kwERROR);
     KeywordStringTree.Add('warning',kwWARNING);
     LastSource:=-1;
     LastLine:=-1;
     InEval:=false;
     SetLength(MacroBody,0);
     AddDefine('__FILE__',MacroBody,0,false,mfFILE);
     AddDefine('__LINE__',MacroBody,0,false,mfLINE);
     AddDefine('__TIME__',MacroBody,0,false,mfTIME);
     AddDefine('__DATE__',MacroBody,0,false,mfDATE);
     AddDefine('_Pragma',MacroBody,0,false,mfPRAGMA);
     SetLength(MacroBody,1);
     MacroBody[0].Kind:=mbikTEXT;
     MacroBody[0].Text:='1';
     MacroBody[0].Quote:=false;
     AddDefine('__POCA__',MacroBody,0,false,mfNONE);
     SetLength(MacroBody,1);
     MacroBody[0].Kind:=mbikTEXT;
     MacroBody[0].Text:='"'+POCAVersion+'"';
     MacroBody[0].Quote:=false;
     AddDefine('__POCA_VERSION__',MacroBody,0,false,mfNONE);
     SetLength(MacroBody,0);
     SetLength(ParserInstance.Preprocessor.InputSources,16);
     SetLength(ParserInstance.Preprocessor.PragmaInfo,16);
     SetLength(ParserInstance.Preprocessor.OutputInfo,16);
     SetLength(ParserInstance.Preprocessor.OutputText,4096);
     ParserInstance.Preprocessor.InputSourcesCount:=0;
     ParserInstance.Preprocessor.PragmaInfoCount:=0;
     ParserInstance.Preprocessor.OutputInfoCount:=0;
     ParserInstance.Preprocessor.OutputTextLength:=0;
     PushInputSource(ParserInstance.Preprocessor.InputKind,ParserInstance.Preprocessor.InputName,ProprocessInputSourceChars(ParserInstance.Preprocessor.InputKind,ParserInstance.Preprocessor.InputName,ParserInstance.Preprocessor.InputText));
     NewLine:=true;
     IFNestedLevel:=0;
     MacroLevel:=0;
     while length(InputStack)>0 do begin
      ExtGetToken;
      if (((CurrentToken=tCHAR) and (CurrentTokenChar=ord('#'))) or
          ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':')))) and NewLine then begin
       if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':')) then begin
        NextChar;
       end;
       SkipGetToken;
       if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('!')) then begin
        NextChar;
        SkipEOL;
       end else begin
        case LookUpKeyword(CurrentTokenString) of
         kwINCLUDE:begin
          DoINCLUDE(false,false);
         end;
         kwINCLUDENEXT:begin
          DoINCLUDE(true,false);
         end;
         kwINCLUDEONCE:begin
          DoINCLUDE(false,true);
         end;
         kwINCLUDENEXTONCE:begin
          DoINCLUDE(true,true);
         end;
         kwDEFINE:begin
          DoDEFINE;
         end;
         kwUNDEF:begin
          DoUNDEF;
         end;
         kwIF:begin
          DoIF;
         end;
         kwIFDEF:begin
          DoIFDEF(true);
         end;
         kwIFNDEF:begin
          DoIFDEF(false);
         end;
         kwELIF:begin
          DoELSEELIF;
         end;
         kwELSE:begin
          DoELSEELIF;
         end;
         kwENDIF:begin
          DoENDIF;
         end;
         kwLINE:begin
          DoLINE;
         end;
         kwPRAGMA:begin
          DoPRAGMA;
         end;
         kwERROR:begin
          DoERROR;
         end;
         kwWARNING:begin
          DoWARNING;
         end;
         else begin
          AddWarning('undefined statement: '+CurrentTokenString);
          SkipEOL;
         end;
        end;
       end;
      end else begin
       if CurrentToken=tSTRINGLONG then begin
        AddToOutput('L');
        AddToOutput(CurrentTokenString);
        NewLine:=false;
       end else if CurrentToken=tCHAR then begin
        if CurrentTokenChar in [0..255] then begin
         case CurrentTokenChar of
          0:begin
           AddToOutput(CurrentTokenString);
          end;
          10:begin
           NewLine:=true;
          end;
          9,11,12,13,32:begin
          end;
          else begin
           NewLine:=false;
          end;
         end;
        end else if CurrentTokenChar<0 then begin
         continue;
        end;
       end else begin
        NewLine:=false;
       end;
       AddToOutput(CurrentTokenString);
      end;
     end;
     if (ParserInstance.Preprocessor.OutputInfoCount>0) then begin
      if ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].LastCharPos<>(ParserInstance.Preprocessor.OutputTextLength-1) then begin
       ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].LastCharPos:=(ParserInstance.Preprocessor.OutputTextLength-1);
      end;
     end;
     SetLength(ParserInstance.Preprocessor.InputSources,ParserInstance.Preprocessor.InputSourcesCount);
     SetLength(ParserInstance.Preprocessor.PragmaInfo,ParserInstance.Preprocessor.PragmaInfoCount);
     SetLength(ParserInstance.Preprocessor.OutputInfo,ParserInstance.Preprocessor.OutputInfoCount);
     SetLength(ParserInstance.Preprocessor.OutputText,ParserInstance.Preprocessor.OutputTextLength);
    finally
     SetLength(InputStack,0);
     SetLength(Macros,0);
     SetLength(MacroBody,0);
    end;
   finally
    KeywordStringTree.Destroy;
   end;
  finally
   MacroStringTree.Destroy;
  end;
 end;
 procedure Dump(Token:PPOCAToken);
  procedure DumpIt(const s:TPOCARawByteString);
  begin
   write(s);
  end;
 begin
  while assigned(Token) do begin
   case Token^.Token of
    ptNONE:begin
    end;
    ptTOP:begin
    end;
    ptAND:begin
     DumpIt(' && ');
    end;
    ptOR:begin
     DumpIt(' || ');
    end;
    ptNOT:begin
     DumpIt(' ! ');
    end;
    ptLPAR:begin
     DumpIt(' ( ');
    end;
    ptRPAR:begin
     DumpIt(' ) ');
    end;
    ptLBRA:begin
     DumpIt(' [ ');
    end;
    ptRBRA:begin
     DumpIt(' ] ');
    end;
    ptLCURL:begin
     DumpIt(' { ');
    end;
    ptRCURL:begin
     DumpIt(' } ');
    end;
    ptMUL:begin
     DumpIt(' * ');
    end;
    ptPLUS:begin
     DumpIt(' + ');
    end;
    ptMINUS:begin
     DumpIt(' - ');
    end;
    ptNEG:begin
     DumpIt(' -');
    end;
    ptDIV:begin
     DumpIt(' / ');
    end;
    ptNUM:begin
     DumpIt(' +');
    end;
    ptCOLON:begin
     DumpIt(' : ');
    end;
    ptDOT:begin
     DumpIt(' . ');
    end;
    ptCOMMA:begin
     DumpIt(' , ');
    end;
    ptSEMI:begin
     DumpIt(' ;'#13#10);
    end;
    ptASSIGN:begin
     DumpIt(' = ');
    end;
    ptLT:begin
     DumpIt(' < ');
    end;
    ptLTEQ:begin
     DumpIt(' <= ');
    end;
    ptEQ:begin
     DumpIt(' == ');
    end;
    ptNEQ:begin
     DumpIt(' != ');
    end;
    ptGT:begin
     DumpIt(' > ');
    end;
    ptGTEQ:begin
     DumpIt(' >= ');
    end;
    ptCMP:begin
     DumpIt(' <=> ');
    end;
    ptIF:begin
     DumpIt(' if ');
    end;
    ptELSEIF:begin
     DumpIt(' elseif ');
    end;
    ptELSE:begin
     DumpIt(' else ');
    end;
    ptFOR:begin
     DumpIt(' for ');
    end;
    ptFOREACH:begin
     DumpIt(' foreach ');
    end;
    ptWHILE:begin
     DumpIt(' while ');
    end;
    ptRETURN:begin
     DumpIt(' return ');
    end;
    ptBREAK:begin
     DumpIt(' break ');
    end;
    ptCONTINUE:begin
     DumpIt(' continue ');
    end;
    ptFUNCTION:begin
     DumpIt(' function ');
    end;
    ptSYMBOL:begin
     DumpIt(' '+Token^.Str+' ');
    end;
    ptLITERALNUM:begin
     DumpIt(' '+POCADoubleToString(Token^.Num)+' ');
    end;
    ptLITERALSTR:begin
     DumpIt(' "'+Token^.Str+'" ');
    end;
    ptEMPTY:begin
     DumpIt(' empty ');
    end;
    ptNULL:begin
     DumpIt(' null ');
    end;
    ptELLIPSIS:begin
     DumpIt(' ... ');
    end;
    ptQUESTION:begin
     DumpIt(' ? ');
    end;
    ptVAR:begin
     DumpIt(' var ');
    end;
    ptPLUSEQ:begin
     DumpIt(' += ');
    end;
    ptMINUSEQ:begin
     DumpIt(' -= ');
    end;
    ptMULEQ:begin
     DumpIt(' *= ');
    end;
    ptDIVEQ:begin
     DumpIt(' /= ');
    end;
    ptCATEQ:begin
     DumpIt(' ~= ');
    end;
    ptFORINDEX:begin
     DumpIt(' forindex ');
    end;
    ptLAND:begin
     DumpIt(' && ');
    end;
    ptLOR:begin
     DumpIt(' || ');
    end;
    ptTRY:begin
     DumpIt(' try ');
    end;
    ptCATCH:begin
     DumpIt(' catch ');
    end;
    ptFINALLY:begin
     DumpIt(' finally ');
    end;
    ptTHROW:begin
     DumpIt(' throw ');
    end;
    ptDO:begin
     DumpIt(' do ');
    end;
    ptWHEN:begin
     DumpIt(' when ');
    end;
    ptSWITCH:begin
     DumpIt(' switch ');
    end;
    ptCASE:begin
     DumpIt(' case ');
    end;
    ptDEFAULT:begin
     DumpIt(' default ');
    end;
    ptFALLTHROUGH:begin
     DumpIt(' fallthrough ');
    end;
    ptRETRY:begin
     DumpIt(' retry ');
    end;
    ptPOSTDEC:begin
     DumpIt('-- ');
    end;
    ptPOSTINC:begin
     DumpIt('++ ');
    end;
    ptPREDEC:begin
     DumpIt(' --');
    end;
    ptPREINC:begin
     DumpIt(' ++');
    end;
    ptBAND:begin
     DumpIt(' & ');
    end;
    ptBOR:begin
     DumpIt(' | ');
    end;
    ptBXOR:begin
     DumpIt(' ^ ');
    end;
    ptBNOT:begin
     DumpIt(' ~');
    end;
    ptBSHL:begin
     DumpIt(' << ');
    end;
    ptBSHR:begin
     DumpIt(' >> ');
    end;
    ptBUSHR:begin
     DumpIt(' >>> ');
    end;
    ptBANDEQ:begin
     DumpIt(' &= ');
    end;
    ptBOREQ:begin
     DumpIt(' |= ');
    end;
    ptBXOREQ:begin
     DumpIt(' ^= ');
    end;
    ptBSHLEQ:begin
     DumpIt(' <<= ');
    end;
    ptBSHREQ:begin
     DumpIt(' >>= ');
    end;
    ptBUSHREQ:begin
     DumpIt(' >>>= ');
    end;
    ptMOD:begin
     DumpIt(' % ');
    end;
    ptMODEQ:begin
     DumpIt(' %= ');
    end;
    ptPOW:begin
     DumpIt(' *= ');
    end;
    ptPOWEQ:begin
     DumpIt(' **= ');
    end;
    ptREGISTER:begin
     DumpIt(' register ');
    end;
    ptSCOPE:begin
     DumpIt(' block ');
    end;
    ptCODE:begin
     DumpIt(' inlineblock ');
    end;
    ptSUPERTHAT:begin
     DumpIt(' superthat ');
    end;
    ptTHAT:begin
     DumpIt(' that ');
    end;
    ptTHIS:begin
     DumpIt(' this ');
    end;
    ptSELF:begin
     DumpIt(' self ');
    end;
    ptLOCAL:begin
     DumpIt(' local ');
    end;
    ptDEFINED:begin
     DumpIt(' defined ');
    end;
    ptNEW:begin
     DumpIt(' new ');
    end;
    ptTRUE:begin
     DumpIt(' true ');
    end;
    ptFALSE:begin
     DumpIt(' false ');
    end;
    ptFASTFUNCTION:begin
     DumpIt(' fastfunction ');
    end;
    ptAT:begin
     DumpIt(' @ ');
    end;
    ptATDOT:begin
     DumpIt(' @. ');
    end;
    ptDOTDOT:begin
     DumpIt(' .. ');
    end;
    ptSAFEDOT:begin
     DumpIt(' ?. ');
    end;
    ptSAFELBRA:begin
     DumpIt(' [? ');
    end;
    ptSAFERBRA:begin
     DumpIt(' ?] ');
    end;
    ptFORKEY:begin
     DumpIt(' forkey ');
    end;
    ptINSTANCEOF:begin
     DumpIt(' instanceof ');
    end;
    ptSEQ:begin
     DumpIt(' === ');
    end;
    ptSNEQ:begin
     DumpIt(' !== ');
    end;
    ptIN:begin
     DumpIt(' in ');
    end;
    ptIS:begin
     DumpIt(' is ');
    end;
    ptSUPER:begin
     DumpIt(' super ');
    end;
    ptCAT:begin
     DumpIt(' ~ ');
    end;
    ptREGEXP:begin
     DumpIt(' "'+Token^.Str+'" ');
    end;
    ptREGEXPEQ:begin
     DumpIt(' =~= ');
    end;
    ptREGEXPNEQ:begin
     DumpIt(' !~= ');
    end;
    ptPROTOTYPE:begin
     DumpIt(' prototype ');
    end;
    ptDELETE:begin
     DumpIt(' delete ');
    end;
    ptCLASS:begin
     DumpIt(' class ');
    end;
    ptMODULE:begin
     DumpIt(' module ');
    end;
    ptEXTENDS:begin
     DumpIt(' extends ');
    end;
    ptLAMBDA:begin
     DumpIt(' => ');
    end;
    ptFASTLAMBDA:begin
     DumpIt(' -> ');
    end;
    ptCLASSFUNCTION:begin
     DumpIt(' classfunction ');
    end;
    ptMODULEFUNCTION:begin
     DumpIt(' modulefunction ');
    end;
    ptGLOBAL:begin
     DumpIt(' global ');
    end;
    ptBASECLASS:begin
     DumpIt(' baseclass ');
    end;
    ptLET:begin
     DumpIt(' let ');
    end;
    ptREG:begin
     DumpIt(' reg ');
    end;
    ptCONST:begin
     DumpIt(' const ');
    end;
    ptFUNC:begin
     DumpIt(' func ');
    end;
    ptFASTFUNC:begin
     DumpIt(' fastfunc ');
    end;
    ptHASHKIND:begin
     DumpIt(' hashkind ');
    end;
    ptTYPEOF:begin
     DumpIt(' typeof ');
    end;
    ptIDOF:begin
     DumpIt(' idof ');
    end;
    ptGHOSTTYPEOF:begin
     DumpIt(' ghosttypeof ');
    end;
    ptCOLONCOLON:begin
     DumpIt(' :: ');
    end;
    ptCONSTRUCTOR:begin
     DumpIt(' constructor ');
    end;
    ptBREAKPOINT:begin
     DumpIt(' breakpoint ');
    end;
    ptIMPORT:begin
     DumpIt(' import ');
    end;
    ptEXPORT:begin
     DumpIt(' export ');
    end;
    ptAUTOSEMI:begin
     DumpIt(' ;'#13#10);
    end;
    ptELVIS:begin
     DumpIt(' ?: ');
    end;
    ptELVISEQ:begin
     DumpIt(' ?= ');
    end;
    ptSYMBOLNAME:begin
     DumpIt(' _'+Token^.Str+'_ ');
    end;
    ptSUPERCODESYMBOL:begin
     DumpIt(' __'+Token^.Str+'__ ');
    end;
    ptNULLISHOR:begin
     DumpIt(' ?? ');
    end;
   end;
   if assigned(Token^.Children) then begin
    Dump(Token^.Children);
   end;
   Token:=Token^.Next;
  end;
 end;
 procedure ProcessLexer(var Parser:TPOCAParser;const Source:TPOCARawByteString);
 var SourcePosition,SourceLength,SourceLine,SourceColumn,LastPragma,LastOutputInfo:TPOCAInt32;
     AutomaticSemicolonInsertion:boolean;
  procedure AddToken(Token:TPOCATokenType;const Str:TPOCARawByteString;Num:double);
  var NewToken:PPOCAToken;
      i,j:TPOCAInt32;
  begin
   case Token of
    ptLITERALSTR:begin
     if assigned(Parser.Tree.LastChild) and (Parser.Tree.LastChild^.Token=ptLITERALSTR) then begin
      Parser.Tree.LastChild^.Str:=Parser.Tree.LastChild^.Str+Str;
      exit;
     end;
    end;
    ptIF:begin
     if assigned(Parser.Tree.LastChild) and (Parser.Tree.LastChild^.Token=ptELSE) then begin
      Parser.Tree.LastChild^.Token:=ptELSEIF;
      exit;
     end;
    end;
    ptSYMBOL:begin
     if assigned(Parser.Tree.LastChild) then begin
      case Parser.Tree.LastChild^.Token of
       ptPOSTDEC:begin
        Parser.Tree.LastChild^.Token:=ptPREDEC;
       end;
       ptPOSTINC:begin
        Parser.Tree.LastChild^.Token:=ptPREINC;
       end;
      end;
     end;
    end;
    ptLAND:begin
     Token:=ptAND;
    end;
    ptLOR:begin
     Token:=ptOR;
    end;
    ptREG,ptREGISTER:begin
     Token:=ptLET;
    end;
    ptFUNC:begin
     Token:=ptFUNCTION;
    end;
    ptFASTFUNC:begin
     Token:=ptFASTFUNCTION;
    end;
    ptFALSE:begin
     Token:=ptLITERALNUM;
     Num:=0.0;
    end;
    ptTRUE:begin
     Token:=ptLITERALNUM;
     Num:=1.0;
    end;
   end;
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=Token;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=Parser.SourceFile;
   NewToken^.SourceLine:=SourceLine;
   NewToken^.SourceColumn:=SourceColumn;
   for i:=LastOutputInfo to PreprocessorInstance.Preprocessor.OutputInfoCount-1 do begin
    if (SourcePosition>=PreprocessorInstance.Preprocessor.OutputInfo[i].FirstCharPos) and
       (SourcePosition<=PreprocessorInstance.Preprocessor.OutputInfo[i].LastCharPos) then begin
     j:=PreprocessorInstance.Preprocessor.OutputInfo[i].Source;
     if (j>=0) and (j<PreprocessorInstance.Preprocessor.InputSourcesCount) then begin
      NewToken^.SourceFile:=PreprocessorInstance.Preprocessor.InputSources[j].Index;
     end;
     NewToken^.SourceLine:=PreprocessorInstance.Preprocessor.OutputInfo[i].Line+1;
     LastOutputInfo:=i;
     break;
    end;
   end;
   NewToken^.Str:=Str;
   NewToken^.Num:=Num;
   NewToken^.Next:=nil;
   NewToken^.Previous:=Parser.Tree.LastChild;
   NewToken^.Children:=nil;
   NewToken^.LastChild:=nil;
   NewToken^.Parent:=nil;
   NewToken^.Rule:=prNONE;
   if (Token in POCAPrefixTokens) and
      (assigned(NewToken^.Previous) and (NewToken^.Previous.Token in POCABinaryOrPrefixTokens)) then begin
    NewToken^.Token:=POCABinaryToPrefixUnaryTokenCorrectionMap[Token];
   end;
   if not assigned(Parser.Tree.Children) then begin
    Parser.Tree.Children:=NewToken;
   end;
   if assigned(Parser.Tree.LastChild) then begin
    Parser.Tree.LastChild^.Next:=NewToken;
   end;
   Parser.Tree.LastChild:=NewToken;
  end;
  function FindKeywordToken(const Source:TPOCARawByteString;SourcePosition,SourceLength:TPOCAInt32):TPOCATokenType;
  var Node:PPOCALexerKeywordTokenCharTreeNode;
      Index:TPOCAInt32;
      CurrentChar:ansichar;
  begin
   result:=ptNONE;
   Node:=LexerKeywordTokenCharTreeRootNode;
   for Index:=SourcePosition to SourceLength do begin
    CurrentChar:=Source[Index];
    if (CurrentChar in POCAKeywordChars) and assigned(Node^.Children[CurrentChar]) then begin
     Node:=Node^.Children[CurrentChar];
     result:=Node^.Token;
     if not Node^.HasChildren then begin
      break;
     end;
    end else begin
     break;
    end;
   end;
   if result<>ptNONE then begin
    inc(SourcePosition,length(LexerKeywordTokens[result]));
    if (SourcePosition<=SourceLength) and PUCUUnicodeIsIDPart(PUCUUTF8CodeUnitGetCharFallback(Source,SourcePosition)) then begin
     result:=ptNONE;
    end;
   end;
  end;
  procedure FixPrevious;
  var t,p:PPOCAToken;
  begin
   t:=Parser.Tree.Children;
   p:=nil;
   while assigned(t) do begin
    t^.Previous:=p;
    p:=t;
    t:=t^.Next;
   end;
  end;
  procedure ProcessPragma;
  var i:TPOCAInt32;
      s:TPOCARawByteString;
  begin
   for i:=LastPragma to PreprocessorInstance.Preprocessor.PragmaInfoCount-1 do begin
    if SourcePosition>=PreprocessorInstance.Preprocessor.PragmaInfo[i].CharPos then begin
     s:=TPOCARawByteString(lowercase(trim(String(PreprocessorInstance.Preprocessor.PragmaInfo[i].Pragma))));
     if (length(s)>3) and (((s[1]='a') and (s[2]='s') and (s[3]='i')) and not (s[4] in ['a'..'z','0'..'9','_'])) then begin
      s:=TPOCARawByteString(trim(String(copy(s,4,length(s)-3))));
      AutomaticSemicolonInsertion:=(s='on') or (s='1') or (s='true');
     end;
     LastPragma:=i+1;
    end;
   end;
  end;
  procedure DoAutomaticSemicolonInsertion;
  begin
   if AutomaticSemicolonInsertion and (assigned(Parser.Tree.LastChild) and not (Parser.Tree.LastChild^.Token in
     [ptAND,ptOR,ptNOT,ptLPAR,ptRPAR,ptLBRA,ptRBRA,ptLCURL,ptMUL,ptPLUS,ptMINUS,ptNEG,ptDIV,ptNUM,ptCOLON,ptDOT,ptCOMMA,ptSEMI,
      ptASSIGN,ptLT,ptLTEQ,ptEQ,ptNEQ,ptGT,ptGTEQ,ptCMP,ptIF,ptELSEIF,ptELSE,ptFOR,ptFOREACH,ptWHILE,ptFUNCTION,ptEMPTY,
      ptNULL,ptELLIPSIS,ptQUESTION,ptVAR,ptPLUSEQ,ptMINUSEQ,ptMULEQ,ptDIVEQ,ptCATEQ,ptFORINDEX,ptLAND,ptLOR,ptTRY,ptCATCH,ptFINALLY,
      ptTHROW,ptDO,ptWHEN,ptSWITCH,ptCASE,ptDEFAULT,ptPOSTDEC,ptPOSTINC,ptPREDEC,ptPREINC,ptBAND,ptBOR,ptBXOR,ptBNOT,ptBSHL,ptBSHR,
      ptBUSHR,ptBANDEQ,ptBOREQ,ptBXOREQ,ptBSHLEQ,ptBSHREQ,ptBUSHREQ,ptMOD,ptMODEQ,ptPOW,ptPOWEQ,ptLET,ptSCOPE,ptCODE,
      ptLOCAL,ptDEFINED,ptNEW,ptFASTFUNCTION,ptAT,ptATDOT,ptDOTDOT,ptSAFEDOT,ptSAFELBRA,ptSAFERBRA,ptFORKEY,ptINSTANCEOF,ptSEQ,
      ptSNEQ,ptIN,ptIS,ptCAT,ptREGEXP,ptREGEXPEQ,ptREGEXPNEQ,ptDELETE,ptCLASS,ptMODULE,ptEXTENDS,ptLAMBDA,ptFASTLAMBDA,
      ptCLASSFUNCTION,ptMODULEFUNCTION,ptREGISTER,ptREG,ptCONST,ptFUNC,ptFASTFUNC,ptHASHKIND,ptTYPEOF,ptIDOF,ptGHOSTTYPEOF,
      ptCOLONCOLON,ptCONSTRUCTOR,ptBREAKPOINT,ptIMPORT,ptEXPORT,ptAUTOSEMI,ptSUPER,ptELVIS,ptELVISEQ,ptSYMBOLNAME,
      ptNULLISHOR])) then begin
    AddToken(ptAUTOSEMI,'',0);
   end;
  end;
  procedure ScanUntil(IncludingHere:TPOCAInt32);
  var SourceToken:TPOCATokenType;
      Counter,SourceLookaheadPosition,LastSourcePosition,Last,OldSourcePosition,OldSourceColumn,OldSourceLine,OldLastPragma,OldLastOutputInfo,CharValue,Level:TPOCAInt32;
      SourceChar,EndChar,OldSourceChar:ansichar;
      StringContent:TPOCARawByteString;
      Value:TPOCAInt64;
      DoParseExp,InClass:boolean;
      OK:boolean;
      RegExp:TFLRE;
   procedure StringInterpolation;
   begin
    AddToken(ptLITERALSTR,{$ifdef pocastrictutf8}PUCUUTF8Correct(StringContent){$else}StringContent{$endif},0);
    StringContent:='';
    AddToken(ptCAT,'',0);
    Last:=SourcePosition;
    SourceLookaheadPosition:=SourcePosition;
    Level:=0;
    while SourceLookaheadPosition<=SourceLength do begin
     case Source[SourceLookaheadPosition] of
      '{':begin
       inc(SourceLookaheadPosition);
       inc(Level);
      end;
      '}':begin
       if Level=0 then begin
        AddToken(ptLPAR,'',0);
        ScanUntil(SourceLookaheadPosition-1);
        AddToken(ptRPAR,'',0);
        AddToken(ptCAT,'',0);
        if SourcePosition=SourceLookaheadPosition then begin
         PUCUUTF8SafeInc(Source,SourcePosition);
         inc(SourceColumn);
        end else begin
         SourcePosition:=Last;
         while SourcePosition<=SourceLookaheadPosition do begin
          CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
          case CharValue of
           $0000:begin
            break;
           end;
           $000a:begin
            if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
             inc(SourcePosition);
            end;
            inc(SourceLine);
            SourceColumn:=0;
           end;
           $000d:begin
            if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
             inc(SourcePosition);
            end;
            inc(SourceLine);
            SourceColumn:=0;
           end;
           $2028,$2029:begin
            inc(SourceLine);
            SourceColumn:=0;
           end;
           else begin
            inc(SourceColumn);
           end;
          end;
         end;
        end;
        break;
       end else begin
        dec(Level);
       end;
      end;
      else begin
       inc(SourceLookaheadPosition);
      end;
     end;
    end;
    StringContent:='';
   end;
  begin
   StringContent:='';
   try
    while SourcePosition<=IncludingHere do begin
     if (LastPragma<PreprocessorInstance.Preprocessor.PragmaInfoCount) and (SourcePosition>=PreprocessorInstance.Preprocessor.PragmaInfo[LastPragma].CharPos) then begin
      ProcessPragma;
     end;
     SourceChar:=Source[SourcePosition];
     case SourceChar of
      #0:begin
       break;
      end;
      #1..#9,#11..#12,#14..#32:begin
       inc(SourcePosition);
       inc(SourceColumn);
      end;
      #10,#13:begin
       DoAutomaticSemicolonInsertion;
       if ((SourcePosition+1)<=SourceLength) and ((Source[SourcePosition+1] in [#10,#13]) and (Source[SourcePosition]<>Source[SourcePosition+1])) then begin
        inc(SourcePosition,2);
       end else begin
        inc(SourcePosition);
       end;
       inc(SourceLine);
       SourceColumn:=0;
      end;
      '(':begin
       inc(SourcePosition);
       AddToken(ptLPAR,'',0);
      end;
      ')':begin
       inc(SourcePosition);
       AddToken(ptRPAR,'',0);
      end;
      '[':begin
       inc(SourcePosition);
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]='?') then begin
        inc(SourcePosition);
        AddToken(ptSAFELBRA,'',0);
       end else begin
        AddToken(ptLBRA,'',0);
       end;
      end;
      ']':begin
       inc(SourcePosition);
       AddToken(ptRBRA,'',0);
      end;
      '{':begin
       inc(SourcePosition);
       AddToken(ptLCURL,'',0);
      end;
      '}':begin
       inc(SourcePosition);
       AddToken(ptRCURL,'',0);
      end;
      '?':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         ':':begin
          inc(SourcePosition);
          AddToken(ptELVIS,'',0);
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptELVISEQ,'',0);
         end;
         '.':begin
          inc(SourcePosition);
          AddToken(ptSAFEDOT,'',0);
         end;
         ']':begin
          inc(SourcePosition);
          AddToken(ptSAFERBRA,'',0);
         end;
         '?':begin
          inc(SourcePosition);
          AddToken(ptNULLISHOR,'',0);
         end;
         else begin
          AddToken(ptQUESTION,'',0);
         end;
        end;
       end else begin
        AddToken(ptQUESTION,'',0);
       end;
      end;
      '^':begin
       inc(SourcePosition);
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]='=') then begin
        inc(SourcePosition);
        AddToken(ptBXOREQ,'',0);
       end else begin
        AddToken(ptBXOR,'',0);
       end;
      end;
      ':':begin
       inc(SourcePosition);
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]=':') then begin
        inc(SourcePosition);
        AddToken(ptCOLONCOLON,'',0);
       end else begin
        AddToken(ptCOLON,'',0);
       end;
      end;
      ';':begin
       inc(SourcePosition);
       AddToken(ptSEMI,'',0);
      end;
      ',':begin
       inc(SourcePosition);
       AddToken(ptCOMMA,'',0);
      end;
      '.':begin
       inc(SourcePosition);
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]='.') then begin
        inc(SourcePosition);
        if (SourcePosition<=SourceLength) and (Source[SourcePosition]='.') then begin
         inc(SourcePosition);
         AddToken(ptELLIPSIS,'',0);
        end else begin
         AddToken(ptDOTDOT,'',0);
        end;
       end else begin
        AddToken(ptDOT,'',0);
       end;
      end;
      '@':begin
       inc(SourcePosition);
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]='.') then begin
        inc(SourcePosition);
        AddToken(ptATDOT,'',0);
       end else begin
        AddToken(ptAT,'',0);
       end;
      end;
      '%':begin
       inc(SourcePosition);
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]='=') then begin
        inc(SourcePosition);
        AddToken(ptMODEQ,'',0);
       end else begin
        AddToken(ptMOD,'',0);
       end;
      end;
      '&':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '&':begin
          inc(SourcePosition);
          AddToken(ptAND,'',0);
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptBANDEQ,'',0);
         end;
         else begin
          AddToken(ptBAND,'',0);
         end;
        end;
       end else begin
        AddToken(ptBAND,'',0);
       end;
      end;
      '|':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '|':begin
          inc(SourcePosition);
          AddToken(ptOR,'',0);
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptBOREQ,'',0);
         end;
         else begin
          AddToken(ptBOR,'',0);
         end;
        end;
       end else begin
        AddToken(ptBOR,'',0);
       end;
      end;
      '+':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '+':begin
          inc(SourcePosition);
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]='+') then begin
           inc(SourcePosition);
           AddToken(ptPREINC,'',0);
          end else begin
           AddToken(ptPOSTINC,'',0);
          end;
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptPLUSEQ,'',0);
         end;
         else begin
          AddToken(ptPLUS,'',0);
         end;
        end;
       end else begin
        AddToken(ptPLUS,'',0);
       end;
      end;
      '-':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '-':begin
          inc(SourcePosition);
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]='-') then begin
           inc(SourcePosition);
           AddToken(ptPREDEC,'',0);
          end else begin
           AddToken(ptPOSTDEC,'',0);
          end;
         end;
         '>':begin
          inc(SourcePosition);
          AddToken(ptFASTLAMBDA,'',0);
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptMINUSEQ,'',0);
         end;
         else begin
          AddToken(ptMINUS,'',0);
         end;
        end;
       end else begin
        AddToken(ptMINUS,'',0);
       end;
      end;
      '*':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '*':begin
          inc(SourcePosition);
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]='=') then begin
           inc(SourcePosition);
           AddToken(ptPOWEQ,'',0);
          end else begin
           AddToken(ptPOW,'',0);
          end;
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptMULEQ,'',0);
         end;
         else begin
          AddToken(ptMUL,'',0);
         end;
        end;
       end else begin
        AddToken(ptMUL,'',0);
       end;
      end;
      '/':begin
       OK:=false;
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '*':begin
          inc(SourcePosition);
          while SourcePosition<=SourceLength do begin
           CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
           case CharValue of
            $0000:begin
             break;
            end;
            $000a:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
              inc(SourcePosition);
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            $000d:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
              inc(SourcePosition);
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            $2028,$2029:begin
             inc(SourceLine);
             SourceColumn:=0;
            end;
            ord('*'):begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]='/') then begin
              inc(SourcePosition);
              inc(SourceColumn);
              break;
             end;
            end;
            else begin
             inc(SourceColumn);
            end;
           end;
          end;
         end;
         '/':begin
          while SourcePosition<=SourceLength do begin
           CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
           case CharValue of
            $0000:begin
             break;
            end;
            $000a:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
              inc(SourcePosition);
             end;
             break;
            end;
            $000d:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
              inc(SourcePosition);
             end;
             break;
            end;
            $2028,$2029:begin
             break;
            end;
            else begin
            end;
           end;
          end;
          inc(SourceLine);
          SourceColumn:=0;
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptDIVEQ,'',0);
         end;
         else begin
          OK:=true;
         end;
        end;
       end else begin
        OK:=true;
       end;
       if OK then begin
        if not (assigned(Parser.Tree.LastChild) and (Parser.Tree.LastChild^.Token in [ptLITERALSTR,ptLITERALNUM,ptSYMBOL,ptRPAR,ptRBRA,ptRCURL,ptNULL,ptSUPERTHAT,ptTHAT,ptTHIS,ptSELF,ptLOCAL,ptGLOBAL,ptBASECLASS,ptTRUE,ptFALSE])) then begin
         OldSourcePosition:=SourcePosition;
         OldSourceColumn:=SourceColumn;
         OldSourceLine:=SourceLine;
         OldSourceChar:=SourceChar;
         OldLastPragma:=LastPragma;
         OldLastOutputInfo:=LastOutputInfo;
         dec(SourcePosition);
         OK:=false;
         if OK then begin
         end;
         InClass:=false;
         begin
          LastSourcePosition:=SourcePosition;
          inc(SourcePosition);
          inc(SourceColumn);
          while SourcePosition<=SourceLength do begin
           SourceChar:=Source[SourcePosition];
           case SourceChar of
            #10,#13:begin
             if ((SourcePosition+1)<=SourceLength) and ((Source[SourcePosition+1] in [#10,#13]) and (Source[SourcePosition]<>Source[SourcePosition+1])) then begin
              inc(SourcePosition,2);
             end else begin
              inc(SourcePosition);
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            '/':begin
             if not InClass then begin
              inc(SourcePosition);
              inc(SourceColumn);
              while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['a'..'z']) do begin
               inc(SourcePosition);
               inc(SourceColumn);
              end;
              break;
             end;
            end;
            '\':begin
             inc(SourcePosition);
             inc(SourceColumn);
             if SourcePosition<=SourceLength then begin
              PUCUUTF8SafeInc(Source,SourcePosition);
              inc(SourceColumn);
             end;
            end;
            '#':begin
             inc(SourcePosition);
             while SourcePosition<=SourceLength do begin
              CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
              case CharValue of
               $0000:begin
                break;
               end;
               $000a:begin
                if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
                 inc(SourcePosition);
                end;
                break;
               end;
               $000d:begin
                if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
                 inc(SourcePosition);
                end;
                break;
               end;
               $2028,$2029:begin
                break;
               end;
               else begin
               end;
              end;
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            '[':begin
             inc(SourcePosition);
             inc(SourceColumn);
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=':') then begin
              inc(SourcePosition);
              inc(SourceColumn);
              while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['a'..'z']) do begin
               inc(SourcePosition);
               inc(SourceColumn);
              end;
              if (SourcePosition<=SourceLength) and (Source[SourcePosition]=':') then begin
               inc(SourcePosition);
               inc(SourceColumn);
               if (SourcePosition<=SourceLength) and (Source[SourcePosition]=']') then begin
                inc(SourcePosition);
                inc(SourceColumn);
               end;
              end;
             end else begin
              InClass:=true;
             end;
            end;
            ']':begin
             InClass:=false;
             inc(SourcePosition);
             inc(SourceColumn);
            end;
            '(':begin
             inc(SourcePosition);
             inc(SourceColumn);
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]='?') then begin
              inc(SourcePosition);
              inc(SourceColumn);
              if (SourcePosition<=SourceLength) and (Source[SourcePosition]='#') then begin
               inc(SourcePosition);
               inc(SourceColumn);
               while (SourcePosition<=SourceLength) and (Source[SourcePosition]<>')') do begin
                CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
                case CharValue of
                 $0000:begin
                  break;
                 end;
                 $000a:begin
                  if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
                   inc(SourcePosition);
                  end;
                  inc(SourceLine);
                  SourceColumn:=0;
                 end;
                 $000d:begin
                  if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
                   inc(SourcePosition);
                  end;
                  inc(SourceLine);
                  SourceColumn:=0;
                 end;
                 $2028,$2029:begin
                  inc(SourceLine);
                  SourceColumn:=0;
                 end;
                 else begin
                  inc(SourceColumn);
                 end;
                end;
               end;
               if (SourcePosition<=SourceLength) and (Source[SourcePosition]=')') then begin
                inc(SourcePosition);
                inc(SourceColumn);
               end;
              end;
             end;
            end;
            else begin
             CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
             case CharValue of
              $000a:begin
               if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
                inc(SourcePosition);
               end;
               inc(SourceLine);
               SourceColumn:=0;
              end;
              $000d:begin
               if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
                inc(SourcePosition);
               end;
               inc(SourceLine);
               SourceColumn:=0;
              end;
              $2028,$2029:begin
               inc(SourceLine);
               SourceColumn:=0;
              end;
              else begin
               inc(SourceColumn);
              end;
             end;
            end;
           end;
          end;
          if LastSourcePosition<SourcePosition then begin
           StringContent:=copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition);
           RegExp:=nil;
           try
            try
             RegExp:=POCARegExpCompile(Parser.Context,StringContent,PUCUUTF8Get(StringContent));
             OK:=true;
            except
             on e:Exception do begin
              SyntaxError(TPUCUUTF8String(e.Message),Parser.SourceFile,SourceLine,SourceColumn);
              OK:=false;
             end;
            end;
           finally
            if assigned(RegExp) then begin
             RegExp.Free;
            end;
           end;
          end else begin
           OK:=false;
          end;
         end;
         if OK then begin
          AddToken(ptLPAR,'',0);
          AddToken(ptREGEXP,'',0);
          AddToken(ptLITERALSTR,{$ifdef pocastrictutf8}PUCUUTF8Correct(StringContent){$else}StringContent{$endif},0);
          AddToken(ptRPAR,'',0);
          continue;
         end else begin
          SourcePosition:=OldSourcePosition;
          SourceColumn:=OldSourceColumn;
          SourceLine:=OldSourceLine;
          SourceChar:=OldSourceChar;
          LastPragma:=OldLastPragma;
          LastOutputInfo:=OldLastOutputInfo;
          if SourceChar<>#0 then begin
          end;
         end;
        end;
        AddToken(ptDIV,'',0);
       end;
      end;
      '~':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '=':begin
          inc(SourcePosition);
          AddToken(ptCATEQ,'',0);
         end;
         else begin
          AddToken(ptCAT,'',0);
         end;
        end;
       end else begin
        AddToken(ptCAT,'',0);
       end;
      end;
      '!':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '=':begin
          inc(SourcePosition);
          if SourcePosition<=SourceLength then begin
           case Source[SourcePosition] of
            '=':begin
             inc(SourcePosition);
             AddToken(ptSNEQ,'',0);
            end;
            else begin
             AddToken(ptNEQ,'',0);
            end;
           end;
          end else begin
           AddToken(ptNEQ,'',0);
          end;
         end;
         '~':begin
          if ((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='=') then begin
           inc(SourcePosition,2);
           AddToken(ptREGEXPNEQ,'',0);
          end else begin
           AddToken(ptNOT,'',0);
          end;
         end;
         else begin
          AddToken(ptNOT,'',0);
         end;
        end;
       end else begin
        AddToken(ptNOT,'',0);
       end;
      end;
      '=':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '=':begin
          inc(SourcePosition);
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]='=') then begin
           inc(SourcePosition);
           AddToken(ptSEQ,'',0);
          end else begin
           AddToken(ptEQ,'',0);
          end;
         end;
         '~':begin
          if ((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='=') then begin
           inc(SourcePosition,2);
           AddToken(ptREGEXPEQ,'',0);
          end else begin
           AddToken(ptASSIGN,'',0);
          end;
         end;
         '>':begin
          inc(SourcePosition);
          AddToken(ptLAMBDA,'',0);
         end;
         else begin
          AddToken(ptASSIGN,'',0);
         end;
        end;
       end else begin
        AddToken(ptASSIGN,'',0);
       end;
      end;
      '<':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '<':begin
          inc(SourcePosition);
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]='=') then begin
           inc(SourcePosition);
           AddToken(ptBSHLEQ,'',0);
          end else begin
           AddToken(ptBSHL,'',0);
          end;
         end;
         '=':begin
          inc(SourcePosition);
          case Source[SourcePosition] of
           '>':begin
            inc(SourcePosition);
            AddToken(ptCMP,'',0);
           end;
           else begin
            AddToken(ptLTEQ,'',0);
           end;
          end;
         end;
         else begin
          AddToken(ptLT,'',0);
         end;
        end;
       end else begin
        AddToken(ptLT,'',0);
       end;
      end;
      '>':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '>':begin
          inc(SourcePosition);
          if SourcePosition<=SourceLength then begin
           case Source[SourcePosition] of
            '>':begin
             inc(SourcePosition);
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]='=') then begin
              inc(SourcePosition);
              AddToken(ptBUSHREQ,'',0);
             end else begin
              AddToken(ptBUSHR,'',0);
             end;
            end;
            '=':begin
             inc(SourcePosition);
             AddToken(ptBSHREQ,'',0);
            end;
            else begin
             AddToken(ptBSHR,'',0);
            end;
           end;
          end else begin
           AddToken(ptBSHR,'',0);
          end;
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptGTEQ,'',0);
         end;
         else begin
          AddToken(ptGT,'',0);
         end;
        end;
       end else begin
        AddToken(ptGT,'',0);
       end;
      end;
      '#':begin
       inc(SourcePosition);
       while SourcePosition<=SourceLength do begin
        CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
        case CharValue of
         $0000:begin
          break;
         end;
         $000a:begin
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
           inc(SourcePosition);
          end;
          break;
         end;
         $000d:begin
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
           inc(SourcePosition);
          end;
          break;
         end;
         $2028,$2029:begin
          break;
         end;
         else begin
         end;
        end;
       end;
       inc(SourceLine);
       SourceColumn:=0;
      end;
      '''','"','`':begin
       EndChar:=SourceChar;
       inc(SourcePosition);
       inc(SourceColumn);
       LastSourcePosition:=SourcePosition;
       StringContent:='';
       while SourcePosition<=SourceLength do begin
        SourceChar:=Source[SourcePosition];
        if SourceChar=EndChar then begin
         if (EndChar='''') and (((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='''')) then begin
          if LastSourcePosition<SourcePosition then begin
           StringContent:=StringContent+copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition);
          end;
          StringContent:=StringContent+'''';
          inc(SourcePosition,2);
          LastSourcePosition:=SourcePosition;
         end else begin
          break;
         end;
        end else begin
         case SourceChar of
          #0:begin
           SyntaxError('Unterminated string',Parser.SourceFile,SourceLine,SourceColumn);
           break;
          end;
          #10,#13:begin
           if ((SourcePosition+1)<=SourceLength) and ((Source[SourcePosition+1] in [#10,#13]) and (Source[SourcePosition]<>Source[SourcePosition+1])) then begin
            inc(SourcePosition,2);
           end else begin
            inc(SourcePosition);
           end;
           inc(SourceLine);
           SourceColumn:=0;
          end;
          '$':begin
           if (EndChar='`') and (((SourcePosition+1)<=SourceLength) and ((Source[SourcePosition+1]='{'))) then begin
            if LastSourcePosition<SourcePosition then begin
             StringContent:=StringContent+copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition);
            end;
            inc(SourcePosition,2);
            inc(SourceColumn,2);
            LastSourcePosition:=SourcePosition;
            StringInterpolation;
            LastSourcePosition:=SourcePosition;
           end else begin
            inc(SourcePosition);
            inc(SourceColumn);
           end;
          end;
          '\':begin
           if LastSourcePosition<SourcePosition then begin
            StringContent:=StringContent+copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition);
           end;
           inc(SourcePosition);
           inc(SourceColumn);
           if (EndChar='''') or (EndChar='`') then begin
            StringContent:=StringContent+'\';
           end else begin
            if SourcePosition<=SourceLength then begin
             SourceChar:=Source[SourcePosition];
             PUCUUTF8SafeInc(Source,SourcePosition);
             inc(SourceColumn);
             case SourceChar of
              'a':begin
               StringContent:=StringContent+#7;
              end;
              'b':begin
               StringContent:=StringContent+#8;
              end;
              't':begin
               StringContent:=StringContent+#9;
              end;
              'n':begin
               StringContent:=StringContent+#10;
              end;
              'v':begin
               StringContent:=StringContent+#11;
              end;
              'f':begin
               StringContent:=StringContent+#12;
              end;
              'r':begin
               StringContent:=StringContent+#13;
              end;
              'x':begin
               Value:=0;
               Counter:=0;
               while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9','A'..'F','a'..'f']) do begin
                Value:=(Value shl 4) or Hex2Byte(Source[SourcePosition]);
                inc(Counter);
                if Counter>1 then begin
                 StringContent:=StringContent+{$ifdef pocastrictutf8}PUCUUTF32CharToUTF8(Value){$else}ansichar(TPOCAUInt8(Value)){$endif};
                 Value:=0;
                 Counter:=0;
                end;
                inc(SourcePosition);
                inc(SourceColumn);
               end;
               if Counter<>0 then begin
                StringContent:=StringContent+{$ifdef pocastrictutf8}PUCUUTF32CharToUTF8(Value){$else}ansichar(TPOCAUInt8(Value)){$endif};
               end;
              end;
              'u':begin
               Value:=0;
               while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9','A'..'F','a'..'f']) do begin
                Value:=(Value shl 4) or Hex2Byte(Source[SourcePosition]);
                inc(SourcePosition);
                inc(SourceColumn);
               end;
               StringContent:=StringContent+PUCUUTF32CharToUTF8(Value);
              end;
              '0'..'7':begin
               Value:=TPOCAUInt32(TPOCAUInt32(ord(SourceChar))-TPOCAUInt32(ord('0')));
               while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'7']) do begin
                Value:=(Value shl 3) or TPOCAUInt32(ord(Source[SourcePosition])-ord('0'));
                inc(SourcePosition);
                inc(SourceColumn);
               end;
               StringContent:=StringContent+PUCUUTF32CharToUTF8(Value);
              end;
              '{':begin
               StringInterpolation;
              end;
              '\':begin
               StringContent:=StringContent+'\';
              end;
              else begin
               StringContent:=StringContent+SourceChar;
              end;
             end;
            end else begin
             SyntaxError('Unterminated string',Parser.SourceFile,SourceLine,SourceColumn);
             break;
            end;
           end;
           LastSourcePosition:=SourcePosition;
          end;
          else begin
           CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
           case CharValue of
            $000a:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
              inc(SourcePosition);
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            $000d:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
              inc(SourcePosition);
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            $2028,$2029:begin
             inc(SourceLine);
             SourceColumn:=0;
            end;
            else begin
             inc(SourceColumn);
            end;
           end;
          end;
         end;
        end;
       end;
       if LastSourcePosition<SourcePosition then begin
        StringContent:=StringContent+copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition);
        LastSourcePosition:=SourcePosition+2;
        if LastSourcePosition=0 then begin
        end;
       end;
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]=EndChar) then begin
        inc(SourcePosition);
        inc(SourceColumn);
        AddToken(ptLITERALSTR,{$ifdef pocastrictutf8}PUCUUTF8Correct(StringContent){$else}StringContent{$endif},0);
       end else begin
        SyntaxError('Unterminated string',Parser.SourceFile,SourceLine,SourceColumn);
       end;
      end;
      '0'..'9':begin
       LastSourcePosition:=SourcePosition;
       if (SourceChar='0') and (((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='x')) then begin
        inc(SourcePosition,2);
        inc(SourceColumn,2);
        while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9','A'..'F','a'..'f']) do begin
         inc(SourcePosition);
         inc(SourceColumn);
        end;
        if (LastSourcePosition+2)=SourcePosition then begin
         SyntaxError('Invalid number literal',Parser.SourceFile,SourceLine,SourceColumn);
        end else begin
         AddToken(ptLITERALNUM,'',ConvertStringToDouble(copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition)));
        end;
       end else if (SourceChar='0') and (((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='o')) then begin
        inc(SourcePosition,2);
        inc(SourceColumn,2);
        while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'7']) do begin
         inc(SourcePosition);
         inc(SourceColumn);
        end;
        if (LastSourcePosition+2)=SourcePosition then begin
         SyntaxError('Invalid number literal',Parser.SourceFile,SourceLine,SourceColumn);
        end else begin
         AddToken(ptLITERALNUM,'',ConvertStringToDouble(copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition)));
        end;
       end else if (SourceChar='0') and (((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='b')) then begin
        inc(SourcePosition,2);
        inc(SourceColumn,2);
        while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'1']) do begin
         inc(SourcePosition);
         inc(SourceColumn);
        end;
        if (LastSourcePosition+2)=SourcePosition then begin
         SyntaxError('Invalid number literal',Parser.SourceFile,SourceLine,SourceColumn);
        end else begin
         AddToken(ptLITERALNUM,'',ConvertStringToDouble(copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition)));
        end;
       end else begin
        inc(SourcePosition);
        inc(SourceColumn);
        while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9']) do begin
         inc(SourcePosition);
         inc(SourceColumn);
        end;
        DoParseExp:=true;
        if (SourcePosition<=SourceLength) and (Source[SourcePosition]='.') then begin
         if ((SourcePosition+1)<=SourceLength) and not (Source[SourcePosition+1] in (['.','a'..'z','A'..'Z',#$80..#$ff]-['e','E'])) then begin
          inc(SourcePosition);
          inc(SourceColumn);
          while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9']) do begin
           inc(SourcePosition);
           inc(SourceColumn);
          end;
         end else begin
          DoParseExp:=false;
         end;
        end;
        if DoParseExp and ((SourcePosition<=SourceLength) and (Source[SourcePosition] in ['e','E'])) then begin
         inc(SourcePosition);
         inc(SourceColumn);
         if (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['-','+']) then begin
          inc(SourcePosition);
          inc(SourceColumn);
         end;
         if (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9']) then begin
          repeat
           inc(SourcePosition);
           inc(SourceColumn);
          until not ((SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9']));
         end else begin
          SyntaxError('Invalid number literal',Parser.SourceFile,SourceLine,SourceColumn);
         end;
        end;
        AddToken(ptLITERALNUM,'',ConvertStringToDouble(copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition)));
       end;
      end;
      else begin
       if SourceChar in POCAKeywordChars then begin
        SourceToken:=FindKeywordToken(Source,SourcePosition,SourceLength);
       end else begin
        SourceToken:=ptNONE;
       end;
       if SourceToken<>ptNONE then begin
        Value:=length(LexerKeywordTokens[SourceToken]);
        inc(SourcePosition,Value);
        inc(SourceColumn,Value);
        AddToken(SourceToken,'',0);
       end else begin
        CharValue:=PUCUUTF8CodeUnitGetCharFallBack(Source,SourcePosition);
        case CharValue of
         $03bb:begin
          AddToken(ptFUNCTION,'',0);
          inc(SourceColumn);
         end;
         else begin
          if PUCUUnicodeIsIDBegin(CharValue) then begin
           LastSourcePosition:=SourcePosition;
           while SourcePosition<=SourceLength do begin
            Last:=SourcePosition;
            if PUCUUnicodeIsIDPart(PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition)) then begin
             inc(SourceColumn);
            end else begin
             SourcePosition:=Last;
             break;
            end;
           end;
           AddToken(ptSYMBOL,PUCUUTF8Correct(copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition)),0);
          end else if PUCUUnicodeIsWhiteSpace(CharValue) then begin
           while SourcePosition<=SourceLength do begin
            Last:=SourcePosition;
            CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
            case CharValue of
             $000a:begin
              if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
               inc(SourcePosition);
              end;
              inc(SourceLine);
              SourceColumn:=0;
             end;
             $000d:begin
              if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
               inc(SourcePosition);
              end;
              inc(SourceLine);
              SourceColumn:=0;
             end;
             $2028,$2029:begin
              inc(SourceLine);
              SourceColumn:=0;
             end;
             else begin
              if PUCUUnicodeIsWhiteSpace(CharValue) then begin
               inc(SourceColumn);
              end else begin
               SourcePosition:=Last;
               break;
              end;
             end;
            end;
           end;
          end else begin
           SyntaxError('Invalid token',Parser.SourceFile,SourceLine,SourceColumn);
           break;
          end;
         end;
        end;
       end;
      end;
     end;
    end;
   finally
    StringContent:='';
   end;
  end;
 begin
  AutomaticSemicolonInsertion:=Instance.AutomaticSemicolonInsertion;
  try
   LastPragma:=0;
   LastOutputInfo:=0;
   SourcePosition:=1;
   SourceLength:=length(Source);
   SourceLine:=1;
   SourceColumn:=0;
   if (SourceLength>2) and ((Source[1]=#$ef) and (Source[2]=#$bb) and (Source[3]=#$bf)) then begin
    inc(SourcePosition,3);
   end;
   ScanUntil(SourceLength);
   FixPrevious;
  finally
   Instance.AutomaticSemicolonInsertion:=AutomaticSemicolonInsertion;
  end;
 end;
 function ScanBlockForwards(Token:PPOCAToken):PPOCAToken;
 var BeginToken,EndToken:TPOCATokenType;
     NestedLevel:TPOCAInt32;
 begin
  if assigned(Token) and (Token^.Token in [ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA]) then begin
   BeginToken:=Token^.Token;
   case BeginToken of
    ptLPAR:begin
     EndToken:=ptRPAR;
    end;
    ptLBRA:begin
     EndToken:=ptRBRA;
    end;
    ptLCURL:begin
     EndToken:=ptRCURL;
    end;
    else {ptSAFELBRA:}begin
     EndToken:=ptSAFERBRA;
    end;
   end;
   result:=Token^.Next;
   NestedLevel:=1;
   while assigned(result) do begin
    if result^.Token=BeginToken then begin
     inc(NestedLevel);
    end else if result^.Token=EndToken then begin
     dec(NestedLevel);
     if NestedLevel<=0 then begin
      break;
     end;
    end else if result^.Token in [ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA] then begin
     result:=ScanBlockForwards(result);
     if not assigned(result) then begin
      exit;
     end;
    end;
    result:=result^.Next;
   end;
   if assigned(result) and (result^.Token<>EndToken) then begin
    result:=nil;
   end;
  end else begin
   result:=nil;
  end;
 end;
 function ScanBlockBackwards(Token:PPOCAToken):PPOCAToken;
 var BeginToken,EndToken:TPOCATokenType;
     NestedLevel:TPOCAInt32;
 begin
  if assigned(Token) and (Token^.Token in [ptRPAR,ptRBRA,ptRCURL,ptSAFERBRA]) then begin
   BeginToken:=Token^.Token;
   case BeginToken of
    ptRPAR:begin
     EndToken:=ptLPAR;
    end;
    ptRBRA:begin
     EndToken:=ptLBRA;
    end;
    ptRCURL:begin
     EndToken:=ptLCURL;
    end;
    else {ptSAFERBRA:}begin
     EndToken:=ptSAFELBRA;
    end;
   end;
   result:=Token^.Previous;
   NestedLevel:=1;
   while assigned(result) do begin
    if result^.Token=BeginToken then begin
     inc(NestedLevel);
    end else if result^.Token=EndToken then begin
     dec(NestedLevel);
     if NestedLevel<=0 then begin
      break;
     end;
    end else if result^.Token in [ptRPAR,ptRBRA,ptRCURL] then begin
     result:=ScanBlockBackwards(result);
     if not assigned(result) then begin
      exit;
     end;
    end;
    result:=result^.Previous;
   end;
   if assigned(result) and (result^.Token<>EndToken) then begin
    result:=nil;
   end;
  end else begin
   result:=nil;
  end;
 end;
 procedure ProcessTransformer(var Parser:TPOCAParser);
  function NewToken(WhereToken:PPOCAToken;Token:TPOCATokenType):PPOCAToken;
  begin
   New(result);
   FillChar(result^,sizeof(TPOCAToken),#0);
   result^.TokenListNext:=TokenList;
   TokenList:=result;
   result^.Token:=Token;
   result^.Visited:=false;
   result^.Rule:=prNONE;
   result^.SourceFile:=WhereToken^.SourceFile;
   result^.SourceLine:=WhereToken^.SourceLine;
   result^.SourceColumn:=WhereToken^.SourceColumn;
  end;
  function InsertAfter(WhereToken:PPOCAToken;Token:TPOCATokenType):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=Token;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken;
   NewToken^.Next:=WhereToken^.Next;
   WhereToken^.Next:=NewToken;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertNumAfter(WhereToken:PPOCAToken;Value:double):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;     
   NewToken^.Token:=ptLITERALNUM;
   NewToken^.Num:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken;
   NewToken^.Next:=WhereToken^.Next;
   WhereToken^.Next:=NewToken;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertSymbolAfter(WhereToken:PPOCAToken;const Value:TPOCARawByteString):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptSYMBOL;
   NewToken^.Str:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken;
   NewToken^.Next:=WhereToken^.Next;
   WhereToken^.Next:=NewToken;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertStringAfter(WhereToken:PPOCAToken;const Value:TPOCARawByteString):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptLITERALSTR;
   NewToken^.Str:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken;
   NewToken^.Next:=WhereToken^.Next;
   WhereToken^.Next:=NewToken;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertSymbolNameAfter(WhereToken:PPOCAToken;const Value:TPOCARawByteString):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptSYMBOLNAME;
   NewToken^.Str:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken;
   NewToken^.Next:=WhereToken^.Next;
   WhereToken^.Next:=NewToken;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertBefore(WhereToken:PPOCAToken;Token:TPOCATokenType):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=Token;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken^.Previous;
   NewToken^.Next:=WhereToken;
   if assigned(NewToken^.Previous) then begin
    NewToken^.Previous^.Next:=NewToken;
   end;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.Children=WhereToken then begin
    Parser.Tree.Children:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertNumBefore(WhereToken:PPOCAToken;Value:double):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptLITERALNUM;
   NewToken^.Num:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken^.Previous;
   NewToken^.Next:=WhereToken;
   if assigned(NewToken^.Previous) then begin
    NewToken^.Previous^.Next:=NewToken;
   end;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.Children=WhereToken then begin
    Parser.Tree.Children:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertSymbolBefore(WhereToken:PPOCAToken;const Value:TPOCARawByteString):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptSYMBOL;
   NewToken^.Str:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken^.Previous;
   NewToken^.Next:=WhereToken;
   if assigned(NewToken^.Previous) then begin
    NewToken^.Previous^.Next:=NewToken;
   end;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.Children=WhereToken then begin
    Parser.Tree.Children:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertSymbolNameBefore(WhereToken:PPOCAToken;const Value:TPOCARawByteString):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptSYMBOLNAME;
   NewToken^.Str:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken^.Previous;
   NewToken^.Next:=WhereToken;
   if assigned(NewToken^.Previous) then begin
    NewToken^.Previous^.Next:=NewToken;
   end;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.Children=WhereToken then begin
    Parser.Tree.Children:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  procedure RemoveToken(Token:PPOCAToken);
  begin
   if assigned(Token^.Previous) then begin
    Token^.Previous^.Next:=Token^.Next;
   end else if Parser.Tree.Children=Token then begin
    Parser.Tree.Children:=Token^.Next;
   end;
   if assigned(Token^.Next) then begin
    Token^.Next^.Previous:=Token^.Previous;
   end else if Parser.Tree.LastChild=Token then begin
    Parser.Tree.LastChild:=Token^.Previous;
   end;
  end;
  function MoveToAfter(WhereToken,Token:PPOCAToken):PPOCAToken;
  begin
   RemoveToken(Token);
   Token^.Previous:=WhereToken;
   Token^.Next:=WhereToken^.Next;
   WhereToken^.Next:=Token;
   if assigned(Token^.Next) then begin
    Token^.Next^.Previous:=Token;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=Token;
   end;
   result:=Token;
  end;
  function MoveToBefore(WhereToken,Token:PPOCAToken):PPOCAToken;
  begin
   RemoveToken(Token);
   Token^.Previous:=WhereToken^.Previous;
   Token^.Next:=WhereToken;
   if assigned(Token^.Previous) then begin
    Token^.Previous^.Next:=Token;
   end;
   if assigned(Token^.Next) then begin
    Token^.Next^.Previous:=Token;
   end;
   if Parser.Tree.Children=WhereToken then begin
    Parser.Tree.Children:=Token;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=Token;
   end;
   result:=Token;
  end;
  procedure TransformAtThis;
  var CurrentToken:PPOCAToken;
  begin
   CurrentToken:=Parser.Tree.Children;
   while assigned(CurrentToken) do begin
    case CurrentToken^.Token of
     ptAT:begin
      if not (assigned(CurrentToken^.Previous) and
              (CurrentToken^.Previous.Token in [ptSYMBOL,
                                                ptSUPERCODESYMBOL,
                                                ptSUPERTHAT,
                                                ptTHAT,
                                                ptTHIS,
                                                ptSELF,
                                                ptLOCAL,
                                                ptGLOBAL,
                                                ptBASECLASS,
                                                ptPROTOTYPE,
                                                ptCONSTRUCTOR,
                                                ptHASHKIND,
                                                ptRPAR,
                                                ptRBRA,
                                                ptRCURL,
                                                ptLITERALSTR,
                                                ptLITERALNUM,
                                                ptTRUE,
                                                ptFALSE])) then begin
       CurrentToken^.Token:=ptTHIS;
       InsertAfter(CurrentToken,ptDOT);
      end else begin
       CurrentToken:=CurrentToken^.Next;
      end;
     end;
     else begin
      CurrentToken:=CurrentToken^.Next;
     end;
    end;
   end;
  end;
  procedure TransformLambdaFunction;
  var CurrentToken,NextToken,Token:PPOCAToken;
  begin
   CurrentToken:=Parser.Tree.Children;
   while assigned(CurrentToken) do begin
    case CurrentToken^.Token of
     ptLAMBDA,ptFASTLAMBDA:begin
      NextToken:=CurrentToken^.Next;
      if assigned(NextToken) and (NextToken^.Token=ptSYMBOLNAME) then begin
       NextToken:=NextToken^.Next;
      end;
      if not (assigned(CurrentToken^.Previous) and (CurrentToken^.Previous^.Token=ptRPAR)) then begin
       SyntaxError('Missed closed parenthesis brace',CurrentToken^.SourceFile,CurrentToken^.SourceLine,CurrentToken^.SourceColumn);
      end;
      Token:=ScanBlockBackwards(CurrentToken^.Previous);
      if not (assigned(Token) and (Token^.Token=ptLPAR)) then begin
       SyntaxError('Missed open parenthesis brace',CurrentToken^.SourceFile,CurrentToken^.SourceLine,CurrentToken^.SourceColumn);
      end;
      MoveToBefore(Token,CurrentToken);
      if CurrentToken^.Token=ptFASTLAMBDA then begin
       CurrentToken^.Token:=ptFASTFUNCTION;
      end else begin
       CurrentToken^.Token:=ptFUNCTION;
      end;
      if (assigned(CurrentToken^.Previous) and
         (CurrentToken^.Previous^.Token in [ptSYMBOL,
                                            ptSUPERTHAT,
                                            ptTHAT,
                                            ptTHIS,
                                            ptSELF,
                                            ptLOCAL,
                                            ptGLOBAL,
                                            ptBASECLASS,
                                            ptPROTOTYPE,
                                            ptCONSTRUCTOR,
                                            ptHASHKIND,
                                            ptRBRA])) then begin
       InsertBefore(CurrentToken,ptASSIGN);
       if assigned(CurrentToken) and
          assigned(CurrentToken^.Previous) and
          (CurrentToken^.Previous^.Token=ptASSIGN) and
          assigned(CurrentToken^.Previous^.Previous) and
          (CurrentToken^.Previous^.Previous^.Token=ptSYMBOL) then begin
        if (assigned(CurrentToken^.Previous^.Next) and (CurrentToken^.Previous^.Next^.Token in [ptFASTFUNCTION,ptFUNCTION])) and not
           (assigned(CurrentToken^.Previous^.Next^.Next) and (CurrentToken^.Previous^.Next^.Next^.Token in [ptSYMBOLNAME])) then begin
         InsertSymbolNameAfter(CurrentToken^.Previous^.Next,CurrentToken^.Previous^.Previous^.Str);
        end;
       end;
      end;
      CurrentToken:=NextToken;
     end;
     else begin
      CurrentToken:=CurrentToken^.Next;
     end;
    end;
   end;
  end;
  type TByteSet=set of TPOCAUInt8;
  function TransformBlock(StartToken:PPOCAToken;EndToken:TPOCATokenTypes;IgnoreVarLocal:boolean):PPOCAToken;
   procedure SkipBraces(var CurrentToken:PPOCAToken);
   var LastToken:PPOCAToken;
   begin
    LastToken:=CurrentToken;
    case CurrentToken^.Token of
     ptLPAR:begin
      CurrentToken:=TransformBlock(CurrentToken^.Next,[ptRPAR],false);
      if assigned(CurrentToken) and (CurrentToken^.Token=ptRPAR) then begin
       CurrentToken:=CurrentToken^.Next;
      end else begin
       SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptLCURL:begin
      CurrentToken:=TransformBlock(CurrentToken^.Next,[ptRCURL],false);
      if assigned(CurrentToken) and (CurrentToken^.Token=ptRCURL) then begin
       CurrentToken:=CurrentToken^.Next;
      end else begin
       SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptLBRA:begin
      CurrentToken:=TransformBlock(CurrentToken^.Next,[ptRBRA],false);
      if assigned(CurrentToken) and (CurrentToken^.Token=ptRBRA) then begin
       CurrentToken:=CurrentToken^.Next;
      end else begin
       SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptSAFELBRA:begin
      CurrentToken:=TransformBlock(CurrentToken^.Next,[ptSAFERBRA],false);
      if assigned(CurrentToken) and (CurrentToken^.Token=ptSAFERBRA) then begin
       CurrentToken:=CurrentToken^.Next;
      end else begin
       SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
    end;
   end;
  var LastToken,NextToken,IdentifierTokenList,LastEndToken,SymbolNameToken,AnchorToken,TempToken,TokenA,TokenB,TokenC:PPOCAToken;
      WhichToken:TPOCATokenType;
      Meta,CountImports,Index:TPOCAInt32;
      CountStatements:TPOCAInt32;
      Imports:array of TPOCARawByteString;
  begin
   result:=StartToken;
   while assigned(result) and not (result^.Token in EndToken) do begin
    LastToken:=result;
    case result^.Token of
     ptCATCH:begin
      result:=result^.Next;
      if assigned(result) and (result^.Token=ptLPAR) then begin
       result:=result^.Next;
       if assigned(result) and (result^.Token in [ptVAR,ptLET,ptCONST]) then begin
        result:=result^.Next;
       end;
       if assigned(result) and (result^.Token=ptSYMBOL) then begin
        result:=result^.Next;
       end else begin
        SyntaxError('Missed symbol',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
       if assigned(result) and (result^.Token in [ptRPAR]) then begin
        result:=result^.Next;
       end else begin
        SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end;
     end;
     ptLPAR:begin
      result:=TransformBlock(result^.Next,[ptRPAR],false);
      if assigned(result) and (result^.Token=ptRPAR) then begin
       result:=result^.Next;
      end else begin
       SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptLCURL:begin
      result:=TransformBlock(result^.Next,[ptRCURL],false);
      if assigned(result) and (result^.Token=ptRCURL) then begin
       result:=result^.Next;
      end else begin
       SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptLBRA:begin
      result:=TransformBlock(result^.Next,[ptRBRA],false);
      if assigned(result) and (result^.Token=ptRBRA) then begin
       result:=result^.Next;
      end else begin
       SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptSAFELBRA:begin
      result:=TransformBlock(result^.Next,[ptSAFERBRA],false);
      if assigned(result) and (result^.Token=ptSAFERBRA) then begin
       result:=result^.Next;
      end else begin
       SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptSUPER:begin
      if assigned(result^.Next) and
         (result^.Next^.Token in [ptDOT,ptATDOT]) and
         assigned(result^.Next^.Next) and
         (result^.Next^.Next^.Token=ptSYMBOL) then begin
       result^.Token:=ptSUPERTHAT;
       result^.Next^.Token:=ptATDOT;
      end else begin
       result^.Token:=ptSUPERTHAT;
       InsertAfter(result,ptSUPERCODESYMBOL);
       InsertAfter(result,ptATDOT);
      end;
     end;
     ptCONSTRUCTOR:begin
      if assigned(result^.Previous) and (result^.Previous^.Token in [ptDOT,ptSAFEDOT,ptATDOT]) then begin
       result:=result^.Next;
      end else begin
       result^.Token:=ptFUNCTION;
       InsertSymbolAfter(result,ConstructorValueSymbolString);
      end;
     end;
     ptIMPORT:begin
      TokenA:=nil;
      TokenB:=nil;
      if assigned(result^.Next) and (result^.Next^.Token=ptLITERALSTR) then begin
       if assigned(result^.Next^.Next) and (result^.Next^.Next^.Token in [ptSEMI,ptAUTOSEMI]) then begin
        result^.Token:=ptSYMBOL;
        result^.Str:='import';
        TokenA:=result^.Next;
        TokenB:=result^.Next^.Next;
        InsertBefore(TokenA,ptLPAR);
        InsertBefore(TokenB,ptRPAR);
        result:=TokenB^.Next;
       end else begin
        SyntaxError('Invalid import statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
        break;
       end;
      end else if assigned(result^.Next) and (result^.Next^.Token=ptLPAR) then begin
       result^.Token:=ptSYMBOL;
       result^.Str:='import';
       result:=TransformBlock(result^.Next^.Next,[ptRPAR],false);
       if assigned(result) and (result^.Token=ptRPAR) then begin
        result:=result^.Next;
       end else begin
        SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end else begin
       TokenC:=result;
       result^.Token:=ptSEMI;
       result:=result^.Next;
       TempToken:=result;
       while assigned(result) and not ((result^.Token in [ptSEMI,ptAUTOSEMI]) or
                                       ((result^.Token=ptSYMBOL) and (result^.Str='from'))) do begin
        if assigned(result) and ((result^.Token=ptSYMBOL) or (result^.Token=ptMUL)) then begin
         result:=result^.Next;
         if assigned(result) then begin
          case result^.Token of
           ptSEMI,ptAUTOSEMI:begin
            break;
           end;
           ptCOMMA:begin
            result:=result^.Next;
           end;
           else begin
            if (result^.Token=ptSYMBOL) and (result^.Str='from') then begin
             break;
            end else begin
             SyntaxError('Invalid import statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
             break;
            end;
           end;
          end;
         end;
        end else begin
         result:=result^.Next;
        end;
       end;
       if (result^.Token=ptSYMBOL) and (result^.Str='from') then begin
        result:=result^.Next;
       end else begin
        SyntaxError('Invalid import statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
        break;
       end;
       if assigned(result) and (result^.Token=ptLITERALSTR) then begin
        TokenC^.Token:=ptSYMBOL;
        TokenC^.Str:='import';
        TokenA:=InsertAfter(TokenC,ptLPAR);
        TokenA:=InsertStringAfter(TokenA,result^.Str);
        TokenB:=TempToken;
        Imports:=nil;
        CountImports:=0;
        try
         while assigned(TokenB) and not ((TokenB^.Token in [ptSEMI,ptAUTOSEMI]) or
                                         ((TokenB^.Token=ptSYMBOL) and (TokenB^.Str='from'))) do begin
          if assigned(TokenB) and ((TokenB^.Token=ptSYMBOL) or (TokenB^.Token=ptMUL)) then begin
           if length(Imports)<=CountImports then begin
            SetLength(Imports,(CountImports+1)*2);
           end;
           if  TokenB^.Token=ptSYMBOL then begin
            Imports[CountImports]:=TokenB^.Str;
           end else begin
            Imports[CountImports]:='*';
           end;
           inc(CountImports);
           TokenB:=TokenB^.Next;
           if assigned(TokenB) then begin
            case TokenB^.Token of
             ptSEMI,ptAUTOSEMI:begin
              break;
             end;
             ptCOMMA:begin
              TokenB:=TokenB^.Next;
             end;
             else begin
              if (TokenB^.Token=ptSYMBOL) and (TokenB^.Str='from') then begin
               break;
              end else begin
               SyntaxError('Invalid import statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
               break;
              end;
             end;
            end;
           end;
          end else begin
           TokenB:=TokenB^.Next;
          end;
         end;
         SetLength(Imports,CountImports);
         if CountImports>0 then begin
          TokenA:=InsertAfter(TokenA,ptCOMMA);
          TokenA:=InsertAfter(TokenA,ptLBRA);
          for Index:=0 to CountImports-1 do begin
           if Index>0 then begin
            TokenA:=InsertAfter(TokenA,ptCOMMA);
           end;
           TokenA:=InsertStringAfter(TokenA,Imports[Index]);
          end;
          TokenA:=InsertAfter(TokenA,ptRBRA);
         end;
         TokenA:=InsertAfter(TokenA,ptRPAR);
         if assigned(result^.Previous) then begin
          result^.Previous^.Next:=nil;
         end;
         result^.Previous:=TokenA;
         TokenA^.Next:=result^.Next;
         result:=result^.Next;
        finally
         Imports:=nil;
        end;
        continue;
       end else if assigned(result) and (result^.Token=ptSYMBOL) then begin
        TokenA:=result;
        TokenB:=result;
        result:=result^.Next;
        repeat
         if assigned(result) and (result^.Token=ptDOT) then begin
          result:=result^.Next;
          if assigned(result) and (result^.Token=ptSYMBOL) then begin
           TokenB:=result;
           result:=result^.Next;
          end else begin
           SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end else begin
          break;
         end;
        until false;
       end else begin
        SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
       if not (assigned(result) and (result^.Token in [ptSEMI,ptAUTOSEMI])) then begin
        SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
       result:=TempToken;
       while assigned(result) and not ((result^.Token in [ptSEMI,ptAUTOSEMI]) or
                                       ((result^.Token=ptSYMBOL) and (result^.Str='from'))) do begin
        if assigned(result) and (result^.Token=ptMUL) then begin
         SyntaxError('Invalid import statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
         break;
        end else if assigned(result) and (result^.Token=ptSYMBOL) then begin
         NextToken:=result^.Next;
         TempToken:=InsertBefore(result,ptVAR);
         TempToken:=InsertAfter(result,ptASSIGN);
         TokenC:=TokenA;
         while assigned(TokenC) do begin
          TempToken:=InsertAfter(TempToken,TokenC^.Token);
          if TokenC^.Token=ptSYMBOL then begin
           TempToken^.Str:=TokenC^.Str;
          end;
          if TokenC=TokenB then begin
           break;
          end;
          TokenC:=TokenC^.Next;
         end;
         TempToken:=InsertAfter(TempToken,ptDOT);
         TempToken:=InsertSymbolAfter(TempToken,'exports');
         TempToken:=InsertAfter(TempToken,ptDOT);
         TempToken:=InsertAfter(TempToken,result^.Token);
         if result^.Token=ptSYMBOL then begin
          TempToken^.Str:=result^.Str;
         end;
         TempToken:=InsertAfter(TempToken,ptSEMI);
         result:=NextToken;
         if assigned(result) then begin
          case result^.Token of
           ptSEMI,ptAUTOSEMI:begin
            break;
           end;
           ptCOMMA:begin
            result^.Token:=ptSEMI;
            result:=result^.Next;
           end;
           else begin
            if (result^.Token=ptSYMBOL) and (result^.Str='from') then begin
             break;
            end else begin
             SyntaxError('Invalid import statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
             break;
            end;
           end;
          end;
         end;
        end else begin
         result:=result^.Next;
        end;
       end;
       if (result^.Token=ptSYMBOL) and (result^.Str='from') then begin
        result^.Token:=ptSEMI;
        result:=result^.Next;
       end else begin
        SyntaxError('Invalid import statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
        break;
       end;
       if assigned(result) and (result^.Token=ptSYMBOL) then begin
        result^.Token:=ptSEMI;
        result:=result^.Next;
        repeat
         if assigned(result) and (result^.Token=ptDOT) then begin
          result^.Token:=ptSEMI;
          result:=result^.Next;
          if assigned(result) and (result^.Token=ptSYMBOL) then begin
           result^.Token:=ptSEMI;
           result:=result^.Next;
          end else begin
           SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end else begin
          break;
         end;
        until false;
       end else begin
        SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
       if not (assigned(result) and (result^.Token in [ptSEMI,ptAUTOSEMI])) then begin
        SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end;
     end;
     ptEXPORT:begin
      result^.Token:=ptSEMI;
      result:=result^.Next;
      while assigned(result) and not (result^.Token in [ptSEMI,ptAUTOSEMI]) do begin
       if assigned(result) and (result^.Token=ptSYMBOL) then begin
        NextToken:=result^.Next;
        TempToken:=InsertBefore(result,ptDOT);
        InsertSymbolBefore(TempToken,'exports');
        TempToken:=InsertAfter(result,ptASSIGN);
        TempToken:=InsertSymbolAfter(TempToken,result^.Str);
        TempToken:=InsertAfter(TempToken,ptSEMI);
        result:=NextToken;
        if assigned(result) then begin
         case result^.Token of
          ptSEMI,ptAUTOSEMI:begin
           break;
          end;
          ptCOMMA:begin
           result^.Token:=ptSEMI;
           result:=result^.Next;
          end;
          else begin
           SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
           break;
          end;
         end;
        end else begin
         break;
        end;
       end else begin
        SyntaxError('Symbol to export expected',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
        break;
       end;
      end;
      if not (assigned(result) and (result^.Token in [ptSEMI,ptAUTOSEMI])) then begin
       SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptFOREACH,ptFORKEY,ptFORINDEX:begin
      // transform foreach(a in b) into foreach(a;b) (also for forkey and forindex)
      Meta:=1;
      result:=result^.Next;
      if assigned(result) and (result^.Token=ptLPAR) then begin
       AnchorToken:=result;
       result:=result^.Next;
       while assigned(result) and not (result^.Token=ptRPAR) do begin
        case result^.Token of
         ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA:begin
          result:=ScanBlockForwards(result);
         end;
         ptSEMI:begin
          Meta:=0;
          result:=result^.Next;
         end;
         ptIN:begin
          if Meta>0 then begin
           dec(Meta);
           result^.Token:=ptSEMI;
           result:=result^.Next;
          end else begin
           SyntaxError('Invalid IN syntax usage',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end;
         else begin
          result:=result^.Next;
         end;
        end;
       end;
       if assigned(result) and (result^.Token=ptRPAR) then begin
        result:=AnchorToken;
       end else begin
        SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end else begin
       result:=result^.Next;
      end;
     end;
     ptFASTFUNCTION,ptFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin
      if assigned(result^.Next) and (result^.Next^.Token in [ptSYMBOL,
                                                             ptSUPERTHAT,
                                                             ptTHAT,
                                                             ptTHIS,
                                                             ptSELF,
                                                             ptLOCAL,
                                                             ptGLOBAL,
                                                             ptBASECLASS,
                                                             ptPROTOTYPE,
                                                             ptCONSTRUCTOR,
                                                             ptHASHKIND]) then begin
       if assigned(result^.Next^.Next) and (result^.Next^.Next^.Token<>ptLPAR) then begin
        LastToken:=result;
        NextToken:=result^.Next;
        while assigned(NextToken) do begin
         LastToken:=NextToken;
         case NextToken^.Token of
          ptLPAR:begin
           break;
          end;
          ptLCURL:begin
           NextToken:=TransformBlock(NextToken^.Next,[ptRCURL],false);
           if assigned(NextToken) and (NextToken^.Token=ptRCURL) then begin
            NextToken:=NextToken^.Next;
           end else begin
            SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
           end;
           break;
          end;
          ptLBRA:begin
           NextToken:=TransformBlock(NextToken^.Next,[ptRBRA],false);
           if assigned(NextToken) and (NextToken^.Token=ptRBRA) then begin
            NextToken:=NextToken^.Next;
           end else begin
            SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
           end;
          end;
          ptSAFELBRA:begin
           NextToken:=TransformBlock(NextToken^.Next,[ptSAFERBRA],false);
           if assigned(NextToken) and (NextToken^.Token=ptSAFERBRA) then begin
            NextToken:=NextToken^.Next;
           end else begin
            SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
           end;
          end;
          else begin
           NextToken:=NextToken^.Next;
          end;
         end;
        end;
        SymbolNameToken:=nil;
        if assigned(NextToken) and (NextToken^.Token=ptLPAR) then begin
         if assigned(NextToken^.Previous) and (NextToken^.Previous^.Token=ptSYMBOL) then begin
          SymbolNameToken:=NextToken^.Previous;
         end;
        end else begin
         SyntaxError('Missed open parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
        end;
        while assigned(result^.Next) and (result^.Next<>NextToken) do begin
         case result^.Next^.Token of
          ptCOLONCOLON:begin
           result^.Next^.Token:=ptDOT;
          end;
         end;
         MoveToBefore(result,result^.Next);
        end;
        InsertBefore(result,ptASSIGN);
        LastToken:=result;
        if assigned(SymbolNameToken) and
           (SymbolNameToken^.Token=ptSYMBOL) and
           assigned(result) and
           (result^.Token in [ptFASTFUNCTION,ptFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION]) then begin
         InsertSymbolNameAfter(result,SymbolNameToken^.Str);
         result:=result^.Next;
        end;
        result:=result^.Next;
       end else begin
        if (result^.Next^.Token=ptSYMBOL) and ((not assigned(result^.Previous)) or not (result^.Previous^.Token in [ptVAR,ptLET,ptCONST])) then begin
         InsertBefore(result,ptVAR);
        end;
        if (result^.Next^.Token=ptSYMBOL) and not (assigned(result^.Next^.Next) and (result^.Next^.Next^.Token=ptSYMBOLNAME)) then begin
         InsertSymbolNameAfter(result^.Next,result^.Next^.Str);
        end;
        MoveToBefore(result,result^.Next);
        InsertBefore(result,ptASSIGN);
        LastToken:=result;
        result:=result^.Next;
       end;
      end else begin
       LastToken:=result;
       result:=result^.Next;
      end;
      if assigned(result) then begin
       LastToken:=result;
      end;
      if assigned(result) and (result^.Token=ptSYMBOLNAME) then begin
       result:=result^.Next;
      end;
      if assigned(result) and (result^.Token=ptLPAR) then begin
       result:=TransformBlock(result^.Next,[ptRPAR],true);
       if assigned(result) and (result^.Token=ptRPAR) then begin
        result:=result^.Next;
       end else begin
        SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end;
      if assigned(result) and (result^.Token=ptLCURL) then begin
       result:=TransformBlock(result^.Next,[ptRCURL],false);
       if assigned(result) and (result^.Token=ptRCURL) then begin
        result:=result^.Next;
       end else begin
        SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end;
     end;
     ptCLASS,ptMODULE:begin
      WhichToken:=result^.Token;
      if assigned(result^.Next) and (result^.Next^.Token=ptSYMBOL) then begin
       SymbolNameToken:=result^.Next;
      end else begin
       if WhichToken=ptCLASS then begin
        SymbolNameToken:=InsertSymbolAfter(result,'');
       end else begin
        SymbolNameToken:=nil;
       end;
      end;
      if assigned(result^.Next) and (result^.Next^.Token in [ptSYMBOL,
                                                             ptSUPERTHAT,
                                                             ptTHAT,
                                                             ptTHIS,
                                                             ptSELF,
                                                             ptLOCAL,
                                                             ptGLOBAL,
                                                             ptBASECLASS,
                                                             ptPROTOTYPE,
                                                             ptCONSTRUCTOR,
                                                             ptHASHKIND]) then begin
       if (not assigned(result^.Previous)) or not (result^.Previous^.Token in [ptVAR,ptLET,ptCONST]) then begin
        result^.Token:=ptVAR;
        result:=result^.Next^.Next;
       end else begin
        NextToken:=result^.Next^.Next;
        RemoveToken(result);
        result:=NextToken;
       end;
       while assigned(result) do begin
        case result^.Token of
         ptLPAR:begin
          result:=TransformBlock(result^.Next,[ptRPAR],false);
          if assigned(result) and (result^.Token=ptRPAR) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end;
         ptLCURL:begin
          break;
         end;
         ptLBRA:begin
          result:=TransformBlock(result^.Next,[ptRBRA],false);
          if assigned(result) and (result^.Token=ptRBRA) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end;
         ptSAFELBRA:begin
          result:=TransformBlock(result^.Next,[ptSAFERBRA],false);
          if assigned(result) and (result^.Token=ptSAFERBRA) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end;
         ptEXTENDS:begin
          break;
         end;
         else begin
          result:=result^.Next;
         end;
        end;
       end;
       if assigned(result) then begin
        LastToken:=result;
        InsertBefore(result,ptASSIGN);
        InsertBefore(result,ptLPAR);
        if WhichToken=ptCLASS then begin
         InsertBefore(result,ptCLASSFUNCTION);
        end else begin
         InsertBefore(result,ptMODULEFUNCTION);
        end;
        IdentifierTokenList:=nil;
        if assigned(result) and (result^.Token=ptEXTENDS) then begin
         LastToken:=result;
         NextToken:=result^.Next;
         RemoveToken(result);
         result:=NextToken;
         if assigned(result) and (result^.Token=ptLCURL) then begin
          SyntaxError('Missed symbol',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
         end else begin
          NextToken:=result;
          while assigned(NextToken) do begin
           case NextToken^.Token of
            ptLPAR:begin
             NextToken:=TransformBlock(NextToken^.Next,[ptRPAR],false);
             if assigned(NextToken) and (NextToken^.Token=ptRPAR) then begin
              NextToken:=NextToken^.Next;
             end else begin
              SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
             end;
            end;
            ptLCURL:begin
             break;
            end;
            ptLBRA:begin
             NextToken:=TransformBlock(NextToken^.Next,[ptRBRA],false);
             if assigned(NextToken) and (NextToken^.Token=ptRBRA) then begin
              NextToken:=NextToken^.Next;
             end else begin
              SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
             end;
            end;
            ptSAFELBRA:begin
             NextToken:=TransformBlock(NextToken^.Next,[ptSAFERBRA],false);
             if assigned(NextToken) and (NextToken^.Token=ptSAFERBRA) then begin
              NextToken:=NextToken^.Next;
             end else begin
              SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
             end;
            end;
            else begin
             NextToken:=NextToken^.Next;
            end;
           end;
          end;
          if assigned(NextToken) and (NextToken^.Token=ptLCURL) then begin
           LastEndToken:=NextToken;
           while assigned(result) and (result<>LastEndToken) do begin
            LastToken:=result;
            NextToken:=result^.Next;
            RemoveToken(result);
            result^.Previous:=nil;
            result^.Next:=nil;
            if assigned(IdentifierTokenList) then begin
             IdentifierTokenList^.Next:=result;
             result^.Previous:=IdentifierTokenList;
            end;
            IdentifierTokenList:=result;
            result:=NextToken;
           end;
          end else begin
           SyntaxError('Missed open curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end;
        end;
        InsertBefore(result,ptLPAR);
        if assigned(IdentifierTokenList) then begin
         InsertBefore(result,ptLET);
         InsertSymbolBefore(result,#1'PROTO'#1);
        end;
        InsertBefore(result,ptRPAR);
        if assigned(result) and (result^.Token=ptLCURL) then begin
         if (WhichToken in [ptCLASS]) and assigned(SymbolNameToken) then begin
          result:=InsertAfter(result,ptLOCAL);
          result:=InsertAfter(result,ptDOT);
          result:=InsertSymbolAfter(result,'className');
          result:=InsertAfter(result,ptASSIGN);
          result:=InsertStringAfter(result,SymbolNameToken^.Str);
          result:=InsertAfter(result,ptSEMI);
         end;
         if (WhichToken in [ptCLASS]) and assigned(SymbolNameToken) then begin
          result:=InsertAfter(result,ptLOCAL);
          result:=InsertAfter(result,ptDOT);
          result:=InsertSymbolAfter(result,'classType');
          result:=InsertAfter(result,ptASSIGN);
          result:=InsertAfter(result,ptLOCAL);
          result:=InsertAfter(result,ptSEMI);
         end;
         if WhichToken in [ptCLASS,ptMODULE] then begin
          result:=InsertAfter(result,ptLOCAL);
          result:=InsertAfter(result,ptDOT);
          result:=InsertAfter(result,ptHASHKIND);
          result:=InsertAfter(result,ptASSIGN);
          if WhichToken=ptCLASS then begin
           result:=InsertNumAfter(result,phkCLASS);
          end else begin
           result:=InsertNumAfter(result,phkMODULE);
          end;
          result:=InsertAfter(result,ptSEMI);
         end;
         if WhichToken=ptMODULE then begin
          result:=InsertAfter(result,ptLOCAL);
          result:=InsertAfter(result,ptDOT);
          result:=InsertSymbolAfter(result,'exports');
          result:=InsertAfter(result,ptASSIGN);
          result:=InsertAfter(result,ptLCURL);
          result:=InsertAfter(result,ptRCURL);
          result:=InsertAfter(result,ptSEMI);
         end;
         if assigned(IdentifierTokenList) or (WhichToken=ptCLASS) then begin
          begin
           result:=InsertAfter(result,ptLOCAL);
           result:=InsertAfter(result,ptDOT);
           result:=InsertAfter(result,ptPROTOTYPE);
           result:=InsertAfter(result,ptASSIGN);
           if assigned(IdentifierTokenList) then begin
            result:=InsertSymbolAfter(result,#1'PROTO'#1);
           end else begin
            if WhichToken=ptCLASS then begin
             result:=InsertAfter(result,ptBASECLASS);
            end else begin
             result:=InsertAfter(result,ptNULL);
            end;
           end;
           result:=InsertAfter(result,ptSEMI);
          end;
          begin
           result:=InsertAfter(result,ptLOCAL);
           result:=InsertAfter(result,ptDOT);
           result:=InsertAfter(result,ptCONSTRUCTOR);
           result:=InsertAfter(result,ptASSIGN);
           if assigned(IdentifierTokenList) then begin
            result:=InsertSymbolAfter(result,#1'PROTO'#1);
           end else begin
            if WhichToken=ptCLASS then begin
             result:=InsertAfter(result,ptBASECLASS);
            end else begin
             result:=InsertAfter(result,ptNULL);
            end;
           end;
           result:=InsertAfter(result,ptSEMI);
          end;
         end;
         result:=TransformBlock(result^.Next,[ptRCURL],false);
         if assigned(result) and (result^.Token=ptRCURL) then begin
          LastToken:=result;
          result:=InsertAfter(result,ptRPAR);
          result:=InsertAfter(result,ptLPAR);
          if assigned(IdentifierTokenList) then begin
           while assigned(IdentifierTokenList) do begin
            NextToken:=IdentifierTokenList^.Next;
            IdentifierTokenList^.Previous:=nil;
            IdentifierTokenList^.Next:=nil;
            MoveToAfter(result,IdentifierTokenList);
            result:=IdentifierTokenList;
            IdentifierTokenList:=NextToken;
           end;
          end else begin
           if WhichToken=ptCLASS then begin
            result:=InsertAfter(result,ptBASECLASS);
           end else begin
            result:=InsertAfter(result,ptNULL);
           end;
          end;
          result:=InsertAfter(result,ptRPAR);
          if not (assigned(result^.Next) and (result^.Next^.Token in [ptSEMI,ptAUTOSEMI])) then begin
           result:=InsertAfter(result,ptSEMI);
          end;
          result:=result^.Next;
         end else begin
          SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
         end;
        end else begin
         SyntaxError('Missed open curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
        end;
       end else begin
        SyntaxError('Corrupt class definition',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end else begin
       SyntaxError('Missed symbol',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptVAR,ptLET,ptCONST:begin
      if IgnoreVarLocal or (assigned(result^.Next) and (result^.Next^.Token in [ptFASTFUNCTION,ptFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION])) then begin
       result:=result^.Next;
      end else begin
       CountStatements:=0;
       AnchorToken:=result;
       WhichToken:=result^.Token;
       result:=result^.Next;
       while assigned(result) and not ((result^.Token in [ptCOMMA,ptSEMI,ptAUTOSEMI]) or (result^.Token in EndToken)) do begin
        LastToken:=result;
        case result^.Token of
         ptLPAR:begin
          result:=TransformBlock(result^.Next,[ptRPAR],false);
          if assigned(result) and (result^.Token=ptRPAR) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
          if assigned(result) and (result^.Token=ptASSIGN) then begin
           result:=TransformBlock(result^.Next,[ptCOMMA,ptSEMI,ptAUTOSEMI]+EndToken,false);
          end;
         end;
         ptLCURL:begin
          result:=TransformBlock(result^.Next,[ptRCURL],false);
          if assigned(result) and (result^.Token=ptRCURL) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
          if assigned(result) and (result^.Token=ptASSIGN) then begin
           result:=TransformBlock(result^.Next,[ptCOMMA,ptSEMI,ptAUTOSEMI]+EndToken,false);
          end;
         end;
         ptLBRA:begin
          result:=TransformBlock(result^.Next,[ptRBRA],false);
          if assigned(result) and (result^.Token=ptRBRA) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
          if assigned(result) and (result^.Token=ptASSIGN) then begin
           result:=TransformBlock(result^.Next,[ptCOMMA,ptSEMI,ptAUTOSEMI]+EndToken,false);
          end;
         end;
         ptSAFELBRA:begin
          result:=TransformBlock(result^.Next,[ptSAFERBRA],false);
          if assigned(result) and (result^.Token=ptSAFERBRA) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
          if assigned(result) and (result^.Token=ptASSIGN) then begin
           result:=TransformBlock(result^.Next,[ptCOMMA,ptSEMI,ptAUTOSEMI]+EndToken,false);
          end;
         end;
         ptSYMBOL:begin
          if assigned(result^.Next) and (result^.Next^.Token in [ptASSIGN]) then begin
           result:=TransformBlock(result^.Next,[ptCOMMA,ptSEMI,ptAUTOSEMI]+EndToken,false);
          end else begin
           result:=InsertAfter(result,ptASSIGN);
           result:=InsertAfter(result,ptNULL);
           result:=result^.Next;
          end;
         end;
         else begin
          result:=result^.Next;
         end;
        end;
        if assigned(result) and (result^.Token=ptCOMMA) then begin
         result^.Token:=ptSEMI;
         result:=InsertAfter(result,WhichToken);
         result:=result^.Next;
        end;
        inc(CountStatements);
       end;
       if assigned(result) and ((result^.Token in [ptSEMI,ptAUTOSEMI]) or (result^.Token in EndToken)) then begin
        if CountStatements>1 then begin
         InsertBefore(AnchorToken,ptCODE);
         InsertBefore(AnchorToken,ptLCURL);
         InsertBefore(result,ptSEMI);
         InsertBefore(result,ptRCURL);
        end;
        if result^.Token in EndToken then begin
         break;
        end else begin
         result:=result^.Next;
        end;
       end else begin
        SyntaxError('Missed semicolon',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end;
     end;
     else begin
      result:=result^.Next;
     end;
    end;
   end;
  end;
 begin
  ResetTokenVisited;
  TransformAtThis;
  TransformLambdaFunction;
  TransformBlock(Parser.Tree.Children,[],false);
//Dump(Parser.Tree.Children);
 end;
 procedure ProcessParser(var Parser:TPOCAParser);
  function NewToken(const t:PPOCAToken;const Token:TPOCATokenType):PPOCAToken;
  begin
   New(result);
   FillChar(result^,sizeof(TPOCAToken),#0);
   result^.TokenListNext:=TokenList;
   TokenList:=result;
   result^.Token:=Token;
   result^.Visited:=false;
   result^.Rule:=prNONE;
   result^.SourceFile:=t^.SourceFile;
   result^.SourceLine:=t^.SourceLine;
   result^.SourceColumn:=t^.SourceColumn;
  end;
  procedure AddNewChild(p,c:PPOCAToken);
  begin
   c^.Parent:=p;
   if assigned(p^.LastChild) then begin
    c^.Previous:=p^.LastChild;
    p^.LastChild^.Next:=c;
   end else begin
    p^.Children:=c;
   end;
   p^.LastChild:=c;
   c^.Rule:=prNONE;
  end;
  procedure ParseBlock(Top:PPOCAToken;EndToken,EarlyEndToken:TPOCATokenType;List:PPPOCAToken;UntilIncludingToken:PPOCAToken);
   function ParseToken(Parent:PPOCAToken;List:PPPOCAToken;ParentToken:TPOCATokenType=ptNONE):PPOCAToken;
   var t,Block,CaseBlock,UntilToIncludeToken:PPOCAToken;
    function Pop:PPOCAToken;
    begin
     result:=List^;
     List^:=result^.Next;
     if assigned(result^.Next) then begin
      result^.Next^.Previous:=result^.Previous;
     end;
     if assigned(result^.Previous) then begin
      result^.Previous^.Next:=result^.Next;
     end;
     result^.Next:=nil;
     result^.Previous:=nil;
    end;
    procedure ParseBraceBlock(IgnoreAutomaticInsertedSemicolon:boolean);
    begin
     if IgnoreAutomaticInsertedSemicolon and (assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptLBRA)))) then begin
      Pop;
     end;
     if (not assigned(List^)) or (List^^.Token<>ptLBRA) then begin
      SyntaxError('Missed open brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
     AddNewChild(t,ParseToken(t,List));
    end;
    procedure ParseParenthesisBraceBlock(IgnoreAutomaticInsertedSemicolon:boolean);
    begin
     if IgnoreAutomaticInsertedSemicolon and (assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptLPAR)))) then begin
      Pop;
     end;
     if (not assigned(List^)) or (List^^.Token<>ptLPAR) then begin
      SyntaxError('Missed open parenthesis brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
     AddNewChild(t,ParseToken(t,List));
    end;
    procedure ParseCurlyBraceBlock(AddCurlyBraceIfNotExist,IgnoreAutomaticInsertedSemicolon:boolean);
    begin
     if IgnoreAutomaticInsertedSemicolon and (assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptLCURL)))) then begin
      Pop;
     end;
     if AddCurlyBraceIfNotExist then begin
      if not assigned(List^) then begin
       SyntaxError('Missed curly brace, expression or statement',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end else begin
      if (not assigned(List^)) or (List^^.Token<>ptLCURL) then begin
       SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
     if List^^.Token=ptLCURL then begin
      AddNewChild(t,ParseToken(t,List));
     end else begin
      if AddCurlyBraceIfNotExist then begin
       Block:=NewToken(t,ptLCURL);
       if List^^.Token in [ptIF,ptELSEIF,ptELSE,ptFOR,ptFOREACH,ptWHILE,ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION,ptFORINDEX,ptFORKEY,ptTRY,ptCATCH,ptFINALLY,ptDO,ptWHEN,ptSWITCH,ptCASE,ptDEFAULT,ptSCOPE,ptCODE] then begin
        AddNewChild(Block,ParseToken(t,List));
       end else begin
        ParseBlock(Block,ptSEMI,ptNONE,List,UntilIncludingToken);
       end;
       AddNewChild(t,Block);
      end else begin
       SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
    end;
    function ScanUntil(const UntilTokens:TPOCATokenTypes):PPOCAToken;
    var Current:PPOCAToken;
    begin
     result:=nil;
     Current:=List^;
     while assigned(Current) and not (Current^.Token in UntilTokens) do begin
      result:=Current;
      case Current^.Token of
       ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA:begin
        Current:=ScanBlockForwards(Current);
       end;
       else begin
        Current:=Current^.Next;
       end;
      end;
     end;
    end;
    procedure ParseUntil(const Dest:PPOCAToken;const UntilTokens:TPOCATokenTypes);
    begin
     while assigned(List^) and not (List^^.Token in UntilTokens) do begin
      AddNewChild(Dest,ParseToken(Dest,List));
     end;
    end;
   var i:TPOCAInt32;
   begin
    t:=List^;
    if assigned(t) then begin
     List^:=t^.Next;
     if assigned(t^.Next) then begin
      t^.Next^.Previous:=nil;
     end;
     if assigned(t^.Previous) then begin
      t^.Previous^.Next:=nil;
     end;
     t^.Next:=nil;
     t^.Previous:=nil;
     t^.Parent:=Parent;
     case t^.Token of
      ptLPAR:begin
       ParseBlock(t,ptRPAR,ptNONE,List,UntilIncludingToken);
      end;
      ptLBRA:begin
       ParseBlock(t,ptRBRA,ptNONE,List,UntilIncludingToken);
      end;
      ptLCURL:begin
       ParseBlock(t,ptRCURL,ptNONE,List,UntilIncludingToken);
      end;
      ptSAFELBRA:begin
       ParseBlock(t,ptSAFERBRA,ptNONE,List,UntilIncludingToken);
      end;
      ptSCOPE:begin
       ParseCurlyBraceBlock(false,true);
      end;
      ptCODE:begin
       ParseCurlyBraceBlock(false,true);
      end;
      ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin // function(...){...} / function SymbolName (...){...}
       begin
        if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptSYMBOLNAME))) then begin
         Pop;
        end;
        if assigned(List^) and (List^^.Token=ptSYMBOLNAME) then begin
         AddNewChild(t,Pop);
        end;
       end;
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptIF:begin // if(...){...} / if(...)... + elseif's + else
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptELSEIF,ptELSE]))) then begin
        Pop;
       end;
       while assigned(List^) and (List^^.Token=ptELSEIF) do begin
        AddNewChild(t,ParseToken(t,List));
        if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptELSEIF,ptELSE]))) then begin
         Pop;
        end;
       end;
       if assigned(List^) and (List^^.Token=ptELSE) then begin
        AddNewChild(t,ParseToken(t,List));
        if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptELSEIF,ptELSE]))) then begin
         Pop;
        end;
       end;
      end;
      ptELSEIF:begin // elseif(...){...} / elseif(...)...
       if (not assigned(Parent)) or (Parent^.Token<>ptIF) then begin
        SyntaxError('Missed owner IF-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        ParseParenthesisBraceBlock(true);
        ParseCurlyBraceBlock(true,true);
        if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptELSEIF,ptELSE]))) then begin
         Pop;
        end;
       end;
      end;
      ptELSE:begin // else{...} / else...
       if (not assigned(Parent)) or (Parent^.Token<>ptIF) then begin
        SyntaxError('Missed owner IF-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        ParseCurlyBraceBlock(true,true);
        if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptELSEIF,ptELSE]))) then begin
         Pop;
        end;
       end;
      end;
      ptFOR:begin // for(...){...} / for(...)...
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptFOREACH:begin // foreach(...){...} / foreach(...)...
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptWHILE:begin // while(...){...} / while(...)...
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptFORINDEX:begin // forindex(...){...} / forindex(...)...
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptFORKEY:begin // forkey(...){...} / forkkey(...)...
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptDO:begin // do{...}while(...)
       ParseCurlyBraceBlock(false,true);
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptWHILE))) then begin
        Pop;
       end;
       if assigned(List^) and (List^^.Token=ptWHILE) then begin
        AddNewChild(t,Pop);
        ParseParenthesisBraceBlock(true);
       end else begin
        SyntaxError('Bad do{}while() block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptTRY:begin // try{...}
       ParseCurlyBraceBlock(false,true);
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptFINALLY,ptCATCH]))) then begin
        Pop;
       end;
       if assigned(List^) and (List^^.Token=ptFINALLY) then begin
        AddNewChild(t,ParseToken(t,List));
       end else begin
        if assigned(List^) and (List^^.Token=ptCATCH) then begin
         AddNewChild(t,ParseToken(t,List));
         if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptFINALLY))) then begin
          Pop;
         end;
         if assigned(List^) and (List^^.Token=ptFINALLY) then begin
          AddNewChild(t,ParseToken(t,List));
         end;
        end else begin
         //SyntaxError('Missed try catch or finally block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
       end;
      end;
      ptCATCH:begin // catch(...){...}
       if (not assigned(Parent)) or (Parent^.Token<>ptTRY) then begin
        SyntaxError('Missed owner TRY-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        if assigned(List^) and (List^^.Token=ptLPAR) then begin
         ParseParenthesisBraceBlock(true);
        end;
        ParseCurlyBraceBlock(false,true);
       end;
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptFINALLY,ptCATCH]))) then begin
        Pop;
       end;
      end;
      ptFINALLY:begin // finally{...}
       if (not assigned(Parent)) or (Parent^.Token<>ptTRY) then begin
        SyntaxError('Missed owner TRY-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        ParseCurlyBraceBlock(false,true);
       end;
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptFINALLY,ptCATCH]))) then begin
        Pop;
       end;
      end;
      ptWHEN:begin
       ParseParenthesisBraceBlock(true);
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptLCURL))) then begin
        Pop;
       end;
       if assigned(List^) and (List^^.Token=ptLCURL) then begin
        Block:=Pop;
        i:=0;
        while assigned(List^) and not (List^^.Token in [ptRCURL]) do begin
         case List^^.Token of
          ptCASE,ptDEFAULT,ptELSE:begin
           case List^^.Token of
            ptDEFAULT,ptELSE:begin
             List^^.Token:=ptDEFAULT;
            end;
            else begin
             List^^.Token:=ptCASE;
            end;
           end;
           AddNewChild(Block,ParseToken(Block,List,ptWHEN));
           if assigned(List^) and (List^^.Token in [ptSEMI,ptAUTOSEMI]) then begin
            Pop;
           end;
           inc(i);
          end;
          else begin
           SyntaxError('case/default expected',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
          end;
         end;
        end;
        if assigned(List^) and (List^^.Token in [ptRCURL]) then begin
         Pop;
        end;
        if i=0 then begin
         SyntaxError('No empty when blocks allowed',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        AddNewChild(t,Block);
       end else begin
        SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptSWITCH:begin
       ParseParenthesisBraceBlock(true);
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptLCURL))) then begin
        Pop;
       end;
       if assigned(List^) and (List^^.Token=ptLCURL) then begin
        Block:=Pop;
        CaseBlock:=nil;
        i:=0;
        while assigned(List^) and not (List^^.Token in [ptRCURL]) do begin
         case List^^.Token of
          ptCASE,ptDEFAULT:begin
           case List^^.Token of
            ptDEFAULT:begin
             List^^.Token:=ptDEFAULT;
            end;
            else begin
             List^^.Token:=ptCASE;
            end;
           end;
           CaseBlock:=ParseToken(Block,List,ptSWITCH);
           AddNewChild(Block,CaseBlock);
           if assigned(List^) and (List^^.Token in [ptSEMI,ptAUTOSEMI]) then begin
            Pop;
           end;
           if assigned(List^) and (List^^.Token in [ptCASE,ptDEFAULT]) then begin
            AddNewChild(CaseBlock^.Right,NewToken(CaseBlock^.Right,ptFALLTHROUGH));
            AddNewChild(CaseBlock^.Right,NewToken(CaseBlock^.Right,ptSEMI));
           end;
           inc(i);
          end;
          else begin
           if assigned(CaseBlock) and assigned(CaseBlock^.Right) and (CaseBlock^.Right^.Token=ptLCURL) then begin
            UntilToIncludeToken:=ScanUntil([ptCASE,ptDEFAULT,ptRCURL]);
            ParseBlock(CaseBlock^.Right,ptNONE,ptNONE,List,UntilToIncludeToken);
            if assigned(List^) and (List^^.Token in [ptSEMI,ptAUTOSEMI]) then begin
             Pop;
            end;
            if assigned(CaseBlock^.Right^.LastChild) and not (CaseBlock^.Right^.LastChild^.Token in [ptSEMI]) then begin
             AddNewChild(CaseBlock^.Right,NewToken(CaseBlock^.Right,ptSEMI));
            end;
            AddNewChild(CaseBlock^.Right,NewToken(CaseBlock^.Right,ptFALLTHROUGH));
            AddNewChild(CaseBlock^.Right,NewToken(CaseBlock^.Right,ptSEMI));
           end else begin
            SyntaxError('Invalid switch block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
           end;
          end;
         end;
        end;
        if assigned(List^) and (List^^.Token in [ptRCURL]) then begin
         Pop;
        end;
        if i=0 then begin
         SyntaxError('No empty switch blocks allowed',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        AddNewChild(t,Block);
       end else begin
        SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptCASE:begin
       if assigned(Parent) and (Parent^.Token=ptLCURL) and (ParentToken in [ptWHEN,ptSWITCH]) then begin
        if ParentToken=ptWHEN then begin
         ParseParenthesisBraceBlock(true);
         ParseCurlyBraceBlock(false,true);
        end else begin
         Block:=NewToken(t,ptLPAR);
         UntilToIncludeToken:=ScanUntil([ptCOLON]);
         if assigned(UntilToIncludeToken) and assigned(UntilToIncludeToken^.Next) and (UntilToIncludeToken^.Next.Token=ptCOLON) then begin
          if assigned(Block) and (Block^.Token=ptLPAR) then begin
           ParseBlock(Block,ptNONE,ptCOLON,List,UntilToIncludeToken);
          end else begin
           ParseBlock(Block,ptNONE,ptNONE,List,UntilToIncludeToken);
          end;
          AddNewChild(t,Block);
          if assigned(List^) and (List^^.Token=ptCOLON) then begin
           Pop;
           AddNewChild(t,NewToken(t,ptLCURL));
          end else begin
           SyntaxError('Invalid SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
          end;
         end else begin
          SyntaxError('Invalid SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end;
{        ParseUntil(Block,[ptCOLON]);
         AddNewChild(t,Block);
         if assigned(List^) and (List^^.Token=ptCOLON) then begin
          Pop;
          AddNewChild(t,NewToken(t,ptLCURL));
         end else begin
          SyntaxError('Invalid SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end;}
        end;
       end else begin
        SyntaxError('Missed owner WHEN-block or SWITCH-BLOCK',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptDEFAULT:begin
       if assigned(Parent) and (Parent^.Token=ptLCURL) and (ParentToken in [ptWHEN,ptSWITCH]) then begin
        if ParentToken=ptWHEN then begin
         ParseCurlyBraceBlock(false,true);
        end else begin
         if assigned(List^) and (List^^.Token=ptCOLON) then begin
          Pop;
          AddNewChild(t,NewToken(t,ptLCURL));
         end else begin
          SyntaxError('Invalid SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end;
        end;
       end else begin
        SyntaxError('Missed owner WHEN-block or SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
     end;
     result:=t;
    end else begin
     result:=nil;
    end;
   end;
   function DoNeedSemicolon(t,n:PPOCAToken):boolean;
   begin
    if (not assigned(n)) or (n^.Token in [ptSEMI,ptAUTOSEMI,ptRPAR,ptRBRA,ptRCURL,ptELSEIF,ptELSE,ptCATCH,ptFINALLY]) then begin
     result:=false;
    end else begin
     case t^.Token of
      ptIF:begin
       result:=(not assigned(t^.Previous)) or (t^.Previous^.Token in [ptSEMI,ptAUTOSEMI]);
      end;
      ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin
       result:=assigned(t^.Previous) and (t^.Previous^.Token=ptASSIGN);
      end;
      ptFOR,ptFOREACH,ptWHILE,ptFORINDEX,ptFORKEY,ptDO,ptWHEN,ptSWITCH:begin
       result:=true;
      end;
      ptSCOPE,ptCODE:begin
       result:=(not assigned(t^.Previous)) or (t^.Previous^.Token in [ptSEMI,ptAUTOSEMI]);
      end;
      ptTRY:begin
       result:=(not assigned(t^.Previous)) or (t^.Previous^.Token in [ptSEMI,ptAUTOSEMI]);
      end;
      else begin
       result:=false;
      end;
     end;
    end;
   end;
  var t:PPOCAToken;
  begin
   t:=Top;
   while assigned(List^) do begin
    if (List^^.Token=EarlyEndToken) or
       (((List^^.Token in [ptRPAR,ptRBRA,ptRCURL,ptELSEIF,ptELSE,ptCASE,ptDEFAULT,ptCATCH,ptFINALLY]) and (List^^.Token<>EndToken)) or ((EndToken in [ptSEMI,ptAUTOSEMI]) and (List^^.Token=ptCOMMA))) then begin
     break;
    end;
    t:=ParseToken(t,List);
    if (t^.Token=EndToken) then begin
     exit;
    end;
    AddNewChild(Top,t);
    if DoNeedSemicolon(t,List^) then begin
     AddNewChild(Top,NewToken(t,ptSEMI));
    end;
    if assigned(UntilIncludingToken) and (t=UntilIncludingToken) then begin
     exit;
    end;
   end;
   if ((EndToken<>ptSEMI) and (EndToken<>ptAUTOSEMI)) and (EndToken<>ptNONE) then begin
    if assigned(List^) then begin
     if List^^.Token<>EndToken then begin
      case List^^.Token of
       ptRPAR:begin
        SyntaxError('Missed matching open parenthesis',List^^.SourceFile,List^^.SourceLine,List^^.SourceColumn);
       end;
       ptRBRA:begin
        SyntaxError('Missed matching open brace',List^^.SourceFile,List^^.SourceLine,List^^.SourceColumn);
       end;
       ptRCURL:begin
        SyntaxError('Missed matching open curly brace',List^^.SourceFile,List^^.SourceLine,List^^.SourceColumn);
       end;
       ptELSEIF,ptELSE:begin
        SyntaxError('Missed owner IF-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       ptCATCH,ptFINALLY:begin
        SyntaxError('Missed owner TRY-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       ptCASE,ptDEFAULT:begin
        SyntaxError('Missed owner WHEN-block or SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
     end;
    end;
    case EndToken of
     ptRPAR:begin
      SyntaxError('Missed closed parenthesis',Top^.SourceFile,Top^.SourceLine,Top^.SourceColumn);
     end;
     ptRBRA:begin
      SyntaxError('Missed closed brace',Top^.SourceFile,Top^.SourceLine,Top^.SourceColumn);
     end;
     ptRCURL:begin
      SyntaxError('Missed closed curly brace',Top^.SourceFile,Top^.SourceLine,Top^.SourceColumn);
     end;
     else begin
      SyntaxError('Unterminated block',Top^.SourceFile,Top^.SourceLine,Top^.SourceColumn);
     end;
    end;
   end;
  end;
  function ParsePrecedences(StartToken,EndToken:PPOCAToken;Level:TPOCAInt32):PPOCAToken;
   function EmptyToken:PPOCAToken;
   begin
    New(result);
    FillChar(result^,sizeof(TPOCAToken),#0);
    result^.TokenListNext:=TokenList;
    TokenList:=result;
    result^.Token:=ptEMPTY;
    result^.Visited:=false;
    result^.SourceFile:=Parser.SourceFile;
    result^.SourceLine:=-1;
    result^.SourceColumn:=-1;
   end;
   procedure PrecedenceChildren(t:PPOCAToken);
   var Top:PPOCAToken;
   begin
    Top:=ParsePrecedences(t^.Children,t^.LastChild,0);
    t^.Children:=Top;
    t^.LastChild:=Top;
   end;
   procedure PrecedenceBlock(Block:PPOCAToken);
   var t:PPOCAToken;
   begin
    t:=Block^.Children;
    while assigned(t) do begin
     case t^.Token of
      ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA:begin
       PrecedenceChildren(t);
      end;
      ptIF,ptELSEIF,ptELSE,ptFOR,ptFOREACH,ptWHILE,ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION,ptFORINDEX,ptFORKEY,ptTRY,ptCATCH,ptFINALLY,ptDO,ptWHEN,ptSWITCH,ptCASE,ptDEFAULT,ptSCOPE,ptCODE:begin
       PrecedenceBlock(t);
      end;
     end;
     t:=t^.Next;
    end;
   end;
   procedure PrecedenceWhen(Block:PPOCAToken);
   var t:PPOCAToken;
   begin
    t:=Block^.Children;
    PrecedenceChildren(t);
    PrecedenceBlock(t^.Next);
   end;
   procedure PrecedenceSwitch(Block:PPOCAToken);
   var t:PPOCAToken;
   begin
    t:=Block^.Children;
    PrecedenceChildren(t);
    PrecedenceBlock(t^.Next);
   end;
  var Rule:TPOCATokenPrecedenceRule;
      Precedence:PPOCATokenPrecedence;
      t,Top,Left,Right,a,b,c,d:PPOCAToken;
  begin
   result:=nil;
   if (Level>=length(POCATokenPrecedences)) and (StartToken<>EndToken) then begin
    if assigned(StartToken) then begin
     SyntaxError('Precedence level overflow',StartToken^.SourceFile,StartToken^.SourceLine,StartToken^.SourceColumn);
    end else begin
     SyntaxError('Precedence level overflow',Parser.SourceFile,-1,-1);
    end;
   end;
   if not (assigned(StartToken) or assigned(EndToken)) then begin
    result:=EmptyToken;
   end else begin
{   if TPOCAInt32(StartToken^.Token)=39 then begin
     writeln(TPOCAInt32(StartToken^.Token));
    end;}
    begin
     if not assigned(EndToken) then begin
      EndToken:=StartToken;
     end;
     if not assigned(StartToken) then begin
      StartToken:=EndToken;
     end;
    end;
    begin
     if assigned(StartToken^.Previous) then begin
      StartToken^.Previous^.Next:=nil;
     end;
     if assigned(EndToken^.Next) then begin
      EndToken^.Next^.Previous:=nil;
     end;
     StartToken^.Previous:=nil;
     EndToken^.Next:=nil;
    end;
    if StartToken=EndToken then begin
     case StartToken^.Token of
      ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA:begin
       PrecedenceChildren(StartToken);
      end;
      ptIF,ptELSEIF,ptELSE,ptFOR,ptFOREACH,ptWHILE,ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION,ptFORINDEX,ptFORKEY,ptTRY,ptCATCH,ptFINALLY,ptDO,ptCASE,ptDEFAULT,ptSCOPE,ptCODE:begin
       PrecedenceBlock(StartToken);
      end;
      ptWHEN:begin
       PrecedenceWhen(StartToken);
      end;
      ptSWITCH:begin
       PrecedenceSwitch(StartToken);
      end;
     end;
     result:=StartToken;
    end else begin
     begin
      if StartToken^.Token in [ptSEMI,ptCOMMA,ptCOLON,ptDOTDOT,ptAUTOSEMI] then begin
       t:=EmptyToken;
       StartToken^.Previous:=t;
       t^.Next:=StartToken;
       StartToken:=t;
      end;
      if EndToken^.Token in [ptSEMI,ptCOMMA,ptCOLON,ptDOTDOT,ptAUTOSEMI] then begin
       t:=EmptyToken;
       EndToken^.Next:=t;
       t^.Previous:=EndToken;
       EndToken:=t;
      end;
     end;
     Precedence:=@POCATokenPrecedences[Level];
     if (ptDOT in Precedence^.Tokens) or
        (ptATDOT in Precedence^.Tokens) or
        (ptSAFEDOT in Precedence^.Tokens) then begin
      case EndToken^.Token of
       ptLPAR,ptLBRA,ptSAFELBRA:begin
        dec(Level);
       end;
      end;
     end;
     begin
      Top:=nil;
      Left:=nil;
      Right:=nil;
      Rule:=POCATokenPrecedences[Level].Rule;
      case Rule of
       prBINARY:begin
        t:=EndToken^.Previous;
        while assigned(t^.Previous) do begin
         if t^.Token in POCATokenPrecedences[Level].Tokens then begin
          if assigned(t^.Previous) then begin
           a:=StartToken;
          end else begin
           a:=nil;
          end;
          b:=t^.Previous;
          c:=t^.Next;
          if assigned(t^.Next) then begin
           d:=EndToken;
          end else begin
           d:=nil;
          end;
          Top:=t;
          Left:=ParsePrecedences(a,b,Level);
          Right:=ParsePrecedences(c,d,Level+1);
          break;
         end;
         t:=t^.Previous;
        end;
       end;
       prREVERSE:begin
        t:=StartToken^.Next;
        while assigned(t^.Next) do begin
         if t^.Token in POCATokenPrecedences[Level].Tokens then begin
          if assigned(t^.Previous) then begin
           a:=StartToken;
          end else begin
           a:=nil;
          end;
          b:=t^.Previous;
          c:=t^.Next;
          if assigned(t^.Next) then begin
           d:=EndToken;
          end else begin
           d:=nil;
          end;
          Top:=t;
          Left:=ParsePrecedences(a,b,Level+1);
          Right:=ParsePrecedences(c,d,Level);
          break;
         end;
         t:=t^.Next;
        end;
       end;
       prPREFIX:begin
        if (StartToken^.Token in POCATokenPrecedences[Level].Tokens) and assigned(StartToken^.Next) then begin
         a:=StartToken^.Children;
         b:=StartToken^.LastChild;
         c:=StartToken^.Next;
         d:=EndToken;
         Top:=StartToken;
         if assigned(a) then begin
          Left:=ParsePrecedences(a,b,0);
         end;
         Right:=ParsePrecedences(c,d,Level);
        end;
       end;
       prSUFFIX:begin
        if (EndToken^.Token in POCATokenPrecedences[Level].Tokens) and assigned(EndToken^.Previous) then begin
         a:=StartToken;
         b:=EndToken^.Previous;
         c:=EndToken^.Children;
         d:=EndToken^.LastChild;
         Top:=EndToken;
         Left:=ParsePrecedences(a,b,Level);
         if assigned(c) then begin
          Right:=ParsePrecedences(c,d,0);
         end;
        end;
       end;
      end;
      if assigned(Top) then begin
       Top^.Rule:=Rule;
       if assigned(Left) then begin
        Left^.Next:=Right;
        Left^.Previous:=nil;
       end;
       Top^.Children:=Left;
       if assigned(Right) then begin
        Right^.Next:=nil;
        Right^.Previous:=Left;
       end;
       Top^.LastChild:=Right;
       Top^.Next:=nil;
       Top^.Previous:=nil;
       result:=Top;
      end else begin
       result:=ParsePrecedences(StartToken,EndToken,Level+1);
      end;
     end;
    end;
   end;
  end;
 var t:PPOCAToken;
 begin
  if assigned(Parser.Tree.Children) then begin
   begin
    t:=Parser.Tree.Children;
    while assigned(t) do begin
     t^.Previous:=nil;
     t:=t^.Next;
    end;
   end;
   begin
    t:=Parser.Tree.Children;
    Parser.Tree.Children:=nil;
    Parser.Tree.LastChild:=nil;
    ParseBlock(@Parser.Tree,ptNONE,ptNONE,@t,nil);
    if assigned(t) then begin
     case t^.Token of
      ptRPAR:begin
       SyntaxError('Missed matching open parenthesis',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptRBRA:begin
       SyntaxError('Missed matching open brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptRCURL:begin
       SyntaxError('Missed matching open curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptELSEIF,ptELSE:begin
       SyntaxError('Missed owner IF-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptCATCH,ptFINALLY:begin
       SyntaxError('Missed owner TRY-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptCASE,ptDEFAULT:begin
       SyntaxError('Missed owner WHEN-block or SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      else begin
       SyntaxError('Invalid source',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
    end;
   end;
   begin
    t:=ParsePrecedences(Parser.Tree.Children,Parser.Tree.LastChild,0);
    t^.Next:=nil;
    t^.Previous:=nil;
    Parser.Tree.Children:=t;
    Parser.Tree.LastChild:=t;
   end;
  end;
 end;
 function ProcessCodeGenerator(var Parser:TPOCAParser):TPOCAValue;
 type TTypeKind=
       (
        tkNONE,
        tkUNKNOWN,
        tkNULL,
        tkNUMBER,
        tkSTRING,
        tkARRAY,
        tkHASH,
        tkCODE
       );
      PTypeKind=^TTypeKind;
      PPOCACodeGeneratorRegister=^TPOCACodeGeneratorRegister;
      TPOCACodeGeneratorRegister=packed record
       TypeKind:TTypeKind;
       InUse,Freeable,IsConst:bytebool;
      end;
      TPOCACodeGeneratorRegisters=array of TPOCACodeGeneratorRegister;
      PPOCACodeGeneratorSwitch=^TPOCACodeGeneratorSwitch;
      TPOCACodeGeneratorSwitch=record
       BreakJumps:array of TPOCAUInt32;
       CountBreakJumps:TPOCAInt32;
       BreakRegisters:array of TPOCACodeGeneratorRegisters;
      end;
      TPOCACodeGeneratorSwitchs=array of TPOCACodeGeneratorSwitch;
      PPOCACodeGeneratorLoop=^TPOCACodeGeneratorLoop;
      TPOCACodeGeneratorLoop=record
       LabelToken:PPOCAToken;
       BreakJumps,ContinueJumps:array of TPOCAUInt32;
       CountBreakJumps,CountContinueJumps:TPOCAInt32;
       BreakRegisters,ContinueRegisters:array of TPOCACodeGeneratorRegisters;
      end;
      TPOCACodeGeneratorLoops=array of TPOCACodeGeneratorLoop;
      TPOCACodeGeneratorScopeSymbolKind=
       (
        sskLOCAL,
        sskREG,
        sskFRAMEVALUE,
        sskVAR
       );
      PPOCACodeGeneratorScopeSymbol=^TPOCACodeGeneratorScopeSymbol;
      TPOCACodeGeneratorScopeSymbol=record
       Name:TPOCARawByteString;
       Kind:TPOCACodeGeneratorScopeSymbolKind;
       TypeKind:TTypeKind;
       Constant:Boolean;
       Freeable:Boolean;
       Register:TPOCAInt32;
       FrameValueLevel:TPOCAInt32;
       FrameValueIndex:TPOCAInt32;
      end;
      TPOCACodeGeneratorScopeSymbols=array of PPOCACodeGeneratorScopeSymbol;
      PPOCACodeGeneratorScope=^TPOCACodeGeneratorScope;
      TPOCACodeGeneratorScope=record
       SymbolNameHashMap:TPOCAStringHashMap;
       Symbols:TPOCACodeGeneratorScopeSymbols;
       CountSymbols:TPOCAInt32;
       BeginCountFrameValues:TPOCAInt32;
      end;
      TPOCACodeGeneratorScopes=array of TPOCACodeGeneratorScope;
      PPOCACodeGeneratorWhenSwitchCaseBlock=^TPOCACodeGeneratorWhenSwitchCaseBlock;
      TPOCACodeGeneratorWhenSwitchCaseBlock=record
       RetryRegisters:TPOCACodeGeneratorRegisters;
       FallthroughRegisters:TPOCACodeGeneratorRegisters;
       Fallthroughs:array of TPOCAUInt32;
       CountFallthroughs:TPOCAInt32;
       JumpRetryPos:TPOCAUInt32;
       HasRetry:boolean;
       HasFallthrough:boolean;
      end;
      TPOCACodeGeneratorWhenSwitchCaseBlocks=array of TPOCACodeGeneratorWhenSwitchCaseBlock;
      PPOCACodeGeneratorBreakContinueScopeKind=^TPOCACodeGeneratorBreakContinueScopeKind;
      TPOCACodeGeneratorBreakContinueScopeKind=(bcskLOOP,bcskSWITCH);
      PPOCACodeGeneratorBreakContinueScope=^TPOCACodeGeneratorBreakContinueScope;
      TPOCACodeGeneratorBreakContinueScope=record
       Kind:TPOCACodeGeneratorBreakContinueScopeKind;
       Index:TPOCAInt32;
      end;
      TPOCACodeGeneratorBreakContinueScopes=array of TPOCACodeGeneratorBreakContinueScope;
      PPOCACodeGenerator=^TPOCACodeGenerator;
      TPOCACodeGenerator=record
       ParentCodeGenerator:PPOCACodeGenerator;
       UsedFrameValues:TPOCABool32;
       LastLine:TPOCAInt32;
       ByteCode:PPOCAUInt32Array;
       ByteCodeSize:TPOCAInt32;
       ByteCodeAllocated:TPOCAInt32;
       Lines:TPOCACodeLines;
       LineCount:TPOCAInt32;
       NextLineIP:TPOCAInt32;
       ArgumentSymbols:PPOCAInt32Array;
       ArgumentLocals:PPOCACodeArguments;
       ArgAllocated:TPOCAUInt32;
       OptionalArgumentSymbols:PPOCAInt32Array;
       OptionalArgumentLocals:PPOCACodeArguments;
       OptionalArgumentValues:PPOCAInt32Array;
       OptionalArgumentAllocated:TPOCAUInt32;
       RestArgSymbolString:TPOCAUTF8String;
       RestArgSym:TPOCAValue;
       HasRestArguments:TPOCABool32;
       HasNestedFunctions:TPOCABool32;
       SwitchTop:TPOCAInt32;
       SwitchAllocated:TPOCAInt32;
       Switchs:TPOCACodeGeneratorSwitchs;
       LoopTop:TPOCAInt32;
       LoopAllocated:TPOCAInt32;
       Loops:TPOCACodeGeneratorLoops;
       Consts:TPOCAValue;
       Scopes:TPOCACodeGeneratorScopes;
       CountScopes:TPOCAInt32;
       Registers:TPOCACodeGeneratorRegisters;
       CountRegisters:TPOCAUInt32;
       LocalArguments:array of TPOCACodeArgument;
       CountLocalArguments:TPOCAInt32;
       LocalArgumentIndex:TPOCAInt32;
       WhenSwitchCaseBlocks:TPOCACodeGeneratorWhenSwitchCaseBlocks;
       CountWhenSwitchCaseBlocks:TPOCAInt32;
       BreakContinueScopes:TPOCACodeGeneratorBreakContinueScopes;
       CountBreakContinueScopes:TPOCAInt32;
       Opcodes:array of TPOCAInt32;
       CountOpcodes:TPOCAInt32;
       HasLocals:TPOCABool32;
       FastFunction:TPOCABool32;
       Constants:array of PPOCAToken;
       ConstantRegisters:array of TPOCAInt32;
       CountConstants:TPOCAInt32;
       CountRegExps:TPOCAInt32;
       CountFrameValues:TPOCAInt32;
       Level:TPOCAUInt64;
      end;
      TScopeState=record
       CountScopes:TPOCAInt32;
       CountSymbols:TPOCAInt32;
       CountFrameValues:TPOCAInt32;
      end;
  function GenerateCode(var Parser:TPOCAParser;Block:PPOCAToken;ArgumentList:PPOCAToken;CodeToken:TPOCATokenType;const CodeName:TPOCARawByteString;const ParentCodeGenerator:PPOCACodeGenerator):TPOCAValue;
  var CodeGenerator:PPOCACodeGenerator;
   function GetRegisters:TPOCACodeGeneratorRegisters;
   begin
    result:=copy(CodeGenerator^.Registers,0,CodeGenerator^.CountRegisters);
   end;
   procedure ClearRegisters;
   var i:TPOCAInt32;
   begin
    for i:=0 to CodeGenerator^.CountRegisters-1 do begin
     CodeGenerator^.Registers[i].TypeKind:=tkUNKNOWN;
    end;
    for i:=0 to CodeGenerator^.CountConstants-1 do begin
     if assigned(CodeGenerator^.Constants[i]) then begin
      case CodeGenerator^.Constants[i]^.Token of
       ptLITERALNUM:begin
        CodeGenerator^.Registers[CodeGenerator^.ConstantRegisters[i]].TypeKind:=tkNUMBER;
       end;
       ptLITERALSTR:begin
        CodeGenerator^.Registers[CodeGenerator^.ConstantRegisters[i]].TypeKind:=tkSTRING;
       end;
       else begin
       end;
      end;
     end;
    end;
   end;
   procedure SetRegisters(const Src:TPOCACodeGeneratorRegisters);
   var i:TPOCAInt32;
   begin
    for i:=0 to CodeGenerator^.CountRegisters-1 do begin
     if i<length(Src) then begin
      CodeGenerator^.Registers[i].TypeKind:=Src[i].TypeKind;
     end;
    end;
   end;
   function AreRegistersEqual(const r1,r2:TPOCACodeGeneratorRegisters;Exact:boolean;Safe:boolean=true):boolean;
   var i:TPOCAInt32;
   begin
    if (Exact and (length(r1)=length(r2))) or ((not Exact) and (length(r1)<=length(r2))) then begin
     result:=true;
     for i:=0 to length(r1)-1 do begin
      if (r1[i].TypeKind<>r2[i].TypeKind) and (Safe or (r1[i].InUse or r2[i].InUse)) then begin
       result:=false;
       break;
      end;
     end;
    end else begin
     result:=false;
    end;
   end;
   procedure CombineRegisters(var Dst:TPOCACodeGeneratorRegisters;const Src:TPOCACodeGeneratorRegisters;Safe:boolean=false);
   var i:TPOCAInt32;
   begin
    for i:=0 to length(Dst)-1 do begin
     if i<length(Src) then begin
      if Dst[i].TypeKind<>Src[i].TypeKind then begin
       Dst[i].TypeKind:=tkUNKNOWN;
      end;
     end else begin
      if Safe then begin
       Dst[i].TypeKind:=tkUNKNOWN;
      end else begin
       break;
      end;
     end;
    end;
   end;
   procedure CombineCurrentRegisters(const Src:TPOCACodeGeneratorRegisters;Safe:boolean=false);
   var i:TPOCAInt32;
   begin
    for i:=0 to CodeGenerator^.CountRegisters-1 do begin
     if i<length(Src) then begin
      if CodeGenerator^.Registers[i].TypeKind<>Src[i].TypeKind then begin
       CodeGenerator^.Registers[i].TypeKind:=tkUNKNOWN;
      end;
     end else begin
      if Safe then begin
       CodeGenerator^.Registers[i].TypeKind:=tkUNKNOWN;
      end else begin
       break;
      end;
     end;
    end;
   end;
   function GetRegisterTypeKind(RegNr:TPOCAInt32):TTypeKind;
   begin
    if (RegNr>=0) and (RegNr<TPOCAInt32(CodeGenerator^.CountRegisters)) then begin
     result:=CodeGenerator^.Registers[RegNr].TypeKind;
    end else begin
     result:=tkUNKNOWN;
    end;
   end;
   function GetRegisterConstant(RegNr:TPOCAInt32):boolean;
   begin
    if (RegNr>=0) and (RegNr<TPOCAInt32(CodeGenerator^.CountRegisters)) then begin
     result:=CodeGenerator^.Registers[RegNr].InUse and CodeGenerator^.Registers[RegNr].IsConst;
    end else begin
     result:=false;
    end;
   end;
   procedure SetRegisterTypeKind(RegNr:TPOCAInt32;TypeKind:TTypeKind);
   begin
    if (RegNr>=0) and (RegNr<TPOCAInt32(CodeGenerator^.CountRegisters)) then begin
     CodeGenerator^.Registers[RegNr].TypeKind:=TypeKind;
    end;
   end;
   function Unary(t:PPOCAToken):boolean; {$ifdef caninline}inline;{$endif}
   begin
    result:=assigned(t^.Children) and (t^.Children=t^.LastChild);
   end;
   function Binary(t:PPOCAToken):boolean; {$ifdef caninline}inline;{$endif}
   begin
    result:=(assigned(t^.Children) and assigned(t^.LastChild)) and (t^.Children^.Next=t^.LastChild);
   end;
   function GetRegister(Freeable,IsConst:boolean):TPOCAInt32;
   var i:TPOCAInt32;
   begin
    for i:=0 to CodeGenerator^.CountRegisters-1 do begin
     if not CodeGenerator^.Registers[i].InUse then begin
      CodeGenerator^.Registers[i].TypeKind:=tkUNKNOWN;
      CodeGenerator^.Registers[i].InUse:=true;
      CodeGenerator^.Registers[i].Freeable:=Freeable;
      CodeGenerator^.Registers[i].IsConst:=IsConst;
      result:=i;
      exit;
     end;
    end;
    if TPOCAInt32(CodeGenerator^.CountRegisters)>=length(CodeGenerator^.Registers) then begin
     if CodeGenerator^.CountRegisters=0 then begin
      SetLength(CodeGenerator^.Registers,16);
     end else begin
      SetLength(CodeGenerator^.Registers,CodeGenerator^.CountRegisters shl 1);
     end;
    end;
    result:=CodeGenerator^.CountRegisters;
    CodeGenerator^.Registers[result].TypeKind:=tkUNKNOWN;
    CodeGenerator^.Registers[result].InUse:=true;
    CodeGenerator^.Registers[result].Freeable:=Freeable;
    CodeGenerator^.Registers[result].IsConst:=IsConst;
    inc(CodeGenerator^.CountRegisters);
   end;
   procedure FreeRegister(var RegNr:TPOCAInt32;Force:boolean=false);
   begin
    if ((RegNr>=0) and (RegNr<TPOCAInt32(CodeGenerator^.CountRegisters))) and (Force or CodeGenerator^.Registers[RegNr].Freeable) then begin
     CodeGenerator^.Registers[RegNr].TypeKind:=tkUNKNOWN;
     CodeGenerator^.Registers[RegNr].InUse:=false;
     CodeGenerator^.Registers[RegNr].IsConst:=false;
     RegNr:=-1;
    end;
   end;
   procedure Emit(Value:TPOCAUInt32);
   var NewSize:TPOCAInt32;
       NewByteCode:TPOCAPointer;
   begin
    if CodeGenerator^.ByteCodeSize>=CodeGenerator^.ByteCodeAllocated then begin
     NewSize:=CodeGenerator^.ByteCodeAllocated;
     while CodeGenerator^.ByteCodeSize>=NewSize do begin
      inc(NewSize,NewSize);
     end;
     GetMem(NewByteCode,NewSize*sizeof(TPOCAUInt32));
     FillChar(NewByteCode^,NewSize*sizeof(TPOCAUInt32),#0);
     if assigned(CodeGenerator^.ByteCode) then begin
      Move(CodeGenerator^.ByteCode^,NewByteCode^,CodeGenerator^.ByteCodeSize*sizeof(TPOCAUInt32));
      FreeMem(CodeGenerator^.ByteCode);
     end;
     CodeGenerator^.ByteCode:=NewByteCode;
     CodeGenerator^.ByteCodeAllocated:=NewSize;
    end;
    CodeGenerator^.ByteCode^[CodeGenerator^.ByteCodeSize]:=Value;
    inc(CodeGenerator^.ByteCodeSize);
   end;
   procedure PeepholeOptimize;
   var Opcode:TPOCAUInt32;
   begin
    while (CodeGenerator^.ByteCodeSize>0) and (CodeGenerator^.CountOpcodes>0) do begin
     Opcode:=CodeGenerator^.ByteCode^[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-1]];
     case Opcode and $ff of
      popLOADNULL:begin
      end;
     end;
{    case Opcode and $ff of
      popPOP:begin
       if CodeGenerator^.CountOpcodes>1 then begin
        case CodeGenerator^.ByteCode^[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-2]] and $ff of
         popPUSHREG,popGETLOCAL,popGETLOCALVALUE,popGETOUTERVALUE,popPUSHZERO,popPUSHONE,popPUSHCONST,popPUSHEND,popGETLENGTH,popGETMEMBER,popSAFEGETMEMBER:begin
          dec(CodeGenerator^.CountOpcodes,2);
          CodeGenerator^.ByteCodeSize:=CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes];
          continue;
         end;
         popINCREG,popDECREG:begin
          if CodeGenerator^.CountOpcodes>2 then begin
           case CodeGenerator^.ByteCode^[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-3]] and $ff of
            popPUSHREG:begin
             CodeGenerator^.ByteCode^[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-3]]:=CodeGenerator^.ByteCode^[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-2]];
             dec(CodeGenerator^.CountOpcodes,2);
             CodeGenerator^.ByteCodeSize:=CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes];
             continue;
            end;
           end;
          end;
         end;
        end;
       end;
      end;
     end;}
     break;
    end;
   end;
   procedure EmitOpcode(Opcode:TPOCAUInt32); overload;
   begin
    PeepholeOptimize;
    if CodeGenerator^.CountOpcodes>=length(CodeGenerator^.Opcodes) then begin
     if CodeGenerator^.CountOpcodes=0 then begin
      SetLength(CodeGenerator^.Opcodes,1024);
     end else begin
      SetLength(CodeGenerator^.Opcodes,CodeGenerator^.CountOpcodes shl 1);
     end;
    end;
    CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes]:=CodeGenerator^.ByteCodeSize;
    inc(CodeGenerator^.CountOpcodes);
    Emit(Opcode);
   end;
   procedure EmitImmediate(Opcode,Immediate:TPOCAUInt32);
   begin
    EmitOpcode((Opcode and $ff) or ((Immediate and $ffffff) shl 8));
   end;
   procedure EmitOpcode(Opcode,Operand:TPOCAUInt32); overload;
   begin
    EmitImmediate(Opcode,1);
    Emit(Operand);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB:TPOCAUInt32); overload;
   begin
    EmitImmediate(Opcode,2);
    Emit(OperandA);
    Emit(OperandB);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC:TPOCAUInt32); overload;
   begin
    EmitImmediate(Opcode,3);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC,OperandD:TPOCAUInt32); overload;
   begin
    EmitImmediate(Opcode,4);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
    Emit(OperandD);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC,OperandD,OperandE:TPOCAUInt32); overload;
   begin
    EmitImmediate(Opcode,5);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
    Emit(OperandD);
    Emit(OperandE);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC,OperandD,OperandE,OperandF:TPOCAUInt32); overload;
   begin
    EmitImmediate(Opcode,6);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
    Emit(OperandD);
    Emit(OperandE);
    Emit(OperandF);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC,OperandD,OperandE,OperandF,OperandG:TPOCAUInt32); overload;
   begin
    EmitImmediate(Opcode,7);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
    Emit(OperandD);
    Emit(OperandE);
    Emit(OperandF);
    Emit(OperandG);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC,OperandD,OperandE,OperandF,OperandG,OperandH:TPOCAUInt32); overload;
   begin
    EmitImmediate(Opcode,8);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
    Emit(OperandD);
    Emit(OperandE);
    Emit(OperandF);
    Emit(OperandG);
    Emit(OperandH);
   end;
   procedure EmitGetMember(OperandA,OperandB,OperandC,OperandD,OperandE:TPOCAUInt32);
   begin
    if (POCAGetStringValue(Context,POCAArrayGet(CodeGenerator^.Consts,OperandC))='length') or
       (POCAArrayGet(CodeGenerator^.Consts,OperandC).CastedUInt64=Context^.Instance^.Globals.LengthStringReference.CastedUInt64) then begin
     EmitImmediate(popGETLENGTH,5);
    end else begin
     EmitImmediate(popGETMEMBER,5);
    end;
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
    Emit(OperandD);
    Emit(OperandE);
   end;
   function NewConstant(c:TPOCAValue):TPOCAInt32;
   begin
    POCAArrayPush(CodeGenerator^.Consts,c);
    result:=POCAArraySize(CodeGenerator^.Consts)-1;
    if result>=$10000 then begin
     SyntaxError('Too many constants in code block',Parser.SourceFile,-1,-1);
    end;
   end;
   function InternConstant(c:TPOCAValue):TPOCAInt32;
   var i,n:TPOCAInt32;
       b:TPOCAValue;
   begin
    n:=POCAArraySize(CodeGenerator^.Consts);
    if not POCAIsValueCode(c) then begin
     for i:=0 to n-1 do begin
      b:=POCAArrayGet(CodeGenerator^.Consts,i);
      if ((POCAIsValueNumber(b) and POCAIsValueNumber(c)) and (b.Num=c.Num)) or
         (POCAIsValueNull(b) and POCAIsValueNull(c)) or
         ((POCAIsValueString(b) and POCAIsValueString(c)) and (PPOCAString(POCAGetValueReferencePointer(b))^.Data=PPOCAString(POCAGetValueReferencePointer(c))^.Data)) then begin
       result:=i;
       exit;
      end;
     end;
    end;
    result:=NewConstant(c);
   end;
   function NewLambda(t:PPOCAToken):TPOCAValue;
   var ArgList:PPOCAToken;
       Name:TPOCARawByteString;
   begin
    if not (assigned(t^.Right) and (t^.Right^.Token=ptLCURL)) then begin
     SyntaxError('Bad function definition',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
    end;
    Name:='';
    ArgList:=nil;
    if assigned(t^.Left) then begin
     if t^.Left^.Token=ptSYMBOLNAME then begin
      Name:=t^.Left^.Str;
      if t^.Left^.Next^.Token=ptLPAR then begin
       if assigned(t^.Left^.Next^.Left) then begin
        ArgList:=t^.Left^.Next^.Left;
       end;
      end else begin
       SyntaxError('Bad function definition',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end else if (t^.Left^.Token=ptLPAR) and assigned(t^.Left^.Left) then begin
      ArgList:=t^.Left^.Left;
     end;
    end;
    result:=GenerateCode(Parser,t^.Right^.Left,ArgList,t^.Token,Name,CodeGenerator);
   end;
   function FindScopeSymbol(t:PPOCAToken;const SearchOnlyParents:Boolean=false;const MultiLevels:Boolean=true;const SingleScope:Boolean=false):PPOCACodeGeneratorScopeSymbol;
   var CurrentCodeGenerator:PPOCACodeGenerator;
       i:TPOCAInt32;
       HashMap:TPOCAStringHashMap;
       Item:PPOCAStringHashMapItem;
   begin
    if assigned(t) and (t^.Token=ptSYMBOL) then begin
     if SearchOnlyParents then begin
      CurrentCodeGenerator:=CodeGenerator^.ParentCodeGenerator;
     end else begin
      CurrentCodeGenerator:=CodeGenerator;
     end;
     while assigned(CurrentCodeGenerator) do begin
      for i:=CurrentCodeGenerator^.CountScopes-1 downto 0 do begin
       HashMap:=CurrentCodeGenerator^.Scopes[i].SymbolNameHashMap;
       if assigned(HashMap) then begin
        Item:=HashMap.GetKey(t^.Str);
        if assigned(Item) then begin
         result:=CurrentCodeGenerator^.Scopes[i].Symbols[Item^.Value];
         exit;
        end;
       end;
       if SingleScope then begin
        result:=nil;
        exit;
       end;
      end;
      if MultiLevels then begin
       CurrentCodeGenerator:=CurrentCodeGenerator^.ParentCodeGenerator;
      end else begin
       result:=nil;
       exit;
      end;
     end;
    end;
    result:=nil;
   end;
   function ExistScopeSymbol(t:PPOCAToken;const SearchOnlyParents:Boolean=false;const MultiLevels:Boolean=true;const SingleScope:Boolean=false):Boolean;
   begin
    result:=assigned(FindScopeSymbol(t,SearchOnlyParents,MultiLevels,SingleScope));
   end;
   function IsScopeSymbolConstant(t:PPOCAToken;const SearchOnlyParents:Boolean=false;const MultiLevels:Boolean=true;const SingleScope:Boolean=false):Boolean;
   var Symbol:PPOCACodeGeneratorScopeSymbol;
   begin
    Symbol:=FindScopeSymbol(t,SearchOnlyParents,MultiLevels,SingleScope);
    result:=assigned(Symbol) and Symbol^.Constant;
   end;
   function IsScopeSymbolFreeable(t:PPOCAToken;const SearchOnlyParents:Boolean=false;const MultiLevels:Boolean=true;const SingleScope:Boolean=false):Boolean;
   var Symbol:PPOCACodeGeneratorScopeSymbol;
   begin
    Symbol:=FindScopeSymbol(t,SearchOnlyParents,MultiLevels,SingleScope);
    result:=assigned(Symbol) and Symbol^.Freeable;
   end;
   function GetScopeSymbolRegister(t:PPOCAToken;const SearchOnlyParents:Boolean=false;const MultiLevels:Boolean=true;const SingleScope:Boolean=false):TPOCAInt32;
   var Symbol:PPOCACodeGeneratorScopeSymbol;
   begin
    Symbol:=FindScopeSymbol(t,SearchOnlyParents,MultiLevels,SingleScope);
    if assigned(Symbol) then begin
     result:=Symbol^.Register;
    end else begin
     result:=-1;
    end;
   end;
   function GetSymbolName(t:PPOCAToken;const SearchOnlyParents:Boolean=false;const MultiLevels:Boolean=true;const SingleScope:Boolean=false):TPOCARawByteString;
   var Symbol:PPOCACodeGeneratorScopeSymbol;
   begin
    if assigned(t) and (t^.Token=ptSYMBOL) then begin
     Symbol:=FindScopeSymbol(t,SearchOnlyParents,MultiLevels,SingleScope);
     if assigned(Symbol) then begin
      result:=Symbol^.Name;
     end else begin
      result:=t^.Str;
     end;
    end else begin
     result:='';
    end;
   end;
   function DefineScopeSymbol(t:PPOCAToken;const aCanBeOuter,aLetConst,aConstant,aFreeable:Boolean;const aRegister:TPOCAInt32):PPOCACodeGeneratorScopeSymbol;
   var CurrentCodeGenerator:PPOCACodeGenerator;
       i,SymbolIndex:TPOCAInt32;
       HashMap:TPOCAStringHashMap;
       Item:PPOCAStringHashMapItem;
       Kind:TPOCACodeGeneratorScopeSymbolKind;
   begin
    if aLetConst then begin
     if aCanBeOuter then begin
      Kind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
     end else begin
      Kind:=TPOCACodeGeneratorScopeSymbolKind.sskREG;
     end;
    end else begin
     Kind:=TPOCACodeGeneratorScopeSymbolKind.sskLOCAL;
    end;
    if assigned(t) and (t^.Token=ptSYMBOL) then begin
     CurrentCodeGenerator:=CodeGenerator;
     i:=CurrentCodeGenerator^.CountScopes-1;
     HashMap:=CurrentCodeGenerator^.Scopes[i].SymbolNameHashMap;
     SymbolIndex:=CurrentCodeGenerator^.Scopes[i].CountSymbols;
     Item:=HashMap.GetKey(t^.Str);
     if assigned(Item) then begin
      SyntaxError('Symbol already defined',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      result:=nil;
     end else begin
      Item:=HashMap.NewKey(t^.Str,true);
      Item^.Value:=SymbolIndex;
      inc(CurrentCodeGenerator^.Scopes[i].CountSymbols);
      if length(CurrentCodeGenerator^.Scopes[i].Symbols)<CurrentCodeGenerator^.Scopes[i].CountSymbols then begin
       SetLength(CurrentCodeGenerator^.Scopes[i].Symbols,CurrentCodeGenerator^.Scopes[i].CountSymbols*2);
      end;
      GetMem(CurrentCodeGenerator^.Scopes[i].Symbols[SymbolIndex],SizeOf(TPOCACodeGeneratorScopeSymbol));
      result:=CurrentCodeGenerator^.Scopes[i].Symbols[SymbolIndex];
      Initialize(result^);
      result^.FrameValueLevel:=CurrentCodeGenerator^.Level;
      if Kind=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE then begin
       CurrentCodeGenerator^.UsedFrameValues:=true;
       result^.FrameValueIndex:=CurrentCodeGenerator^.CountFrameValues;
       inc(CurrentCodeGenerator^.CountFrameValues);
      end else begin
       result^.FrameValueIndex:=0;
      end;
      result^.Name:=t^.Str;
      result^.Kind:=Kind;
      result^.TypeKind:=tkUNKNOWN;
      result^.Constant:=aConstant;
      result^.Register:=aRegister;
     end;
    end else begin
     result:=nil;
    end;
   end;
   function FindConstantIndex(t:PPOCAToken;const ForScope:Boolean;const Value:PPOCAValue=nil):TPOCAInt32;
   var c:TPOCAValue;
   begin
    case t^.Token of
     ptNULL:begin
    //c:=POCAValueNull;
      c.CastedUInt64:=POCAValueNullCastedUInt64;
     end;
     ptLITERALSTR:begin
      c:=POCANewUniqueString(Parser.Context,t^.Str);
     end;
     ptSYMBOL:begin
      if ForScope then begin
       c:=POCAInternSymbol(Parser.Context,Instance,POCANewUniqueString(Parser.Context,GetSymbolName(t)));
      end else begin
       c:=POCAInternSymbol(Parser.Context,Instance,POCANewUniqueString(Parser.Context,t^.Str));
      end;
     end;
     ptSUPERCODESYMBOL:begin
      if length(CodeName)>0 then begin
       c:=POCAInternSymbol(Parser.Context,Instance,POCANewUniqueString(Parser.Context,CodeName));
      end else begin
     //c:=POCAValueNull;
       c.CastedUInt64:=POCAValueNullCastedUInt64;
       SyntaxError('Invalid super syntax usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
     ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin
      c:=NewLambda(t);
     end;
     ptLITERALNUM:begin
      c:=POCANumber(t^.Num);
     end;
     else begin
    //c:=POCAValueNull;
      c.CastedUInt64:=POCAValueNullCastedUInt64;
      SyntaxError('Invalid constant',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
    end;
    if assigned(Value) then begin
     Value^:=c;
    end;
    result:=InternConstant(c);
   end;
   function DefineArgument(t:PPOCAToken):TPOCAInt32;
   begin
    if t^.Token=ptLPAR then begin
     if t^.Rule=prSUFFIX then begin
      SyntaxError('Function calls can''t be default arguments',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
     result:=DefineArgument(t^.Right);
    end else begin
     if (t^.Token in [ptMINUS,ptNEG]) and (assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM)) then begin
      t^.Right^.Num:=-t^.Right^.Num;
      result:=DefineArgument(t^.Right);
     end else if (t^.Token in [ptCAT,ptBNOT]) and (assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM)) then begin
      t^.Right^.Num:=not TPOCAInt64(trunc(t^.Right^.Num));
      result:=DefineArgument(t^.Right);
     end else if (t^.Token in [ptPLUS,ptNUM]) and (assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM)) then begin
      result:=DefineArgument(t^.Right);
     end else begin
      result:=FindConstantIndex(t,true);
     end;
    end;
   end;
   procedure ScopeStart;
   var OldCount,NewCount,i:TPOCAInt32;
       Scope:PPOCACodeGeneratorScope;
   begin
    OldCount:=length(CodeGenerator^.Scopes);
    if CodeGenerator^.CountScopes>=OldCount then begin
     if CodeGenerator^.CountScopes=0 then begin
      NewCount:=8;
     end else begin
      NewCount:=CodeGenerator^.CountScopes*2;
     end;
     SetLength(CodeGenerator^.Scopes,NewCount);
     for i:=OldCount to NewCount-1 do begin
      Scope:=@CodeGenerator^.Scopes[i];
      Scope^.SymbolNameHashMap:=nil;
      Scope^.Symbols:=nil;
      Scope^.CountSymbols:=0;
     end;
    end;
    Scope:=@CodeGenerator^.Scopes[CodeGenerator^.CountScopes];
    inc(CodeGenerator^.CountScopes);
    Scope^.SymbolNameHashMap:=TPOCAStringHashMap.Create(true);
    Scope^.Symbols:=nil;
    Scope^.CountSymbols:=0;
    Scope^.BeginCountFrameValues:=CodeGenerator^.CountFrameValues;
   end;
   procedure ScopeEnd;
   var ScopeIndex,Index,Reg:TPOCAInt32;
       Scope:PPOCACodeGeneratorScope;
       Symbol:PPOCACodeGeneratorScopeSymbol;
   begin
    dec(CodeGenerator^.CountScopes);
    ScopeIndex:=CodeGenerator^.CountScopes;
    Scope:=@CodeGenerator^.Scopes[ScopeIndex];
    begin
     for Index:=0 to Scope^.CountSymbols-1 do begin
      Symbol:=Scope^.Symbols[Index];
      Scope^.Symbols[Index]:=nil;
      if assigned(Symbol) then begin
       Reg:=Symbol^.Register;
       if Reg>=0 then begin
        FreeRegister(Reg,true);
       end;
       Finalize(Symbol^);
       FreeMem(Symbol);
      end;
     end;
    end;
    Scope^.Symbols:=nil;
    Scope^.CountSymbols:=0;
    Scope^.BeginCountFrameValues:=0;
    FreeAndNil(Scope^.SymbolNameHashMap);
   end;
   procedure ScopeReset;
   var ScopeIndex,Index,Reg:TPOCAInt32;
       Scope:PPOCACodeGeneratorScope;
       Symbol:PPOCACodeGeneratorScopeSymbol;
   begin
    if CodeGenerator^.CountScopes>0 then begin
     ScopeIndex:=CodeGenerator^.CountScopes-1;
     Scope:=@CodeGenerator^.Scopes[ScopeIndex];
     begin
      for Index:=0 to Scope^.CountSymbols-1 do begin
       Symbol:=Scope^.Symbols[Index];
       Scope^.Symbols[Index]:=nil;
       if assigned(Symbol) then begin
        Reg:=Symbol^.Register;
        if Reg>=0 then begin
         FreeRegister(Reg,true);
        end;
        Finalize(Symbol^);
        FreeMem(Symbol);
       end;
      end;
     end;
     Scope^.Symbols:=nil;
     Scope^.CountSymbols:=0;
     CodeGenerator^.CountFrameValues:=Scope^.BeginCountFrameValues;
     Scope^.SymbolNameHashMap.Clear;
    end;
   end;
   procedure ScopePush(out aScopeState:TScopeState); // Save current scope state
   begin
    aScopeState.CountScopes:=CodeGenerator^.CountScopes;
    if CodeGenerator^.CountScopes>0 then begin
     aScopeState.CountSymbols:=CodeGenerator^.Scopes[CodeGenerator^.CountScopes-1].CountSymbols;
    end else begin
     aScopeState.CountSymbols:=0;
    end;
    aScopeState.CountFrameValues:=CodeGenerator^.CountFrameValues;
   end;
   procedure ScopePop(var aScopeState:TScopeState); // Restore current scope state
   var Index,Reg:TPOCAInt32;
       Scope:PPOCACodeGeneratorScope;
       Symbol:PPOCACodeGeneratorScopeSymbol;
       Item:PPOCAStringHashMapItem;
   begin
    if (aScopeState.CountScopes>=0) and (aScopeState.CountScopes<CodeGenerator^.CountScopes) then begin
     for Index:=CodeGenerator^.CountScopes-1 downto aScopeState.CountScopes do begin
      FreeAndNil(CodeGenerator^.Scopes[Index].SymbolNameHashMap);
      CodeGenerator^.Scopes[Index].Symbols:=nil;
      CodeGenerator^.Scopes[Index].CountSymbols:=0;
     end;
     SetLength(CodeGenerator^.Scopes,aScopeState.CountScopes);
     CodeGenerator^.CountScopes:=aScopeState.CountScopes;
    end;
    if CodeGenerator^.CountScopes>0 then begin
     // Delete newer symbols from the symbol hashmap
     Scope:=@CodeGenerator^.Scopes[CodeGenerator^.CountScopes-1];
     if (aScopeState.CountSymbols>=0) and (aScopeState.CountSymbols<Scope^.CountSymbols) then begin
      for Index:=Scope^.CountSymbols-1 downto aScopeState.CountSymbols do begin
       Symbol:=Scope^.Symbols[Index];
       Scope^.Symbols[Index]:=nil;
       if assigned(Symbol) then begin
        Item:=Scope^.SymbolNameHashMap.GetKey(Symbol^.Name);
        if assigned(Item) then begin
         Scope^.SymbolNameHashMap.DeleteKey(Item);
        end;
        Reg:=Symbol^.Register;
        if Reg>=0 then begin
         FreeRegister(Reg,true);
        end;
        Finalize(Symbol^);
        FreeMem(Symbol);
       end;
      end;
      Scope^.CountSymbols:=aScopeState.CountSymbols;
     end;
    end;
    if aScopeState.CountFrameValues>=0 then begin
     CodeGenerator^.CountFrameValues:=aScopeState.CountFrameValues;
    end;
    aScopeState.CountScopes:=-1;
    aScopeState.CountSymbols:=-1;
    aScopeState.CountFrameValues:=-1;
   end;
   procedure ScopeDrop(var aScopeState:TScopeState); // Drop current scope state
   begin
    aScopeState.CountScopes:=-1;
    aScopeState.CountSymbols:=-1;
    aScopeState.CountFrameValues:=-1;
   end;
   function GenerateScalarConstant(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
   var v,i:TPOCAInt32;
       Num:Double;
       Value:TPOCAValue;
   begin
    if OutReg<0 then begin
     OutReg:=GetRegister(true,false);
    end;
    result:=OutReg;
    case t^.Token of
     ptLITERALNUM:begin
      Num:=t^.Num;
      if Num=0 then begin
       EmitOpcode(popLOADZERO,result);
       SetRegisterTypeKind(result,tkNUMBER);
       exit;
      end else if Num=1 then begin
       EmitOpcode(popLOADONE,result);
       SetRegisterTypeKind(result,tkNUMBER);
       exit;
      end else if POCAIsFinite(Num) then begin
       v:=trunc(Num);
       if TPOCAInt32(v)=Num then begin
        EmitOpcode(popLOADINT32,result,TPOCAUInt32(v));
        SetRegisterTypeKind(result,tkNUMBER);
        exit;
       end;
      end;
     end;
     else begin
     end;
    end;
    Value.CastedUInt64:=POCAValueNullCastedUInt64;
    i:=FindConstantIndex(t,true,@Value);
    if POCAIsValueCode(Value) then begin
     EmitOpcode(popLOADCODE,result,i);
     SetRegisterTypeKind(result,tkCODE);
    end else begin
     EmitOpcode(popLOADCONST,result,i);
     case t^.Token of
      ptLITERALNUM:begin
       SetRegisterTypeKind(result,tkNUMBER);
      end;
      ptLITERALSTR:begin
       SetRegisterTypeKind(result,tkSTRING);
      end;
      else begin
       SetRegisterTypeKind(result,tkUNKNOWN);
      end;
     end;
    end;
   end;
   function GenerateNumberConstant(Num:Double;OutReg:TPOCAInt32):TPOCAInt32;
   var v:TPOCAInt32;
   begin
    if OutReg<0 then begin
     OutReg:=GetRegister(true,false);
    end;
    result:=OutReg;
    if Num=0 then begin
     EmitOpcode(popLOADZERO,result);
     SetRegisterTypeKind(result,tkNUMBER);
    end else if Num=1 then begin
     EmitOpcode(popLOADONE,result);
     SetRegisterTypeKind(result,tkNUMBER);
    end else begin
     if POCAIsFinite(Num) then begin
      v:=trunc(Num);
      if TPOCAInt32(v)=Num then begin
       EmitOpcode(popLOADINT32,result,TPOCAUInt32(v));
       SetRegisterTypeKind(result,tkNUMBER);
       exit;
      end;
     end;
     EmitOpcode(popLOADCONST,result,InternConstant(POCANumber(Num)));
     SetRegisterTypeKind(result,tkNUMBER);
    end;
   end;
   function DeleteSymbolRegister(t:PPOCAToken;Depth:TPOCAInt32):boolean;
   var HashMap:TPOCAStringHashMap;
       Item:PPOCAStringHashMapItem;
       i,r:TPOCAInt32;
       SymbolIndex:TPOCAInt32;
       Symbol:PPOCACodeGeneratorScopeSymbol;
   begin
    result:=false;
    if t^.Token=ptSYMBOL then begin
     for i:=CodeGenerator^.CountScopes-1 downto 0 do begin
      if Depth<1 then begin
       break;
      end;
      dec(Depth);
      HashMap:=CodeGenerator^.Scopes[i].SymbolNameHashMap;
      if assigned(HashMap) then begin
       Item:=HashMap.GetKey(t^.Str);
       if assigned(Item) then begin
        SymbolIndex:=Item^.Value;
        Symbol:=CodeGenerator^.Scopes[i].Symbols[SymbolIndex];
        r:=Symbol^.Register;
        Symbol^.Name:='';
        Symbol^.Constant:=false;
        Symbol^.Freeable:=false;
        Symbol^.Register:=-1;
        HashMap.DeleteKey(Item);
        FreeRegister(r,true);
        result:=true;
        break;
       end;
      end;
     end;
    end;
   end;
   procedure CollectConstant(t:PPOCAToken);
   var i,r:TPOCAInt32;
       c:PPOCAToken;
   begin
    for i:=0 to CodeGenerator^.CountConstants-1 do begin
     c:=CodeGenerator^.Constants[i];
     if c=t then begin
      exit;
     end else if c^.Token=t^.Token then begin
      case c^.Token of
       ptLITERALNUM:begin
        if c^.Num=t^.Num then begin
         exit;
        end;
       end;
       ptLITERALSTR:begin
        if c^.Str=t^.Str then begin
         exit;
        end;
       end;
      end;
     end;
    end;
    if CodeGenerator^.CountConstants>=length(CodeGenerator^.Constants) then begin
     if CodeGenerator^.CountConstants=0 then begin
      SetLength(CodeGenerator^.Constants,1024);
      SetLength(CodeGenerator^.ConstantRegisters,1024);
     end else begin
      SetLength(CodeGenerator^.Constants,CodeGenerator^.CountConstants shl 1);
      SetLength(CodeGenerator^.ConstantRegisters,CodeGenerator^.CountConstants shl 1);
     end;
    end;
    r:=GenerateScalarConstant(t,GetRegister(false,false));
    CodeGenerator^.Constants[CodeGenerator^.CountConstants]:=t;
    CodeGenerator^.ConstantRegisters[CodeGenerator^.CountConstants]:=r;
    case t^.Token of
     ptLITERALNUM:begin
      SetRegisterTypeKind(r,tkNUMBER);
     end;
     ptLITERALSTR:begin
      SetRegisterTypeKind(r,tkSTRING);
     end;
     else begin
      SetRegisterTypeKind(r,tkUNKNOWN);
     end;
    end;
    if (r>=0) and (r<TPOCAInt32(CodeGenerator^.CountRegisters)) then begin
     CodeGenerator^.Registers[r].InUse:=true;
     CodeGenerator^.Registers[r].Freeable:=false;
     CodeGenerator^.Registers[r].IsConst:=true;
    end;
    inc(CodeGenerator^.CountConstants);
   end;
   procedure CollectConstants(t:PPOCAToken);
    procedure ScanToken(t,p:PPOCAToken);
    begin
     if assigned(t) and not t^.Visited then begin
      t^.Visited:=true;
      case t^.Token of
       ptLITERALNUM,ptLITERALSTR:begin
        if (not assigned(p)) or (p^.Token<>ptASSIGN) then begin
         CollectConstant(t);
        end;
       end;
      end;
      case t^.Token of
       ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin
        CodeGenerator^.HasNestedFunctions:=true;
       end;
       else begin
        if assigned(t^.Children) and (t^.Children<>t^.LastChild) and (t^.Children<>t^.Next) then begin
         ScanToken(t^.Children,t);
        end;
        if assigned(t^.LastChild) and (t^.LastChild<>t^.Next) then begin
         ScanToken(t^.LastChild,t);
        end;
        if assigned(t^.Next) then begin
         ScanToken(t^.Next,t);
        end;
       end;
      end;
     end;
    end;
   begin
    if assigned(t) then begin
     ResetTokenVisited;
     ScanToken(t,nil);
    end;
   end;
   function FindConstantRegister(t:PPOCAToken):TPOCAInt32;
   var i:TPOCAInt32;
       c:PPOCAToken;
   begin
    result:=-1;
    for i:=0 to CodeGenerator^.CountConstants-1 do begin
     c:=CodeGenerator^.Constants[i];
     if c=t then begin
      result:=CodeGenerator^.ConstantRegisters[i];
      exit;
     end else if c^.Token=t^.Token then begin
      case c^.Token of
       ptLITERALNUM:begin
        if c^.Num=t^.Num then begin     
         result:=CodeGenerator^.ConstantRegisters[i];
         exit;
        end;
       end;
       ptLITERALSTR:begin
        if c^.Str=t^.Str then begin
         result:=CodeGenerator^.ConstantRegisters[i];
         exit;
        end;
       end;
      end;
     end;
    end;
   end;
   procedure ScanForNestedFunctions(ta,tb:PPOCAToken);
    procedure ScanToken(t:PPOCAToken);
    begin
     if (not CodeGenerator^.HasNestedFunctions) and (assigned(t) and not t^.Visited) then begin
      t^.Visited:=true;
      case t^.Token of
       ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin
        CodeGenerator^.HasNestedFunctions:=true;
       end else begin
        ScanToken(t^.Children);
        ScanToken(t^.LastChild);
        ScanToken(t^.Previous);
        ScanToken(t^.Next);
        ScanToken(t^.Left);
        ScanToken(t^.Right);
       end;
      end;
     end;
    end;
   begin
    ResetTokenVisited;
    ScanToken(ta);
    ScanToken(tb);
   end;
   procedure ProcessConstantFolding(t:PPOCAToken);
    procedure ScanToken(t,p:PPOCAToken;IsExpression:boolean);
     function ToNum(l:PPOCAToken):double;
     var OK:TPasDblStrUtilsBoolean;
     begin
      case l^.Token of
       ptLITERALNUM:begin
        result:=l^.Num;
       end;
       ptLITERALSTR:begin
        OK:=false;
        result:=ConvertStringToDouble(l^.Str,rmNearest,@OK);
        if not OK then begin
         result:=NAN;
        end;
       end;
       else begin
        result:=NAN;
       end;
      end;
     end;
     function ToStr(l:PPOCAToken):TPOCARawByteString;
     begin
      case l^.Token of
       ptLITERALNUM:begin
        result:=POCADoubleToString(l^.Num);
       end;
       ptLITERALSTR:begin
        result:=l^.Str;
       end;
       else begin
        result:='';
       end;
      end;
     end;
    var n:double;
    begin
     if assigned(t) and not t^.Visited then begin
      t^.Visited:=true;
      if assigned(p) then begin
      end;
      case t^.Token of
       ptASSIGN,ptPLUSEQ,ptMINUSEQ,ptMULEQ,ptDIVEQ,ptCATEQ,ptBANDEQ,ptBOREQ,ptBXOREQ,ptBSHLEQ,ptBSHREQ,ptBUSHREQ,ptMODEQ,ptPOWEQ:begin
        case t^.Rule of
         prREVERSE:begin
          ScanToken(t^.Right,t,true);
          ScanToken(t^.Left,t,false);
         end;
         else begin
          ScanToken(t^.Children,t,false);
          ScanToken(t^.LastChild,t,false);
          ScanToken(t^.Next,t,false);
         end;
        end;
       end;
       ptLPAR:begin
        if IsExpression and not (Binary(t) or not assigned(t^.Right)) then begin
         ScanToken(t^.Left,t,true);
         ScanToken(t^.Right,t,true);
         if assigned(t^.Right) and (t^.Right^.Token<>ptREGEXP) then begin
          if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=t^.Left^.Num;
           t^.Left^.Token:=ptEMPTY;
          end else if assigned(t^.Right) and (t^.Right^.Token=ptLITERALSTR) then begin
           t^.Token:=ptLITERALSTR;
           t^.Str:=t^.Left^.Str;
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
        end else begin
         ScanToken(t^.Left,t,false);
         ScanToken(t^.Right,t,false);
        end;
       end;
       ptPLUS:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ToNum(t^.Left);
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ToNum(t^.Left)+ToNum(t^.Right);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptMINUS:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=-ToNum(t^.Left);
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ToNum(t^.Left)-ToNum(t^.Right);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptMUL:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ToNum(t^.Left)*ToNum(t^.Right);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptDIV:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           n:=ToNum(t^.Right);
           if n<>0 then begin
            t^.Token:=ptLITERALNUM;
            t^.Num:=ToNum(t^.Left)/n;
            t^.Left^.Token:=ptEMPTY;
            t^.Right^.Token:=ptEMPTY;
           end;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptMOD:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           n:=ToNum(t^.Right);
           if n<>0 then begin
            t^.Token:=ptLITERALNUM;
            t^.Num:=Modulo(ToNum(t^.Left),n);
            t^.Left^.Token:=ptEMPTY;
            t^.Right^.Token:=ptEMPTY;
           end;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptPOW:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=Math.Power(ToNum(t^.Left),ToNum(t^.Right));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptCAT:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=TPOCAInt64(not TPOCAInt64(trunc(ToNum(t^.Left))));
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALSTR;
           t^.Str:=ToStr(t^.Left)+ToStr(t^.Right);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptNOT:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(ToNum(t^.Left)=0) and 1;
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptNEG:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=-ToNum(t^.Left);
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptBNOT:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=TPOCAInt64(not TPOCAInt64(trunc(ToNum(t^.Left))));
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptNUM:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ToNum(t^.Left);
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptLT:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num<t^.Right^.Num) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str<t^.Right^.Str) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptLTEQ:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num<=t^.Right^.Num) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str<=t^.Right^.Str) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptGT:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num>t^.Right^.Num) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str>t^.Right^.Str) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptGTEQ:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num>=t^.Right^.Num) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str>=t^.Right^.Str) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptEQ:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num=t^.Right^.Num) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str=t^.Right^.Str) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptNEQ:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num<>t^.Right^.Num) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str<>t^.Right^.Str) and 1;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptCMP:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           if t^.Left^.Num<t^.Right^.Num then begin
            t^.Num:=-1;
           end else if t^.Left^.Num>t^.Right^.Num then begin
            t^.Num:=1;
           end else begin
            t^.Num:=0;
           end;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           if t^.Left^.Str=t^.Right^.Str then begin
            t^.Num:=0;
           end else if t^.Left^.Str<t^.Right^.Str then begin
            t^.Num:=-1;
           end else begin
            t^.Num:=1;
           end;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptBAND:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=TPOCAInt64(System.trunc(ToNum(t^.Left))) and TPOCAInt64(System.trunc(ToNum(t^.Right)));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptBXOR:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=TPOCAInt64(System.trunc(ToNum(t^.Left))) xor TPOCAInt64(System.trunc(ToNum(t^.Right)));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptBOR:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=TPOCAInt64(System.trunc(ToNum(t^.Left))) or TPOCAInt64(System.trunc(ToNum(t^.Right)));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptBSHL:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=TPOCAInt64(System.trunc(ToNum(t^.Left))) shl TPOCAInt32(System.trunc(ToNum(t^.Right)));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptBSHR:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=sar64(TPOCAInt64(System.trunc(ToNum(t^.Left))),TPOCAInt32(System.trunc(ToNum(t^.Right))));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptBUSHR:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=TPOCAInt64(System.trunc(ToNum(t^.Left))) shr TPOCAInt32(System.trunc(ToNum(t^.Right)));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
         end;
        end;
       end;
       ptNULLISHOR:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=t^.Left^.Token;
           t^.Str:=t^.Left^.Str;
           t^.Num:=t^.Left^.Num;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and (t^.Left^.Token=ptNULL)) and
                      (assigned(t^.Right) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=t^.Right^.Token;
           t^.Str:=t^.Right^.Str;
           t^.Num:=t^.Right^.Num;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
         else begin
          ScanToken(t^.Children,t,false);
          ScanToken(t^.LastChild,t,false);
          ScanToken(t^.Next,t,false);
         end;
        end;
       end;
       else begin
        if not (t^.Token in [ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION]) then begin
         ScanToken(t^.Children,t,false);
         ScanToken(t^.LastChild,t,false);
         ScanToken(t^.Next,t,false);
        end;
       end;
      end;
     end;
    end;
   begin
    ResetTokenVisited;
    ScanToken(t,nil,false);
   end;
   procedure FixTargetImmediate(Position:TPOCAInt32);
   begin
    CodeGenerator^.ByteCode[Position]:=CodeGenerator^.ByteCodeSize;
   end;
   function GenerateExpression(t:PPOCAToken;OutReg:TPOCAInt32=-1;DoNeedResult:boolean=false):TPOCAInt32; forward;
   function GenerateBlock(t:PPOCAToken;OutReg:TPOCAInt32=-1;DoNeedResult:boolean=false;NewScope:boolean=true):TPOCAInt32;
   var Expression:PPOCAToken;
       Reg:TPOCAInt32;
   begin
    result:=-1;
    if NewScope then begin
     ScopeStart;
    end;
    try
     while assigned(t) do begin
      if t^.Token in [ptSEMI,ptAUTOSEMI] then begin
       Expression:=t^.Left;
       if assigned(Expression) and ((DoNeedResult and (result<0)) or (Expression^.Token<>ptEMPTY)) then begin
        Reg:=GenerateExpression(Expression,OutReg,DoNeedResult);
        if Reg>=0 then begin
         result:=Reg;
        end;
       end;
       if assigned(Expression) and (Expression^.Token in [ptCONTINUE,ptBREAK,ptTHROW,ptRETURN,ptFALLTHROUGH,ptRETRY]) then begin
        break;
       end else begin
        t:=t^.Right;
       end;
      end else begin
       if (DoNeedResult and (result<0)) or (t^.Token<>ptEMPTY) then begin
        Reg:=GenerateExpression(t,OutReg,DoNeedResult);
        if Reg>=0 then begin
         result:=Reg;
        end;
       end;
       break;
      end;
     end;
    finally
     if NewScope then begin
      ScopeEnd;
     end;
    end;
   end;
   function GenerateCommaBlock(t:PPOCAToken;OutReg:TPOCAInt32=-1;DoNeedResult:boolean=false;NewScope:boolean=true):TPOCAInt32;
   var Expression:PPOCAToken;
       Reg:TPOCAInt32;
   begin
    result:=-1;
    if NewScope then begin
     ScopeStart;
    end;
    try
     while assigned(t) do begin
      if t^.Token=ptCOMMA then begin
       Expression:=t^.Left;
       if assigned(Expression) and ((DoNeedResult and (result<0)) or (Expression^.Token<>ptEMPTY)) then begin
        Reg:=GenerateExpression(Expression,OutReg,DoNeedResult);
        if Reg>=0 then begin
         result:=Reg;
        end;
       end;
       if assigned(Expression) and (Expression^.Token in [ptCONTINUE,ptBREAK,ptTHROW,ptRETURN,ptFALLTHROUGH,ptRETRY]) then begin
        break;
       end else begin
        t:=t^.Right;
       end;
      end else begin
       if (DoNeedResult and (result<0)) or (t^.Token<>ptEMPTY) then begin
        Reg:=GenerateExpression(t,OutReg,DoNeedResult);
        if Reg>=0 then begin
         result:=Reg;
        end;
       end;
       break;
      end;
     end;
    finally
     if NewScope then begin
      ScopeEnd;
     end;
    end;
   end;
   function GenerateExpression(t:PPOCAToken;OutReg:TPOCAInt32=-1;DoNeedResult:boolean=false):TPOCAInt32;
    procedure NewLine(Line:TPOCAInt32);
    begin
     if (CodeGenerator^.LineCount+1)>=length(CodeGenerator^.Lines) then begin
      SetLength(CodeGenerator^.Lines,(CodeGenerator^.LineCount+1)*2);
     end;
     CodeGenerator^.Lines[CodeGenerator^.LineCount].InstructionPointer:=CodeGenerator^.ByteCodeSize;
     CodeGenerator^.Lines[CodeGenerator^.LineCount].Line:=Line;
     inc(CodeGenerator^.LineCount);
    end;
    function GetNumberOp(Op:TPOCAUInt32):TPOCAUInt32;
    begin
     case Op and $ff of
      popNOT:begin
       result:=popN_NOT or (Op and $ffffff00);
      end;
      popMUL:begin
       result:=popN_MUL or (Op and $ffffff00);
      end;
      popADD:begin
       result:=popN_ADD or (Op and $ffffff00);
      end;
      popSUB:begin
       result:=popN_SUB or (Op and $ffffff00);
      end;
      popDIV:begin
       result:=popN_DIV or (Op and $ffffff00);
      end;
      popNEG:begin
       result:=popN_NEG or (Op and $ffffff00);
      end;
      popLT:begin
       result:=popN_LT or (Op and $ffffff00);
      end;
      popLTEQ:begin
       result:=popN_LTEQ or (Op and $ffffff00);
      end;
      popGT:begin
       result:=popN_GT or (Op and $ffffff00);
      end;
      popGTEQ:begin
       result:=popN_GTEQ or (Op and $ffffff00);
      end;
      popEQ:begin
       result:=popN_EQ or (Op and $ffffff00);
      end;
      popNEQ:begin
       result:=popN_NEQ or (Op and $ffffff00);
      end;
      popCMP:begin
       result:=popN_CMP or (Op and $ffffff00);
      end;
      popDEC:begin
       result:=popN_DEC or (Op and $ffffff00);
      end;
      popINC:begin
       result:=popN_INC or (Op and $ffffff00);
      end;
      popBAND:begin
       result:=popN_BAND or (Op and $ffffff00);
      end;
      popBXOR:begin
       result:=popN_BXOR or (Op and $ffffff00);
      end;
      popBOR:begin
       result:=popN_BOR or (Op and $ffffff00);
      end;
      popBNOT:begin
       result:=popN_NOT or (Op and $ffffff00);
      end;
      popBSHL:begin
       result:=popN_BSHL or (Op and $ffffff00);
      end;
      popBSHR:begin
       result:=popN_BSHR or (Op and $ffffff00);
      end;
      popBUSHR:begin
       result:=popN_BUSHR or (Op and $ffffff00);
      end;
      popMOD:begin
       result:=popN_MOD or (Op and $ffffff00);
      end;
      popPOW:begin
       result:=popN_POW or (Op and $ffffff00);
      end;
      popINRANGE:begin
       result:=popN_INRANGE or (Op and $ffffff00);
      end;
      popJIFTRUE:begin
       result:=popN_JIFTRUE or (Op and $ffffff00);
      end;
      popJIFFALSE:begin
       result:=popN_JIFFALSE or (Op and $ffffff00);
      end;
      popJIFTRUELOOP:begin
       result:=popN_JIFTRUELOOP or (Op and $ffffff00);
      end;
      popJIFFALSELOOP:begin
       result:=popN_JIFFALSELOOP or (Op and $ffffff00);
      end;
      else begin
       result:=Op;
      end;
     end;
    end;
    function GenerateBinaryOperation(Op:TPOCAUInt32;t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var r1,r2:TPOCAInt32;
    begin
     if not (assigned(t^.Left) and assigned(t^.Right)) then begin
      SyntaxError('Empty subexpression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     r1:=GenerateExpression(t^.Left,-1,true);
     r2:=GenerateExpression(t^.Right,-1,true);
     if (GetRegisterTypeKind(r1)=tkNUMBER) and (GetRegisterTypeKind(r2)=tkNUMBER) then begin
      EmitOpcode(GetNumberOp(Op),result,r1,r2);
      SetRegisterTypeKind(result,tkNUMBER);
     end else begin
      EmitOpcode(Op,result,r1,r2);
      SetRegisterTypeKind(result,tkUNKNOWN);
     end;
     FreeRegister(r1);
     FreeRegister(r2);
    end;
    function GenerateInOperation(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var rt:PPOCAToken;
        Reg1,Reg2,Reg3:TPOCAInt32;
    begin
     rt:=t^.Right;
     while assigned(rt) and ((rt^.Token=ptLPAR) and (assigned(rt^.Left) and ((rt^.Left=rt^.Right) or not assigned(rt^.Right)))) do begin
      rt:=rt^.Left;
     end;
     if assigned(rt) and ((rt^.Token=ptDOTDOT) and Binary(rt)) then begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      Reg1:=GenerateExpression(t^.Left,-1,true);
      Reg2:=GenerateExpression(rt^.Left,-1,true);
      Reg3:=GenerateExpression(rt^.Right,-1,true);
      EmitOpcode(popINRANGE,result,Reg1,Reg2,Reg3);
      SetRegisterTypeKind(result,tkUNKNOWN);
      FreeRegister(Reg3);
      FreeRegister(Reg2);
      FreeRegister(Reg1);
     end else begin
      result:=GenerateBinaryOperation(popIN,t,OutReg);
     end;
    end;
    function GetLeftValueLocalRegister(t:PPOCAToken):TPOCAInt32;
    var Token:TPOCATokenType;
        Symbol:PPOCACodeGeneratorScopeSymbol;
        SymbolKind:TPOCACodeGeneratorScopeSymbolKind;
    begin
     result:=-1;
     if not assigned(t) then begin
      SyntaxError('Bad left value',Parser.SourceFile,-1,-1);
     end;
     Token:=t^.Token;
     case Token of
      ptLPAR:begin
       if t^.Rule<>prSUFFIX then begin
        result:=GetLeftValueLocalRegister(t^.Left);
       end;
      end;
      ptSYMBOL:begin
       Symbol:=FindScopeSymbol(t,false,true,false);
       if assigned(Symbol) and (Symbol^.Register>=0) then begin
        if Symbol^.Constant then begin
         SyntaxError('Constants are read-only',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        result:=Symbol^.Register;
       end;
      end;
      ptSUPERCODESYMBOL:begin
       SyntaxError('Invalid super syntax usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptVAR,ptLET,ptCONST:begin
       t:=t^.Right;
       while assigned(t) and ((t^.Token=ptLPAR) and (t^.Rule<>prSUFFIX)) do begin
        t:=t^.Left;
       end;
       if assigned(t) and (t^.Token=ptSYMBOL) then begin
        if IsScopeSymbolConstant(t,false,false) then begin
         SyntaxError('Constants are read-only',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        case Token of
         ptVAR:begin
          SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskVAR;
         end;
         else {ptLET,ptCONST:}begin
{         if ExistScopeSymbol(t,false,false,true) then begin
           SyntaxError('Symbol already defined',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
          end else}begin
           if CodeGenerator^.HasNestedFunctions then begin
            SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
           end else begin
            SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskREG;
           end;
          end;
         end;
        end;
        if SymbolKind=TPOCACodeGeneratorScopeSymbolKind.sskREG then begin
         Symbol:=FindScopeSymbol(t,false,true,false);
         if not assigned(Symbol) then begin
          Symbol:=DefineScopeSymbol(t,false,(Token=ptLET) or (Token=ptCONST),Token=ptCONST,false,GetRegister(false,Token=ptCONST));
         end;
         if assigned(Symbol) then begin
          result:=Symbol^.Register;
         end else begin
          result:=-1;
         end;
         exit;
        end else begin
         result:=-1;
         exit;
        end;
       end;
      end;
      else begin
       result:=-1;
      end;
     end;
    end;
    function ProcessLeftValue(t:PPOCAToken;var ConstantIndex,Reg1,Reg2,FrameValueLevel,FrameValueIndex:TPOCAInt32;out Symbol:PPOCACodeGeneratorScopeSymbol):TPOCAUInt32;
    var Token:TPOCATokenType;
        SymbolKind:TPOCACodeGeneratorScopeSymbolKind;
    begin
     result:=0;
     if not assigned(t) then begin
      SyntaxError('Bad left value',Parser.SourceFile,-1,-1);
     end;
     Token:=t^.Token;
     Symbol:=nil;
     case Token of
      ptLPAR:begin
       if t^.Rule<>prSUFFIX then begin
        result:=ProcessLeftValue(t^.Left,ConstantIndex,Reg1,Reg2,FrameValueLevel,FrameValueIndex,Symbol);
        exit;
       end;
      end;
      ptSYMBOL:begin
       Symbol:=FindScopeSymbol(t,false,true,false);
       if assigned(Symbol) and (Symbol^.Kind=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE) then begin
        CodeGenerator^.UsedFrameValues:=true;
        FrameValueLevel:=Symbol^.FrameValueLevel;
        FrameValueIndex:=Symbol^.FrameValueIndex;
        ConstantIndex:=0;
        if FrameValueLevel=CodeGenerator^.Level then begin
         result:=popSETLOCALVALUE;
        end else begin
         result:=popSETOUTERVALUE;
        end;
       end else if assigned(Symbol) and (Symbol^.Register>=0) then begin
        if Symbol^.Constant then begin
         SyntaxError('Constants are read-only',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        Reg1:=Symbol^.Register;
        result:=popCOPY;
       end else begin
        ConstantIndex:=FindConstantIndex(t,true);
        result:=popSETSYM;
       end;
       exit;
      end;
      ptSUPERCODESYMBOL:begin
       SyntaxError('Invalid super syntax usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptDOT:begin
       Reg1:=GenerateExpression(t^.Left,-1,true);
       if assigned(t^.Right) and (t^.Right^.Token=ptPROTOTYPE) then begin
        result:=popSETPROTOTYPE;
       end else if assigned(t^.Right) and (t^.Right^.Token=ptCONSTRUCTOR) then begin
        result:=popSETCONSTRUCTOR;
       end else if assigned(t^.Right) and (t^.Right^.Token=ptHASHKIND) then begin
        result:=popSETHASHKIND;
       end else begin
        ConstantIndex:=FindConstantIndex(t^.Right,false);
        result:=popSETMEMBER;
       end;
       exit;
      end;
      ptSAFEDOT:begin
       SyntaxError('??. is not allowed as lvalue',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptLBRA:begin
       Reg1:=GenerateExpression(t^.Left,-1,true);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       result:=popINSERT;
       exit;
      end;
      ptSAFELBRA:begin
       SyntaxError('?[ is not allowed as lvalue',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptVAR,ptLET,ptCONST:begin
       t:=t^.Right;
       while assigned(t) and ((t^.Token=ptLPAR) and (t^.Rule<>prSUFFIX)) do begin
        t:=t^.Left;
       end;
       if assigned(t) and (t^.Token=ptSYMBOL) then begin
        if IsScopeSymbolConstant(t,false,false) then begin
         SyntaxError('Constants are read-only',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        case Token of
         ptVAR:begin
          SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskVAR;
         end;
         else {ptLET,ptCONST:}begin
          if ExistScopeSymbol(t,false,false,true) then begin
           SyntaxError('Symbol already defined',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
           SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
          end else begin
           if CodeGenerator^.HasNestedFunctions then begin
            SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
           end else begin
            SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskREG;
           end;
          end;
         end;
        end;
        if SymbolKind=TPOCACodeGeneratorScopeSymbolKind.sskREG then begin
         Symbol:=DefineScopeSymbol(t,false,true,Token=ptCONST,false,GetRegister(false,Token=ptCONST));
         if assigned(Symbol) then begin
          Reg1:=Symbol^.Register;
          result:=popCOPY;
          exit;
         end;
        end else begin
         if CodeToken=ptFASTFUNCTION then begin
          SyntaxError('VAR is not allowed in fastfunctions',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end;
         CodeGenerator^.HasLocals:=true;
         Symbol:=DefineScopeSymbol(t,true,(Token=ptLET) or (Token=ptCONST),Token=ptCONST,false,-1);
         if Symbol^.Kind=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE then begin
          CodeGenerator^.UsedFrameValues:=true;
          FrameValueLevel:=Symbol^.FrameValueLevel;
          FrameValueIndex:=Symbol^.FrameValueIndex;
          ConstantIndex:=0;
          if FrameValueLevel=CodeGenerator^.Level then begin
           result:=popSETLOCALVALUE;
          end else begin
           result:=popSETOUTERVALUE;
          end;
         end else begin
          ConstantIndex:=FindConstantIndex(t,true);
          if Token=ptCONST then begin
           result:=popSETCONSTLOCAL;
          end else begin
           result:=popSETLOCAL;
          end;
         end;
         exit;
        end;
       end;
      end;
     end;
     SyntaxError('Bad left value',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
    end;
    procedure GenerateLeftValue(t:PPOCAToken;Reg:TPOCAInt32);
    var AssignOp,ConstantIndex,Reg1,Reg2,FrameValueLevel,FrameValueIndex:TPOCAInt32;
        Symbol:PPOCACodeGeneratorScopeSymbol;
    begin
     ConstantIndex:=0;
     Reg1:=0;
     Reg2:=0;
     FrameValueLevel:=0;
     FrameValueIndex:=0;
     AssignOp:=ProcessLeftValue(t,ConstantIndex,Reg1,Reg2,FrameValueLevel,FrameValueIndex,Symbol);
     case AssignOp and $ff of
      popSETMEMBER:begin
       EmitOpcode(popSETMEMBER,Reg1,ConstantIndex,Reg,$ffffffff);
      end;
      popSETPROTOTYPE:begin
       EmitOpcode(popSETPROTOTYPE,Reg1,Reg);
      end;
      popSETHASHKIND:begin
       EmitOpcode(popSETHASHKIND,Reg1,Reg);
      end;
      popINSERT:begin
       case GetRegisterTypeKind(Reg1) of
        tkARRAY:begin
         EmitOpcode(popARRAYINSERT,Reg1,Reg2,Reg);
        end;
        else begin
         EmitOpcode(popINSERT,Reg1,Reg2,Reg);
        end;
       end;
      end;
      popCOPY:begin
       EmitOpcode(popCOPY,Reg1,Reg);
       SetRegisterTypeKind(Reg1,GetRegisterTypeKind(Reg));
      end;
      popSETLOCAL:begin
       EmitOpcode(popSETLOCAL,ConstantIndex,Reg,$ffffffff);
      end;
      popSETLOCALVALUE:begin
       EmitOpcode(popSETLOCALVALUE,FrameValueIndex,Reg);
       if assigned(Symbol) then begin
        Symbol^.TypeKind:=GetRegisterTypeKind(Reg);
       end;
      end;
      popSETOUTERVALUE:begin
       EmitOpcode(popSETOUTERVALUE,FrameValueLevel,FrameValueIndex,Reg);
       if assigned(Symbol) then begin
        Symbol^.TypeKind:=GetRegisterTypeKind(Reg);
       end;
      end;
      popSETCONSTLOCAL:begin
       EmitOpcode(popSETCONSTLOCAL,ConstantIndex,Reg,$ffffffff);
      end;
      popSETSYM:begin
       EmitOpcode(popSETSYM,ConstantIndex,Reg,$ffffffff);
      end;
      else begin
       EmitOpcode(AssignOp and $ff,ConstantIndex,Reg);
      end;
     end;
    end;
    function GenerateAssignOp(Op:TPOCAInt32;t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var ConstantIndex,Reg1,Reg2,Reg3,FrameValueLevel,FrameValueIndex:TPOCAInt32;
        SetOp:TPOCAUInt32;
        Symbol:PPOCACodeGeneratorScopeSymbol;
    begin
     ConstantIndex:=0;
     Reg1:=-1;
     Reg2:=-1;
     Reg3:=-1;
     SetOp:=ProcessLeftValue(t^.Left,ConstantIndex,Reg1,Reg2,FrameValueLevel,FrameValueIndex,Symbol);
     case SetOp and $ff of
      popSETMEMBER:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitGetMember(result,Reg1,ConstantIndex,$ffffffff,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       Reg3:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg3);
       FreeRegister(Reg3);
       EmitOpcode(popSETMEMBER,Reg1,ConstantIndex,result,$ffffffff);
      end;
      popSETPROTOTYPE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETPROTOTYPE,result,Reg1);
       SetRegisterTypeKind(result,tkUNKNOWN);
       Reg3:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg3);
       FreeRegister(Reg3);
       EmitOpcode(popSETPROTOTYPE,Reg1,result);
      end;
      popSETHASHKIND:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETHASHKIND,result,Reg1);
       SetRegisterTypeKind(result,tkUNKNOWN);
       Reg3:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg3);
       FreeRegister(Reg3);
       EmitOpcode(popSETHASHKIND,Reg1,result);
      end;
      popINSERT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       case GetRegisterTypeKind(Reg1) of
        tkARRAY:begin
         EmitOpcode(popARRAYEXTRACT,result,Reg1,Reg2);
         SetRegisterTypeKind(result,tkUNKNOWN);
         Reg3:=GenerateExpression(t^.Right,-1,true);
         EmitOpcode(Op,result,result,Reg3);
         FreeRegister(Reg3);
         EmitOpcode(popARRAYINSERT,Reg1,Reg2,result);
        end;
        else begin
         EmitOpcode(popEXTRACT,result,Reg1,Reg2);
         SetRegisterTypeKind(result,tkUNKNOWN);
         Reg3:=GenerateExpression(t^.Right,-1,true);
         EmitOpcode(Op,result,result,Reg3);
         FreeRegister(Reg3);
         EmitOpcode(popINSERT,Reg1,Reg2,result);
        end;
       end;
      end;
      popCOPY:begin
       Reg2:=GenerateExpression(t^.Right,-1,true);
       if (GetRegisterTypeKind(Reg1)=tkNUMBER) and (GetRegisterTypeKind(Reg2)=tkNUMBER) then begin
        EmitOpcode(GetNumberOp(Op),Reg1,Reg1,Reg2);
        SetRegisterTypeKind(Reg1,tkNUMBER);
       end else begin
        EmitOpcode(Op,Reg1,Reg1,Reg2);
        SetRegisterTypeKind(Reg1,tkUNKNOWN);
       end;
       FreeRegister(Reg2);
       if OutReg<0 then begin
        result:=Reg1;
       end else begin
        EmitOpcode(popCOPY,OutReg,Reg1);
        SetRegisterTypeKind(OutReg,GetRegisterTypeKind(Reg1));
        result:=OutReg;
       end;
      end;
      popSETLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg2);
       FreeRegister(Reg2);
       EmitOpcode(popSETLOCAL,ConstantIndex,result,$ffffffff);
      end;
      popSETLOCALVALUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCALVALUE,result,FrameValueIndex);
       SetRegisterTypeKind(result,tKUNKNOWN);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg2);
       FreeRegister(Reg2);
       EmitOpcode(popSETLOCALVALUE,FrameValueIndex,result);
       Symbol^.TypeKind:=tkUNKNOWN;
      end;
      popSETOUTERVALUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETOUTERVALUE,result,FrameValueLevel,FrameValueIndex);
       SetRegisterTypeKind(result,tkUNKNOWN);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg2);
       FreeRegister(Reg2);
       EmitOpcode(popSETOUTERVALUE,FrameValueLevel,FrameValueIndex,result);
       Symbol^.TypeKind:=tkUNKNOWN;
      end;
      popSETCONSTLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg2);
       FreeRegister(Reg2);
       EmitOpcode(popSETCONSTLOCAL,ConstantIndex,result,$ffffffff);
      end;
      popSETSYM:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg2);
       FreeRegister(Reg2);
       EmitOpcode(popSETSYM,ConstantIndex,result,$ffffffff);
      end;
      else begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg2);
       FreeRegister(Reg2);
       EmitOpcode(SetOp and $ff,ConstantIndex,result);
      end;
     end;
    end;
    function GenerateElvisAssignOp(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var ConstantIndex,Reg1,Reg2,Reg3,JumpTrue,FrameValueLevel,FrameValueIndex:TPOCAInt32;
        SetOp:TPOCAUInt32;
        Registers:TPOCACodeGeneratorRegisters;
        Symbol:PPOCACodeGeneratorScopeSymbol;
    begin
     ConstantIndex:=0;
     Reg1:=-1;
     Reg2:=-1;
     Reg3:=-1;
     SetOp:=ProcessLeftValue(t^.Left,ConstantIndex,Reg1,Reg2,FrameValueLevel,FrameValueIndex,Symbol);
     case SetOp and $ff of
      popSETMEMBER:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitGetMember(result,Reg1,ConstantIndex,$ffffffff,$ffffffff);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       case GetRegisterTypeKind(result) of
        tkNUMBER:begin
         EmitOpcode(popN_JIFTRUE,0,result);
        end;
        else begin
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       Reg3:=GenerateExpression(t^.Right,result,true);
       if result<>Reg3 then begin
        EmitOpcode(popCOPY,result,Reg3);
        FreeRegister(Reg3);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETMEMBER,Reg1,ConstantIndex,result,$ffffffff);
      end;
      popSETPROTOTYPE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETPROTOTYPE,result,Reg1);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       case GetRegisterTypeKind(result) of
        tkNUMBER:begin
         EmitOpcode(popN_JIFTRUE,0,result);
        end
        else begin
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       Reg3:=GenerateExpression(t^.Right,result,true);
       if result<>Reg3 then begin
        EmitOpcode(popCOPY,result,Reg3);
        FreeRegister(Reg3);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETPROTOTYPE,Reg1,result);
      end;
      popSETHASHKIND:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETHASHKIND,result,Reg1);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       case GetRegisterTypeKind(result) of
        tkNUMBER:begin
         EmitOpcode(popN_JIFTRUE,0,result);
        end;
        else begin
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       Reg3:=GenerateExpression(t^.Right,result,true);
       if result<>Reg3 then begin
        EmitOpcode(popCOPY,result,Reg3);
        FreeRegister(Reg3);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETHASHKIND,Reg1,result);
      end;
      popINSERT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       case GetRegisterTypeKind(Reg1) of
        tkARRAY:begin
         EmitOpcode(popARRAYEXTRACT,result,Reg1,Reg2);
         JumpTrue:=CodeGenerator^.ByteCodeSize+1;
         case GetRegisterTypeKind(result) of
          tkNUMBER:begin
           EmitOpcode(popN_JIFTRUE,0,result);
          end
          else begin
           EmitOpcode(popJIFTRUE,0,result);
          end;
         end;
         Registers:=GetRegisters;
         Reg3:=GenerateExpression(t^.Right,result,true);
         if result<>Reg3 then begin
          EmitOpcode(popCOPY,result,Reg3);
          FreeRegister(Reg3);
         end;
         FixTargetImmediate(JumpTrue);
         CombineCurrentRegisters(Registers);
         EmitOpcode(popARRAYINSERT,Reg1,Reg2,result);
        end;
        else begin
         EmitOpcode(popEXTRACT,result,Reg1,Reg2);
         JumpTrue:=CodeGenerator^.ByteCodeSize+1;
         case GetRegisterTypeKind(result) of
          tkNUMBER:begin
           EmitOpcode(popN_JIFTRUE,0,result);
          end
          else begin
           EmitOpcode(popJIFTRUE,0,result);
          end;
         end;
         Registers:=GetRegisters;
         Reg3:=GenerateExpression(t^.Right,result,true);
         if result<>Reg3 then begin
          EmitOpcode(popCOPY,result,Reg3);
          FreeRegister(Reg3);
         end;
         FixTargetImmediate(JumpTrue);
         CombineCurrentRegisters(Registers);
         EmitOpcode(popINSERT,Reg1,Reg2,result);
        end;
       end;
      end;
      popCOPY:begin
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       case GetRegisterTypeKind(Reg1) of
        tkNUMBER:begin
         EmitOpcode(popN_JIFTRUE,0,Reg1);
        end;
        else begin
         EmitOpcode(popJIFTRUE,0,Reg1);
        end;
       end;
       Registers:=GetRegisters;
       Reg2:=GenerateExpression(t^.Right,Reg1,true);
       if Reg1<>Reg2 then begin
        EmitOpcode(popCOPY,Reg1,Reg2);
        FreeRegister(Reg2);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       if OutReg<0 then begin
        result:=Reg1;
       end else begin
        EmitOpcode(popCOPY,OutReg,Reg1);
        SetRegisterTypeKind(OutReg,GetRegisterTypeKind(Reg1));
        result:=OutReg;
       end;
      end;
      popSETLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       case GetRegisterTypeKind(result) of
        tkNUMBER:begin
         EmitOpcode(popN_JIFTRUE,0,result);
        end
        else begin
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       Reg2:=GenerateExpression(t^.Right,result,true);
       if result<>Reg2 then begin
        EmitOpcode(popCOPY,result,Reg2);
        FreeRegister(Reg2);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETLOCAL,ConstantIndex,result,$ffffffff);
      end;
      popSETLOCALVALUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCALVALUE,result,FrameValueIndex);
       SetRegisterTypeKind(result,tkUNKNOWN);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       case GetRegisterTypeKind(result) of
        tkNUMBER:begin
         EmitOpcode(popN_JIFTRUE,0,result);
        end;
        else begin
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       Reg2:=GenerateExpression(t^.Right,result,true);
       if result<>Reg2 then begin
        EmitOpcode(popCOPY,result,Reg2);
        FreeRegister(Reg2);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETLOCALVALUE,FrameValueIndex,result);
       Symbol^.TypeKind:=GetRegisterTypeKind(result);
      end;
      popSETOUTERVALUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETOUTERVALUE,result,FrameValueLevel,FrameValueIndex);
       SetRegisterTypeKind(result,tkUNKNOWN);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       case GetRegisterTypeKind(result) of
        tkNUMBER:begin
         EmitOpcode(popN_JIFTRUE,0,result);
        end;
        else begin
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       Reg2:=GenerateExpression(t^.Right,result,true);
       if result<>Reg2 then begin
        EmitOpcode(popCOPY,result,Reg2);
        FreeRegister(Reg2);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETOUTERVALUE,FrameValueLevel,FrameValueIndex,result);
       Symbol^.TypeKind:=GetRegisterTypeKind(result);
      end;
      popSETCONSTLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       case GetRegisterTypeKind(result) of
        tkNUMBER:begin
         EmitOpcode(popN_JIFTRUE,0,result);
        end;
        else begin
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       Reg2:=GenerateExpression(t^.Right,result,true);
       if result<>Reg2 then begin
        EmitOpcode(popCOPY,result,Reg2);
        FreeRegister(Reg2);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETCONSTLOCAL,ConstantIndex,result,$ffffffff);
      end;
      popSETSYM:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       case GetRegisterTypeKind(result) of
        tkNUMBER:begin
         EmitOpcode(popN_JIFTRUE,0,result);
        end;
        else begin
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       Reg2:=GenerateExpression(t^.Right,result,true);
       if result<>Reg2 then begin
        EmitOpcode(popCOPY,result,Reg2);
        FreeRegister(Reg2);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETSYM,ConstantIndex,result,$ffffffff);
      end;
      else begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       case GetRegisterTypeKind(result) of
        tkNUMBER:begin
         EmitOpcode(popN_JIFTRUE,0,result);
        end;
        else begin
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       Reg2:=GenerateExpression(t^.Right,result,true);
       if result<>Reg2 then begin
        EmitOpcode(popCOPY,result,Reg2);
        FreeRegister(Reg2);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(SetOp and $ff,ConstantIndex,result);
      end;
     end;
    end;
    function GeneratePostfixDecIncOp(Op:TPOCAInt32;t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var ConstantIndex,Reg1,Reg2,Reg3,FrameValueLevel,FrameValueIndex:TPOCAInt32;
        SetOp:TPOCAUInt32;
        Symbol:PPOCACodeGeneratorScopeSymbol;
    begin
     ConstantIndex:=0;
     Reg1:=-1;
     Reg2:=-1;
     Reg3:=-1;
     SetOp:=ProcessLeftValue(t^.Left,ConstantIndex,Reg1,Reg2,FrameValueLevel,FrameValueIndex,Symbol);
     case SetOp and $ff of
      popSETMEMBER:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitGetMember(result,Reg1,ConstantIndex,$ffffffff,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,Reg2,result);
       EmitOpcode(popSETMEMBER,Reg1,ConstantIndex,Reg2,$ffffffff);
       FreeRegister(Reg2);
      end;
      popSETPROTOTYPE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitOpcode(popGETPROTOTYPE,result,Reg1);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,Reg2,result);
       EmitOpcode(popSETPROTOTYPE,Reg1,Reg2);
       FreeRegister(Reg2);
      end;
      popSETHASHKIND:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitOpcode(popGETHASHKIND,result,Reg1);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,Reg2,result);
       EmitOpcode(popSETHASHKIND,Reg1,Reg2);
       FreeRegister(Reg2);
      end;
      popINSERT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg3:=GetRegister(true,false);
       case GetRegisterTypeKind(Reg1) of
        tkARRAY:begin
         EmitOpcode(popARRAYEXTRACT,result,Reg1,Reg2);
         SetRegisterTypeKind(result,tkUNKNOWN);
         EmitOpcode(Op,Reg3,result);
         EmitOpcode(popARRAYINSERT,Reg1,Reg2,Reg3);
         FreeRegister(Reg3);
        end;
        else begin
         EmitOpcode(popEXTRACT,result,Reg1,Reg2);
         SetRegisterTypeKind(result,tkUNKNOWN);
         EmitOpcode(Op,Reg3,result);
         EmitOpcode(popINSERT,Reg1,Reg2,Reg3);
         FreeRegister(Reg3);
        end;
       end;
      end;
      popCOPY:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popCOPY,result,Reg1);
       SetRegisterTypeKind(result,GetRegisterTypeKind(Reg1));
       if GetRegisterTypeKind(Reg1)=tkNUMBER then begin
        EmitOpcode(GetNumberOp(Op),Reg1,Reg1);
       end else begin
        EmitOpcode(Op,Reg1,Reg1);
       end;
      end;
      popSETLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg1:=GetRegister(true,false);
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,Reg1,result);
       EmitOpcode(popSETLOCAL,ConstantIndex,Reg1,$ffffffff);
       FreeRegister(Reg1);
      end;
      popSETLOCALVALUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg1:=GetRegister(true,false);
       EmitOpcode(popGETLOCALVALUE,result,FrameValueIndex);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,Reg1,result);
       EmitOpcode(popSETLOCALVALUE,FrameValueIndex,Reg1);
       FreeRegister(Reg1);
      end;
      popSETOUTERVALUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg1:=GetRegister(true,false);
       EmitOpcode(popGETOUTERVALUE,result,FrameValueLevel,FrameValueIndex);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,Reg1,result);
       EmitOpcode(popSETOUTERVALUE,FrameValueLevel,FrameValueIndex,Reg1);
       FreeRegister(Reg1);
      end;
      popSETCONSTLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg1:=GetRegister(true,false);
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,Reg1,result);
       EmitOpcode(popSETCONSTLOCAL,ConstantIndex,Reg1,$ffffffff);
       FreeRegister(Reg1);
      end;
      popSETSYM:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg1:=GetRegister(true,false);
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,Reg1,result);
       EmitOpcode(popSETSYM,ConstantIndex,Reg1,$ffffffff);
       FreeRegister(Reg1);
      end;
      else begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg1:=GetRegister(true,false);
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,Reg1,result);
       EmitOpcode(SetOp and $ff,ConstantIndex,Reg1);
       FreeRegister(Reg1);
      end;
     end;
    end;
    function GeneratePrefixDecIncOp(Op:TPOCAInt32;t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var ConstantIndex,Reg1,Reg2,Reg3,FrameValueLevel,FrameValueIndex:TPOCAInt32;
        SetOp:TPOCAUInt32;
        Symbol:PPOCACodeGeneratorScopeSymbol;
    begin
     ConstantIndex:=0;
     Reg1:=-1;
     Reg2:=-1;
     Reg3:=-1;
     SetOp:=ProcessLeftValue(t^.Right,ConstantIndex,Reg1,Reg2,FrameValueLevel,FrameValueIndex,Symbol);
     case SetOp and $ff of
      popSETMEMBER:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitGetMember(result,Reg1,ConstantIndex,$ffffffff,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETMEMBER,Reg1,ConstantIndex,result,$ffffffff);
      end;
      popSETPROTOTYPE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitOpcode(popGETPROTOTYPE,result,Reg1);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETPROTOTYPE,Reg1,result);
      end;
      popSETHASHKIND:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitOpcode(popGETHASHKIND,result,Reg1);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETHASHKIND,Reg1,result);
      end;
      popINSERT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg3:=GetRegister(true,false);
       case GetRegisterTypeKind(Reg1) of
        tkARRAY:begin
         EmitOpcode(popARRAYEXTRACT,result,Reg1,Reg2);
         SetRegisterTypeKind(result,tkUNKNOWN);
         EmitOpcode(Op,result,result);
         EmitOpcode(popARRAYINSERT,Reg1,Reg2,result);
        end;
        else begin
         EmitOpcode(popEXTRACT,result,Reg1,Reg2);
         SetRegisterTypeKind(result,tkUNKNOWN);
         EmitOpcode(Op,result,result);
         EmitOpcode(popINSERT,Reg1,Reg2,result);
        end;
       end;
      end;
      popCOPY:begin
       if OutReg<0 then begin
        if GetRegisterTypeKind(Reg1)=tkNUMBER then begin
         EmitOpcode(GetNumberOp(Op),Reg1,Reg1);
        end else begin
         EmitOpcode(Op,Reg1,Reg1);
        end;
        result:=Reg1;
       end else begin
        result:=OutReg;
        if GetRegisterTypeKind(Reg1)=tkNUMBER then begin
         EmitOpcode(GetNumberOp(Op),result,Reg1);
         SetRegisterTypeKind(result,tkNUMBER);
        end else begin
         EmitOpcode(Op,result,Reg1);
         SetRegisterTypeKind(result,tkUNKNOWN);
        end;
       end;
      end;
      popSETLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETLOCAL,ConstantIndex,result,$ffffffff);
      end;
      popSETLOCALVALUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCALVALUE,result,FrameValueIndex);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETLOCALVALUE,FrameValueIndex,result);
      end;
      popSETOUTERVALUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETOUTERVALUE,result,FrameValueLevel,FrameValueIndex);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETOUTERVALUE,FrameValueLevel,FrameValueIndex,result);
      end;
      popSETCONSTLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETCONSTLOCAL,ConstantIndex,result,$ffffffff);
      end;
      popSETSYM:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       SetRegisterTypeKind(result,tkUNKNOWN);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETSYM,ConstantIndex,result,$ffffffff);
      end;
      else begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       EmitOpcode(Op,result,result);
       EmitOpcode(SetOp and $ff,ConstantIndex,result);
      end;
     end;
     FreeRegister(Reg3);
     FreeRegister(Reg2);
     FreeRegister(Reg1);
    end;
    function GenerateLambda(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     EmitOpcode(popLOADCODE,result,NewConstant(NewLambda(t)));
    end;
    procedure GenerateArrayItem(t:PPOCAToken;ArrayReg:TPOCAInt32);
    var Reg1,Reg2:TPOCAInt32;
    begin
     if assigned(t) then begin
      if Binary(t) and (t^.Token=ptDOTDOT) then begin
       Reg1:=GenerateExpression(t^.Left,-1,true);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(popARRAYRANGEPUSH,ArrayReg,Reg1,Reg2);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
      end else begin
       Reg1:=GenerateExpression(t,-1,true);
       EmitOpcode(popARRAYPUSH,ArrayReg,Reg1);
       FreeRegister(Reg1);
      end;
     end;
    end;
    procedure GenerateArray(t:PPOCAToken;ArrayReg:TPOCAInt32);
    begin
     while assigned(t) do begin
      if t^.Token=ptCOMMA then begin
       GenerateArrayItem(t^.Left,ArrayReg);
       t:=t^.Right;
      end else begin
       if t^.Token<>ptEMPTY then begin
        GenerateArrayItem(t,ArrayReg);
       end;
       break;
      end;
     end;
    end;
    procedure GenerateHashElement(t:PPOCAToken;HashReg:TPOCAInt32);
    var Reg1,Reg2:TPOCAInt32;
    begin
     if (not assigned(t)) or (t^.Token=ptEMPTY) then begin
      exit;
     end;
     if t^.Token=ptSYMBOL then begin
      // Shorthand
      Reg1:=GenerateScalarConstant(t,-1);
      Reg2:=GenerateExpression(t,-1,true);
      EmitOpcode(popHASHAPPEND,HashReg,Reg1,Reg2);
      FreeRegister(Reg1);
      FreeRegister(Reg2);
     end else begin
      if (t^.Token<>ptCOLON) or not assigned(t^.Left) then begin
       SyntaxError('Bad hash initializer',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end else begin
       case t^.Left^.Token of
        ptSYMBOL:begin
         Reg1:=GenerateScalarConstant(t^.Left,-1);
        end;
        ptLITERALSTR,ptLITERALNUM:begin
         Reg1:=GenerateExpression(t^.Left,-1,true);
        end;
        ptPROTOTYPE:begin
         Reg2:=GenerateExpression(t^.Right,-1,true);
         EmitOpcode(popSETPROTOTYPE,HashReg,Reg2);
         FreeRegister(Reg2);
         exit;
        end;
        ptCONSTRUCTOR:begin
         Reg2:=GenerateExpression(t^.Right,-1,true);
         EmitOpcode(popSETCONSTRUCTOR,HashReg,Reg2);
         FreeRegister(Reg2);
         exit;
        end;
        ptHASHKIND:begin
         Reg2:=GenerateExpression(t^.Right,-1,true);
         EmitOpcode(popSETHASHKIND,HashReg,Reg2);
         FreeRegister(Reg2);
         exit;
        end;
        else begin
         Reg1:=-1;
         SyntaxError('Bad hash initializer',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
       end;
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(popHASHAPPEND,HashReg,Reg1,Reg2);
       FreeRegister(Reg1);
       FreeRegister(Reg2);
      end;
     end;
    end;
    procedure GenerateHash(t:PPOCAToken;HashReg:TPOCAInt32);
    begin
     while assigned(t) do begin
      if t^.Token=ptCOMMA then begin
       GenerateHashElement(t^.Left,HashReg);
       t:=t^.Right;
      end else begin
       if t^.Token<>ptEMPTY then begin
        GenerateHashElement(t,HashReg);
       end;
       break;
      end;
     end;
    end;
    function IsLCURLCodeBlock(t:PPOCAToken):boolean;
    begin
     if assigned(t) then begin
      if (not assigned(t^.Left)) or
         ((assigned(t^.Left) and (t^.Token=ptCOMMA) and (t^.Left^.Token in [ptCOLON,ptSYMBOL])) or (t^.Token=ptCOLON)) then begin
       result:=false;
      end else begin
       result:=true;
      end;
     end else begin
      result:=false;
     end;
    end;
    function IsHashCall(t:PPOCAToken):boolean;
    begin
     if assigned(t) then begin
      if assigned(t^.Left) and (t^.Token=ptCOMMA) then begin
       result:=t^.Left^.Token=ptCOLON;
      end else begin
       result:=t^.Token=ptCOLON;
      end;
     end else begin
      result:=false;
     end;
    end;
    function CountList(t:PPOCAToken;Token:TPOCATokenType):TPOCAInt32; overload;
    begin
     result:=1;
     while assigned(t) and (t^.Token=Token) do begin
      inc(result);
      t:=t^.Right;
     end;
    end;
    function CountList(t:PPOCAToken;Tokens:TPOCATokenTypes):TPOCAInt32; overload;
    begin
     result:=1;
     while assigned(t) and (t^.Token in Tokens) do begin
      inc(result);
      t:=t^.Right;
     end;
    end;
    function GenerateFunctionCall(t:PPOCAToken;OutReg:TPOCAInt32;const InjectedMember:TPOCARawByteString=''):TPOCAInt32;
    var IsMethod,IsSafeMethod:boolean;
        Count,Reg1,Reg2,Reg3,i,JumpNull,JumpEnd,ConstantIndex:TPOCAInt32;
        Registers:TPOCACodeGeneratorRegisters;
        Regs:array of TPOCAInt32;
     function CollectList(t:PPOCAToken):TPOCAInt32;
     begin
      result:=0;
      while assigned(t) do begin
       if t^.Token=ptCOMMA then begin
        inc(result);
        t:=t^.Right;
       end else begin
        inc(result);
        break;
       end;
      end;
     end;
     procedure EmitList(t:PPOCAToken);
     var Count,r:TPOCAInt32;  
     begin
      Count:=0;
      while assigned(t) do begin
       if t^.Token=ptCOMMA then begin
        r:=GenerateExpression(t^.Left,-1,true);
        Regs[Count]:=r;
        inc(Count);
        t:=t^.Right;
       end else begin
        r:=GenerateExpression(t,-1,true);
        Regs[Count]:=r;
        break;
       end;
      end;
     end;
    begin
     Regs:=nil;
     try
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      if assigned(t^.Left) and (t^.Left^.Token in [ptDOT,ptSAFEDOT]) then begin
       IsSafeMethod:=t^.Left^.Token=ptSAFEDOT;
       IsMethod:=true;
       if assigned(t^.Left^.Left) and (t^.Left^.Left^.Token=ptAT) then begin
        Reg1:=GenerateExpression(t^.Left^.Left^.Left,-1,true);
        Reg3:=GenerateExpression(t^.Left^.Left^.Right,-1,true);
        Reg2:=GetRegister(true,false);
        if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptPROTOTYPE) then begin
         EmitOpcode(popGETPROTOTYPE,Reg2,Reg3);
        end else if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptCONSTRUCTOR) then begin
         EmitOpcode(popGETCONSTRUCTOR,Reg2,Reg3);
        end else if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptHASHKIND) then begin
         EmitOpcode(popGETHASHKIND,Reg2,Reg3);
        end else begin
         EmitGetMember(Reg2,Reg3,FindConstantIndex(t^.Left^.Right,false),$ffffffff,$ffffffff);
        end;
        FreeRegister(Reg3);
       end else begin
        Reg1:=GenerateExpression(t^.Left^.Left,-1,true);
        Reg2:=GetRegister(true,false);
        if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptPROTOTYPE) then begin
         EmitOpcode(popGETPROTOTYPE,Reg2,Reg1);
        end else if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptCONSTRUCTOR) then begin
         EmitOpcode(popGETCONSTRUCTOR,Reg2,Reg1);
        end else if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptHASHKIND) then begin
         EmitOpcode(popGETHASHKIND,Reg2,Reg1);
        end else begin
         EmitGetMember(Reg2,Reg1,FindConstantIndex(t^.Left^.Right,false),$ffffffff,$ffffffff);
        end;
       end;
      end else if assigned(t^.Left) and (t^.Left^.Token=ptATDOT) and assigned(t^.Left^.Left) and (t^.Left^.Left^.Token=ptSUPERTHAT) then begin
       IsSafeMethod:=false;
       IsMethod:=true;
       Reg1:=GetRegister(true,false);
       EmitOpcode(popLOADTHAT,Reg1);
       SetRegisterTypeKind(Reg1,tkUNKNOWN);
       Reg2:=GetRegister(true,false);
       EmitOpcode(popINHERITEDGETMEMBER,Reg2,Reg1,FindConstantIndex(t^.Left^.Right,false),$ffffffff,$ffffffff);
       EmitOpcode(popLOADTHIS,Reg1);
      end else if assigned(t^.Left) and (t^.Left^.Token=ptATDOT) then begin
       IsSafeMethod:=false;
       IsMethod:=true;
       Reg1:=GenerateExpression(t^.Left^.Left,-1,true);
       Reg2:=GetRegister(true,false);
       EmitOpcode(popINHERITEDGETMEMBER,Reg2,Reg1,FindConstantIndex(t^.Left^.Right,false),$ffffffff,$ffffffff);
      end else begin
       IsSafeMethod:=false;
       IsMethod:=false;
       Reg1:=-1;
       Reg2:=GenerateExpression(t^.Left,-1,true);
      end;
      if IsSafeMethod then begin
       Registers:=GetRegisters;
       JumpNull:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJIFFALSE,0,Reg1);
      end else begin
       JumpNull:=0;
      end;
      if length(InjectedMember)>0 then begin
       IsMethod:=true;
       ConstantIndex:=InternConstant(POCAInternSymbol(Parser.Context,Instance,POCANewUniqueString(Parser.Context,InjectedMember)));
       Reg1:=Reg2;
       Reg2:=GetRegister(true,false);
       EmitGetMember(Reg2,Reg1,ConstantIndex,$ffffffff,$ffffffff);
      end;
      if IsHashCall(t^.Right) then begin
       Reg3:=GetRegister(true,false);
       EmitOpcode(popNEWHASH,Reg3);
       GenerateHash(t^.Right,Reg3);
       if IsMethod then begin
        EmitOpcode(popMCALLH,result,Reg1,Reg2,Reg3);
       end else begin
        EmitOpcode(popFCALLH,result,Reg2,Reg3);
       end;
       FreeRegister(Reg3);
      end else begin
       Count:=CollectList(t^.Right);
       SetLength(Regs,Count);
       EmitList(t^.Right);
       if IsMethod then begin
        EmitOpcode(popMCALL or ((3+Count) shl 8));
        Emit(result);
        Emit(Reg1);
        Emit(Reg2);
       end else begin
        EmitOpcode(popFCALL or ((2+Count) shl 8));
        Emit(result);
        Emit(Reg2);
       end;
       for i:=0 to Count-1 do begin
        Emit(Regs[i]);
        FreeRegister(Regs[i]);
       end;
      end;
      if IsSafeMethod then begin
       JumpEnd:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJMP,0);
       FixTargetImmediate(JumpNull);
       EmitOpcode(popLOADNULL,result);
       SetRegisterTypeKind(result,tkNULL);
       CombineCurrentRegisters(Registers);
       FixTargetImmediate(JumpEnd);
      end;     
      FreeRegister(Reg2);
      FreeRegister(Reg1);
     finally
      SetLength(Regs,0);
     end;
    end;
    function StartBreakContinueScope(const Kind:TPOCACodeGeneratorBreakContinueScopeKind;const Index:TPOCAInt32):TPOCAInt32;
    var bcs:PPOCACodeGeneratorBreakContinueScope;
    begin
     if (CodeGenerator^.CountBreakContinueScopes+1)>length(CodeGenerator^.BreakContinueScopes) then begin
      SetLength(CodeGenerator^.BreakContinueScopes,(CodeGenerator^.CountBreakContinueScopes+1)*2);
     end;
     bcs:=@CodeGenerator^.BreakContinueScopes[CodeGenerator^.CountBreakContinueScopes];
     result:=CodeGenerator^.CountBreakContinueScopes;
     inc(CodeGenerator^.CountBreakContinueScopes);
     bcs^.Kind:=Kind;
     bcs^.Index:=Index;
    end;
    procedure EndBreakContinueScope;
    begin
     dec(CodeGenerator^.CountBreakContinueScopes);
    end;
    function StartSwitch:TPOCAInt32;
    var s:PPOCACodeGeneratorSwitch;
    begin
     if CodeGenerator^.SwitchTop>=CodeGenerator^.SwitchAllocated then begin
      CodeGenerator^.SwitchAllocated:=(CodeGenerator^.SwitchTop+1)*2;
      SetLength(CodeGenerator^.Switchs,CodeGenerator^.SwitchAllocated);
     end;
     s:=@CodeGenerator^.Switchs[CodeGenerator^.SwitchTop];
     s^.CountBreakJumps:=0;
     s^.BreakRegisters:=nil;
     StartBreakContinueScope(bcskSWITCH,CodeGenerator^.SwitchTop);
     inc(CodeGenerator^.SwitchTop);
     result:=CodeGenerator^.ByteCodeSize;
    end;
    procedure EndSwitch(BreakPos:TPOCAInt32;var BreakRegisters:TPOCACodeGeneratorRegisters;var HasBreak:boolean);
    var s:PPOCACodeGeneratorSwitch;
        i:TPOCAInt32;
    begin
     EndBreakContinueScope;
     dec(CodeGenerator^.SwitchTop);
     s:=@CodeGenerator^.Switchs[CodeGenerator^.SwitchTop];
     HasBreak:=HasBreak or (s^.CountBreakJumps>0);
     for i:=0 to s^.CountBreakJumps-1 do begin
      CodeGenerator^.ByteCode[s^.BreakJumps[i]]:=BreakPos;
     end;
     s^.CountBreakJumps:=0;
     for i:=0 to length(s^.BreakRegisters)-1 do begin
      CombineRegisters(BreakRegisters,s^.BreakRegisters[i]);
      SetLength(s^.BreakRegisters[i],0);
     end;
     SetLength(s^.BreakRegisters,0);
     SetLength(s^.BreakJumps,0);
    end;
    function StartLoop(LabelToken:PPOCAToken;IsSwitch:boolean):TPOCAInt32;
    var l:PPOCACodeGeneratorLoop;
    begin
     if CodeGenerator^.LoopTop>=CodeGenerator^.LoopAllocated then begin
      CodeGenerator^.LoopAllocated:=(CodeGenerator^.LoopTop+1)*2;
      SetLength(CodeGenerator^.Loops,CodeGenerator^.LoopAllocated);
     end;
     l:=@CodeGenerator^.Loops[CodeGenerator^.LoopTop];
     l^.LabelToken:=LabelToken;
     l^.CountBreakJumps:=0;
     l^.CountContinueJumps:=0;
     l^.BreakRegisters:=nil;
     l^.ContinueRegisters:=nil;
     StartBreakContinueScope(bcskLOOP,CodeGenerator^.LoopTop);
     inc(CodeGenerator^.LoopTop);
     result:=CodeGenerator^.ByteCodeSize;
    end;
    procedure EndLoop(BreakPos,ContinuePos:TPOCAInt32;var BreakRegisters,ContinueRegisters:TPOCACodeGeneratorRegisters);
    var l:PPOCACodeGeneratorLoop;
        i:TPOCAInt32;
    begin
     EndBreakContinueScope;
     dec(CodeGenerator^.LoopTop);
     l:=@CodeGenerator^.Loops[CodeGenerator^.LoopTop];
     for i:=0 to l^.CountBreakJumps-1 do begin
      CodeGenerator^.ByteCode[l^.BreakJumps[i]]:=BreakPos;
     end;
     for i:=0 to l^.CountContinueJumps-1 do begin
      CodeGenerator^.ByteCode[l^.ContinueJumps[i]]:=ContinuePos;
     end;
     l^.CountBreakJumps:=0;
     l^.CountContinueJumps:=0;
     for i:=0 to length(l^.BreakRegisters)-1 do begin
      CombineRegisters(BreakRegisters,l^.BreakRegisters[i]);
      SetLength(l^.BreakRegisters[i],0);
     end;
     for i:=0 to length(l^.ContinueRegisters)-1 do begin
      CombineRegisters(ContinueRegisters,l^.ContinueRegisters[i]);
      SetLength(l^.ContinueRegisters[i],0);
     end;
     SetLength(l^.BreakRegisters,0);
     SetLength(l^.ContinueRegisters,0);
     SetLength(l^.BreakJumps,0);
     SetLength(l^.ContinueJumps,0);
    end;
    function GenerateNullishShortCircuit(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var e,r:TPOCAInt32;
        Registers:TPOCACodeGeneratorRegisters;
    begin
     Registers:=nil;
     try
      begin
       if OutReg<0 then begin
        OutReg:=GetRegister(true,false);
       end;
       result:=OutReg;
       r:=GenerateExpression(t^.Left,result,true);
       if result<>r then begin
        EmitOpcode(popCOPY,result,r);
        SetRegisterTypeKind(result,GetRegisterTypeKind(r));
       end;
       if GetRegisterTypeKind(result)=tkNUMBER then begin
        e:=CodeGenerator^.ByteCodeSize+1;
        EmitOpcode(popJMP,0);
       end else begin
        e:=CodeGenerator^.ByteCodeSize+1;
        EmitOpcode(popJIFNOTNULL,0,result);
       end;
       Registers:=GetRegisters;
       r:=GenerateExpression(t^.Right,result,true);
       if result<>r then begin
        EmitOpcode(popCOPY,result,r);
        SetRegisterTypeKind(result,GetRegisterTypeKind(r));
       end;
       CombineCurrentRegisters(Registers);
       FixTargetImmediate(e);
      end;
     finally
      SetLength(Registers,0);
     end;
    end;
    function GenerateShortCircuit(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var e,r:TPOCAInt32;
        Registers:TPOCACodeGeneratorRegisters;
    begin
     Registers:=nil;
     try
     {if OutReg<0 then begin
       result:=GenerateExpression(t^.Left,-1,true);
       if GetRegisterNumber(result) then begin
        if t^.Token=ptAND then begin
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popN_JIFFALSE,0,result);
        end else begin // ptOR or ptELVIS
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popN_JIFTRUE,0,result);
        end;
       end else begin
        if t^.Token=ptAND then begin
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popJIFFALSE,0,result);
        end else begin // ptOR or ptELVIS
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       r:=GenerateExpression(t^.Right,result,true);
       if result<>r then begin
        EmitOpcode(popCOPY,result,r);
        SetRegisterNumber(result,GetRegisterNumber(r));
       end;
       FixTargetImmediate(e);
       CombineCurrentRegisters(Registers);
      end else}begin
       if OutReg<0 then begin
        OutReg:=GetRegister(true,false);
       end;
       result:=OutReg;
       r:=GenerateExpression(t^.Left,result,true);
       if result<>r then begin
        EmitOpcode(popCOPY,result,r);
        SetRegisterTypeKind(result,GetRegisterTypeKind(r));
       end;
       if GetRegisterTypeKind(result)=tkNUMBER then begin
        if t^.Token=ptAND then begin
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popN_JIFFALSE,0,result);
        end else begin // ptOR or ptELVIS
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popN_JIFTRUE,0,result);
        end;
       end else begin
        if t^.Token=ptAND then begin
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popJIFFALSE,0,result);
        end else begin // ptOR or ptELVIS
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       r:=GenerateExpression(t^.Right,result,true);
       if result<>r then begin
        EmitOpcode(popCOPY,result,r);
        SetRegisterTypeKind(result,GetRegisterTypeKind(r));
       end;
       CombineCurrentRegisters(Registers);
       FixTargetImmediate(e);
      end;
     finally
      SetLength(Registers,0);
     end;
    end;
    function GenerateTest(Test:PPOCAToken;IsLoop,DoNegative:boolean;JumpNext:TPOCAInt32):TPOCAInt32;
    var Back,RegLeft,RegRight,RegExpression:TPOCAInt32;
        Optimized:boolean;
        ScopeState:TScopeState;
    begin
     result:=0;
     Optimized:=false;
     Back:=CodeGenerator^.ByteCodeSize;
     ScopePush(ScopeState);
     if assigned(Test) and (Test^.Token in [ptLT,ptLTEQ,ptGT,ptGTEQ,ptEQ,ptNEQ,ptCMP]) and Binary(Test) then begin
      RegLeft:=GenerateExpression(Test^.Left);
      RegRight:=GenerateExpression(Test^.Right);
      if (GetRegisterTypeKind(RegLeft)=tkNUMBER) and (GetRegisterTypeKind(RegRight)=tkNUMBER) then begin
       case Test^.Token of
        ptLT:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if IsLoop then begin
           EmitOpcode(popN_JIFGTEQLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFGTEQ,JumpNext,RegLeft,RegRight);
          end;
         end else begin
          if IsLoop then begin
           EmitOpcode(popN_JIFLTLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFLT,JumpNext,RegLeft,RegRight);
          end;
         end;
         Optimized:=true;
        end;
        ptLTEQ:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if IsLoop then begin
           EmitOpcode(popN_JIFGTLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFGT,JumpNext,RegLeft,RegRight);
          end;
         end else begin
          if IsLoop then begin
           EmitOpcode(popN_JIFLTEQLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFLTEQ,JumpNext,RegLeft,RegRight);
          end;
         end;
         Optimized:=true;
        end;
        ptGT:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if IsLoop then begin
           EmitOpcode(popN_JIFLTEQLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFLTEQ,JumpNext,RegLeft,RegRight);
          end;
         end else begin
          if IsLoop then begin
           EmitOpcode(popN_JIFGTLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFGT,JumpNext,RegLeft,RegRight);
          end;
         end;
         Optimized:=true;
        end;
        ptGTEQ:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if IsLoop then begin
           EmitOpcode(popN_JIFLTLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFLT,JumpNext,RegLeft,RegRight);
          end;
         end else begin
          if IsLoop then begin
           EmitOpcode(popN_JIFGTEQLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFGTEQ,JumpNext,RegLeft,RegRight);
          end;
         end;
         Optimized:=true;
        end;
        ptEQ:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if (Test^.Right^.Token=ptLITERALNUM) and (Test^.Right^.Num=0) then begin
           if IsLoop then begin
            EmitOpcode(popN_JIFTRUELOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFTRUE,JumpNext,RegLeft,RegRight);
           end;
          end else begin
           if IsLoop then begin
            EmitOpcode(popN_JIFNEQLOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFNEQ,JumpNext,RegLeft,RegRight);
           end;
          end;
         end else begin
          if (Test^.Right^.Token=ptLITERALNUM) and (Test^.Right^.Num=0) then begin
           if IsLoop then begin
            EmitOpcode(popN_JIFFALSELOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFFALSE,JumpNext,RegLeft,RegRight);
           end;
          end else begin
           if IsLoop then begin
            EmitOpcode(popN_JIFEQLOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFEQ,JumpNext,RegLeft,RegRight);
           end;
          end;
         end;
         Optimized:=true;
        end;
        ptNEQ,ptCMP:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if (Test^.Right^.Token=ptLITERALNUM) and (Test^.Right^.Num=0) then begin
           if IsLoop then begin
            EmitOpcode(popN_JIFFALSELOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFFALSE,JumpNext,RegLeft,RegRight);
           end;
          end else begin
           if IsLoop then begin
            EmitOpcode(popN_JIFEQLOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFEQ,JumpNext,RegLeft,RegRight);
           end;
          end;
         end else begin
          if (Test^.Right^.Token=ptLITERALNUM) and (Test^.Right^.Num=0) then begin
           if IsLoop then begin
            EmitOpcode(popN_JIFTRUELOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFTRUE,JumpNext,RegLeft,RegRight);
           end;
          end else begin
           if IsLoop then begin
            EmitOpcode(popN_JIFNEQLOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFNEQ,JumpNext,RegLeft,RegRight);
           end;
          end;
         end;
         Optimized:=true;
        end;   
       end;
      end;
      FreeRegister(RegLeft);
      FreeRegister(RegRight);
     end;
     if Optimized then begin
      ScopeDrop(ScopeState);
     end else begin
      ScopePop(ScopeState);
      CodeGenerator^.ByteCodeSize:=Back;
      RegExpression:=GenerateExpression(Test,-1,true);
      result:=CodeGenerator^.ByteCodeSize+1;
      if GetRegisterTypeKind(RegExpression)=tkNUMBER then begin
       if DoNegative then begin
        if IsLoop then begin
         EmitOpcode(popN_JIFFALSELOOP,JumpNext,RegExpression);
        end else begin
         EmitOpcode(popN_JIFFALSE,JumpNext,RegExpression);
        end;
       end else begin
        if IsLoop then begin
         EmitOpcode(popN_JIFTRUELOOP,JumpNext,RegExpression);
        end else begin
         EmitOpcode(popN_JIFTRUE,JumpNext,RegExpression);
        end;
       end;
      end else begin
       if DoNegative then begin
        if IsLoop then begin
         EmitOpcode(popJIFFALSELOOP,JumpNext,RegExpression);
        end else begin
         EmitOpcode(popJIFFALSE,JumpNext,RegExpression);
        end;
       end else begin
        if IsLoop then begin
         EmitOpcode(popJIFTRUELOOP,JumpNext,RegExpression);
        end else begin
         EmitOpcode(popJIFTRUE,JumpNext,RegExpression);
        end;
       end;
      end;
      FreeRegister(RegExpression);
     end;
    end;
    function GenerateIF(tIF,tELSE:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var JumpNext,JumpEnd:TPOCAInt32;
        Registers:array[0..1] of TPOCACodeGeneratorRegisters;
    begin
     Registers[0]:=nil;
     Registers[1]:=nil;
     try
      if tIF^.Children^.Token=ptLPAR then begin
       JumpNext:=GenerateTest(tIF^.Children^.Left,false,true,0);
      end else begin
       JumpNext:=GenerateTest(tIF^.Children,false,true,0);
      end;
      if OutReg<0 then begin
       OutReg:=GetRegister(true,false);
       if not (assigned(tELSE) and (tELSE^.Token<>ptEMPTY)) then begin
        if DoNeedResult then begin
         EmitOpcode(popLOADNULL,OutReg);
        end;
       end;
      end;
      Registers[0]:=GetRegisters;
      result:=GenerateBlock(tIF^.Children^.Next^.Children,OutReg,DoNeedResult,true);
      if result<>OutReg then begin
       EmitOpcode(popCOPY,OutReg,result);
       SetRegisterTypeKind(OutReg,GetRegisterTypeKind(result));
       result:=OutReg;
      end;
      if (not (assigned(tELSE) and (tELSE^.Token<>ptEMPTY))) and not DoNeedResult then begin
       CombineCurrentRegisters(Registers[0]);
       FixTargetImmediate(JumpNext);
      end else begin
       begin
        JumpEnd:=CodeGenerator^.ByteCodeSize+1;
        EmitOpcode(popJMP,0);
       end;
       FixTargetImmediate(JumpNext);
       Registers[1]:=GetRegisters;
       SetRegisters(Registers[0]);
       if assigned(tELSE) and (tELSE^.Token<>ptEMPTY) then begin
        if tELSE^.Token=ptELSEIF then begin
         result:=GenerateIF(tELSE,tELSE^.Next,OutReg);
        end else begin
         result:=GenerateBlock(tELSE^.Children^.Children,OutReg,DoNeedResult,true);
        end;
        if result<>OutReg then begin
         EmitOpcode(popCOPY,OutReg,result);
         SetRegisterTypeKind(OutReg,GetRegisterTypeKind(result));
         result:=OutReg;
        end;
       end else begin
        if DoNeedResult then begin
         EmitOpcode(popLOADNULL,result);
         SetRegisterTypeKind(OutReg,tkNULL);
        end;
       end;
       FixTargetImmediate(JumpEnd);
       CombineCurrentRegisters(Registers[1]);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
     end;
    end;
    function GenerateIFELSE(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    begin
     result:=GenerateIF(t,t^.Left^.Next.Next,OutReg);
    end;
    function GenerateTry(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var TryBlock,CatchBlock,FinallyBlock,CatchIdentifier,TemporaryCatchIdentifier,
        FullCatchIdentifier:PPOCAToken;
        CatchIdentifierRegister,TryBlockPos,CatchBlockPos,FinallyBlockPos,EndPos,Reg:TPOCAInt32;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
      EmitOpcode(popLOADNULL,result);
     end else begin
      result:=OutReg;
     end;
     TryBlock:=t^.Children;
     CatchBlock:=nil;
     FinallyBlock:=nil;
     if assigned(TryBlock) then begin
      if assigned(TryBlock^.Next) then begin
       case TryBlock^.Next^.Token of
        ptCATCH:begin
         CatchBlock:=TryBlock^.Next;
         if assigned(CatchBlock^.Next) and (CatchBlock^.Next^.Token=ptFINALLY) then begin
          FinallyBlock:=CatchBlock^.Next;
         end;
        end;
        ptFINALLY:begin
         FinallyBlock:=TryBlock^.Next;
        end;
       end;
      end;
     end;
     if assigned(TryBlock) {and (assigned(CatchBlock) or assigned(FinallyBlock))} then begin
      CatchIdentifierRegister:=GetRegister(true,false);
      EmitImmediate(popTRY,6);
      Emit(result);
      Emit(CatchIdentifierRegister);
      TryBlockPos:=CodeGenerator^.ByteCodeSize;
      Emit($ffffffff);
      CatchBlockPos:=CodeGenerator^.ByteCodeSize;
      Emit($ffffffff);
      FinallyBlockPos:=CodeGenerator^.ByteCodeSize;
      Emit($ffffffff);
      EndPos:=CodeGenerator^.ByteCodeSize;
      Emit($ffffffff);
      if assigned(CatchBlock) then begin
       CatchIdentifier:=CatchBlock^.Children;
       FullCatchIdentifier:=nil;
       if assigned(CatchIdentifier) and (CatchIdentifier^.Token=ptLPAR) then begin
        FullCatchIdentifier:=CatchIdentifier^.Children;
        TemporaryCatchIdentifier:=FullCatchIdentifier;
        if assigned(TemporaryCatchIdentifier) and (TemporaryCatchIdentifier^.Token in [ptVAR,ptLET]) then begin
         TemporaryCatchIdentifier:=TemporaryCatchIdentifier^.Right;
        end;
        if assigned(TemporaryCatchIdentifier) and (TemporaryCatchIdentifier^.Token=ptSYMBOL) then begin
         if (not assigned(TemporaryCatchIdentifier^.Next)) or (TemporaryCatchIdentifier^.Next^.Token=ptEMPTY) then begin
          CatchBlock:=CatchIdentifier^.Next;
          CatchIdentifier:=TemporaryCatchIdentifier;
         end else begin
          SyntaxError('Bad catch identifier',CatchIdentifier^.SourceFile,CatchIdentifier^.SourceLine,CatchIdentifier^.SourceColumn);
         end;
        end else begin
         SyntaxError('Missed catch identifier',CatchIdentifier^.SourceFile,CatchIdentifier^.SourceLine,CatchIdentifier^.SourceColumn);
        end;
       end else begin
        CatchIdentifier:=nil;
        FullCatchIdentifier:=nil;
        CatchBlock:=CatchBlock^.Children;
        if not (assigned(CatchBlock) and (CatchBlock^.Token=ptLCURL)) then begin
         SyntaxError('Bad CATCH-block expression',CatchBlock^.SourceFile,CatchBlock^.SourceLine,CatchBlock^.SourceColumn);
        end;
       end;
       if CatchBlock^.Token=ptLCURL then begin
        if assigned(FinallyBlock) then begin
         if assigned(FinallyBlock^.Children) and (FinallyBlock^.Children^.Token=ptLCURL) then begin
          FinallyBlock:=FinallyBlock^.Children;
          begin
           FixTargetImmediate(TryBlockPos);
           Reg:=GenerateBlock(TryBlock^.Children,result,DoNeedResult,true);
           if result<>Reg then begin
            EmitOpcode(popCOPY,result,Reg);
            SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
            FreeRegister(Reg);
           end;
           EmitOpcode(popTRYBLOCKEND,result);
          end;
          begin
           ClearRegisters;
           FixTargetImmediate(CatchBlockPos);
           if assigned(CatchIdentifier) and assigned(FullCatchIdentifier) and (FullCatchIdentifier^.Token in [ptVAR,ptLET]) then begin
            ScopeStart;
            GenerateBlock(FullCatchIdentifier,-1,false,false);
            GenerateLeftValue(CatchIdentifier,CatchIdentifierRegister);
            Reg:=GenerateBlock(CatchBlock^.Children,result,DoNeedResult,false);
            if result<>Reg then begin
             EmitOpcode(popCOPY,result,Reg);
             SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
             FreeRegister(Reg);
            end;
            ScopeEnd;
           end else begin
            if assigned(CatchIdentifier) then begin
             GenerateLeftValue(CatchIdentifier,CatchIdentifierRegister);
            end;
            Reg:=GenerateBlock(CatchBlock^.Children,result,DoNeedResult,true);
            if result<>Reg then begin
             EmitOpcode(popCOPY,result,Reg);
             SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
             FreeRegister(Reg);
            end;
           end;
           EmitOpcode(popTRYBLOCKEND,result);
          end;
          begin
           ClearRegisters;
           FixTargetImmediate(FinallyBlockPos);
           Reg:=GenerateBlock(FinallyBlock^.Children,result,DoNeedResult,true);
           if result<>Reg then begin
            EmitOpcode(popCOPY,result,Reg);
            SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
            FreeRegister(Reg);
           end;
           EmitOpcode(popTRYBLOCKEND,result);
          end;
          FixTargetImmediate(EndPos);
          ClearRegisters;
         end else begin
          SyntaxError('Bad finally block',FinallyBlock^.SourceFile,FinallyBlock^.SourceLine,FinallyBlock^.SourceColumn);
         end;
        end else begin
         begin
          FixTargetImmediate(TryBlockPos);
          Reg:=GenerateBlock(TryBlock^.Children,result,DoNeedResult,true);
          if result<>Reg then begin
           EmitOpcode(popCOPY,result,Reg);
           SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
           FreeRegister(Reg);
          end;
          EmitOpcode(popTRYBLOCKEND,result);
         end;
         begin
          ClearRegisters;
          FixTargetImmediate(CatchBlockPos);
          if assigned(CatchIdentifier) and assigned(FullCatchIdentifier) and (FullCatchIdentifier^.Token in [ptVAR,ptLET]) then begin
           ScopeStart;
           GenerateBlock(FullCatchIdentifier,-1,false,false);
           GenerateLeftValue(CatchIdentifier,CatchIdentifierRegister);
           Reg:=GenerateBlock(CatchBlock^.Children,result,DoNeedResult,false);
           if result<>Reg then begin
            EmitOpcode(popCOPY,result,Reg);
            SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
            FreeRegister(Reg);
           end;
           ScopeEnd;
          end else begin
           if assigned(CatchIdentifier) then begin
            GenerateLeftValue(CatchIdentifier,CatchIdentifierRegister);
           end;
           Reg:=GenerateBlock(CatchBlock^.Children,result,DoNeedResult,true);
           if result<>Reg then begin
            EmitOpcode(popCOPY,result,Reg);
            SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
            FreeRegister(Reg);
           end;
          end;
          EmitOpcode(popTRYBLOCKEND,result);
         end;
         FixTargetImmediate(EndPos);
         ClearRegisters;
        end;
       end else begin
        SyntaxError('Bad catch block',CatchBlock^.SourceFile,CatchBlock^.SourceLine,CatchBlock^.SourceColumn);
       end;
      end else if assigned(FinallyBlock) then begin
       if assigned(FinallyBlock^.Children) and (FinallyBlock^.Children^.Token=ptLCURL) then begin
        FinallyBlock:=FinallyBlock^.Children;
        begin
         FixTargetImmediate(TryBlockPos);
         Reg:=GenerateBlock(TryBlock^.Children,result,DoNeedResult,true);
         if result<>Reg then begin
          EmitOpcode(popCOPY,result,Reg);
          SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
          FreeRegister(Reg);
         end;
         EmitOpcode(popTRYBLOCKEND,result);
        end;
        begin
         ClearRegisters;
         FixTargetImmediate(FinallyBlockPos);
         Reg:=GenerateBlock(FinallyBlock^.Children,result,DoNeedResult,true);
         if result<>Reg then begin
          EmitOpcode(popCOPY,result,Reg);
          SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
          FreeRegister(Reg);
         end;
         EmitOpcode(popTRYBLOCKEND,result);
        end;
        FixTargetImmediate(EndPos);
        ClearRegisters;
       end else begin
        SyntaxError('Bad finally block',FinallyBlock^.SourceFile,FinallyBlock^.SourceLine,FinallyBlock^.SourceColumn);
       end;
      end else begin
       begin
        FixTargetImmediate(TryBlockPos);
        Reg:=GenerateBlock(TryBlock^.Children,result,DoNeedResult,true);
        if result<>Reg then begin
         EmitOpcode(popCOPY,result,Reg);
         SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
         FreeRegister(Reg);
        end;
        EmitOpcode(popTRYBLOCKEND,result);
       end;
       begin
        ClearRegisters;
        FixTargetImmediate(CatchBlockPos);
        EmitOpcode(popLOADNULL,result);
        EmitOpcode(popTRYBLOCKEND,result);
       end;
       FixTargetImmediate(EndPos);
       ClearRegisters;
      end;
      FreeRegister(CatchIdentifierRegister);
     end else begin
      SyntaxError('Bad TRY-block expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
     SetRegisterTypeKind(result,tkUNKNOWN);
    end;
    function GenerateQuestion(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var JumpNext,JumpEnd:TPOCAInt32;
        Registers:array[0..1] of TPOCACodeGeneratorRegisters;
    begin
     Registers[0]:=nil;
     Registers[1]:=nil;
     try
      if (assigned(t^.Right)) and (t^.Right^.Token<>ptCOLON) then begin
       result:=-1;
       SyntaxError('Bad short circuit IF ?: expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end else begin
       if OutReg<0 then begin
        OutReg:=GetRegister(true,false);
       end;
{      if t^.Left^.Token=ptLPAR then begin
        JumpNext:=GenerateTest(t^.Left^.Left,false,true,0);
       end else begin
        JumpNext:=GenerateTest(t^.Left,false,true,0);
       end;}
       JumpNext:=GenerateTest(t^.Left,false,true,0);
       Registers[0]:=GetRegisters;
       begin
        result:=GenerateExpression(t^.Right^.Left,OutReg,true);
        if result<>OutReg then begin
         EmitOpcode(popCOPY,OutReg,result);
         SetRegisterTypeKind(OutReg,GetRegisterTypeKind(result));
         result:=OutReg;
        end;
       end;
       begin
        JumpEnd:=CodeGenerator^.ByteCodeSize+1;
        EmitOpcode(popJMP,0);
       end;
       FixTargetImmediate(JumpNext);
       Registers[1]:=GetRegisters;
       SetRegisters(Registers[0]);
       begin
        result:=GenerateExpression(t^.Right^.Right,OutReg,true);
        if result<>OutReg then begin
         EmitOpcode(popCOPY,OutReg,result);
         SetRegisterTypeKind(OutReg,GetRegisterTypeKind(result));
         result:=OutReg;
        end;
       end;
       FixTargetImmediate(JumpEnd);
       CombineCurrentRegisters(Registers[1]);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
     end;
    end;
    function GenerateWhile(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var Test,Body,LabelToken:PPOCAToken;
        Len,JumpNext,JumpOver,BreakPos,ContinuePos,Start:TPOCAInt32;
        Registers:array[0..4] of TPOCACodeGeneratorRegisters;
    begin
     ScopeStart;
     Registers[0]:=nil;
     Registers[1]:=nil;
     Registers[2]:=nil;
     Registers[3]:=nil;
     Registers[4]:=nil;
     try
      begin
       Test:=t^.Left^.Children;
       LabelToken:=nil;
       Len:=CountList(Test,[ptSEMI,ptAUTOSEMI]);
       if Len=2 then begin
        LabelToken:=Test^.Right;
        if (not assigned(LabelToken)) or (LabelToken^.Token<>ptSYMBOL) then begin
         SyntaxError('Bad loop label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        Test:=Test^.Left;
       end else if Len<>1 then begin
        SyntaxError('Too many semicolons in list',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       Body:=t^.Right^.Left;
      end;
      Start:=CodeGenerator^.ByteCodeSize;
      begin
       Registers[0]:=GetRegisters;
       StartLoop(LabelToken,false);
       JumpOver:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJMP,0);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       begin
        ContinuePos:=CodeGenerator^.ByteCodeSize;
        FixTargetImmediate(JumpOver);
        Registers[1]:=GetRegisters;
        Registers[4]:=GetRegisters;
        GenerateTest(Test,true,false,JumpNext);
        Registers[2]:=GetRegisters;
        Registers[3]:=GetRegisters;
       end;
       BreakPos:=CodeGenerator^.ByteCodeSize;
       EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
      end;
      if not (AreRegistersEqual(Registers[0],Registers[1],false,false) and
              AreRegistersEqual(Registers[4],Registers[1],false,false) and
              AreRegistersEqual(Registers[1],Registers[2],false,false) and
              AreRegistersEqual(Registers[4],Registers[2],false,false)) then begin
       ScopeReset;
       CodeGenerator^.ByteCodeSize:=Start;
       SetRegisters(Registers[0]);
       CombineCurrentRegisters(Registers[1]);
       CombineCurrentRegisters(Registers[4]);
       StartLoop(LabelToken,false);
       JumpOver:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJMP,0);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       begin
        CombineCurrentRegisters(Registers[0]);
        CombineCurrentRegisters(Registers[1]);
        CombineCurrentRegisters(Registers[4]);
        ContinuePos:=CodeGenerator^.ByteCodeSize;
        FixTargetImmediate(JumpOver);
        GenerateTest(Test,true,false,JumpNext);
       end;
       BreakPos:=CodeGenerator^.ByteCodeSize;
       CombineCurrentRegisters(Registers[2]);
       CombineCurrentRegisters(Registers[3]);
       EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
      SetLength(Registers[2],0);
      SetLength(Registers[3],0);
      SetLength(Registers[4],0);
     end;
     ScopeEnd;
    end;
    function GenerateDoWhile(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var Test,Body,LabelToken:PPOCAToken;
        Len,JumpNext,BreakPos,ContinuePos,Start:TPOCAInt32;
        Registers:array[0..4] of TPOCACodeGeneratorRegisters;
    begin
     ScopeStart;
     Registers[0]:=nil;
     Registers[1]:=nil;
     Registers[2]:=nil;
     Registers[3]:=nil;
     Registers[4]:=nil;
     try
      begin
       Body:=t^.Children^.Children;
       Test:=t^.Children^.Next^.Next^.Children;
       LabelToken:=nil;
       Len:=CountList(Test,[ptSEMI,ptAUTOSEMI]);
       if Len=2 then begin
        LabelToken:=Test^.Right;
        if (not assigned(LabelToken)) or (LabelToken^.Token<>ptSYMBOL) then begin
         SyntaxError('Bad loop label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        Test:=Test^.Left;
       end else if Len<>1 then begin
        SyntaxError('Too many semicolons in list',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      Start:=CodeGenerator^.ByteCodeSize;
      begin
       Registers[0]:=GetRegisters;
       StartLoop(LabelToken,false);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       Registers[1]:=GetRegisters;
       Registers[4]:=GetRegisters;
       ContinuePos:=CodeGenerator^.ByteCodeSize;
       GenerateTest(Test,true,false,JumpNext);
       Registers[2]:=GetRegisters;
       Registers[3]:=GetRegisters;
       BreakPos:=CodeGenerator^.ByteCodeSize;
       EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
      end;
      if not (AreRegistersEqual(Registers[0],Registers[1],false,false) and
              AreRegistersEqual(Registers[4],Registers[1],false,false) and
              AreRegistersEqual(Registers[1],Registers[2],false,false) and
              AreRegistersEqual(Registers[4],Registers[2],false,false)) then begin
       ScopeReset;
       CodeGenerator^.ByteCodeSize:=Start;
       SetRegisters(Registers[0]);
       CombineCurrentRegisters(Registers[1]);
       CombineCurrentRegisters(Registers[4]);
       StartLoop(LabelToken,false);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       CombineCurrentRegisters(Registers[0]);
       CombineCurrentRegisters(Registers[1]);
       CombineCurrentRegisters(Registers[4]);
       ContinuePos:=CodeGenerator^.ByteCodeSize;
       GenerateTest(Test,true,false,JumpNext);
       BreakPos:=CodeGenerator^.ByteCodeSize;
       CombineCurrentRegisters(Registers[2]);
       CombineCurrentRegisters(Registers[3]);
       EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
      SetLength(Registers[2],0);
      SetLength(Registers[3],0);
      SetLength(Registers[4],0);
     end;
     ScopeEnd;
    end;
    function GenerateFor(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var Init,Test,Body,Update,LabelToken,h:PPOCAToken;
        Len,JumpNext,JumpOver,BreakPos,ContinuePos,Reg,Start,CountFrameValues:TPOCAInt32;
        Registers:array[0..5] of TPOCACodeGeneratorRegisters;
    begin
     ScopeStart;
     Registers[0]:=nil;
     Registers[1]:=nil;
     Registers[2]:=nil;
     Registers[3]:=nil;
     Registers[4]:=nil;
     Registers[5]:=nil;
     try
      begin
       LabelToken:=nil;
       h:=t^.Left^.Children;
       Len:=CountList(h,[ptSEMI,ptAUTOSEMI]);
       Init:=h^.Left;
       Test:=h^.Right^.Left;
       Update:=h^.Right^.Right;
       if Len=4 then begin
        LabelToken:=Update^.Right;
        if (not assigned(LabelToken)) or (LabelToken^.Token<>ptSYMBOL) then begin
         SyntaxError('Bad loop label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        Update:=Update^.Left;
       end else if Len<>3 then begin
        SyntaxError('Wrong count of terms in for header',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       Body:=t^.Right^.Children;
      end;
      Start:=CodeGenerator^.ByteCodeSize;
      CountFrameValues:=CodeGenerator^.CountFrameValues;
      begin
       Registers[0]:=GetRegisters;
       StartLoop(LabelToken,false);
       if assigned(Init) and (Init^.Token<>ptEMPTY) then begin
        Reg:=GenerateCommaBlock(Init,-1,false,false);
        FreeRegister(Reg);
       end;
       JumpOver:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJMP,0);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       Registers[1]:=GetRegisters;
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       Registers[2]:=GetRegisters;
       Registers[5]:=GetRegisters;
       ContinuePos:=CodeGenerator^.ByteCodeSize;
       if assigned(Update) and (Update^.Token<>ptEMPTY) then begin
        Reg:=GenerateCommaBlock(Update,-1,false,false);
        FreeRegister(Reg);
       end;
       begin
        FixTargetImmediate(JumpOver);
        GenerateTest(Test,true,false,JumpNext);
       end;
       Registers[3]:=GetRegisters;
       Registers[4]:=GetRegisters;
       BreakPos:=CodeGenerator^.ByteCodeSize;
       EndLoop(BreakPos,ContinuePos,Registers[4],Registers[5]);
      end;
      if not (AreRegistersEqual(Registers[0],Registers[1],false,false) and
              AreRegistersEqual(Registers[1],Registers[2],false,false) and
              AreRegistersEqual(Registers[2],Registers[3],false,false) and
              AreRegistersEqual(Registers[4],Registers[3],false,false) and
              AreRegistersEqual(Registers[5],Registers[2],false,false)) then begin
       CodeGenerator^.CountFrameValues:=CountFrameValues;
       ScopeReset;
       CodeGenerator^.ByteCodeSize:=Start;
       SetRegisters(Registers[0]);
       StartLoop(LabelToken,false);
       if assigned(Init) and (Init^.Token<>ptEMPTY) then begin
        Reg:=GenerateCommaBlock(Init,-1,false,false);
        FreeRegister(Reg);
       end;
       JumpOver:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJMP,0);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       SetRegisters(Registers[1]);
       CombineCurrentRegisters(Registers[2]);
       CombineCurrentRegisters(Registers[5]);
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       CombineCurrentRegisters(Registers[1]);
       CombineCurrentRegisters(Registers[2]);
       CombineCurrentRegisters(Registers[5]);
       ContinuePos:=CodeGenerator^.ByteCodeSize;
       if assigned(Update) and (Update^.Token<>ptEMPTY) then begin
        Reg:=GenerateCommaBlock(Update,-1,false,false);
//      Reg:=GenerateExpression(Update,-1,false);
        FreeRegister(Reg);
       end;
       begin
        FixTargetImmediate(JumpOver);
        GenerateTest(Test,true,false,JumpNext);
       end;
       CombineCurrentRegisters(Registers[3]);
       CombineCurrentRegisters(Registers[4]);
       BreakPos:=CodeGenerator^.ByteCodeSize;
       EndLoop(BreakPos,ContinuePos,Registers[4],Registers[5]);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
      SetLength(Registers[2],0);
      SetLength(Registers[3],0);
      SetLength(Registers[4],0);
      SetLength(Registers[5],0);
     end;
    end;
    function GenerateForEachForIndexForKey(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var JumpNext,JumpOver,BreakPos,ContinuePos,Reg1,Reg2,Reg3,Reg4,Len,Start:TPOCAInt32;
        Element,Body,ArrayInstance,LabelToken,h,StartElement:PPOCAToken;
        Registers:array[0..4] of TPOCACodeGeneratorRegisters;
    begin
     ScopeStart;
     Registers[0]:=nil;
     Registers[1]:=nil;
     Registers[2]:=nil;
     Registers[3]:=nil;
     Registers[4]:=nil;
     try
      Element:=nil;
      ArrayInstance:=nil;
      LabelToken:=nil;
      h:=t^.Left^.Left;
      Len:=CountList(h,[ptSEMI,ptAUTOSEMI]);
      if (Len=3) and assigned(h^.Right) then begin
       LabelToken:=h^.Right^.Right;
       if (not assigned(LabelToken)) or (LabelToken^.Token<>ptSYMBOL) then begin
        SyntaxError('Bad loop label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       Element:=h^.Left;
       ArrayInstance:=h^.Right^.Left;
      end else if Len=2 then begin
       Element:=h^.Left;
       ArrayInstance:=h^.Right;
      end else begin
       case t^.Token of
        ptFOREACH:begin
         SyntaxError('Wrong count of terms in foreach header',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        ptFORKEY:begin
         SyntaxError('Wrong count of terms in forkey header',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        else begin
         SyntaxError('Wrong count of terms in forindex header',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
       end;
      end;
      StartElement:=Element;
      Body:=t^.Right^.Children;
      begin
       Start:=CodeGenerator^.ByteCodeSize;
       begin
        Element:=StartElement;
        if assigned(Element) and (Element^.Token=ptASSIGN) and assigned(Element^.Left) then begin
         Reg1:=GenerateExpression(Element,-1,false);
         FreeRegister(Reg1);
         Element:=Element^.Left;
         if (Element^.Token in [ptVAR,ptLET,ptCONST]) and assigned(Element^.Right) then begin
          Element:=Element^.Right;
         end;
        end;
        Reg1:=GenerateExpression(ArrayInstance,-1,true);
        Reg2:=GetRegister(true,false);
        EmitOpcode(popLOADZERO,Reg2);
        Reg3:=GetRegister(true,false);
        case t.Token of
         ptFOREACH,ptFORKEY:begin
          Reg4:=GetRegister(true,false);
          EmitOpcode(popLOADNULL,Reg4);
         end;
         else begin
          Reg4:=-1;
         end;
        end;
        Registers[0]:=GetRegisters;
        StartLoop(LabelToken,false);
        JumpOver:=CodeGenerator^.ByteCodeSize+1;
        EmitOpcode(popJMP,0);
        JumpNext:=CodeGenerator^.ByteCodeSize;
        GenerateLeftValue(Element,Reg3);
        result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
        ContinuePos:=CodeGenerator^.ByteCodeSize;
        Registers[1]:=GetRegisters;
        Registers[4]:=GetRegisters;
        FixTargetImmediate(JumpOver);
        case t.Token of
         ptFOREACH:begin
          EmitOpcode(popEACH,Reg1,Reg2,Reg3,Reg4,JumpNext);
         end;
         ptFORKEY:begin
          EmitOpcode(popKEY,Reg1,Reg2,Reg3,Reg4,JumpNext);
         end;
         else begin
          EmitOpcode(popINDEX,Reg1,Reg2,Reg3,JumpNext);
         end;
        end;
        Registers[2]:=GetRegisters;
        Registers[3]:=GetRegisters;
        BreakPos:=CodeGenerator^.ByteCodeSize;
        EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
       end;
       if not (AreRegistersEqual(Registers[0],Registers[1],false,false) and
               AreRegistersEqual(Registers[4],Registers[1],false,false) and
               AreRegistersEqual(Registers[1],Registers[2],false,false) and
               AreRegistersEqual(Registers[4],Registers[2],false,false)) then begin
        FreeRegister(Reg1);
        FreeRegister(Reg2);
        FreeRegister(Reg3);
        FreeRegister(Reg4);
        ScopeReset;
        CodeGenerator^.ByteCodeSize:=Start;
        Element:=StartElement;
        if assigned(Element) and (Element^.Token=ptASSIGN) and assigned(Element^.Left) then begin
         Reg1:=GenerateExpression(Element,-1,false);
         FreeRegister(Reg1);
         Element:=Element^.Left;
         if (Element^.Token in [ptVAR,ptLET,ptCONST]) and assigned(Element^.Right) then begin
          Element:=Element^.Right;
         end;
        end;
        Reg1:=GenerateExpression(ArrayInstance,-1,true);
        Reg2:=GetRegister(true,false);
        EmitOpcode(popLOADZERO,Reg2);
        Reg3:=GetRegister(true,false);
        case t.Token of
         ptFOREACH,ptFORKEY:begin
          Reg4:=GetRegister(true,false);
          EmitOpcode(popLOADNULL,Reg4);
         end;
         else begin
          Reg4:=-1;
         end;
        end;
        StartLoop(LabelToken,false);
        JumpOver:=CodeGenerator^.ByteCodeSize+1;
        EmitOpcode(popJMP,0);
        JumpNext:=CodeGenerator^.ByteCodeSize;
        SetRegisters(Registers[0]);
        CombineCurrentRegisters(Registers[1]);
        CombineCurrentRegisters(Registers[4]);
        GenerateLeftValue(Element,Reg3);
        CombineCurrentRegisters(Registers[0]);
        CombineCurrentRegisters(Registers[1]);
        CombineCurrentRegisters(Registers[4]);
        result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
        ContinuePos:=CodeGenerator^.ByteCodeSize;
        CombineCurrentRegisters(Registers[0]);
        CombineCurrentRegisters(Registers[1]);
        CombineCurrentRegisters(Registers[4]);
        FixTargetImmediate(JumpOver);
        case t.Token of
         ptFOREACH:begin
          EmitOpcode(popEACH,Reg1,Reg2,Reg3,Reg4,JumpNext);
         end;
         ptFORKEY:begin
          EmitOpcode(popKEY,Reg1,Reg2,Reg3,Reg4,JumpNext);
         end;
         else begin
          EmitOpcode(popINDEX,Reg1,Reg2,Reg3,JumpNext);
         end;
        end;
        CombineCurrentRegisters(Registers[2]);
        CombineCurrentRegisters(Registers[3]);
        BreakPos:=CodeGenerator^.ByteCodeSize;
        EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
       end;
       FreeRegister(Reg4);
       FreeRegister(Reg3);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
      SetLength(Registers[2],0);
      SetLength(Registers[3],0);
      SetLength(Registers[4],0);
     end;
     ScopeEnd;
    end;
    procedure GenerateBreakContinue(t:PPOCAToken);
    var Levels,Loop,i:TPOCAInt32;
        LabelToken:PPOCAToken;
        LoopItem:PPOCACodeGeneratorLoop;
        SwitchItem:PPOCACodeGeneratorSwitch;
        BreakContinueScope,CurrentBreakContinueScope:PPOCACodeGeneratorBreakContinueScope;
    begin
     Levels:=1;
     Loop:=-1;
     if assigned(t^.Right) then begin
      if t^.Right^.Token<>ptSYMBOL then begin
       if t^.Token=ptBREAK then begin
        SyntaxError('Bad break label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        SyntaxError('Bad continue label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      LabelToken:=t^.Right;
      for i:=0 to CodeGenerator^.LoopTop-1 do begin
       if assigned(CodeGenerator^.Loops[i].LabelToken) and (CodeGenerator^.Loops[i].LabelToken^.Str=LabelToken^.Str) then begin
        Loop:=i;
        break;
       end;
      end;
      if Loop<0 then begin
       if t^.Token=ptBREAK then begin
        SyntaxError('No matching break label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        SyntaxError('No matching continue label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      Levels:=CodeGenerator^.LoopTop-Loop;
     end else begin
      BreakContinueScope:=nil;
      for i:=CodeGenerator^.CountBreakContinueScopes-1 downto 0 do begin
       CurrentBreakContinueScope:=@CodeGenerator^.BreakContinueScopes[i];
       case CurrentBreakContinueScope^.Kind of
        bcskLOOP:begin
         BreakContinueScope:=CurrentBreakContinueScope;
         break;
        end;
        bcskSWITCH:begin
         if t^.Token=ptBREAK then begin
          BreakContinueScope:=CurrentBreakContinueScope;
          if (BreakContinueScope^.Index<0) or (BreakContinueScope^.Index>=CodeGenerator^.SwitchTop) then begin
           SyntaxError('Invalid break without matching owner switch',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
           exit;
          end;
          SwitchItem:=@CodeGenerator^.Switchs[BreakContinueScope^.Index];
          if SwitchItem^.CountBreakJumps>=length(SwitchItem^.BreakJumps) then begin
           if SwitchItem^.CountBreakJumps=0 then begin
            SetLength(SwitchItem^.BreakJumps,SwitchItem^.CountBreakJumps+256);
            SetLength(SwitchItem^.BreakRegisters,SwitchItem^.CountBreakJumps+256);
           end else begin
            SetLength(SwitchItem^.BreakJumps,SwitchItem^.CountBreakJumps shl 1);
            SetLength(SwitchItem^.BreakRegisters,SwitchItem^.CountBreakJumps shl 1);
           end;
          end;
          SwitchItem^.BreakJumps[SwitchItem^.CountBreakJumps]:=CodeGenerator^.ByteCodeSize+1;
          SwitchItem^.BreakRegisters[SwitchItem^.CountBreakJumps]:=GetRegisters;
          inc(SwitchItem^.CountBreakJumps);
          EmitOpcode(popJMP,0);
          exit;
         end;
        end;
        else begin
         break;
        end;
       end;
      end;
      if assigned(BreakContinueScope) and (BreakContinueScope^.Kind=bcskLOOP) then begin
       Levels:=CodeGenerator^.LoopTop-BreakContinueScope^.Index;
      end else begin
       if t^.Token=ptBREAK then begin
        SyntaxError('Invalid break without matching owner loop',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        SyntaxError('Invalid continue without matching owner loop',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
     end;
     if not ((Levels>0) and (Levels<=CodeGenerator^.LoopTop)) then begin
      if t^.Token=ptBREAK then begin
       SyntaxError('Invalid break without matching owner loop',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end else begin
       SyntaxError('Invalid continue without matching owner loop',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
     i:=CodeGenerator^.LoopTop-Levels;
     LoopItem:=@CodeGenerator^.Loops[i];
     if t^.Token=ptBREAK then begin
      if LoopItem^.CountBreakJumps>=length(LoopItem^.BreakJumps) then begin
       if LoopItem^.CountBreakJumps=0 then begin
        SetLength(LoopItem^.BreakJumps,LoopItem^.CountBreakJumps+256);
        SetLength(LoopItem^.BreakRegisters,LoopItem^.CountBreakJumps+256);
       end else begin
        SetLength(LoopItem^.BreakJumps,LoopItem^.CountBreakJumps shl 1);
        SetLength(LoopItem^.BreakRegisters,LoopItem^.CountBreakJumps shl 1);
       end;
      end;
      LoopItem^.BreakJumps[LoopItem^.CountBreakJumps]:=CodeGenerator^.ByteCodeSize+1;
      LoopItem^.BreakRegisters[LoopItem^.CountBreakJumps]:=GetRegisters;
      inc(LoopItem^.CountBreakJumps);
      EmitOpcode(popJMP,0);
     end else begin
      if LoopItem^.CountContinueJumps>=length(LoopItem^.ContinueJumps) then begin
       if LoopItem^.CountContinueJumps=0 then begin
        SetLength(LoopItem^.ContinueJumps,LoopItem^.CountContinueJumps+256);
        SetLength(LoopItem^.ContinueRegisters,LoopItem^.CountContinueJumps+256);
       end else begin
        SetLength(LoopItem^.ContinueJumps,LoopItem^.CountContinueJumps shl 1);
        SetLength(LoopItem^.ContinueRegisters,LoopItem^.CountContinueJumps shl 1);
       end;
      end;
      LoopItem^.ContinueJumps[LoopItem^.CountContinueJumps]:=CodeGenerator^.ByteCodeSize+1;
      LoopItem^.ContinueRegisters[LoopItem^.CountContinueJumps]:=GetRegisters;
      inc(LoopItem^.CountContinueJumps);
      EmitOpcode(popJMP,0);
     end;
    end;
    function ParameterListLen(t:PPOCAToken):TPOCAInt32;
    begin
     if (not assigned(t)) or ((t^.Token<>ptLPAR) or ((not assigned(t^.Left)) or (t^.Left^.Token<>ptCOMMA))) then begin
      result:=0;
     end else begin
      result:=CountList(t^.Left,ptCOMMA);
     end;
    end;
    function GenerateAssignment(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    const vNONE=0;
          vVAR=1;
          vLET=2;
          vCONST=3;
    var lv,rv:PPOCAToken;
        Len,Variable:TPOCAInt32;
     procedure EmitMultiLeftValue(t:PPOCAToken;Variable,Reg:TPOCAInt32);
     var r:TPOCAInt32;
         Symbol:PPOCACodeGeneratorScopeSymbol;
         SymbolKind:TPOCACodeGeneratorScopeSymbolKind;
     begin
      if Variable=0 then begin
       GenerateLeftValue(t,Reg);
      end else begin
       if t^.Token<>ptSYMBOL then begin
        SyntaxError('Bad left value',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        case Variable of
         vVAR:begin
          SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskVAR;
         end;
         else {vLET,vCONST:}begin
          if ExistScopeSymbol(t,false,false,true) then begin
           SyntaxError('Symbol already defined',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
           SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
          end else begin
           if CodeGenerator^.HasNestedFunctions then begin
            SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
           end else begin
            SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskREG;
           end;
          end;
         end;
        end;
        if SymbolKind=TPOCACodeGeneratorScopeSymbolKind.sskREG then begin
         Symbol:=DefineScopeSymbol(t,false,true,Variable=vCONST,false,GetRegister(false,Variable=vCONST));
         if assigned(Symbol) then begin
          r:=Symbol^.Register;
          EmitOpcode(popCOPY,r,Reg);
          SetRegisterTypeKind(r,GetRegisterTypeKind(Reg));
         end;
         exit;
        end else begin
         if CodeToken=ptFASTFUNCTION then begin
          SyntaxError('VAR is not allowed in fastfunctions',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end;
         CodeGenerator^.HasLocals:=true;
         Symbol:=DefineScopeSymbol(t,true,(Variable=vLET) or (Variable=vCONST),Variable=vCONST,false,-1);
         if assigned(Symbol) and (Symbol^.Kind=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE) then begin
          CodeGenerator^.UsedFrameValues:=true;
          if Symbol^.FrameValueLevel=CodeGenerator^.Level then begin
           EmitOpcode(popSETLOCALVALUE,Symbol^.FrameValueIndex,Reg);
          end else begin
           EmitOpcode(popSETOUTERVALUE,Symbol^.FrameValueLevel,Symbol^.FrameValueIndex,Reg);
          end;
          Symbol^.TypeKind:=GetRegisterTypeKind(Reg);
         end else if Variable=vCONST then begin
          EmitOpcode(popSETCONSTLOCAL,FindConstantIndex(t,true),Reg,$ffffffff);
         end else begin
          EmitOpcode(popSETLOCAL,FindConstantIndex(t,true),Reg,$ffffffff);
         end;
         exit;
        end;
       end;
      end;
     end;
     function DoList(at,pt:PPOCAToken;Variable,OutReg:TPOCAInt32):TPOCAInt32;
     var Reg,Reg2,Count,Index:TPOCAInt32;
         tat,tpt,t:PPOCAToken;
         Regs:array of TPOCAInt32;
         LastHasNoLeft,OnlyLiterals:boolean;
         Symbol:PPOCACodeGeneratorScopeSymbol;
         SymbolKind:TPOCACodeGeneratorScopeSymbolKind;
     begin
      result:=-1;
      try
       OnlyLiterals:=true;
       Regs:=nil;
       Count:=0;
       at:=at^.Left;
       pt:=pt^.Left;
       tat:=at;
       tpt:=pt;
       while (assigned(tat) and (tat^.Token=ptCOMMA)) and (assigned(tpt) and (tpt^.Token=ptCOMMA)) do begin
        if assigned(tpt^.Left) and not (tpt^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
         OnlyLiterals:=false;
        end;
        inc(Count);
        tat:=tat^.Right;
        tpt:=tpt^.Right;
       end;
       if assigned(tat) and assigned(tpt) then begin
        if assigned(tpt) and not (tpt^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
         OnlyLiterals:=false;
        end;
        inc(Count);
        LastHasNoLeft:=true;
       end else begin
        LastHasNoLeft:=false;
       end;
       if OnlyLiterals then begin
        while (assigned(at) and (at^.Token=ptCOMMA)) and (assigned(pt) and (pt^.Token=ptCOMMA)) do begin
         if Variable=0 then begin
          Reg:=GenerateExpression(pt^.Left,-1,true);
          EmitMultiLeftValue(at^.Left,Variable,Reg);
          FreeRegister(Reg);
         end else if at^.Left^.Token<>ptSYMBOL then begin
          SyntaxError('Bad lvalue',at^.SourceFile,at^.SourceLine,at^.SourceColumn);
         end else begin
          case Variable of
           vVAR:begin
            SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskVAR;
           end;
           else {vLET,vCONST:}begin
            if ExistScopeSymbol(at^.Left,false,false,true) then begin
             SyntaxError('Symbol already defined',at^.SourceFile,at^.SourceLine,at^.SourceColumn);
             SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
            end else begin
             if CodeGenerator^.HasNestedFunctions then begin
              SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
             end else begin
              SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskREG;
             end;
            end;
           end;
          end;
          if SymbolKind=TPOCACodeGeneratorScopeSymbolKind.sskREG then begin
           Symbol:=DefineScopeSymbol(at^.Left,false,true,Variable=vCONST,false,GetRegister(false,Variable=vCONST));
           if assigned(Symbol) then begin
            Reg2:=Symbol^.Register;
            Reg:=GenerateExpression(pt^.Left,Reg2,true);
            if Reg<>Reg2 then begin
             EmitOpcode(popCOPY,Reg2,Reg);
             SetRegisterTypeKind(Reg2,GetRegisterTypeKind(Reg));
             FreeRegister(Reg);
            end;
           end;
          end else begin
           Reg:=GenerateExpression(pt^.Left,-1,true);
           EmitMultiLeftValue(at^.Left,Variable,Reg);
           FreeRegister(Reg);
          end;
         end;
         at:=at^.Right;
         pt:=pt^.Right;
        end;
        if assigned(at) and assigned(pt) then begin
         if Variable=0 then begin
          result:=GenerateExpression(pt,OutReg,true);
          EmitMultiLeftValue(at,Variable,result);
         end else if at^.Token<>ptSYMBOL then begin
          SyntaxError('Bad lvalue',at^.SourceFile,at^.SourceLine,at^.SourceColumn);
         end else begin
          case Variable of
           1:begin
            SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskVAR;
           end;
           else {2,3:}begin
            if ExistScopeSymbol(at,false,false,true) then begin
             SyntaxError('Symbol already defined',at^.SourceFile,at^.SourceLine,at^.SourceColumn);
             SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
            end else begin
             if CodeGenerator^.HasNestedFunctions then begin
              SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
             end else begin
              SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskREG;
             end;
            end;
           end;
          end;
          if SymbolKind=TPOCACodeGeneratorScopeSymbolKind.sskREG then begin
           Symbol:=DefineScopeSymbol(at,false,true,Variable=vCONST,false,GetRegister(false,Variable=vCONST));
           if assigned(Symbol) then begin
            if OutReg<0 then begin
             result:=Symbol^.Register;
             Reg:=GenerateExpression(pt,result,true);
             if Reg<>result then begin
              EmitOpcode(popCOPY,result,Reg);
              SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
              FreeRegister(Reg);
             end;
            end else begin
             result:=OutReg;
             Reg2:=Symbol^.Register;
             Reg:=GenerateExpression(pt,Reg2,true);
             EmitOpcode(popCOPY,result,Reg);
             SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
             if Reg<>Reg2 then begin
              EmitOpcode(popCOPY,Reg2,Reg);
              SetRegisterTypeKind(Reg2,GetRegisterTypeKind(Reg));
              FreeRegister(Reg);
             end;
            end;
           end;
          end else begin
           result:=GenerateExpression(pt,OutReg,true);
           EmitMultiLeftValue(at,Variable,result);
          end;
         end;
        end;
       end else begin
        if Count>0 then begin
         SetLength(Regs,Count);
         tat:=at;
         tpt:=pt;
         for Index:=0 to Count-1 do begin
          Regs[Index]:=GetRegister(Index=(Count-1),false);
          Reg2:=Regs[Index];
          if (Index=(Count-1)) and LastHasNoLeft then begin
           t:=tpt;
          end else begin
           t:=tpt^.Left;
          end;
          Reg:=GenerateExpression(t,Reg2,true);
          if Reg<>Reg2 then begin
           EmitOpcode(popCOPY,Reg2,Reg);
           SetRegisterTypeKind(Reg2,GetRegisterTypeKind(Reg));
           FreeRegister(Reg);
          end;
          tpt:=tpt^.Right;
         end;
         for Index:=0 to Count-1 do begin
          Reg:=Regs[Index];
          if (Index=(Count-1)) and LastHasNoLeft then begin
           t:=tat;
          end else begin
           t:=tat^.Left;
          end;
          if Variable=0 then begin
           EmitMultiLeftValue(t,Variable,Reg);
          end else if t^.Token<>ptSYMBOL then begin
           SyntaxError('Bad lvalue',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
          end else begin
           case Variable of
            vVAR:begin
             SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskVAR;
            end;
            else {vLET,vCONST:}begin
             if ExistScopeSymbol(t,false,false,true) then begin
              SyntaxError('Symbol already defined',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
              SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
             end else begin
              if CodeGenerator^.HasNestedFunctions then begin
               SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
              end else begin
               SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskREG;
              end;
             end;
            end;
           end;
           if SymbolKind=TPOCACodeGeneratorScopeSymbolKind.sskREG then begin
            Symbol:=DefineScopeSymbol(t,false,true,Variable=vCONST,false,GetRegister(false,Variable=vCONST));
            if assigned(Symbol) then begin
             if OutReg<0 then begin
              Reg2:=Symbol^.Register;
              EmitOpcode(popCOPY,Reg2,Reg);
              SetRegisterTypeKind(Reg2,GetRegisterTypeKind(Reg));
              FreeRegister(Reg2);
             end;
            end;
           end else begin
            EmitMultiLeftValue(t,Variable,Reg);
           end;
          end;
          if Index=(Count-1) then begin
           result:=Reg;
          end else begin
           FreeRegister(Reg);
          end;
          tat:=tat^.Right;
         end;
        end;
       end;
      finally
       SetLength(Regs,0);
      end;
     end;
     function DoUnpackList(LeftValue,RightValue:PPOCAToken;Count,Variable,OutReg:TPOCAInt32):TPOCAInt32;
     var t:PPOCAToken;
         Reg,i:TPOCAInt32;
         Regs:array of TPOCAInt32;
     begin
      result:=-1;
      Reg:=-1;
      Regs:=nil;
      SetLength(Regs,Count);
      try
       begin
        Reg:=GenerateExpression(RightValue,-1,true);
        i:=0;
        t:=LeftValue^.Left;
        while assigned(t) and (t^.Token=ptCOMMA) do begin
         Regs[i]:=GetRegister(true,false);
         inc(i);
         t:=t^.Right;
        end;
        if assigned(t) then begin
         if OutReg<0 then begin
          result:=GetRegister(true,false);
         end else begin
          result:=OutReg;
         end;
         Regs[i]:=result;
        end;
        EmitImmediate(popUNPACK,1+Count);
        Emit(Reg);
        for i:=0 to Count-1 do begin
         Emit(Regs[i]);
        end;
       end;
       begin
        i:=0;
        t:=LeftValue^.Left;
        while assigned(t) and (t^.Token=ptCOMMA) do begin
         EmitMultiLeftValue(t^.Left,Variable,Regs[i]);
         inc(i);
         t:=t^.Right;
        end;
        if assigned(t) then begin
         EmitMultiLeftValue(t,Variable,Regs[i]);
        end;
       end;
      finally
       FreeRegister(Reg);
       for i:=0 to Count-1 do begin
        if Regs[i]<>result then begin
         FreeRegister(Regs[i]);
        end;
       end;
       SetLength(Regs,0);
      end;
     end;
    begin
     lv:=t^.Left;
     rv:=t^.Right;
     Variable:=0;
     Len:=ParameterListLen(lv);
     if (Len=0) and (lv^.Token in [ptVAR,ptLET,ptCONST]) then begin
      Len:=ParameterListLen(lv^.Right);
     end;
     if Len<>0 then begin
      case lv^.Token of
       ptVAR:begin
        if CodeToken=ptFASTFUNCTION then begin
         SyntaxError('VAR is not allowed in fastfunctions',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        CodeGenerator^.HasLocals:=true;
        lv:=lv^.Right;
        Variable:=vVAR;
       end;
       ptLET:begin
        lv:=lv^.Right;
        Variable:=vLET;
       end;
       ptCONST:begin
        lv:=lv^.Right;
        Variable:=vCONST;
       end;
      end;                                   
      if (rv^.Token=ptLPAR) and not (Binary(rv) or not assigned(rv^.Right)) then begin
       if Len<>ParameterListLen(rv) then begin
        SyntaxError('Bad assignment count',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       result:=DoList(lv,rv,Variable,OutReg);
      end else begin
       result:=DoUnpackList(lv,rv,Len,Variable,OutReg);
      end;
     end else begin
      if OutReg<0 then begin
       OutReg:=GetLeftValueLocalRegister(lv);
       result:=GenerateExpression(rv,OutReg,true);
       if OutReg<0 then begin
        GenerateLeftValue(lv,result);
       end;
      end else begin
       result:=GenerateExpression(rv,OutReg,true);
       GenerateLeftValue(lv,result);
      end;
     end;
    end;
    procedure GenerateSlice(t:PPOCAToken;DestArrayReg,SourceArrayReg:TPOCAInt32);
    var Reg1,Reg2:TPOCAInt32;
    begin
     if (not assigned(t)) or (t^.Token=ptEMPTY) then begin
      if assigned(t) then begin
       SyntaxError('Empty slice expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end else begin
       SyntaxError('Empty slice expression',Parser.SourceFile,-1,-1);
      end;
     end;
     if t^.Token in [ptCOLON,ptDOTDOT] then begin
      if assigned(t^.Left) then begin
       Reg1:=GenerateExpression(t^.Left,-1,true);
      end else begin
       Reg1:=GetRegister(true,false);
       EmitOpcode(popLOADNULL,Reg1);
      end;
      if assigned(t^.Right) then begin
       Reg2:=GenerateExpression(t^.Right,-1,true);
      end else begin
       Reg2:=GetRegister(true,false);
       EmitOpcode(popLOADNULL,Reg2);
      end;
      if t^.Token=ptDOTDOT then begin
       EmitOpcode(popSLICE2,DestArrayReg,SourceArrayReg,Reg1,Reg2);
      end else begin
       EmitOpcode(popSLICE3,DestArrayReg,SourceArrayReg,Reg1,Reg2);
      end;
      FreeRegister(Reg1);
      FreeRegister(Reg2);
     end else begin
      Reg1:=GenerateExpression(t,-1,true);
      EmitOpcode(popSLICE,DestArrayReg,SourceArrayReg,Reg1);
      FreeRegister(Reg1);
     end;
     SetRegisterTypeKind(result,tkUNKNOWN);
    end;
    function GenerateExtract(t:PPOCAToken;OutReg:TPOCAInt32;Safe:boolean):TPOCAInt32;
    var Reg1,Reg2,JumpNull,JumpEnd:TPOCAInt32;
        Registers:TPOCACodeGeneratorRegisters;
    begin
     Reg1:=GenerateExpression(t^.Left,-1,true);
     Registers:=GetRegisters;
     if Safe then begin
      JumpNull:=CodeGenerator^.ByteCodeSize+1;
      EmitOpcode(popJIFFALSE,0,Reg1);
     end else begin
      JumpNull:=0;
     end;
     if (CountList(t^.Right,ptCOMMA)=1) and not (t^.Right^.Token in [ptCOLON,ptDOTDOT]) then begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      Reg2:=GenerateExpression(t^.Right,-1,true);
      if Safe then begin
       EmitOpcode(popSAFEEXTRACT,result,Reg1,Reg2);
      end else begin
       case GetRegisterTypeKind(Reg1) of
        tkARRAY:begin
         EmitOpcode(popARRAYEXTRACT,result,Reg1,Reg2);
        end;
        else begin
         EmitOpcode(popEXTRACT,result,Reg1,Reg2);
        end;
       end;
      end;
      FreeRegister(Reg2);
     end else begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      EmitOpcode(popLOADNULL,result);
      t:=t^.Right;
      while assigned(t) and (t^.Token=ptCOMMA) do begin
       GenerateSlice(t^.Left,result,Reg1);
       t:=t^.Right;
      end;
      GenerateSlice(t,result,Reg1);
      EmitOpcode(popUPDATESTRING,result);
     end;
     if Safe then begin
      JumpEnd:=CodeGenerator^.ByteCodeSize+1;
      EmitOpcode(popJMP,0);
      FixTargetImmediate(JumpNull);
      if result<>Reg1 then begin
       EmitOpcode(popCOPY,result,Reg1);
       FreeRegister(Reg1);
      end;
      SetRegisterTypeKind(result,tkUNKNOWN);
      CombineCurrentRegisters(Registers);
      FixTargetImmediate(JumpEnd);
     end else begin
      FreeRegister(Reg1);
      SetRegisterTypeKind(result,tkUNKNOWN);
     end;
    end;
    procedure StartFallthrough(JumpRetryPos:TPOCAUInt32);
    var Item:PPOCACodeGeneratorWhenSwitchCaseBlock;
        i,j:TPOCAInt32;
    begin
     j:=length(CodeGenerator^.WhenSwitchCaseBlocks);
     if CodeGenerator^.CountWhenSwitchCaseBlocks>=j then begin
      if CodeGenerator^.CountWhenSwitchCaseBlocks=0 then begin
       SetLength(CodeGenerator^.WhenSwitchCaseBlocks,8);
      end else begin
       SetLength(CodeGenerator^.WhenSwitchCaseBlocks,CodeGenerator^.CountWhenSwitchCaseBlocks*2);
      end;
      for i:=j to length(CodeGenerator^.WhenSwitchCaseBlocks)-1 do begin
       Item:=@CodeGenerator^.WhenSwitchCaseBlocks[i];
       Item^.Fallthroughs:=nil;
       Item^.CountFallthroughs:=0;
      end;
     end;
     Item:=@CodeGenerator^.WhenSwitchCaseBlocks[CodeGenerator^.CountWhenSwitchCaseBlocks];
     SetLength(Item^.Fallthroughs,16);
     Item^.CountFallthroughs:=0;
     Item^.JumpRetryPos:=JumpRetryPos;
     Item^.HasRetry:=false;
     Item^.HasFallthrough:=false;
     Item^.RetryRegisters:=GetRegisters;
     Item^.FallthroughRegisters:=GetRegisters;
     inc(CodeGenerator^.CountWhenSwitchCaseBlocks);
    end;
    procedure EndFallthrough(EndJumpPos:TPOCAUInt32;var RetryRegisters,FallthroughRegisters:TPOCACodeGeneratorRegisters;var HasRetry,HasFallthrough:boolean);
    var Item:PPOCACodeGeneratorWhenSwitchCaseBlock;
        i:TPOCAInt32;
    begin
     if CodeGenerator^.CountWhenSwitchCaseBlocks=0 then begin
      SyntaxError('Invalid falthrough without matching owner when block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      dec(CodeGenerator^.CountWhenSwitchCaseBlocks);
      Item:=@CodeGenerator^.WhenSwitchCaseBlocks[CodeGenerator^.CountWhenSwitchCaseBlocks];
      for i:=0 to Item^.CountFallthroughs-1 do begin
       if Item^.Fallthroughs[i]<>$ffffffff then begin
        CodeGenerator^.ByteCode[Item^.Fallthroughs[i]]:=EndJumpPos;
       end;
      end;
      SetLength(Item^.Fallthroughs,0);
      Item^.CountFallthroughs:=0;
      Item^.JumpRetryPos:=0;
      CombineRegisters(RetryRegisters,Item^.RetryRegisters);
      CombineRegisters(FallthroughRegisters,Item^.FallthroughRegisters);
      SetLength(Item^.RetryRegisters,0);
      SetLength(Item^.FallthroughRegisters,0);
      HasRetry:=HasRetry or Item^.HasRetry;
      HasFallthrough:=HasFallthrough or Item^.HasFallthrough;
     end;
    end;
    procedure GenerateFallthrough(t:PPOCAToken);
    var Item:PPOCACodeGeneratorWhenSwitchCaseBlock;
        i,j:TPOCAInt32;
    begin
     if CodeGenerator^.CountWhenSwitchCaseBlocks=0 then begin
      SyntaxError('Invalid fallthrough without matching owner when block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      Item:=@CodeGenerator^.WhenSwitchCaseBlocks[CodeGenerator^.CountWhenSwitchCaseBlocks-1];
      Item^.HasFallthrough:=true;
      Item^.FallthroughRegisters:=GetRegisters;
      j:=length(Item^.Fallthroughs);
      if Item^.CountFallthroughs>=j then begin
       if Item^.CountFallthroughs=0 then begin
        SetLength(Item^.Fallthroughs,8);
       end else begin
        SetLength(Item^.Fallthroughs,Item^.CountFallthroughs*2);
       end;
       for i:=j to length(Item^.Fallthroughs)-1 do begin
        Item^.Fallthroughs[i]:=$ffffffff;
       end;
      end;
      Item^.Fallthroughs[Item^.CountFallthroughs]:=CodeGenerator^.ByteCodeSize+1;
      EmitOpcode(popJMP,0);
      inc(Item^.CountFallthroughs);
     end;
    end;
    procedure GenerateRetry(t:PPOCAToken);
    var Item:PPOCACodeGeneratorWhenSwitchCaseBlock;
    begin
     if CodeGenerator^.CountWhenSwitchCaseBlocks=0 then begin
      SyntaxError('Invalid retry without matching owner when block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      Item:=@CodeGenerator^.WhenSwitchCaseBlocks[CodeGenerator^.CountWhenSwitchCaseBlocks-1];
      Item^.HasRetry:=true;
      CombineRegisters(Item^.RetryRegisters,GetRegisters);
      EmitOpcode(popJMPLOOP,Item^.JumpRetryPos);
     end;
    end;
    function GenerateWhenOrSwitch(t:PPOCAToken;OutReg:TPOCAInt32;const IsSwitch:boolean):TPOCAInt32;
    type PWhenSwitchCaseExpression=^TWhenSwitchCaseExpression;
         TWhenSwitchCaseExpression=record
          Token:PPOCAToken;
          JumpPosition:TPOCAUInt32;
         end;
         PWhenSwitchCase=^TWhenSwitchCase;
         TWhenSwitchCase=record
          IsDefault:boolean;
          Body:PPOCAToken;
          EndJumpPosition:TPOCAUInt32;
          Expressions:array of TWhenSwitchCaseExpression;
         end;
         TWhenSwitchCases=array of TWhenSwitchCase;
    var Expression,Current:PPOCAToken;
        WhenSwitchCases:TWhenSwitchCases;
        WhenSwitchCase,DefaultWhenSwitchCase:PWhenSwitchCase;
        WhenSwitchCaseExpression:PWhenSwitchCaseExpression;
        CountWhenSwitchCases,CapacityWhenSwitchCases,Expressions,ExpressionIndex,i,j,RegExpression,RegComparsion,Reg,Reg1,Reg2,TryIndex,Start:TPOCAInt32;
        EndJumpPosition,JumpRetryPos:TPOCAUInt32;
        Registers:array[0..7] of TPOCACodeGeneratorRegisters;
        HasDefault,HasRetry,HasBreak,HasFallthrough:boolean;
        ScopeState:TScopeState;
     procedure AddCaseExpression(t:PPOCAToken);
     begin
      WhenSwitchCaseExpression:=@WhenSwitchCase^.Expressions[ExpressionIndex];
      WhenSwitchCaseExpression^.Token:=t;
      WhenSwitchCaseExpression^.JumpPosition:=0;
      inc(ExpressionIndex);
     end;
     procedure ProcessCommaList(t:PPOCAToken);
     begin
      if assigned(t) then begin
       if t^.Token<>ptCOMMA then begin
        AddCaseExpression(t);
       end else begin
        ProcessCommaList(t^.Right);
        AddCaseExpression(t^.Left);
       end;
      end;
     end;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
      EmitOpcode(popLOADNULL,result);
     end else begin
      result:=OutReg;
     end;
     WhenSwitchCases:=nil;
     Registers[0]:=nil;
     Registers[1]:=nil;
     Registers[2]:=nil;
     Registers[3]:=nil;
     Registers[4]:=nil;
     Registers[5]:=nil;
     Registers[6]:=nil;
     Registers[7]:=nil;
     try
      HasDefault:=false;
      HasRetry:=false;
      HasBreak:=false;
      HasFallthrough:=false;
      begin
       Expression:=t^.Children;
       if (not assigned(Expression)) and (Expression^.Token<>ptLPAR) then begin
        SyntaxError('Missed when expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       Expression:=Expression^.Children;
      end;
      begin
       begin
        Current:=t^.Children^.Next;
        if (not assigned(Current)) and (Current^.Token<>ptLCURL) then begin
         SyntaxError('Missed when block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        Current:=Current^.Children;
       end;
       CountWhenSwitchCases:=0;
       while assigned(Current) and (Current^.Token in [ptCASE,ptDEFAULT]) do begin
        if CountWhenSwitchCases>=length(WhenSwitchCases) then begin
         CapacityWhenSwitchCases:=length(WhenSwitchCases)*2;
         if CapacityWhenSwitchCases=0 then begin
          CapacityWhenSwitchCases:=16;
         end;
         SetLength(WhenSwitchCases,CapacityWhenSwitchCases);
        end;
        WhenSwitchCase:=@WhenSwitchCases[CountWhenSwitchCases];
        FillChar(WhenSwitchCase^,sizeof(TWhenSwitchCase),#0);
        WhenSwitchCase^.IsDefault:=Current^.Token=ptDEFAULT;
        WhenSwitchCase^.EndJumpPosition:=$ffffffff;
        WhenSwitchCase^.Expressions:=nil;
        if WhenSwitchCase^.IsDefault then begin
         SetLength(WhenSwitchCase^.Expressions,1);
         WhenSwitchCaseExpression:=@WhenSwitchCase^.Expressions[0];
         WhenSwitchCaseExpression^.Token:=nil;
         WhenSwitchCaseExpression^.JumpPosition:=0;
         if (not assigned(Current^.Children)) and (Current^.Children^.Token<>ptLCURL) then begin
          SyntaxError('Missed default body',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         WhenSwitchCase^.Body:=Current^.Children^.Children;
        end else begin
         if (not assigned(Current^.Children)) and (Current^.Children^.Token<>ptLPAR) then begin
          SyntaxError('Missed case expression',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         Expressions:=ParameterListLen(Current^.Children);
         if Expressions=0 then begin
          SetLength(WhenSwitchCase^.Expressions,1);
          ExpressionIndex:=0;
          AddCaseExpression(Current^.Children^.Children);
         end else begin
          SetLength(WhenSwitchCase^.Expressions,Expressions);
          ExpressionIndex:=0;
          ProcessCommaList(Current^.Children^.Left);
         end;
         if (not assigned(Current^.Children^.Next)) and (Current^.Children^.Next^.Token<>ptLCURL) then begin
          SyntaxError('Missed case body',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         WhenSwitchCase^.Body:=Current^.Children^.Next^.Children;
        end;
        inc(CountWhenSwitchCases);
        if WhenSwitchCase^.IsDefault then begin
         if HasDefault then begin
          SyntaxError('A when block may contain only a default block',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         HasDefault:=true;
        end;
        Current:=Current^.Next;
       end;
       if assigned(Current) then begin
        case Current^.Token of
         ptCASE:begin
          SyntaxError('Illegal case block',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         ptDEFAULT:begin
          SyntaxError('Illegal default block',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         else begin
          SyntaxError('Illegal token',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
        end;
       end;
      end; 
      Registers[0]:=GetRegisters;
      Start:=CodeGenerator^.ByteCodeSize;
      ScopePush(ScopeState);
      for TryIndex:=0 to 1 do begin
       CodeGenerator^.ByteCodeSize:=Start;
       SetRegisters(Registers[0]);
       SetLength(WhenSwitchCases,CountWhenSwitchCases);
       begin
        begin
         if TryIndex=1 then begin
          ClearRegisters;
          ScopePop(ScopeState);
         end;
         DefaultWhenSwitchCase:=nil;
         JumpRetryPos:=CodeGenerator^.ByteCodeSize;
         RegExpression:=GenerateExpression(Expression,-1,true);
         for i:=0 to CountWhenSwitchCases-1 do begin
          WhenSwitchCase:=@WhenSwitchCases[i];
          if WhenSwitchCase^.IsDefault then begin
           DefaultWhenSwitchCase:=WhenSwitchCase;
          end else begin
           for j:=0 to length(WhenSwitchCase^.Expressions)-1 do begin
            WhenSwitchCaseExpression:=@WhenSwitchCase^.Expressions[j];
            if assigned(WhenSwitchCaseExpression^.Token) and (WhenSwitchCaseExpression^.Token^.Token=ptDOTDOT) then begin
             Reg1:=GenerateExpression(WhenSwitchCaseExpression^.Token^.Left,-1,true);
             Reg2:=GenerateExpression(WhenSwitchCaseExpression^.Token^.Right,-1,true);
             RegComparsion:=GetRegister(true,false);
             if (GetRegisterTypeKind(RegExpression)=tkNUMBER) and (GetRegisterTypeKind(Reg1)=tkNUMBER) and (GetRegisterTypeKind(Reg2)=tkNUMBER) then begin
              EmitOpcode(popN_INRANGE,RegComparsion,RegExpression,Reg1,Reg2);
              SetRegisterTypeKind(RegComparsion,tkNUMBER);
             end else begin
              EmitOpcode(popINRANGE,RegComparsion,RegExpression,Reg1,Reg2);
              SetRegisterTypeKind(RegComparsion,tkUNKNOWN);
             end;
             FreeRegister(Reg1);
             FreeRegister(Reg2);
            end else begin
             RegComparsion:=GenerateExpression(WhenSwitchCaseExpression^.Token,-1,true);
             Reg1:=RegComparsion;
             if GetRegisterConstant(Reg1) then begin
              RegComparsion:=GetRegister(true,false);
             end;
             if (GetRegisterTypeKind(RegComparsion)=tkNUMBER) and (GetRegisterTypeKind(RegExpression)=tkNUMBER) then begin
              EmitOpcode(popN_EQ,RegComparsion,Reg1,RegExpression);
             end else begin
              EmitOpcode(popEQ,RegComparsion,Reg1,RegExpression);
             end;
             if Reg1<>RegComparsion then begin
              FreeRegister(Reg1);
             end;
            end;
            WhenSwitchCaseExpression^.JumpPosition:=CodeGenerator^.ByteCodeSize+1;
            if GetRegisterTypeKind(RegComparsion)=tkNUMBER then begin
             EmitOpcode(popN_JIFTRUE,0,RegComparsion);
            end else begin
             EmitOpcode(popJIFTRUE,0,RegComparsion);
            end;
            FreeRegister(RegComparsion);
           end;
          end;
         end;
         FreeRegister(RegExpression);
         if assigned(DefaultWhenSwitchCase) then begin
          DefaultWhenSwitchCase^.Expressions[0].JumpPosition:=CodeGenerator^.ByteCodeSize+1;
          EmitOpcode(popJMP,0);
          EndJumpPosition:=0;
         end else begin
          EndJumpPosition:=CodeGenerator^.ByteCodeSize+1;
          EmitOpcode(popJMP,0);
         end;
        end;
        begin
         if IsSwitch then begin
          StartSwitch;
         end;
         if TryIndex=0 then begin
          Registers[1]:=GetRegisters;
          Registers[2]:=GetRegisters;
          Registers[3]:=GetRegisters;
          Registers[4]:=GetRegisters;
          Registers[5]:=GetRegisters;
         end;
         begin
          for i:=0 to CountWhenSwitchCases-1 do begin
           WhenSwitchCase:=@WhenSwitchCases[i];
           if length(WhenSwitchCase^.Expressions)>0 then begin
            for j:=0 to length(WhenSwitchCase^.Expressions)-1 do begin
             FixTargetImmediate(WhenSwitchCase^.Expressions[j].JumpPosition);
            end;
            if TryIndex=0 then begin
             CombineRegisters(Registers[2],GetRegisters);
            end else begin
             ClearRegisters;
            end;
            StartFallthrough(JumpRetryPos);
            Reg:=GenerateBlock(WhenSwitchCase^.Body,result,DoNeedResult,true);
            if Reg<>result then begin
             EmitOpcode(popCOPY,result,Reg);
             SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
            end;
            WhenSwitchCase^.EndJumpPosition:=CodeGenerator^.ByteCodeSize+1;
            EmitOpcode(popJMP,0);
            if Reg<>result then begin
             EmitOpcode(popCOPY,result,Reg);
             SetRegisterTypeKind(result,GetRegisterTypeKind(Reg));
             FreeRegister(Reg);
            end;
            if TryIndex=0 then begin
             CombineRegisters(Registers[3],GetRegisters);
            end else begin
             ClearRegisters;
            end;
            EndFallthrough(CodeGenerator^.ByteCodeSize,Registers[4],Registers[5],HasRetry,HasFallthrough);
           end;
          end;
         end;
         Registers[6]:=GetRegisters;
         if IsSwitch then begin
          EndSwitch(CodeGenerator^.ByteCodeSize,Registers[6],HasBreak);
         end;
         if TryIndex=0 then begin
          Registers[7]:=GetRegisters;
         end else begin
          ClearRegisters;
         end;
         begin
          for i:=0 to CountWhenSwitchCases-1 do begin
           WhenSwitchCase:=@WhenSwitchCases[i];
           if WhenSwitchCase^.EndJumpPosition<>$ffffffff then begin
            FixTargetImmediate(WhenSwitchCase^.EndJumpPosition);
           end;
          end;
          if not assigned(DefaultWhenSwitchCase) then begin
           FixTargetImmediate(EndJumpPosition);
          end;
         end;
        end;
       end;
       if TryIndex=0 then begin
        // 0 = Before switch
        // 1 = After switch expression
        // 2 = Combined before each case block entrypoint
        // 3 = Combined after each case block end
        // 4 = Combined at each retry
        // 5 = Combined at each fallthrough
        // 6 = Combined at break
        // 7 = After switch
        if not AreRegistersEqual(Registers[0],Registers[1],false,false) then begin
         continue;
        end;
        if not AreRegistersEqual(Registers[1],Registers[2],false,false) then begin
         continue;
        end;
        if not AreRegistersEqual(Registers[2],Registers[3],false,false) then begin
         continue;
        end;
        if HasRetry and not (AreRegistersEqual(Registers[0],Registers[4],false,false) and
                             AreRegistersEqual(Registers[1],Registers[2],false,false) and
                             AreRegistersEqual(Registers[1],Registers[4],false,false) and
                             AreRegistersEqual(Registers[2],Registers[4],false,false)) then begin
         continue;
        end;
        if HasFallthrough and not AreRegistersEqual(Registers[2],Registers[5],false,false) then begin
         continue;
        end;
        if HasBreak and not AreRegistersEqual(Registers[6],Registers[7],false,false) then begin
         continue;
        end;
        ScopeDrop(ScopeState);
        break;
       end;
      end;
     finally
      SetLength(WhenSwitchCases,0);
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
      SetLength(Registers[2],0);
      SetLength(Registers[3],0);
      SetLength(Registers[4],0);
      SetLength(Registers[5],0);
      SetLength(Registers[6],0);
      SetLength(Registers[7],0);
     end;
     SetRegisterTypeKind(result,tkUNKNOWN);
    end;
    function GenerateDot(t:PPOCAToken;OutReg:TPOCAInt32;Safe:boolean):TPOCAInt32;
    var Reg,JumpNull,JumpEnd:TPOCAInt32;
        Registers:TPOCACodeGeneratorRegisters;
    begin
     result:=-1;
     Reg:=GenerateExpression(t^.Left,-1,true);
     Registers:=GetRegisters;
     if Safe then begin
      JumpNull:=CodeGenerator^.ByteCodeSize+1;
      EmitOpcode(popJIFFALSE,0,Reg);
     end else begin
      JumpNull:=0;
     end;
     if assigned(t^.Right) then begin
      case t^.Right^.Token of
       ptPROTOTYPE:begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popGETPROTOTYPE,result,Reg);
       end;
       ptCONSTRUCTOR:begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popGETCONSTRUCTOR,result,Reg);
       end;
       ptHASHKIND:begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popGETHASHKIND,result,Reg);
       end;
       ptSYMBOL,ptSUPERCODESYMBOL:begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        if Safe then begin
         EmitOpcode(popSAFEGETMEMBER,result,Reg,FindConstantIndex(t^.Right,false),$ffffffff,$ffffffff);
        end else begin
         EmitGetMember(result,Reg,FindConstantIndex(t^.Right,false),$ffffffff,$ffffffff);
        end;
       end;
       else begin
        SyntaxError('Object field must be symbol',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
     end;
     if Safe then begin
      JumpEnd:=CodeGenerator^.ByteCodeSize+1;
      EmitOpcode(popJMP,0);
      FixTargetImmediate(JumpNull);
      if result<>Reg then begin
       EmitOpcode(popCOPY,result,Reg);
       FreeRegister(Reg);
      end;
      SetRegisterTypeKind(result,tkUNKNOWN);
      CombineCurrentRegisters(Registers);
      FixTargetImmediate(JumpEnd);
     end else begin
      FreeRegister(Reg);
      SetRegisterTypeKind(result,tkUNKNOWN);
     end;
    end;
    function GenerateDefined(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var Reg,Reg1,Reg2,ConstantIndex,EndPos,TryBlockPos,CatchBlockPos:TPOCAInt32;
        Symbol:PPOCACodeGeneratorScopeSymbol;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     if (not assigned(t^.Right)) or (t^.Right^.Token=ptEMPTY) then begin
      SyntaxError('Missed expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      Symbol:=FindScopeSymbol(t^.Right,false,false,false);
      if assigned(Symbol) and (Symbol^.Register>=0) then begin
       EmitOpcode(popLOADONE,result);
      end else begin
       EmitImmediate(popTRY,6);
       Emit(result);
       Emit($ffffffff);
       TryBlockPos:=CodeGenerator^.ByteCodeSize;
       Emit($ffffffff);
       CatchBlockPos:=CodeGenerator^.ByteCodeSize;
       Emit($ffffffff);
       Emit($ffffffff);
       EndPos:=CodeGenerator^.ByteCodeSize;
       Emit($ffffffff);
       begin
        FixTargetImmediate(TryBlockPos);
        case t^.Right^.Token of
         ptLBRA,ptSAFELBRA:begin
          if not (assigned(t^.Right^.Left) and assigned(t^.Right^.Right)) then begin
           SyntaxError('Identifier expected',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
           exit;
          end;
          Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
          Reg2:=GenerateExpression(t^.Right^.Right,-1,true);
          EmitOpcode(popDEFINEDEX,result,Reg1,Reg2);
          FreeRegister(Reg2);
          FreeRegister(Reg1);
         end;
         ptDOT,ptSAFEDOT:begin
          if not (assigned(t^.Right^.Left) and assigned(t^.Right^.Right)) then begin
           SyntaxError('Symbol expected',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
           exit;
          end;
          case t^.Right^.Right^.Token of
           ptSYMBOL:begin
            ConstantIndex:=FindConstantIndex(t^.Right^.Right,false);
            Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
            EmitOpcode(popDEFINED,result,Reg1,ConstantIndex);
            FreeRegister(Reg1);
           end;
           ptPROTOTYPE,ptCONSTRUCTOR,ptHASHKIND:begin
            Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
            EmitOpcode(popLOADONE,result);
            FreeRegister(Reg1);
           end;
           else begin
            SyntaxError('Symbol expected',Parser.SourceFile,t^.Right^.Right^.SourceLine,t^.Right^.Right^.SourceColumn);
           end;
          end;
         end;
         else begin
          Reg:=GenerateExpression(t^.Right,-1,false);
          FreeRegister(Reg);
         end;
        end;
        EmitOpcode(popLOADONE,result);
        EmitOpcode(popTRYBLOCKEND,result);
       end;
       begin
        FixTargetImmediate(CatchBlockPos);
        EmitOpcode(popLOADZERO,result);
        EmitOpcode(popTRYBLOCKEND,result);
       end;
       FixTargetImmediate(EndPos);
      end;
     end;
     SetRegisterTypeKind(result,tkNUMBER);
    end;
    function GenerateTypeOf(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var Reg1:TPOCAInt32;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     if (not assigned(t^.Right)) or (t^.Right^.Token=ptEMPTY) then begin
      SyntaxError('Missed expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      Reg1:=GenerateExpression(t^.Right,-1,true);
      EmitOpcode(popTYPEOF,result,Reg1);
      FreeRegister(Reg1);
     end;
     SetRegisterTypeKind(result,tkUNKNOWN);
    end;
    function GenerateIDOf(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var Reg1:TPOCAInt32;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     if (not assigned(t^.Right)) or (t^.Right^.Token=ptEMPTY) then begin
      SyntaxError('Missed expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      Reg1:=GenerateExpression(t^.Right,-1,true);
      EmitOpcode(popIDOF,result,Reg1);
      FreeRegister(Reg1);
     end;
     SetRegisterTypeKind(result,tkUNKNOWN);
    end;
    function GenerateGhostTypeOf(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var Reg1:TPOCAInt32;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     if (not assigned(t^.Right)) or (t^.Right^.Token=ptEMPTY) then begin
      SyntaxError('Missed expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      Reg1:=GenerateExpression(t^.Right,-1,true);
      EmitOpcode(popGHOSTTYPEOF,result,Reg1);
      FreeRegister(Reg1);
     end;
     SetRegisterTypeKind(result,tkUNKNOWN);
    end;
    function GenerateLPAR(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    begin
     if Binary(t) or not assigned(t^.Right) then begin
      case t^.Left^.Token of
       ptDEFINED:begin
        result:=GenerateDefined(t,OutReg);
       end;
       ptTYPEOF:begin
        result:=GenerateTypeOf(t,OutReg);
       end;
       ptIDOF:begin
        result:=GenerateIDOf(t,OutReg);
       end;
       ptGHOSTTYPEOF:begin
        result:=GenerateGhostTypeOf(t,OutReg);
       end;
       else begin
        result:=GenerateFunctionCall(t,OutReg);
       end;
      end;
     end else begin
      if assigned(t^.Right) then begin
       case t^.Right^.Token of
        ptCOMMA:begin
         result:=GenerateCommaBlock(t^.Right,OutReg,DoNeedResult,true);
        end;
        ptSEMI,ptAUTOSEMI:begin
         result:=GenerateBlock(t^.Right,OutReg,DoNeedResult,true);
        end;
        else begin
         result:=GenerateExpression(t^.Right,OutReg,DoNeedResult);
        end;
       end;
      end else begin
       result:=GenerateExpression(t^.Right,OutReg,DoNeedResult);
      end;
     end;
    end;
    function GenerateRegExp(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var Reg:TPOCAInt32;
    begin
     if assigned(t^.Right) then begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      Reg:=GenerateExpression(t^.Right,-1,true);
      EmitOpcode(popREGEXP,result,CodeGenerator^.CountRegExps,Reg);
      FreeRegister(Reg);
      inc(CodeGenerator^.CountRegExps);
     end else begin
      result:=OutReg;
      SyntaxError('Parser error',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
    end;
    function GenerateReturn(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var v:TPOCAUInt32;
    begin
     if CodeToken in [ptCLASSFUNCTION,ptMODULEFUNCTION] then begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      EmitOpcode(popLOADLOCAL,result);
     end else begin
      if assigned(t^.Right) then begin
       result:=GenerateExpression(t^.Right,-1,true);
      end else begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADNULL,result);
      end;
     end;
     if ((CodeToken=ptFASTFUNCTION) or (assigned(t^.Right) and ((assigned(t^.Right^.Left) and (t^.Right^.Left^.Token=ptSELF)) and (Binary(t^.Right) or not assigned(t^.Right^.Right))))) and ((CodeGenerator^.CountOpcodes>0) and ((CodeGenerator^.ByteCode[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-1]] and $ff) in [popFCALL,popMCALL,popFCALLH,popMCALLH])) then begin
      v:=CodeGenerator^.ByteCode[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-1]];
      case v and $ff of
       popFCALL:begin
        v:=popFTAILCALL or (v and $ffffff00);
       end;
       popMCALL:begin
        v:=popMTAILCALL or (v and $ffffff00);
       end;
       popFCALLH:begin
        v:=popFTAILCALLH or (v and $ffffff00);
       end;
       popMCALLH:begin
        v:=popMTAILCALLH or (v and $ffffff00);
       end;
       else begin
        EmitOpcode(popRETURN,result);
       end;
      end;
      CodeGenerator^.ByteCode[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-1]]:=v;
      exit;
     end;
     EmitOpcode(popRETURN,result);
     SetRegisterTypeKind(result,tkUNKNOWN);
    end;
    function GenerateDelete(t:PPOCAToken;OutReg:TPOCAInt32):TPOCAInt32;
    var Reg1,Reg2,ConstantIndex:TPOCAInt32;
        Symbol:PPOCACodeGeneratorScopeSymbol;
    begin
     result:=OutReg;
     if not assigned(t^.Right) then begin
      SyntaxError('Symbol expected',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
      exit;
     end;
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end;
     case t^.Right^.Token of
      ptLBRA:begin
       if not (assigned(t^.Right^.Left) and assigned(t^.Right^.Right)) then begin
        SyntaxError('Identifier expected',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
        exit;
       end;
       Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
       Reg2:=GenerateExpression(t^.Right^.Right,-1,true);
       EmitOpcode(popDELETEEX,result,Reg1,Reg2);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
      end;
      ptSAFELBRA:begin
       SyntaxError('??[ at Delete is not allowed',Parser.SourceFile,t^.Right^.SourceLine,t^.Right^.SourceColumn);
      end;
      ptDOT:begin
       if not (assigned(t^.Right^.Left) and assigned(t^.Right^.Right)) then begin
        SyntaxError('Symbol expected',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
        exit;
       end;
       case t^.Right^.Right^.Token of
        ptSYMBOL:begin
         ConstantIndex:=FindConstantIndex(t^.Right^.Right,false);
         Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
         EmitOpcode(popDELETE,result,Reg1,ConstantIndex);
         FreeRegister(Reg1);
        end;
        ptPROTOTYPE:begin
         Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
         Reg2:=GetRegister(true,false);
         EmitOpcode(popLOADNULL,Reg2);
         EmitOpcode(popSETPROTOTYPE,Reg1,Reg2);
         FreeRegister(Reg2);
         FreeRegister(Reg1);
         EmitOpcode(popLOADONE,result);
        end;
        ptCONSTRUCTOR:begin
         Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
         Reg2:=GetRegister(true,false);
         EmitOpcode(popLOADNULL,Reg2);
         EmitOpcode(popSETCONSTRUCTOR,Reg1,Reg2);
         FreeRegister(Reg2);
         FreeRegister(Reg1);
         EmitOpcode(popLOADONE,result);
        end;
        ptHASHKIND:begin
         Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
         Reg2:=GetRegister(true,false);
         EmitOpcode(popLOADZERO,Reg2);
         EmitOpcode(popSETHASHKIND,Reg1,Reg2);
         FreeRegister(Reg2);
         FreeRegister(Reg1);
         EmitOpcode(popLOADONE,result);
        end;
        else begin
         SyntaxError('Symbol expected',Parser.SourceFile,t^.Right^.Right^.SourceLine,t^.Right^.Right^.SourceColumn);
        end;
       end;
      end;
      ptSAFEDOT:begin
       SyntaxError('??. at Delete is not allowed',Parser.SourceFile,t^.Right^.SourceLine,t^.Right^.SourceColumn);
      end;
      ptSYMBOL:begin
       Symbol:=FindScopeSymbol(t,false,false,false);
       if assigned(Symbol) and (Symbol^.Register>=0) then begin
        if Symbol^.Constant then begin
         SyntaxError('Constants aren''t deleteable',Parser.SourceFile,t^.Right^.SourceLine,t^.Right^.SourceColumn);
        end else begin
         if DeleteSymbolRegister(t^.Right,1) then begin
          EmitOpcode(popLOADONE,result);
         end else begin
          SyntaxError('Local symbols outside scope block not deleteable',Parser.SourceFile,t^.Right^.SourceLine,t^.Right^.SourceColumn);
         end;
        enD;
       end else begin
        Reg1:=GetRegister(true,false);
        EmitOpcode(popLOADLOCAL,Reg1);
        ConstantIndex:=FindConstantIndex(t^.Right,true);
        EmitOpcode(popDELETE,result,Reg1,ConstantIndex);
        FreeRegister(Reg1);
       end;
      end;
      ptPROTOTYPE:begin
       Reg1:=GetRegister(true,false);
       Reg2:=GetRegister(true,false);
       EmitOpcode(popLOADLOCAL,Reg1);
       EmitOpcode(popLOADNULL,Reg2);
       EmitOpcode(popSETPROTOTYPE,Reg1,Reg2);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
       EmitOpcode(popLOADONE,result);
      end;
      ptCONSTRUCTOR:begin
       Reg1:=GetRegister(true,false);
       Reg2:=GetRegister(true,false);
       EmitOpcode(popLOADLOCAL,Reg1);
       EmitOpcode(popLOADNULL,Reg2);
       EmitOpcode(popSETCONSTRUCTOR,Reg1,Reg2);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
       EmitOpcode(popLOADONE,result);
      end;
      ptHASHKIND:begin
       Reg1:=GetRegister(true,false);
       Reg2:=GetRegister(true,false);
       EmitOpcode(popLOADLOCAL,Reg1);
       EmitOpcode(popLOADONE,Reg2);
       EmitOpcode(popSETHASHKIND,Reg1,Reg2);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
       EmitOpcode(popLOADONE,result);
      end;
      else begin
       SyntaxError('Symbol expected',Parser.SourceFile,t^.Right^.Right^.SourceLine,t^.Right^.Right^.SourceColumn);
      end;
     end;
     SetRegisterTypeKind(result,tkNUMBER);
    end;
   var i:TPOCAInt32;
       Symbol:PPOCACodeGeneratorScopeSymbol;
       SymbolKind:TPOCACodeGeneratorScopeSymbolKind;
       Token:TPOCATokenType;
   begin
    result:=-1;
    if not assigned(t) then begin
     SyntaxError('Parser error',Parser.SourceFile,-1,-1);
    end else begin
     if CodeGenerator^.LastLine<>t^.SourceLine then begin
      CodeGenerator^.LastLine:=t^.SourceLine;
      NewLine(t^.SourceLine);
     end;
     case t^.Token of
      ptTOP:begin
       result:=GenerateBlock(t^.Left,OutReg,DoNeedResult,true);
      end;
      ptSCOPE:begin
       if (not assigned(t^.Left)) or (t^.Left^.Token<>ptLCURL) then begin
        SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        result:=GenerateBlock(t^.Left^.Children,OutReg,DoNeedResult,true);
       end;
      end;
      ptCODE:begin
       if (not assigned(t^.Left)) or (t^.Left^.Token<>ptLCURL) then begin
        SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        result:=GenerateBlock(t^.Left^.Children,OutReg,DoNeedResult,false);
       end;
      end;
      ptNEW:begin
       if assigned(t^.Right) and (t^.Right^.Token=ptLPAR) then begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        result:=GenerateFunctionCall(t^.Right,result,'create');
       end else begin
        SyntaxError('Invalid new usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptSUPERTHAT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADTHAT,result);
       SetRegisterTypeKind(result,tkUNKNOWN);
      end;
      ptTHAT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADTHAT,result);
       SetRegisterTypeKind(result,tkUNKNOWN);
      end;
      ptTHIS:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADTHIS,result);
       SetRegisterTypeKind(result,tkUNKNOWN);
      end;
      ptSELF:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADSELF,result);
       SetRegisterTypeKind(result,tkUNKNOWN);
      end;
      ptLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADLOCAL,result);
       SetRegisterTypeKind(result,tkUNKNOWN);
      end;
      ptGLOBAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADGLOBAL,result);
       SetRegisterTypeKind(result,tkUNKNOWN);
      end;
      ptBASECLASS:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADBASECLASS,result);
       SetRegisterTypeKind(result,tkUNKNOWN);
      end;
      ptSYMBOL:begin
       if t^.Str=CodeGenerator^.RestArgSymbolString then begin
        CodeGenerator^.HasRestArguments:=true;
        CodeGenerator^.HasLocals:=true;
       end;
       Symbol:=FindScopeSymbol(t,false,true,false);
       if assigned(Symbol) and (Symbol^.Kind=TPOCACodeGeneratorScopeSymbolKind.sskREG) and (Symbol^.Register>=0) then begin
        result:=Symbol^.Register;
        if OutReg>=0 then begin
         EmitOpcode(popCOPY,OutReg,result);
         SetRegisterTypeKind(OutReg,GetRegisterTypeKind(result));
         result:=OutReg;
        end;
       end else if assigned(Symbol) and (Symbol^.Kind=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE) then begin
        CodeGenerator^.UsedFrameValues:=true;
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        if Symbol^.FrameValueLevel=CodeGenerator^.Level then begin
         EmitOpcode(popGETLOCALVALUE,result,Symbol^.FrameValueIndex);
        end else begin
         EmitOpcode(popGETOUTERVALUE,result,Symbol^.FrameValueLevel,Symbol^.FrameValueIndex);
        end;
        SetRegisterTypeKind(result,tkUNKNOWN);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popGETLOCAL,result,FindConstantIndex(t,true),$ffffffff);
        SetRegisterTypeKind(result,tkUNKNOWN);
       end;
      end;
      ptLITERALNUM,ptLITERALSTR:begin
       if OutReg<0 then begin
        result:=FindConstantRegister(t);
        if result<0 then begin
         result:=GenerateScalarConstant(t,OutReg);
        end;
       end else begin
        result:=GenerateScalarConstant(t,OutReg);
       end;
       case t^.Token of
        ptLITERALNUM:begin
         SetRegisterTypeKind(result,tkNUMBER);
        end;
        ptLITERALSTR:begin
         SetRegisterTypeKind(result,tkSTRING);
        end;
        else begin
         SetRegisterTypeKind(result,tkUNKNOWN);
        end;
       end;
      end;
      ptVAR,ptLET,ptCONST:begin
       Token:=t^.Token;
       if assigned(t^.Right) and (t^.Right^.Token=ptSYMBOL) then begin
        if IsScopeSymbolConstant(t^.Right,false,false) then begin
         SyntaxError('Constants are read-only',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        case Token of
         ptVAR:begin
          SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskVAR;
         end;
         else {ptLET,ptCONST:}begin
          if ExistScopeSymbol(t^.Right,false,false,true) then begin
           SyntaxError('Symbol already defined',t^.Right^.SourceFile,t^.Right^.SourceLine,t^.Right^.SourceColumn);
           SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
          end else begin
           if CodeGenerator^.HasNestedFunctions then begin
            SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE;
           end else begin
            SymbolKind:=TPOCACodeGeneratorScopeSymbolKind.sskREG;
           end;
          end;
         end;
        end;
        if SymbolKind=TPOCACodeGeneratorScopeSymbolKind.sskREG then begin
         Symbol:=DefineScopeSymbol(t^.Right,false,true,Token=ptCONST,false,GetRegister(false,Token=ptCONST));
         if assigned(Symbol) then begin
          if OutReg<0 then begin
           result:=GetRegister(true,false);
          end else begin
           result:=OutReg;
          end;
          EmitOpcode(popLOADNULL,result);
          SetRegisterTypeKind(result,tkNULL);
          i:=Symbol^.Register;
          EmitOpcode(popCOPY,i,result);
          SetRegisterTypeKind(i,GetRegisterTypeKind(result));
         end;
         exit;
        end else begin
         if CodeToken=ptFASTFUNCTION then begin
          SyntaxError('VAR is not allowed in fastfunctions',t^.Right^.SourceFile,t^.Right^.SourceLine,t^.Right^.SourceColumn);
         end;
         CodeGenerator^.HasLocals:=true;
         Symbol:=DefineScopeSymbol(t^.Right,true,(Token=ptLET) or (Token=ptCONST),Token=ptCONST,false,-1);
         if OutReg<0 then begin
          result:=GetRegister(true,false);
         end else begin
          result:=OutReg;
         end;
         EmitOpcode(popLOADNULL,result);
         SetRegisterTypeKind(result,tkNULL);
         if assigned(Symbol) and (Symbol^.Kind=TPOCACodeGeneratorScopeSymbolKind.sskFRAMEVALUE) then begin
          CodeGenerator^.UsedFrameValues:=true;
          if Symbol^.FrameValueLevel=CodeGenerator^.Level then begin
           EmitOpcode(popSETLOCALVALUE,Symbol^.FrameValueIndex,result);
          end else begin
           EmitOpcode(popSETOUTERVALUE,Symbol^.FrameValueLevel,Symbol^.FrameValueIndex,result);
          end;
          Symbol^.TypeKind:=GetRegisterTypeKind(result);
         end else if Token=ptCONST then begin
          EmitOpcode(popSETCONSTLOCAL,FindConstantIndex(t^.Right,true),result,$ffffffff);
         end else begin
          EmitOpcode(popSETLOCAL,FindConstantIndex(t^.Right,true),result,$ffffffff);
         end;
         exit;
        end;
       end else begin
        SyntaxError('Symbol expected',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin
       result:=GenerateLambda(t,OutReg);
       SetRegisterTypeKind(result,tkUNKNOWN);
      end;
      ptTRY:begin
       result:=GenerateTry(t,OutReg);
       SetRegisterTypeKind(result,tkUNKNOWN);
      end;
      ptIF:begin
       result:=GenerateIFELSE(t,OutReg);
      end;
      ptQUESTION:begin
       result:=GenerateQuestion(t,OutReg);
      end;
      ptWHILE:begin
       result:=GenerateWhile(t,OutReg);
      end;
      ptDO:begin
       result:=GenerateDoWhile(t,OutReg);
      end;
      ptFOR:begin
       result:=GenerateFor(t,OutReg);
      end;
      ptLPAR:begin
       result:=GenerateLPAR(t,OutReg);
      end;
      ptFOREACH,ptFORINDEX,ptFORKEY:begin
       result:=GenerateForEachForIndexForKey(t,OutReg);
      end;
      ptBREAK,ptCONTINUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       GenerateBreakContinue(t);
      end;
      ptFALLTHROUGH:begin
       GenerateFallthrough(t);
      end;
      ptRETRY:begin
       GenerateRetry(t);
      end;
      ptASSIGN:begin
       result:=GenerateAssignment(t,OutReg);
      end;
      ptLCURL:begin
       if assigned(t^.Children) and IsLCURLCodeBlock(t^.Children) then begin
        result:=GenerateBlock(t^.Children,OutReg,DoNeedResult,true);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popNEWHASH,result);
        GenerateHash(t^.Left,result);
        SetRegisterTypeKind(result,tkUNKNOWN);
       end;
      end;
      ptLBRA:begin
       if Unary(t) then begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popNEWARRAY,result);
        GenerateArray(t^.Left,result);
        SetRegisterTypeKind(result,tkARRAY);
       end else if Binary(t) then begin
        result:=GenerateExtract(t,OutReg,false);
       end else begin
        SyntaxError('Invalid token usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptSAFELBRA:begin
       if Binary(t) then begin
        result:=GenerateExtract(t,OutReg,true);
       end else begin
        SyntaxError('Invalid token usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptREGEXP:begin
       result:=GenerateRegExp(t,OutReg);
      end;
      ptRETURN:begin
       result:=GenerateReturn(t,OutReg);
      end;
      ptTHROW:begin
       if assigned(t^.Right) then begin
        result:=GenerateExpression(t^.Right,-1,true);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popLOADNULL,result);
        SetRegisterTypeKind(result,tkNULL);
       end;
       EmitOpcode(popTHROW,result);
      end;
      ptNOT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       i:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(popNOT,result,i);
       if GetRegisterTypeKind(i)=tkNUMBER then begin
        SetRegisterTypeKind(result,tkNUMBER);
       end else begin
        SetRegisterTypeKind(result,tkUNKNOWN);
       end;
       FreeRegister(i);
      end;
      ptWHEN:begin
       result:=GenerateWhenOrSwitch(t,OutReg,false);
      end;
      ptSWITCH:begin
       result:=GenerateWhenOrSwitch(t,OutReg,true);
      end;
      ptMINUS:begin
       if Binary(t) then begin
        result:=GenerateBinaryOperation(popSUB,t,OutReg);
       end else if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
        result:=GenerateNumberConstant(-t^.Right^.Num,OutReg);
        SetRegisterTypeKind(result,tkNUMBER);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        EmitOpcode(popNEG,result,i);
        if GetRegisterTypeKind(i)=tkNUMBER then begin
         SetRegisterTypeKind(result,tkNUMBER);
        end else begin
         SetRegisterTypeKind(result,tkUNKNOWN);
        end;
        FreeRegister(i);
       end;
      end;
      ptNEG:begin
       if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
        t^.Right^.Num:=-t^.Right^.Num;
        result:=GenerateScalarConstant(t^.Right,OutReg);
        SetRegisterTypeKind(result,tkNUMBER);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        EmitOpcode(popNEG,result,i);
        if GetRegisterTypeKind(i)=tkNUMBER then begin
         SetRegisterTypeKind(result,tkNUMBER);
        end else begin
         SetRegisterTypeKind(result,tkUNKNOWN);
        end;
        FreeRegister(i);
       end;
      end;
      ptNUM:begin
       if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
        result:=GenerateScalarConstant(t^.Right,OutReg);
        SetRegisterTypeKind(result,tkNUMBER);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        EmitOpcode(popNUM,result,i);
        SetRegisterTypeKind(result,tkNUMBER);
        FreeRegister(i);
       end;
      end;
      ptDOT:begin
       result:=GenerateDot(t,OutReg,false);
      end;
      ptSAFEDOT:begin
       result:=GenerateDot(t,OutReg,true);
      end;
      ptEMPTY:begin
       if OutReg<0 then begin
        if DoNeedResult then begin
         result:=GetRegister(true,false);
         EmitOpcode(popLOADNULL,result);
         SetRegisterTypeKind(result,tkNULL);
        end else begin
         result:=OutReg;
         exit;
        end;
       end else begin
        result:=OutReg;
        EmitOpcode(popLOADNULL,result);
        SetRegisterTypeKind(result,tkNULL);
       end;
      end;
      ptNULL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADNULL,result);
       SetRegisterTypeKind(result,tkNULL);
      end;
      ptAND,ptOR,ptELVIS:begin
       result:=GenerateShortCircuit(t,OutReg);
      end;
      ptNULLISHOR:begin
       result:=GenerateNullishShortCircuit(t,OutReg);
      end;
      ptMUL:begin
       result:=GenerateBinaryOperation(popMUL,t,OutReg);
      end;
      ptPLUS:begin
       if t^.Rule=prPREFIX then begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        EmitOpcode(popNUM,result,i);
        SetRegisterTypeKind(result,tkNUMBER);
        FreeRegister(i);
       end else begin
        result:=GenerateBinaryOperation(popADD,t,OutReg);
       end;
      end;
      ptDIV:begin
       result:=GenerateBinaryOperation(popDIV,t,OutReg);
      end;
      ptLT:begin
       result:=GenerateBinaryOperation(popLT,t,OutReg);
      end;
      ptLTEQ:begin
       result:=GenerateBinaryOperation(popLTEQ,t,OutReg);
      end;
      ptEQ:begin
       result:=GenerateBinaryOperation(popEQ,t,OutReg);
      end;
      ptNEQ:begin
       result:=GenerateBinaryOperation(popNEQ,t,OutReg);
      end;
      ptGT:begin
       result:=GenerateBinaryOperation(popGT,t,OutReg);
      end;
      ptGTEQ:begin
       result:=GenerateBinaryOperation(popGTEQ,t,OutReg);
      end;
      ptCMP:begin
       result:=GenerateBinaryOperation(popCMP,t,OutReg);
      end;
      ptPOSTDEC:begin
       result:=GeneratePostfixDecIncOp(popDEC,t,OutReg);
      end;
      ptPOSTINC:begin
       result:=GeneratePostfixDecIncOp(popINC,t,OutReg);
      end;
      ptPREDEC:begin
       result:=GeneratePrefixDecIncOp(popDEC,t,OutReg);
      end;
      ptPREINC:begin
       result:=GeneratePrefixDecIncOp(popINC,t,OutReg);
      end;
      ptPLUSEQ:begin
       result:=GenerateAssignOp(popADD,t,OutReg);
      end;
      ptMINUSEQ:begin
       result:=GenerateAssignOp(popSUB,t,OutReg);
      end;
      ptMULEQ:begin
       result:=GenerateAssignOp(popMUL,t,OutReg);
      end;
      ptDIVEQ:begin
       result:=GenerateAssignOp(popDIV,t,OutReg);
      end;
      ptCATEQ:begin
       result:=GenerateAssignOp(popCAT,t,OutReg);
      end;
      ptCAT:begin
       if Binary(t) then begin
        result:=GenerateBinaryOperation(popCAT,t,OutReg);
       end else if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
        t^.Right^.Num:=not TPOCAInt64(trunc(t^.Right^.Num));
        result:=GenerateScalarConstant(t^.Right,OutReg);
        SetRegisterTypeKind(result,tkNUMBER);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        if GetRegisterTypeKind(i)=tkNUMBER then begin
         EmitOpcode(popN_BNOT,result,i);
         SetRegisterTypeKind(result,tkNUMBER);
        end else begin
         EmitOpcode(popBNOT,result,i);
         SetRegisterTypeKind(result,tkUNKNOWN);
        end;
        FreeRegister(i);
       end;
      end;
      ptBNOT:begin
       if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
        t^.Right^.Num:=not TPOCAInt64(trunc(t^.Right^.Num));
        result:=GenerateScalarConstant(t^.Right,OutReg);
        SetRegisterTypeKind(result,tkNUMBER);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        if GetRegisterTypeKind(i)=tkNUMBER then begin
         EmitOpcode(popN_BNOT,result,i);
         SetRegisterTypeKind(result,tkNUMBER);
        end else begin
         EmitOpcode(popBNOT,result,i);
         SetRegisterTypeKind(result,tkUNKNOWN);
        end;
        FreeRegister(i);
       end;
      end;
      ptBAND:begin
       result:=GenerateBinaryOperation(popBAND,t,OutReg);
      end;
      ptBOR:begin
       result:=GenerateBinaryOperation(popBOR,t,OutReg);
      end;
      ptBXOR:begin
       result:=GenerateBinaryOperation(popBXOR,t,OutReg);
      end;
      ptBSHL:begin
       result:=GenerateBinaryOperation(popBSHL,t,OutReg);
      end;
      ptBSHR:begin
       result:=GenerateBinaryOperation(popBSHR,t,OutReg);
      end;
      ptBUSHR:begin
       result:=GenerateBinaryOperation(popBUSHR,t,OutReg);
      end;
      ptMOD:begin
       result:=GenerateBinaryOperation(popMOD,t,OutReg);
      end;
      ptPOW:begin
       if ((Binary(t) and assigned(t^.Right)) and (t^.Right^.Token=ptLITERALNUM)) and (t^.Right^.Num=0.5) then begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Left,-1,true);
        if GetRegisterTypeKind(i)=tkNUMBER then begin
         EmitOpcode(popN_SQRT,result,i);
         SetRegisterTypeKind(result,tkNUMBER);
        end else begin
         EmitOpcode(popSQRT,result,i);
         SetRegisterTypeKind(result,tkUNKNOWN);
        end;
        FreeRegister(i);
       end else begin
        result:=GenerateBinaryOperation(popPOW,t,OutReg);
       end;
      end;
      ptBOREQ:begin
       result:=GenerateAssignOp(popBOR,t,OutReg);
      end;
      ptBANDEQ:begin
       result:=GenerateAssignOp(popBAND,t,OutReg);
      end;
      ptBXOREQ:begin
       result:=GenerateAssignOp(popBXOR,t,OutReg);
      end;
      ptBSHLEQ:begin
       result:=GenerateAssignOp(popBSHL,t,OutReg);
      end;
      ptBSHREQ:begin
       result:=GenerateAssignOp(popBSHR,t,OutReg);
      end;
      ptBUSHREQ:begin
       result:=GenerateAssignOp(popBUSHR,t,OutReg);
      end;
      ptMODEQ:begin
       result:=GenerateAssignOp(popMOD,t,OutReg);
      end;
      ptPOWEQ:begin
       result:=GenerateAssignOp(popPOW,t,OutReg);
      end;
      ptELVISEQ:begin
       result:=GenerateElvisAssignOp(t,OutReg);
      end;
      ptINSTANCEOF:begin
       result:=GenerateBinaryOperation(popINSTANCEOF,t,OutReg);
       SetRegisterTypeKind(result,tkNUMBER);
      end;
      ptSEQ:begin
       result:=GenerateBinaryOperation(popSEQ,t,OutReg);
      end;
      ptSNEQ:begin
       result:=GenerateBinaryOperation(popSNEQ,t,OutReg);
      end;
      ptIN:begin
       result:=GenerateInOperation(t,OutReg);
      end;
      ptIS:begin
       result:=GenerateBinaryOperation(popIS,t,OutReg);
       SetRegisterTypeKind(result,tkNUMBER);
      end;
      ptTRUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADONE,result);
       SetRegisterTypeKind(result,tkNUMBER);
      end;
      ptFALSE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADZERO,result);
       SetRegisterTypeKind(result,tkNUMBER);
      end;
      ptREGEXPEQ:begin
       result:=GenerateBinaryOperation(popREGEXPEQ,t,OutReg);
      end;
      ptREGEXPNEQ:begin
       result:=GenerateBinaryOperation(popREGEXPNEQ,t,OutReg);
      end;
      ptBREAKPOINT:begin
       if DoNeedResult then begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popLOADNULL,result);
        SetRegisterTypeKind(result,tkNULL);
        EmitOpcode(popBREAKPOINT);
       end else begin
        result:=OutReg;
        EmitOpcode(popBREAKPOINT);
       end;
      end;
      ptDELETE:begin
       result:=GenerateDelete(t,OutReg);
      end;
      else begin
       SyntaxError('Invalid token',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
     if result<0 then begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      EmitOpcode(popLOADNULL,result);
      SetRegisterTypeKind(result,tkNULL);
     end;
    end;
   end;
   procedure PreprocessArgumentList(t:PPOCAToken);
   var IsLocal,IsConst,IsVar:boolean;
       Symbol:PPOCAToken;
       ScopeScope:PPOCACodeGeneratorScopeSymbol;
       CodeArgument:PPOCACodeArgument;
   begin
    IsConst:=false;
    IsVar:=false;
    if assigned(t) and (t^.Token<>ptEMPTY) then begin
     Symbol:=nil;
     case t^.Token of
      ptELLIPSIS:begin
       IsLocal:=false;
       if CodeToken=ptFASTFUNCTION then begin
        SyntaxError('Bad fastfunction argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptASSIGN:begin
       IsLocal:=assigned(t^.Left) and (t^.Left^.Token in [ptLET,ptCONST]);
       if IsLocal then begin
        if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptSYMBOL) then begin
         Symbol:=t^.Left^.Right;
        end else begin
         SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
       end else if CodeToken=ptFASTFUNCTION then begin
        if assigned(t^.Left) and (t^.Left^.Token=ptVAR) then begin
         SyntaxError('Bad fastfunction argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end else begin
         IsLocal:=true;
         Symbol:=t^.Left;
        end;
       end;
      end;
      ptLET,ptCONST:begin
       IsLocal:=true;
       IsConst:=t^.Token=ptCONST;
       if assigned(t^.Right) and (t^.Right^.Token=ptSYMBOL) then begin
        Symbol:=t^.Right;
       end;
      end;
      ptVAR:begin
       IsVar:=true;
       if CodeToken=ptFASTFUNCTION then begin
        IsLocal:=true;
        Symbol:=t^.Right;
       end else begin
        IsLocal:=false;
        Symbol:=t;
       end;
      end;
      ptSYMBOL:begin
       if CodeToken=ptFASTFUNCTION then begin
        IsLocal:=true;
       end else begin
        IsLocal:=false;
       end;
       Symbol:=t;
      end;
      ptCOMMA:begin
       PreprocessArgumentList(t^.Left);
       PreprocessArgumentList(t^.Right);
       exit;
      end;
      else begin
       IsLocal:=false;
       SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
     if CodeGenerator^.CountLocalArguments>=length(CodeGenerator^.LocalArguments) then begin
      if CodeGenerator^.CountLocalArguments=0 then begin
       SetLength(CodeGenerator^.LocalArguments,128);
      end else begin
       SetLength(CodeGenerator^.LocalArguments,CodeGenerator^.CountLocalArguments*2);
      end;
     end;
     if CodeGenerator^.HasNestedFunctions and not IsVar then begin
      ScopeScope:=FindScopeSymbol(Symbol,false,false,false);
      if not assigned(ScopeScope) then begin
       ScopeScope:=DefineScopeSymbol(Symbol,true,true,IsConst,false,-1);
      end;
      if assigned(ScopeScope) then begin
       CodeGenerator^.LocalArguments[CodeGenerator^.CountLocalArguments].Kind:=TPOCACodeArgument.pcakFRAMEVALUE;
       CodeGenerator^.LocalArguments[CodeGenerator^.CountLocalArguments].Level:=ScopeScope^.FrameValueLevel;
       CodeGenerator^.LocalArguments[CodeGenerator^.CountLocalArguments].Index:=ScopeScope^.FrameValueIndex;
      end;
     end else if IsLocal then begin
      ScopeScope:=FindScopeSymbol(Symbol,false,false,false);
      if not assigned(ScopeScope) then begin
       ScopeScope:=DefineScopeSymbol(Symbol,false,true,IsConst,false,GetRegister(false,IsConst));
      end;
      if assigned(ScopeScope) then begin
       CodeGenerator^.LocalArguments[CodeGenerator^.CountLocalArguments].Kind:=TPOCACodeArgument.pcakREG;
       CodeGenerator^.LocalArguments[CodeGenerator^.CountLocalArguments].Index:=ScopeScope^.Register;
      end;
     end else begin
      CodeGenerator^.LocalArguments[CodeGenerator^.CountLocalArguments].Kind:=TPOCACodeArgument.pcakVAR;
      CodeGenerator^.LocalArguments[CodeGenerator^.CountLocalArguments].Index:=0;
      CodeGenerator^.HasLocals:=true;
     end;
     inc(CodeGenerator^.CountLocalArguments);
    end;
   end;
   procedure GenerateArgumentList(t:PPOCAToken;Code:PPOCACode);
   begin
    if assigned(t) and (t^.Token<>ptEMPTY) then begin
     if not POCAIsValueIdentical(CodeGenerator^.RestArgSym,Instance^.Globals.ArgumentsValueReference) then begin
      SyntaxError('Remainder must be last',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      case t^.Token of
       ptELLIPSIS:begin
        if (not assigned(t^.Left)) or (t^.Left^.Token<>ptSYMBOL) then begin
         SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end else begin
         CodeGenerator^.RestArgSymbolString:=t^.Left^.Str;
         CodeGenerator^.RestArgSym:=POCAInternSymbol(Parser.Context,Instance,POCANewString(Parser.Context,t^.Left^.Str));
         CodeGenerator^.HasLocals:=true;
         CodeGenerator^.HasRestArguments:=true;
         Code^.HasRestArguments:=true;
        end;
       end;
       ptASSIGN:begin
        if assigned(t^.Left) and (t^.Left^.Token in [ptLET,ptCONST]) then begin
         if (not assigned(t^.Left^.Right)) or (t^.Left^.Right^.Token<>ptSYMBOL) then begin
          SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end else begin
          if Code^.CountOptionalArguments>=CodeGenerator^.OptionalArgumentAllocated then begin
           CodeGenerator^.OptionalArgumentAllocated:=Code^.CountOptionalArguments*2;
           ReallocMem(CodeGenerator^.OptionalArgumentSymbols,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCAInt32));
           ReallocMem(CodeGenerator^.OptionalArgumentLocals,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCACodeArgument));
           ReallocMem(CodeGenerator^.OptionalArgumentValues,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCAInt32));
          end;
          CodeGenerator^.OptionalArgumentSymbols[Code^.CountOptionalArguments]:=FindConstantIndex(t^.Left^.Right,true);
          CodeGenerator^.OptionalArgumentLocals[Code^.CountOptionalArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
          CodeGenerator^.OptionalArgumentValues[Code^.CountOptionalArguments]:=DefineArgument(t^.Right);
          inc(Code^.CountOptionalArguments);
          Code^.HasArgumentLocals:=true;
         end;
        end else if assigned(t^.Left) and (t^.Left^.Token=ptVAR) then begin
         if (not assigned(t^.Left^.Right)) or (t^.Left^.Right^.Token<>ptSYMBOL) then begin
          SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end else begin
          if Code^.CountOptionalArguments>=CodeGenerator^.OptionalArgumentAllocated then begin
           CodeGenerator^.OptionalArgumentAllocated:=Code^.CountOptionalArguments*2;
           ReallocMem(CodeGenerator^.OptionalArgumentSymbols,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCAInt32));
           ReallocMem(CodeGenerator^.OptionalArgumentLocals,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCACodeArgument));
           ReallocMem(CodeGenerator^.OptionalArgumentValues,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCAInt32));
          end;
          CodeGenerator^.OptionalArgumentSymbols[Code^.CountOptionalArguments]:=FindConstantIndex(t^.Left^.Right,true);
          CodeGenerator^.OptionalArgumentLocals[Code^.CountOptionalArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
          CodeGenerator^.OptionalArgumentValues[Code^.CountOptionalArguments]:=DefineArgument(t^.Right);
          inc(Code^.CountOptionalArguments);
         end;
        end else begin
         if (not assigned(t^.Left)) or (t^.Left^.Token<>ptSYMBOL) then begin
          SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end else begin
          if Code^.CountOptionalArguments>=CodeGenerator^.OptionalArgumentAllocated then begin
           CodeGenerator^.OptionalArgumentAllocated:=Code^.CountOptionalArguments*2;
           ReallocMem(CodeGenerator^.OptionalArgumentSymbols,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCAInt32));
           ReallocMem(CodeGenerator^.OptionalArgumentLocals,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCACodeArgument));
           ReallocMem(CodeGenerator^.OptionalArgumentValues,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCAInt32));
          end;
          CodeGenerator^.OptionalArgumentSymbols[Code^.CountOptionalArguments]:=FindConstantIndex(t^.Left,true);
          CodeGenerator^.OptionalArgumentLocals[Code^.CountOptionalArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
          CodeGenerator^.OptionalArgumentValues[Code^.CountOptionalArguments]:=DefineArgument(t^.Right);
          inc(Code^.CountOptionalArguments);
         end;
        end;
       end;
       ptLET,ptCONST:begin
        if Code^.CountOptionalArguments>0 then begin
         SyntaxError('Optional arguments must be last',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end else begin
         if (not assigned(t^.Right)) or (t^.Right^.Token<>ptSYMBOL) then begin
          SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end else begin
          if Code^.CountArguments>=CodeGenerator^.ArgAllocated then begin
           CodeGenerator^.ArgAllocated:=Code^.CountArguments*2;
           ReallocMem(CodeGenerator^.ArgumentSymbols,CodeGenerator^.ArgAllocated*sizeof(TPOCAInt32));
           ReallocMem(CodeGenerator^.ArgumentLocals,CodeGenerator^.ArgAllocated*sizeof(TPOCACodeArgument));
          end;
          CodeGenerator^.ArgumentSymbols[Code^.CountArguments]:=FindConstantIndex(t^.Right,true);
          CodeGenerator^.ArgumentLocals[Code^.CountArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
          inc(Code^.CountArguments);
          Code^.HasArgumentLocals:=true;
         end;
        end;
       end;
       ptVAR:begin
        if Code^.CountOptionalArguments>0 then begin
         SyntaxError('Optional arguments must be last',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end else begin
         if (not assigned(t^.Right)) or (t^.Right^.Token<>ptSYMBOL) then begin
          SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end else begin
          if Code^.CountArguments>=CodeGenerator^.ArgAllocated then begin
           CodeGenerator^.ArgAllocated:=Code^.CountArguments*2;
           ReallocMem(CodeGenerator^.ArgumentSymbols,CodeGenerator^.ArgAllocated*sizeof(TPOCAInt32));
           ReallocMem(CodeGenerator^.ArgumentLocals,CodeGenerator^.ArgAllocated*sizeof(TPOCACodeArgument));
          end;
          CodeGenerator^.ArgumentSymbols[Code^.CountArguments]:=FindConstantIndex(t^.Right,true);
          CodeGenerator^.ArgumentLocals[Code^.CountArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
          inc(Code^.CountArguments);
         end;
        end;
       end;
       ptSYMBOL:begin
        if Code^.CountOptionalArguments>0 then begin
         SyntaxError('Optional arguments must be last',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end else begin
         if Code^.CountArguments>=CodeGenerator^.ArgAllocated then begin
          CodeGenerator^.ArgAllocated:=Code^.CountArguments*2;
          ReallocMem(CodeGenerator^.ArgumentSymbols,CodeGenerator^.ArgAllocated*sizeof(TPOCAInt32));
          ReallocMem(CodeGenerator^.ArgumentLocals,CodeGenerator^.ArgAllocated*sizeof(TPOCACodeArgument));
         end;
         CodeGenerator^.ArgumentSymbols[Code^.CountArguments]:=FindConstantIndex(t,true);
         CodeGenerator^.ArgumentLocals[Code^.CountArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
         inc(Code^.CountArguments);
        end;
       end;
       ptCOMMA:begin
        GenerateArgumentList(t^.Left,Code);
        GenerateArgumentList(t^.Right,Code);
        exit;
       end;
       else begin
        SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      inc(CodeGenerator^.LocalArgumentIndex);
     end;
    end;
   end;
  var Code:PPOCACode;
      i,j:TPOCAInt32;
      IsEmpty:TPOCABool32;
      Symbol:PPOCACodeGeneratorScopeSymbol;
  begin
   New(CodeGenerator);
   try
    begin
     FillChar(CodeGenerator^,sizeof(TPOCACodeGenerator),#0);
     Initialize(CodeGenerator^);
     CodeGenerator^.ParentCodeGenerator:=ParentCodeGenerator;
     CodeGenerator^.UsedFrameValues:=false;
     CodeGenerator^.ByteCodeAllocated:=1024;
     GetMem(CodeGenerator^.ByteCode,CodeGenerator^.ByteCodeAllocated*sizeof(TPOCAUInt32));
     FillChar(CodeGenerator^.ByteCode^,CodeGenerator^.ByteCodeAllocated*sizeof(TPOCAUInt32),#0);
     CodeGenerator^.HasLocals:=false;
     CodeGenerator^.RestArgSym:=Instance^.Globals.ArgumentsValueReference;
     CodeGenerator^.RestArgSymbolString:='arguments';
     CodeGenerator^.HasRestArguments:=false;
     CodeGenerator^.HasNestedFunctions:=false;
     CodeGenerator^.FastFunction:=CodeToken=ptFASTFUNCTION;
     CodeGenerator^.Consts:=POCANewArray(Parser.Context);
     CodeGenerator^.SwitchTop:=0;
     CodeGenerator^.SwitchAllocated:=4;
     CodeGenerator^.Switchs:=nil;
     SetLength(CodeGenerator^.Switchs,CodeGenerator^.SwitchAllocated);
     CodeGenerator^.LoopTop:=0;
     CodeGenerator^.LoopAllocated:=4;
     CodeGenerator^.Loops:=nil;
     SetLength(CodeGenerator^.Loops,CodeGenerator^.LoopAllocated);
     CodeGenerator^.Scopes:=nil;
     CodeGenerator^.CountScopes:=0;
     CodeGenerator^.Registers:=nil;
     CodeGenerator^.CountRegisters:=0;
     CodeGenerator^.LocalArguments:=nil;
     CodeGenerator^.CountLocalArguments:=0;
     CodeGenerator^.LocalArgumentIndex:=0;
     CodeGenerator^.WhenSwitchCaseBlocks:=nil;
     CodeGenerator^.CountWhenSwitchCaseBlocks:=0;
     CodeGenerator^.BreakContinueScopes:=nil;
     CodeGenerator^.CountBreakContinueScopes:=0;
     CodeGenerator^.Opcodes:=nil;
     CodeGenerator^.CountOpcodes:=0;
     CodeGenerator^.Constants:=nil;
     CodeGenerator^.ConstantRegisters:=nil;
     CodeGenerator^.CountConstants:=0;
     CodeGenerator^.CountRegExps:=0;
     CodeGenerator^.CountFrameValues:=0;
     if assigned(ParentCodeGenerator) then begin
      CodeGenerator^.Level:=ParentCodeGenerator^.Level+1;
     end else begin
      CodeGenerator^.Level:=0;
     end;
    end;
    begin
     ScanForNestedFunctions(ArgumentList,Block);
     ScopeStart;
     ProcessConstantFolding(ArgumentList);
     PreprocessArgumentList(ArgumentList);                                 
     if assigned(Block) and not (((Block^.Token=ptEMPTY) and not (assigned(Block^.Left) or assigned(Block^.Right))) or ((Block^.Token=ptTOP) and ((not assigned(Block^.Left)) or (((Block^.Left^.Token=ptEMPTY) and not (assigned(Block^.Left^.Left) or assigned(Block^.Left^.Right))))))) then begin
      ProcessConstantFolding(Block);
      CollectConstants(Block);
      ScopeStart;
      i:=GenerateBlock(Block,-1,true,true);
      if CodeToken in [ptCLASSFUNCTION,ptMODULEFUNCTION] then begin
       EmitOpcode(popLOADLOCAL,i);
      end;
      EmitOpcode(popRETURN,i);
      IsEmpty:=false;
     end else begin
      i:=GetRegister(true,false);
      if CodeToken in [ptCLASSFUNCTION,ptMODULEFUNCTION] then begin
       EmitOpcode(popLOADLOCAL,i);
      end else begin
       EmitOpcode(popLOADNULL,i);
      end;
      EmitOpcode(popRETURN,i);
      FreeRegister(i);
      IsEmpty:=true;
     end;
     ScopeEnd;
    end;
    begin
     result:=POCANewCode(Parser.Context);
     Code:=POCAGetValueReferencePointer(result);
     begin
      CodeGenerator^.FastFunction:=(not (CodeToken in [ptCLASSFUNCTION,ptMODULEFUNCTION])) and (CodeGenerator^.FastFunction or not CodeGenerator^.HasLocals);
      Code^.Name:=CodeName;
      Code^.Level:=CodeGenerator^.Level;
      Code^.UseFrameValues:=CodeGenerator^.UsedFrameValues or CodeGenerator^.HasNestedFunctions;
      Code^.CountFrameValues:=CodeGenerator^.CountFrameValues;
      Code^.ClassFunction:=CodeToken=ptCLASSFUNCTION;
      Code^.FastFunction:=CodeGenerator^.FastFunction;
      Code^.IsEmpty:=IsEmpty;
      Code^.HasRestArguments:=false;
      Code^.LocalsAsThisObj:=CodeToken in [ptCLASSFUNCTION,ptMODULEFUNCTION];
      Code^.CountRegisters:=CodeGenerator^.CountRegisters;
      Code^.CountArguments:=0;
      Code^.CountOptionalArguments:=0;
      Code^.HasArgumentLocals:=false;
      Code^.ArgumentSymbols:=nil;
      Code^.ArgumentLocals:=nil;
      Code^.OptionalArgumentSymbols:=nil;
      Code^.OptionalArgumentLocals:=nil;
      Code^.OptionalArgumentValues:=nil;
      Code^.NeedArgumentArray:=true;
      if assigned(ArgumentList) then begin
       Code^.NeedArgumentArray:=false;
       CodeGenerator^.ArgAllocated:=1024;
       CodeGenerator^.OptionalArgumentAllocated:=1024;
       GetMem(CodeGenerator^.ArgumentSymbols,CodeGenerator^.ArgAllocated*sizeof(TPOCAInt32));
       GetMem(CodeGenerator^.ArgumentLocals,CodeGenerator^.ArgAllocated*sizeof(TPOCACodeArgument));
       GetMem(CodeGenerator^.OptionalArgumentSymbols,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCAInt32));
       GetMem(CodeGenerator^.OptionalArgumentLocals,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCACodeArgument));
       GetMem(CodeGenerator^.OptionalArgumentValues,CodeGenerator^.OptionalArgumentAllocated*sizeof(TPOCAInt32));
       GenerateArgumentList(ArgumentList,Code);
      end;
      Code^.RestArgSym:=InternConstant(CodeGenerator^.RestArgSym);
      begin
       Code^.SourceFile:=Parser.SourceFile;
       begin
        Code^.ConstantCount:=POCAArraySize(CodeGenerator^.Consts);
        GetMem(Code^.Constants,Code^.ConstantCount*sizeof(TPOCAValue));
        for i:=0 to Code^.ConstantCount-1 do begin
         Code^.Constants^[i]:=POCAArrayGet(CodeGenerator^.Consts,i);
        end;
       end;
       begin
        Code^.ByteCodeSize:=CodeGenerator^.ByteCodeSize;
        GetMem(Code^.ByteCode,Code^.ByteCodeSize*sizeof(TPOCAUInt32));
        Move(CodeGenerator^.ByteCode^,Code^.ByteCode^,Code^.ByteCodeSize*sizeof(TPOCAUInt32));
{$ifdef POCAHasJIT}
        begin
         SetLength(Code^.InterpretByteCodeMap,Code^.ByteCodeSize);
         for i:=0 to Code^.ByteCodeSize-1 do begin
          Code^.InterpretByteCodeMap[i]:=true;
         end;
        end;
{$Endif}
       end;
       begin
        Code^.CountRegExps:=CodeGenerator^.CountRegExps;
        if Code^.CountRegExps>0 then begin
         GetMem(Code^.RegExps,Code^.CountRegExps*sizeof(TPOCAValue));
         for i:=0 to Code^.CountRegExps-1 do begin
//        Code^.RegExps^[i]:=POCAValueNull;
          Code^.RegExps^[i].CastedUInt64:=POCAValueNullCastedUInt64;
         end;
        end;
       end;
       begin
        if Code^.CountArguments>0 then begin
         GetMem(Code^.ArgumentSymbols,Code^.CountArguments*sizeof(TPOCAInt32));
         GetMem(Code^.ArgumentLocals,Code^.CountArguments*sizeof(TPOCACodeArgument));
         Move(CodeGenerator^.ArgumentSymbols^,Code^.ArgumentSymbols^,Code^.CountArguments*sizeof(TPOCAInt32));
         Move(CodeGenerator^.ArgumentLocals^,Code^.ArgumentLocals^,Code^.CountArguments*sizeof(TPOCACodeArgument));
        end;
        if Code^.CountOptionalArguments>0 then begin
         GetMem(Code^.OptionalArgumentSymbols,Code^.CountOptionalArguments*sizeof(TPOCAInt32));
         GetMem(Code^.OptionalArgumentLocals,Code^.CountOptionalArguments*sizeof(TPOCACodeArgument));
         GetMem(Code^.OptionalArgumentValues,Code^.CountOptionalArguments*sizeof(TPOCAInt32));
         Move(CodeGenerator^.OptionalArgumentSymbols^,Code^.OptionalArgumentSymbols^,Code^.CountOptionalArguments*sizeof(TPOCAInt32));
         Move(CodeGenerator^.OptionalArgumentLocals^,Code^.OptionalArgumentLocals^,Code^.CountOptionalArguments*sizeof(TPOCACodeArgument));
         Move(CodeGenerator^.OptionalArgumentValues^,Code^.OptionalArgumentValues^,Code^.CountOptionalArguments*sizeof(TPOCAInt32));
        end;
        Code^.Lines:=copy(CodeGenerator^.Lines,0,CodeGenerator^.LineCount);
       end;
      end;
      Code^.HasRestArguments:=Code^.HasRestArguments or CodeGenerator^.HasRestArguments;
      Code^.HasArguments:=Code^.HasRestArguments or ((Code^.CountArguments+Code^.CountOptionalArguments)<>0);
     end;
    end;
   finally
    if assigned(CodeGenerator^.ByteCode) then begin
     FreeMem(CodeGenerator^.ByteCode);
     CodeGenerator^.ByteCode:=nil;
    end;
    if assigned(CodeGenerator^.ArgumentSymbols) then begin
     FreeMem(CodeGenerator^.ArgumentSymbols);
     CodeGenerator^.ArgumentSymbols:=nil;
    end;
    if assigned(CodeGenerator^.ArgumentLocals) then begin
     FreeMem(CodeGenerator^.ArgumentLocals);
     CodeGenerator^.ArgumentLocals:=nil;
    end;
    if assigned(CodeGenerator^.OptionalArgumentSymbols) then begin
     FreeMem(CodeGenerator^.OptionalArgumentSymbols);
     CodeGenerator^.OptionalArgumentSymbols:=nil;
    end;
    if assigned(CodeGenerator^.OptionalArgumentLocals) then begin
     FreeMem(CodeGenerator^.OptionalArgumentLocals);
     CodeGenerator^.OptionalArgumentLocals:=nil;
    end;
    if assigned(CodeGenerator^.OptionalArgumentValues) then begin
     FreeMem(CodeGenerator^.OptionalArgumentValues);
     CodeGenerator^.OptionalArgumentValues:=nil;
    end;
    SetLength(CodeGenerator^.Lines,0);
    for i:=0 to length(CodeGenerator^.Loops)-1 do begin
     SetLength(CodeGenerator^.Loops[i].BreakJumps,0);
     SetLength(CodeGenerator^.Loops[i].ContinueJumps,0);
    end;
    for i:=0 to length(CodeGenerator^.WhenSwitchCaseBlocks)-1 do begin
     SetLength(CodeGenerator^.WhenSwitchCaseBlocks[i].Fallthroughs,0);
    end;
    SetLength(CodeGenerator^.WhenSwitchCaseBlocks,0);
    SetLength(CodeGenerator^.BreakContinueScopes,0);
    for i:=0 to length(CodeGenerator^.Scopes)-1 do begin
     for j:=0 to CodeGenerator^.Scopes[i].CountSymbols-1 do begin
      Symbol:=CodeGenerator^.Scopes[i].Symbols[j];
      CodeGenerator^.Scopes[i].Symbols[j]:=nil;
      if assigned(Symbol) then begin
       Finalize(Symbol^);
       FreeMem(Symbol);
      end;
     end;
     CodeGenerator^.Scopes[i].Symbols:=nil;
     FreeAndNil(CodeGenerator^.Scopes[i].SymbolNameHashMap);
    end;
    SetLength(CodeGenerator^.Scopes,0);
    SetLength(CodeGenerator^.Registers,0);
    SetLength(CodeGenerator^.LocalArguments,0);
    SetLength(CodeGenerator^.Opcodes,0);
    SetLength(CodeGenerator^.Constants,0);
    SetLength(CodeGenerator^.ConstantRegisters,0);
    Finalize(CodeGenerator^);
    Dispose(CodeGenerator);
   end;
  end;
 begin
  result:=GenerateCode(Parser,@Parser.Tree,nil,ptTOP,'',nil);
 end;
 procedure FreeParser(var Parser:TPOCAParser);
 var CurrentToken,NextToken:PPOCAToken;
 begin
  CurrentToken:=TokenList;
  TokenList:=nil;
  while assigned(CurrentToken) do begin
   NextToken:=CurrentToken^.TokenListNext;
   CurrentToken^.Str:='';
   Dispose(CurrentToken);
   CurrentToken:=NextToken;
  end;
  Finalize(Parser);
  FillChar(Parser,sizeof(TPOCAParser),#0);
 end;
var Parser:TPOCAParser;
    i:TPOCAInt32;
    OldFPUExceptionMask:TFPUExceptionMask;
    OldFPURoundingMode:TFPURoundingMode;
    OldFPUPrecisionMode:TFPUPrecisionMode;
begin
 OldFPUExceptionMask:=GetExceptionMask;
 OldFPURoundingMode:=GetRoundMode;
 OldFPUPrecisionMode:=GetPrecisionMode;
 try
  if OldFPUExceptionMask<>FPUExceptionMask then begin
   SetExceptionMask(FPUExceptionMask);
  end;
  if OldFPURoundingMode<>FPURoundingMode then begin
   SetRoundMode(FPURoundingMode);
  end;
  if OldFPUPrecisionMode<>FPUPrecisionMode then begin
   SetPrecisionMode(FPUPrecisionMode);
  end;
  TokenList:=nil;
  FillChar(Parser,sizeof(TPOCAParser),#0);
  FillChar(PreprocessorInstance,SizeOf(TPOCAPreprocessorInstance),#0);
  try
   Parser.Context:=Context;
   Parser.SourceFile:=Instance^.SourceFiles.IndexOf(String(SourceFileName));
   if Parser.SourceFile<0 then begin
    Parser.SourceFile:=Instance^.SourceFiles.Add(String(SourceFileName));
    if Parser.SourceFile=TPOCAInt32(POCAArraySize(Context^.Instance.Globals.SourceFiles)) then begin
     POCAArrayPush(Context^.Instance.Globals.SourceFiles,POCANewString(Context,SourceFileName));
    end else begin
     POCAArraySetSize(Context^.Instance.Globals.SourceFiles,Instance^.SourceFiles.Count);
     for i:=0 to Instance^.SourceFiles.Count-1 do begin
      POCAArraySet(Context^.Instance.Globals.SourceFiles,i,POCANewString(Context,TPOCARawByteString(Instance^.SourceFiles[i])));
     end;
    end;
   end;
   Parser.Tree.Token:=ptTOP;
   begin
    PreprocessorInstance.Preprocessor.InputKind:=iskFILE;
    PreprocessorInstance.Preprocessor.InputName:=SourceFileName;
    PreprocessorInstance.Preprocessor.InputText:=Source;
    ProcessPreprocessor(PreprocessorInstance,Parser);
   end;
   ProcessLexer(Parser,PreprocessorInstance.Preprocessor.OutputText);
   ProcessTransformer(Parser);
   ProcessParser(Parser);
   result:=ProcessCodeGenerator(Parser);
   POCATemporarySave(Context,result);
  finally
   Finalize(PreprocessorInstance);
   FreeParser(Parser);
  end;
 finally
  if OldFPUExceptionMask<>FPUExceptionMask then begin
   SetExceptionMask(OldFPUExceptionMask);
  end;
  if OldFPURoundingMode<>FPURoundingMode then begin
   SetRoundMode(OldFPURoundingMode);
  end;
  if OldFPUPrecisionMode<>FPUPrecisionMode then begin
   SetPrecisionMode(OldFPUPrecisionMode);
  end;
 end;
end;

procedure POCASave(Context:PPOCAContext;Obj:TPOCAValue);
begin
 POCAArrayPush(Context^.Instance^.Globals.Save,Obj);
end;

function POCAStackDepth(Context:PPOCAContext):TPOCAInt32;
begin
 if assigned(Context) then begin
  result:=Context^.FrameTop+POCAStackDepth(Context^.CallChild);
 end else begin
  result:=0;
 end;
end;

function POCAFindFrame(Context:PPOCAContext;var OutContext:PPOCAContext;FrameNumber:TPOCAInt32):TPOCAInt32;
var StackDepth:TPOCAInt32;
begin
 if assigned(Context) then begin
  StackDepth:=POCAStackDepth(Context);
  if FrameNumber<StackDepth then begin
   result:=POCAFindFrame(Context^.CallChild,OutContext,FrameNumber);
  end else begin
   OutContext:=Context;
   result:=Context^.FrameTop-(1+(FrameNumber-StackDepth));
  end;
 end else begin
  result:=0;
 end;
end;

function POCAGetSourceLine(Context:PPOCAContext;FrameNumber:TPOCAInt32):TPOCAInt32;
var Frame:PPOCAFrame;
    Code:PPOCACode;
    i:TPOCAInt32;
begin
 result:=-1;
 FrameNumber:=POCAFindFrame(Context,Context,FrameNumber);
 if FrameNumber>=0 then begin
  Frame:=@Context^.FrameStack[FrameNumber];
  if assigned(Frame) and (POCAIsValueFunction(Frame^.Func) and POCAIsValueCode(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code)) then begin
   Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code));
   for i:=0 to length(Code^.Lines)-1 do begin
    if Code^.Lines[i].InstructionPointer>TPOCAUInt32(Frame^.InstructionPointer) then begin
     break;
    end;
    result:=Code^.Lines[i].Line;
   end;
  end;
 end;
end;

function POCAGetSourceFile(Context:PPOCAContext;FrameNumber:TPOCAInt32):TPOCAInt32;
var Frame:PPOCAFrame;
    Code:PPOCACode;
begin
 result:=-1;
 FrameNumber:=POCAFindFrame(Context,Context,FrameNumber);
 if FrameNumber>=0 then begin
  Frame:=@Context^.FrameStack[FrameNumber];
  if assigned(Frame) and (POCAIsValueFunction(Frame^.Func) and POCAIsValueCode(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code)) then begin
   Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code));
   result:=Code^.SourceFile;
  end;
 end;
end;

function POCAGetSourceFileName(Context:PPOCAContext;FrameNumber:TPOCAInt32;AbsolutePath:Boolean):TPOCAUTF8String;
var Index:TPOCAInt32;
begin
 Index:=POCAGetSourceFile(Context,FrameNumber);
 if Index>=0 then begin
  result:=POCAGetStringValue(Context,POCAArrayGet(Context^.Instance^.Globals.SourceFiles,Index));
  if AbsolutePath then begin
   result:=ExpandFileName(result);
  end;
//result:=Context^.Instance^.SourceFiles[Index];
 end else begin
  result:='';
 end;
end;

procedure POCARuntimeError(Context:PPOCAContext;const Msg:TPOCAUTF8String);
var StackDepth:TPOCAInt32;
begin
 StackDepth:=POCAStackDepth(Context);
 raise EPOCARuntimeError.Create(POCAGetSourceFile(Context,StackDepth),POCAGetSourceLine(Context,StackDepth),-1,Msg);
end;

function POCAGetArrayProperty(Context:PPOCAContext;const Obj,Field:TPOCAValue;var OutValue:TPOCAValue;CacheIndex:PPOCAUInt32=nil):boolean;
begin
 result:=false;
 if (Field.CastedUInt64=Context^.Instance^.Globals.LengthStringReference.CastedUInt64) or (POCAGetStringValue(Context,Field)='length') then begin
  OutValue.Num:=POCAArraySize(Obj);
  result:=true;
 end;
end;

function POCAGetStringProperty(Context:PPOCAContext;const Obj,Field:TPOCAValue;var OutValue:TPOCAValue;CacheIndex:PPOCAUInt32=nil):boolean;
begin
 result:=false;
 if (Field.CastedUInt64=Context^.Instance^.Globals.LengthStringReference.CastedUInt64) or (POCAGetStringValue(Context,Field)='length') then begin
  case POCAGetValueType(Obj) of
   pvtSTRING:begin
    if PPOCAString(POCAGetValueReferencePointer(Obj))^.UTF8=suISUTF8 then begin
     OutValue.Num:=PPOCAString(POCAGetValueReferencePointer(Obj))^.UTF8Length;
    end else begin
     OutValue.Num:=length(PPOCAString(POCAGetValueReferencePointer(Obj))^.Data);
    end;
    result:=true;
   end;
   else begin
   end;
  end;
 end;
end;

function POCAGetMember(Context:PPOCAContext;const Obj,Field:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex,HashCacheIndex:TPOCAUInt32;const IsInherited,Throw:boolean):boolean;
var p:TPOCAValue;
    Ghost:PPOCAGhost;
    PropertyIndex:TPOCAInt32;
begin

 case POCAGetValueType(Obj) of

  pvtARRAY:begin
   result:=POCAHashGetCache(Context,Context.Instance^.Globals.ArrayHash,Field,OutValue,CacheIndex);
   if (not result) and POCAGetArrayProperty(Context,Obj,Field,OutValue,@HashCacheIndex) then begin
    result:=true;
   end;
   if (not result) and Throw then begin
    POCARuntimeError(Context,'No such member: '+POCAGetStringValue(Context,Field));
   end;
  end;

  pvtNUMBER:begin
   result:=POCAHashGetCache(Context,Context.Instance^.Globals.NumberHash,Field,OutValue,CacheIndex);
   if (not result) and Throw then begin
    POCARuntimeError(Context,'No such member: '+POCAGetStringValue(Context,Field));
   end;
  end;

  pvtSTRING:begin
   result:=POCAHashGetCache(Context,Context.Instance^.Globals.StringHash,Field,OutValue,CacheIndex);
   if (not result) and POCAGetStringProperty(Context,Obj,Field,OutValue,@HashCacheIndex) then begin
    result:=true;
   end;
   if (not result) and Throw then begin
    POCARuntimeError(Context,'No such member: '+POCAGetStringValue(Context,Field));
   end;
  end;

  pvtHASH:begin

   if IsInherited then begin
    result:=POCAHashGetInheritedCache(Context,Obj,Field,OutValue,CacheIndex);
   end else begin
    result:=POCAHashGetCache(Context,Obj,Field,OutValue,CacheIndex);
   end;
   if result then begin
    exit;
   end;

   result:=POCAHashGetCache(Context,Context.Instance^.Globals.HashHash,Field,OutValue,HashCacheIndex);
   if result then begin
    exit;
   end;

   if Throw then begin
    POCARuntimeError(Context,'No such member: '+POCAGetStringValue(Context,Field));
   end;

   exit;

  end;

  pvtGHOST:begin

   Ghost:=POCAGetValueReferencePointer(Obj);

   if (Ghost^.PtrType=pgptOBJECT) and assigned(Ghost^.Ptr) and (TObject(Ghost^.Ptr) is TPOCANativeObject) then begin
    PropertyIndex:=TPOCANativeObject(Ghost^.Ptr).FindPropertyIndex(Context,Field,@CacheIndex);
    if (PropertyIndex>=0) and TPOCANativeObject(Ghost^.Ptr).GetPropertyValue(Context,PropertyIndex,OutValue) then begin
     result:=true;
     exit;
    end;
   end;

   if assigned(Ghost) and assigned(Ghost^.GhostType) and assigned(Ghost^.GhostType^.GetKey) and Ghost^.GhostType^.GetKey(Context,Ghost,Field,OutValue,@CacheIndex) then begin

    result:=true;

   end else begin

    p:=POCAGhostGetHashValue(Obj);
    if POCAIsValueHash(p) then begin

     result:=POCAGetMember(Context,p,Field,OutValue,CacheIndex,HashCacheIndex,false,Throw);
 {   if not result then begin
      p:=POCAHashGetPrototypeValue(p);
      if POCAIsValueHash(p) and assigned(POCAHashGetGhost(p)) then begin
       p:=POCAHashGetGhostValue(p);
      end;
      if POCAIsValueHash(p) or POCAIsValueGhost(p) then begin
       result:=POCAGetMember(Context,p,Field,OutValue,CacheIndex,HashCacheIndex,false,Throw);
      end;
     end;{}

    end else begin

     result:=false;

    end;

   end;

   if (not result) and Throw then begin
    POCARuntimeError(Context,'No such member: '+POCAGetStringValue(Context,Field));
   end;

  end;

  pvtNULL:begin
   result:=false;
   if Throw then begin
    POCARuntimeError(Context,'Non-null object expected');
   end;
  end;

  else begin
   result:=false;
   if Throw then begin
    POCARuntimeError(Context,'Non-objects have no members');
   end;
  end;

 end;
end;

function POCASetMember(Context:PPOCAContext;const Obj,Field,Value:TPOCAValue;const Constant:Boolean;var CacheIndex:TPOCAUInt32;Throw:boolean):boolean;
var p:TPOCAValue;
    Ghost:PPOCAGhost;
    PropertyIndex:TPOCAInt32;
begin
 case POCAGetValueType(Obj) of
  pvtHASH:begin
   result:=POCAHashSetCache(Context,Obj,Field,Value,Constant,CacheIndex);
  end;
  pvtGHOST:begin
   Ghost:=POCAGetValueReferencePointer(Obj);
   if (Ghost^.PtrType=pgptOBJECT) and assigned(Ghost^.Ptr) and (TObject(Ghost^.Ptr) is TPOCANativeObject) then begin
    PropertyIndex:=TPOCANativeObject(Ghost^.Ptr).FindPropertyIndex(Context,Field,@CacheIndex);
    if (PropertyIndex>=0) and TPOCANativeObject(Ghost^.Ptr).SetPropertyValue(Context,PropertyIndex,Value) then begin
     result:=true;
     exit;
    end;
    if not TPOCANativeObject(Ghost^.Ptr).fExpandable then begin
     POCARuntimeError(Context,'Expandable-write-access to a non-expandable native object isn''t allowed');
    end;
   end;
   if assigned(Ghost) and assigned(Ghost^.GhostType) and assigned(Ghost^.GhostType^.SetKey) and Ghost^.GhostType^.SetKey(Context,Ghost,Field,Value,@CacheIndex) then begin
    result:=true;
   end else begin
    p:=POCAGhostGetHashValue(Obj);
    if POCAIsValueHash(p) then begin
     result:=POCASetMember(Context,p,Field,Value,Constant,CacheIndex,Throw);
  {   if not result then begin
      p:=POCAHashGetPrototypeValue(p);
      if POCAIsValueHash(p) and assigned(POCAHashGetGhost(p)) then begin
       p:=POCAHashGetGhostValue(p);
      end;
      if POCAIsValueHash(p) or POCAIsValueGhost(p) then begin
       result:=POCASetMember(Context,p,Field,Value,Constant,CacheIndex,Throw);
      end;
     end;{}
    end else begin
     result:=false;
    end;
   end;
   if (not result) and Throw then begin
    POCARuntimeError(Context,'Error at setting member: '+POCAGetStringValue(Context,Field));
   end;
  end;
  else begin
   result:=false;
   if Throw then begin
    POCARuntimeError(Context,'Non-objects have no members');
   end;
  end;
 end;
end;

function POCABindFunction(Context:PPOCAContext;Frame:PPOCAFrame;const Code:TPOCAValue;const ClassFunction:Boolean):TPOCAValue;
var Func:PPOCAFunction;
    Index:TPOCAInt32;
begin

 result:=POCANewFunction(Context,Code);

 Func:=PPOCAFunction(POCAGetValueReferencePointer(result));
 if ClassFunction then begin
//Func^.Namespace:=POCAValueNull;
  Func^.Namespace.CastedUInt64:=POCAValueNullCastedUInt64;
 end else begin
  Func^.Namespace:=Frame^.Locals;
 end;
 Func^.Obj:=Frame^.Obj;
 Func^.Next:=Frame^.Func;

{$ifdef POCAClosureArrayValues}
 Func^.ClosureValues:=POCANewArray(Context);
 POCAArraySetSize(Func^.ClosureValues,Frame^.CountOuterValueLevels+1);
 for Index:=0 to Frame^.CountOuterValueLevels-1 do begin
  POCAArrayFastSet(Func^.ClosureValues,Index,POCAArrayFastGet(Frame^.OuterValueLevels,Index));
 end;
 POCAArrayFastSet(Func^.ClosureValues,Frame^.CountOuterValueLevels,Frame^.LocalValues);
{$else}
 Func^.ClosureValues:=nil;
 SetLength(Func^.ClosureValues,Frame^.CountOuterValueLevels+1);
 for Index:=0 to Frame^.CountOuterValueLevels-1 do begin
  Func^.ClosureValues[Index]:=Frame^.OuterValueLevels[Index];
 end;
 Func^.ClosureValues[Frame^.CountOuterValueLevels]:=Frame^.LocalValues;
{$endif}

end;

function POCABindToContext(Context:PPOCAContext;Code:TPOCAValue):TPOCAValue;
var Frame:PPOCAFrame;
    Func:PPOCAFunction;
begin
 result:=POCANewFunction(Context,Code);
 if Context^.FrameTop<>0 then begin
  Frame:=@Context^.FrameStack[Context^.FrameTop-1];
  Func:=PPOCAFunction(POCAGetValueReferencePointer(result));
  Func^.Namespace:=Frame^.Locals;
  Func^.Obj:=Frame^.Obj;
  Func^.Next:=Frame^.Func;
 end;
end;

procedure POCASetupArgumentsErrorTooFewArguments(Context:PPOCAContext;Code:PPOCACode;CountArguments:TPOCAInt32);
begin
 POCARuntimeError(Context,'Too few function arguments (we have '+TPOCARawByteString(IntToStr(CountArguments))+' but we do need '+TPOCARawByteString(IntToStr(Code^.CountArguments))+')');
end;

procedure POCASetupArguments(Context:PPOCAContext;Frame:PPOCAFrame;Code:PPOCACode;Args:PPOCAValues;CountArguments:TPOCAInt32;ArgIndices:PPOCAUInt32Array=nil);
var i,j:TPOCAInt32;
    Hash:PPOCAHash;
    Value,Arguments:TPOCAValue;
    ArrayRecord:PPOCAArrayRecord;
begin
 if CountArguments<TPOCAInt32(Code^.CountArguments) then begin
  POCASetupArgumentsErrorTooFewArguments(Context,Code,CountArguments);
 end else begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(Frame^.Locals));
  j:=0;
  for i:=0 to Code^.CountArguments-1 do begin
   if assigned(ArgIndices) then begin
    Value:=Args^[ArgIndices^[i]];
   end else begin
    Value:=Args^[i];
   end;
   if POCAIsValueCode(Value) then begin
    Value:=POCABindFunction(Context,Frame,Value,false);
   end;
   case Code^.ArgumentLocals[i].Kind of
    TPOCACodeArgument.pcakVAR:begin
     if assigned(Hash) then begin
      if assigned(Hash^.Events) then begin
       POCAHashSet(Context,Frame^.Locals,Code^.Constants[Code^.ArgumentSymbols[i]],Value,false);
      end else begin
       POCAHashNewSymbol(Context^.Instance,Hash,Code^.Constants[Code^.ArgumentSymbols[i]],Value,false);
      end;
     end else begin
      POCARuntimeError(Context,'Function has no locals');
     end;
    end;
    TPOCACodeArgument.pcakREG:begin
     Frame^.Registers[Code^.ArgumentLocals[i].Index]:=Value;
    end;
    TPOCACodeArgument.pcakFRAMEVALUE:begin
{$ifdef POCAClosureArrayValues}
     if Code^.ArgumentLocals[i].Level=Code^.Level then begin
      POCAArrayFastSet(Frame^.LocalValues,Code^.ArgumentLocals[i].Index,Value);
     end else begin
      POCAArrayFastSet(POCAArrayGet(Frame^.OuterValueLevels,Code^.ArgumentLocals[i].Level),Code^.ArgumentLocals[i].Index,Value);
     end;
{$else}
     if Code^.ArgumentLocals[i].Level=Code^.Level then begin
      Frame^.LocalValues[Code^.ArgumentLocals[i].Index]:=Value;
     end else begin
      Frame^.OuterValueLevels[Code^.ArgumentLocals[i].Level][Code^.ArgumentLocals[i].Index]:=Value;
     end;
{$endif}
    end;
    else begin
    end;
   end;
  end;
  inc(j,Code^.CountArguments);
  dec(CountArguments,Code^.CountArguments);
  for i:=0 to Code^.CountOptionalArguments-1 do begin
   if CountArguments>0 then begin
    if assigned(ArgIndices) then begin
     Value:=Args^[ArgIndices^[i+j]];
    end else begin
     Value:=Args^[i+j];
    end;
   end else begin
    Value:=Code^.Constants[Code^.OptionalArgumentValues[i]];
   end;
   if POCAIsValueCode(Value) then begin
    Value:=POCABindFunction(Context,Frame,Value,false);
   end;
   case Code^.OptionalArgumentLocals[i].Kind of
    TPOCACodeArgument.pcakVAR:begin
     if assigned(Hash) then begin
      if assigned(Hash^.Events) then begin
       POCAHashSet(Context,Frame^.Locals,Code^.Constants[Code^.OptionalArgumentSymbols[i]],Value,false);
      end else begin
       POCAHashNewSymbol(Context^.Instance,Hash,Code^.Constants[Code^.OptionalArgumentSymbols[i]],Value,false);
      end;
     end else begin
      POCARuntimeError(Context,'Function has no locals');
     end;
    end;
    TPOCACodeArgument.pcakREG:begin
     Frame^.Registers[Code^.OptionalArgumentLocals[i].Index]:=Value;
    end;
    TPOCACodeArgument.pcakFRAMEVALUE:begin
{$ifdef POCAClosureArrayValues}
     if Code^.ArgumentLocals[i].Level=Code^.Level then begin
      POCAArrayFastSet(Frame^.LocalValues,Code^.OptionalArgumentLocals[i].Index,Value);
     end else begin
      POCAArrayFastSet(POCAArrayGet(Frame^.OuterValueLevels,Code^.OptionalArgumentLocals[i].Level),Code^.OptionalArgumentLocals[i].Index,Value);
     end;
{$else}
     if Code^.ArgumentLocals[i].Level=Code^.Level then begin
      Frame^.LocalValues[Code^.OptionalArgumentLocals[i].Index]:=Value;
     end else begin
      Frame^.OuterValueLevels[Code^.OptionalArgumentLocals[i].Level][Code^.OptionalArgumentLocals[i].Index]:=Value;
     end;
{$endif}
    end;
    else begin
    end;
   end;
   dec(CountArguments);
  end;
  inc(j,Code^.CountOptionalArguments);
  if Code^.NeedArgumentArray or Code^.HasRestArguments or (CountArguments>0) then begin
   Arguments:=POCANewArray(Context);
   if CountArguments<=0 then begin
    CountArguments:=0;
   end;
   POCAArraySetSize(Arguments,CountArguments);
   if CountArguments>0 then begin
    ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(Arguments))^.ArrayRecord;
    for i:=0 to CountArguments-1 do begin
     if assigned(ArgIndices) then begin
      Value:=Args^[ArgIndices^[i+j]];
     end else begin
      Value:=Args^[i+j];
     end;
     if POCAIsValueCode(Value) then begin
      Value:=POCABindFunction(Context,Frame,Value,false);
     end;
     ArrayRecord^.Data[i]:=Value;
    end;
   end;
   if assigned(Hash) then begin
    if assigned(Hash^.Events) then begin
     POCAHashSet(Context,Frame^.Locals,Code^.Constants[Code^.RestArgSym],Arguments,false);
    end else begin
     POCAHashNewSymbol(Context^.Instance,Hash,Code^.Constants[Code^.RestArgSym],Arguments,false);
    end;
   end else begin
    POCARuntimeError(Context,'Function has no locals');
   end;
  end;
 end;
end;

procedure POCACheckNamedArguments(Context:PPOCAContext;Code:PPOCACode;Hash:PPOCAHash;const HashValue:TPOCAValue);
var i:TPOCAInt32;
    Sym,Value:TPOCAValue;
begin
//Value:=POCAValueNull;
 Value.CastedUInt64:=POCAValueNullCastedUInt64;
 for i:=0 to Code^.CountArguments-1 do begin
  Sym:=Code^.Constants[Code^.ArgumentSymbols[i]];
  if assigned(Hash^.Events) then begin
   if not POCAHashGet(Context,HashValue,Sym,Value) then begin
    POCARuntimeError(Context,'Missing argument "'+PPOCAString(POCAGetValueReferencePointer(Sym))^.Data+'"');
    exit;
   end;
  end else begin
   if not POCAHashSymbol(Hash,PPOCAString(POCAGetValueReferencePointer(Sym)),Value) then begin
    POCARuntimeError(Context,'Missing argument "'+PPOCAString(POCAGetValueReferencePointer(Sym))^.Data+'"');
    exit;
   end;
  end;
 end;
 for i:=0 to Code^.CountOptionalArguments-1 do begin
  Sym:=Code^.Constants[Code^.OptionalArgumentSymbols[i]];
  if assigned(Hash^.Events) then begin
   if not POCAHashGet(Context,HashValue,Sym,Value) then begin
    POCAHashSet(Context,HashValue,Sym,Code^.Constants[Code^.OptionalArgumentValues[i]],false);
   end;
  end else begin
   if not POCAHashSymbol(Hash,PPOCAString(POCAGetValueReferencePointer(Sym)),Value) then begin
    POCAHashNewSymbol(Context^.Instance,Hash,Sym,Code^.Constants[Code^.OptionalArgumentValues[i]],false);
   end;
  end;
 end;
 if Code^.NeedArgumentArray then begin
  Sym:=Code^.Constants[Code^.RestArgSym];
  if assigned(Hash^.Events) then begin
   if not POCAHashGet(Context,HashValue,Sym,Value) then begin
    POCAHashSet(Context,HashValue,Sym,POCANewArray(Context),false);
   end;
  end else begin
   if not POCAHashSymbol(Hash,PPOCAString(POCAGetValueReferencePointer(Sym)),Value) then begin
    POCAHashNewSymbol(Context^.Instance,Hash,Sym,POCANewArray(Context),false);
   end;
  end;
 end;
end;

procedure POCASetupNamedArgumentsWithLocals(Context:PPOCAContext;Frame:PPOCAFrame;Code:PPOCACode;const Hash,Locals:TPOCAValue);
var i:TPOCAInt32;
    Sym,Value:TPOCAValue;
begin
//Value:=POCAValueNull;
 Value.CastedUInt64:=POCAValueNullCastedUInt64;
 for i:=0 to Code^.CountArguments-1 do begin
  Sym:=Code^.Constants[Code^.ArgumentSymbols[i]];
  if POCAHashGet(Context,Hash,Sym,Value) then begin
   case Code^.ArgumentLocals[i].Kind of
    TPOCACodeArgument.pcakVAR:begin
     if POCAIsValueHash(Locals) then begin
      POCAHashSet(Context,Locals,Sym,Value,false);
     end else begin
      POCARuntimeError(Context,'Function has no locals');
     end;
    end;
    TPOCACodeArgument.pcakREG:begin
     Frame^.Registers[Code^.ArgumentLocals[i].Index]:=Value;
    end;
    TPOCACodeArgument.pcakFRAMEVALUE:begin
{$ifdef POCAClosureArrayValues}
     if Code^.ArgumentLocals[i].Level=Code^.Level then begin
      POCAArrayFastSet(Frame^.LocalValues,Code^.ArgumentLocals[i].Index,Value);
     end else begin
      POCAArrayFastSet(POCAArrayGet(Frame^.OuterValueLevels,Code^.ArgumentLocals[i].Level),Code^.ArgumentLocals[i].Index,Value);
     end;
{$else}
     if Code^.ArgumentLocals[i].Level=Code^.Level then begin
      Frame^.LocalValues[Code^.ArgumentLocals[i].Index]:=Value;
     end else begin
      Frame^.OuterValueLevels[Code^.ArgumentLocals[i].Level][Code^.ArgumentLocals[i].Index]:=Value;
     end;
{$endif}
    end;
    else begin
    end;
   end;
  end else begin
   POCARuntimeError(Context,'Missing argument "'+PPOCAString(POCAGetValueReferencePointer(Sym))^.Data+'"');
   exit;
  end;
 end;
 for i:=0 to Code^.CountOptionalArguments-1 do begin
  Sym:=Code^.Constants[Code^.OptionalArgumentSymbols[i]];
  if not POCAHashGet(Context,Hash,Sym,Value) then begin
   Value:=Code^.Constants[Code^.OptionalArgumentValues[i]];
  end;
  case Code^.OptionalArgumentLocals[i].Kind of
   TPOCACodeArgument.pcakVAR:begin
    if POCAIsValueHash(Locals) then begin
     POCAHashSet(Context,Locals,Sym,Value,false);
    end else begin
     POCARuntimeError(Context,'Function has no locals');
    end;
   end;
   TPOCACodeArgument.pcakREG:begin
    Frame^.Registers[Code^.OptionalArgumentLocals[i].Index]:=Value;
   end;
   TPOCACodeArgument.pcakFRAMEVALUE:begin
{$ifdef POCAClosureArrayValues}
    if Code^.ArgumentLocals[i].Level=Code^.Level then begin
     POCAArrayFastSet(Frame^.LocalValues,Code^.OptionalArgumentLocals[i].Index,Value);
    end else begin
     POCAArrayFastSet(POCAArrayGet(Frame^.OuterValueLevels,Code^.OptionalArgumentLocals[i].Level),Code^.OptionalArgumentLocals[i].Index,Value);
    end;
{$else}
    if Code^.ArgumentLocals[i].Level=Code^.Level then begin
     Frame^.LocalValues[Code^.OptionalArgumentLocals[i].Index]:=Value;
    end else begin
     Frame^.OuterValueLevels[Code^.OptionalArgumentLocals[i].Level][Code^.OptionalArgumentLocals[i].Index]:=Value;
    end;
{$endif}
   end;
   else begin
   end;
  end;
 end;
 if Code^.NeedArgumentArray then begin
  Sym:=Code^.Constants[Code^.RestArgSym];
  if not POCAHashGet(Context,Hash,Sym,Value) then begin
   Value:=POCANewArray(Context);
  end;
  if POCAIsValueHash(Locals) then begin
   POCAHashSet(Context,Locals,Sym,Value,false);
  end else begin
   POCARuntimeError(Context,'Function has no locals');
  end;
 end;
end;

procedure POCASetupRegisters(Frame:PPOCAFrame;Code:PPOCACode);
var i:TPOCAInt32;
begin
 Frame^.CountRegisters:=Code^.CountRegisters;
 if Frame^.CountRegisters>0 then begin
  if length(Frame^.Registers)<TPOCAInt32(Frame^.CountRegisters) then begin
   SetLength(Frame^.Registers,POCARoundUpToPowerOfTwo(Frame^.CountRegisters+1));
  end;
  for i:=0 to Frame^.CountRegisters-1 do begin
// Frame^.Registers[i]:=POCAValueNull;
   Frame^.Registers[i].CastedUInt64:=POCAValueNullCastedUInt64;
  end;
 end;
end;

procedure POCASetupFrameValues(Context:PPOCAContext;Frame:PPOCAFrame;Code:PPOCACode);
var Index:TPOCAInt32;
    Func:PPOCAFunction;
begin

 if Code^.UseFrameValues then begin

  Func:=PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func));

//writeln(IntToHex(TPOCAPtrUInt(Func),16));

  Frame^.OuterValueLevels:=Func^.ClosureValues;
  Frame^.CountOuterValueLevels:=Code^.Level;

{$ifdef POCAClosureArrayValues}
  Frame^.LocalValues:=POCANewArray(Context);
  POCAArraySetSize(Frame^.LocalValues,Code^.CountFrameValues);
  for Index:=0 to Code^.CountFrameValues-1 do begin
   POCAArrayFastSet(Frame^.LocalValues,Index,POCAValueNull);
  end;
{$else}
  Frame^.LocalValues:=nil;
  SetLength(Frame^.LocalValues,Code^.CountFrameValues);
  for Index:=0 to Code^.CountFrameValues-1 do begin
   Frame^.LocalValues[Index].CastedUInt64:=POCAValueNullCastedUInt64;
  end;
{$endif}

 end else begin

  Frame^.CountOuterValueLevels:=0;

{$ifdef POCAClosureArrayValues}
  Frame^.LocalValues.CastedUInt64:=POCAValueNullCastedUInt64;
{$else}
 Frame^.LocalValues:=nil;
{$endif}

 end;

end;

function POCASetupFunctionCall(Context:PPOCAContext;Frame:PPOCAFrame;Opcode:TPOCAUInt32;Operands:PPOCAUInt32Array;MethodCall,Named:boolean;TheFunc:PPOCAValue=nil):PPOCAFrame;
var Func,Obj,Code:TPOCAValue;
    i,CountArguments,ArgumentIndex:TPOCAInt32;
    ObjPtr:PPOCAObject;
begin
//Obj:=POCAValueNull;
 Obj.CastedUInt64:=POCAValueNullCastedUInt64;

 CountArguments:=Opcode shr 8;

 Frame^.ResultRegister:=Operands^[0];

 if MethodCall then begin
  Obj:=Frame^.Registers[Operands^[1]];
  Func:=Frame^.Registers[Operands^[2]];
  dec(CountArguments,3);
  ArgumentIndex:=3;
 end else begin
  if assigned(TheFunc) then begin
   Func:=TheFunc^;
   dec(CountArguments);
   ArgumentIndex:=1;
  end else begin
   Func:=Frame^.Registers[Operands^[1]];
   dec(CountArguments,2);
   ArgumentIndex:=2;
  end;
 end;

 ObjPtr:=nil;
 repeat
  if {$ifdef cpu64}((TPOCAUInt64(TPOCAPointer(@Func.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and assigned(TPOCAPointer(TPOCAPtrUInt(Func.Reference.Ptr) and POCAValueReferenceMask)){$else}(Func.ReferenceTag=POCAValueReferenceTag) and assigned(Func.Reference.Ptr){$endif} then begin
   ObjPtr:={$ifdef cpu64}TPOCAPointer(TPOCAPtrUInt(Func.Reference.Ptr) and POCAValueReferenceMask){$else}Func.Reference.Ptr{$endif};
   case ObjPtr^.Header.ValueType of
    pvtFUNCTION:begin
     if not MethodCall then begin
      Obj:=PPOCAFunction(ObjPtr)^.Obj;
     end;
     break;
    end;
    pvtHASH:begin
     if assigned(PPOCAHash(ObjPtr)^.Events) and assigned(PPOCAHash(ObjPtr)^.Events^.HashRecord^.Events) then begin
      if POCAIsValueNull(Obj) then begin
       Obj:=Func;
      end;
      Func:=PPOCAHash(ObjPtr)^.Events^.HashRecord^.Events^[pmoCALL];
      if {$ifdef cpu64}((TPOCAUInt64(TPOCAPointer(@Func.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and assigned(TPOCAPointer(TPOCAPtrUInt(Func.Reference.Ptr) and POCAValueReferenceMask)){$else}(Func.ReferenceTag=POCAValueReferenceTag) and assigned(Func.Reference.Ptr){$endif} then begin
       ObjPtr:={$ifdef cpu64}TPOCAPointer(TPOCAPtrUInt(Func.Reference.Ptr) and POCAValueReferenceMask){$else}Func.Reference.Ptr{$endif};
       if ObjPtr^.Header.ValueType=pvtFUNCTION then begin
        break;
       end;
      end;
     end;
    end;
   end;
  end;
  if not MethodCall then begin
   POCARuntimeError(Context,'Method call on uncallable object');
  end else begin
   POCARuntimeError(Context,'Function call on uncallable object');
  end;
  break;
 until false;

 Code:=PPOCAFunction(ObjPtr)^.Code;

 if {$ifdef cpu64}((TPOCAUInt64(TPOCAPointer(@Code.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and assigned(TPOCAPointer(TPOCAPtrUInt(Code.Reference.Ptr) and POCAValueReferenceMask)){$else}(Code.ReferenceTag=POCAValueReferenceTag) and assigned(Code.Reference.Ptr){$endif} then begin
  ObjPtr:={$ifdef cpu64}TPOCAPointer(TPOCAPtrUInt(Code.Reference.Ptr) and POCAValueReferenceMask){$else}Code.Reference.Ptr{$endif};
  case ObjPtr^.Header.ValueType of
   pvtNATIVECODE:begin
    if CountArguments>length(Frame^.Arguments) then begin
     SetLength(Frame^.Arguments,CountArguments);
    end;
    for i:=0 to CountArguments-1 do begin
     Frame^.Arguments[i]:=Frame^.Registers[Operands^[i+ArgumentIndex]];
    end;
    Frame^.CountArguments:=CountArguments;
    if Named then begin
     POCARuntimeError(Context,'Native functions have no named arguments');
    end;
{   if assigned(PPOCANativeCode(ObjPtr)^.UserData) then begin
     Frame^.Registers[Frame^.ResultRegister]:=PPOCANativeCode(ObjPtr)^.FunctionPointer(Context,Obj,@Frame^.Arguments[0],Frame^.CountArguments,PPOCANativeCode(ObjPtr)^.UserData);
    end else begin
     Frame^.Registers[Frame^.ResultRegister]:=PPOCANativeCode(ObjPtr)^.FunctionPointer(Context,Obj,@Frame^.Arguments[0],Frame^.CountArguments,PPOCANativeCode(ObjPtr)^.UserData);
    end;}
    Frame^.Registers[Frame^.ResultRegister]:=PPOCANativeCode(ObjPtr)^.FunctionPointer(Context,Obj,@Frame^.Arguments[0],Frame^.CountArguments,PPOCANativeCode(ObjPtr)^.UserData);
    Frame^.CountArguments:=0;
    result:=@Context.FrameStack[Context.FrameTop-1];
    exit;
   end;
   pvtCODE:begin
    if Context^.FrameTop>=POCA_MAX_RECURSION then begin
     POCARuntimeError(Context,'Call frame overflow');
    end;

{$ifdef POCAHasJIT}
    if not assigned(PPOCACode(ObjPtr)^.NativeCode) then begin
     POCAGenerateNativeCode(Context,PPOCACode(ObjPtr));
    end;
{$endif}

    result:=@Context^.FrameStack[Context^.FrameTop];
    if Named and not PPOCACode(ObjPtr)^.HasArgumentLocals then begin
     result^.Locals:=Frame^.Registers[Operands^[ArgumentIndex]];
     inc(ArgumentIndex);
     dec(CountArguments);
    end else begin
     if PPOCACode(ObjPtr)^.FastFunction then begin
//    result^.Locals:=POCAValueNull;
      result^.Locals.CastedUInt64:=POCAValueNullCastedUInt64;
     end else begin
      result^.Locals:=POCANewHash(Context);
     end;
    end;
    result^.Func:=Func;
    result^.InstructionPointer:=0;
    if PPOCACode(ObjPtr)^.LocalsAsThisObj then begin
     result^.Obj:=result^.Locals;
    end else begin
     result^.Obj:=Obj;
    end;

    if PPOCACode(ObjPtr)^.HasArguments or not PPOCACode(ObjPtr)^.IsEmpty then begin

     POCASetupRegisters(result,PPOCACode(ObjPtr));

     POCASetupFrameValues(Context,result,PPOCACode(ObjPtr));

     if PPOCACode(ObjPtr)^.HasArguments then begin
      if Named then begin
       if PPOCACode(ObjPtr)^.HasArgumentLocals then begin
        POCASetupNamedArgumentsWithLocals(Context,result,PPOCACode(ObjPtr),Frame^.Registers[Operands^[ArgumentIndex]],result^.Locals);
       end else begin
        POCACheckNamedArguments(Context,PPOCACode(ObjPtr),PPOCAHash(POCAGetValueReferencePointer(result^.Locals)),result^.Locals);
       end;
      end else begin
       POCASetupArguments(Context,result,PPOCACode(ObjPtr),@Frame^.Registers[0],CountArguments,@Operands^[ArgumentIndex]);
      end;
     end;
    end;

    if PPOCACode(ObjPtr)^.IsEmpty then begin
//   Frame^.Registers[Frame^.ResultRegister]:=POCAValueNull;
     Frame^.Registers[Frame^.ResultRegister].CastedUInt64:=POCAValueNullCastedUInt64;
     Frame^.CountArguments:=0;
     result:=@Context.FrameStack[Context.FrameTop-1];
    end else begin
     inc(Context^.FrameTop);
    end;
    exit;
   end;
  end;
 end;

//Frame^.Registers[Frame^.ResultRegister]:=POCAValueNull;
 Frame^.Registers[Frame^.ResultRegister].CastedUInt64:=POCAValueNullCastedUInt64;
 Frame^.CountArguments:=0;

 result:=@Context.FrameStack[Context.FrameTop-1];

end;

procedure POCARunStackOverflow(Context:PPOCAContext);
begin
 POCARuntimeError(Context,'Stack overflow');
end;

function POCARunEvalCat(Context:PPOCAContext;const l,r:TPOCAValue):TPOCAValue;
var i,ls,rs:TPOCAInt32;
begin
 if POCAIsValueArray(l) and POCAIsValueArray(r) then begin
  ls:=POCAArraySize(l);
  rs:=POCAArraySize(r);
  result:=POCANewArray(Context);
  POCAArraySetSize(result,ls+rs);
  for i:=0 to ls-1 do begin
   POCAArraySet(result,i,POCAArrayGet(l,i));
  end;
  for i:=0 to rs-1 do begin
   POCAArraySet(result,i+ls,POCAArrayGet(r,i));
  end;
 end else if POCAIsValueHash(l) and POCAIsValueHash(r) then begin
  result:=POCANewHash(Context);
  POCAHashCombine(Context,result,l);
  POCAHashCombine(Context,result,r);
 end else if POCAIsValueString(l) and POCAIsValueString(r) then begin
  result:=POCANewString(Context,'');
  if PPOCAString(POCAGetValueReferencePointer(l))^.UTF8<>suNOUTF8 then begin
   case PPOCAString(POCAGetValueReferencePointer(r))^.UTF8 of
    suPOSSIBLEUTF8:begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PPOCAString(POCAGetValueReferencePointer(l))^.Data+PPOCAString(POCAGetValueReferencePointer(r))^.Data;
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=PPOCAString(POCAGetValueReferencePointer(l))^.UTF8;
    end;
    suISUTF8:begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PPOCAString(POCAGetValueReferencePointer(l))^.Data+PPOCAString(POCAGetValueReferencePointer(r))^.Data;
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suISUTF8;
    end;
    else begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PPOCAString(POCAGetValueReferencePointer(l))^.Data+PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(r))^.Data);
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suISUTF8;
    end;
   end;
  end else begin
   case PPOCAString(POCAGetValueReferencePointer(r))^.UTF8 of
    suPOSSIBLEUTF8:begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(l))^.Data)+PPOCAString(POCAGetValueReferencePointer(r))^.Data;
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suISUTF8;
    end;
    suISUTF8:begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(l))^.Data)+PPOCAString(POCAGetValueReferencePointer(r))^.Data;
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suISUTF8;
    end;
    else begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PPOCAString(POCAGetValueReferencePointer(l))^.Data+PPOCAString(POCAGetValueReferencePointer(r))^.Data;
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suNOUTF8;
    end;
   end;
  end;
  PPOCAString(POCAGetValueReferencePointer(result))^.DataLength:=length(PPOCAString(POCAGetValueReferencePointer(result))^.Data);
  PPOCAString(POCAGetValueReferencePointer(result))^.UTF8Length:=PPOCAString(POCAGetValueReferencePointer(l))^.UTF8Length+PPOCAString(POCAGetValueReferencePointer(r))^.UTF8Length;
  PPOCAString(POCAGetValueReferencePointer(result))^.HashCode:=0;
  if PPOCAString(POCAGetValueReferencePointer(result))^.UTF8=suISUTF8 then begin
   PPOCAString(POCAGetValueReferencePointer(result))^.Dirty:=true;
   POCAStringUpdate(Context,result);
  end;
 end else begin
  result:=POCANewString(Context,POCAGetStringValue(Context,l)+POCAGetStringValue(Context,r));
 end;
end;

procedure POCARunGetLocalError(Context:PPOCAContext;const Sym:TPOCAValue);
begin
 POCARuntimeError(Context,'Undefined symbol: '+POCAGetStringValue(Context,Sym));
end;

procedure POCARunGetLocal(Context:PPOCAContext;Frame:PPOCAFrame;const Sym:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:TPOCAUInt32);
var Func:PPOCAFunction;
begin

 // Optimized search
 repeat

  // 1. Function frame locals
  case POCAHashSymbolCache(PPOCAHash(POCAGetValueReferencePointer(Frame^.Locals)),Sym,OutValue,CacheIndex) of
   1:begin
    exit;
   end;
   2:begin
    break;
   end;
  end;

  // 2. Outer closure name spaces
  Func:=PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func));
  while assigned(Func) do begin
   case POCAHashSymbolCache(PPOCAHash(POCAGetValueReferencePointer(Func^.Namespace)),Sym,OutValue,CacheIndex) of
    1:begin
     exit;
    end;
    2:begin
     break;
    end;
   end;
   Func:=PPOCAFunction(POCAGetValueReferencePointer(Func^.Next));
  end;

  break;

 until false;

 // Full search
 begin
  // 1. Function frame locals
  if POCAHashGet(Context,Frame^.Locals,Sym,OutValue) then begin
   exit;
  end;
 end;

 begin
  // 2. Outer closure name spaces
  Func:=PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func));
  while assigned(Func) do begin
   if POCAHashGet(Context,Func^.Namespace,Sym,OutValue) then begin
    exit;
   end;
   Func:=PPOCAFunction(POCAGetValueReferencePointer(Func^.Next));
  end;
 end;

 POCARunGetLocalError(Context,Sym);

end;

procedure POCARunSetSymbol(Context:PPOCAContext;Frame:PPOCAFrame;const Sym,Value:TPOCAValue;const Constant:Boolean;var CacheIndex:TPOCAUInt32);
var Func:PPOCAFunction;
begin

 begin
  // 1. Function frame locals "if exist"
  if POCAHashTrySetCache(Context,Frame^.Locals,Sym,Value,Constant,CacheIndex) then begin
   exit;
  end;
 end;

 begin
  // 2. Outer closure name spaces
  Func:=PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func));
  while assigned(Func) do begin
   if POCAHashTrySetCache(Context,Func^.Namespace,Sym,Value,Constant,CacheIndex) then begin
    exit;
   end;
   Func:=PPOCAFunction(POCAGetValueReferencePointer(Func^.Next));
  end;
 end;

 begin
  if Context^.Instance^.Globals.StrictMode then begin
   // 3. Raise error
   POCARuntimeError(Context,'Undefined symbol: '+POCAGetStringValue(Context,Sym));
  end else begin
   if POCAIsValueHash(Frame^.Locals) then begin
    // 3. Function frame locals with creation, because symbol isn't existing already
    POCAHashSetCache(Context,Frame^.Locals,Sym,Value,Constant,CacheIndex);
   end else begin
    POCARuntimeError(Context,'Could not define symbol: '+POCAGetStringValue(Context,Sym));
   end;
  end;
 end;

end;

procedure POCARunGetLength(Context:PPOCAContext;const Obj,Fld:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex,HashCacheIndex:TPOCAUInt32;const IsInherited:boolean); //{$ifdef caninline}inline;{$endif}
var p:PPOCAObject;
    ArrayRecord:PPOCAArrayRecord;
begin
 if (Obj.CastedUInt64 and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask then begin
  p:=TPOCAPointer(TPOCAPtrUInt(Obj.Reference.Obj) and POCAValueReferenceMask);
  if assigned(p) then begin
   case p^.Header.ValueType of
    pvtARRAY:begin
     ArrayRecord:=PPOCAArray(p)^.ArrayRecord;
     if assigned(ArrayRecord) then begin
      OutValue.Num:=ArrayRecord^.Size;
     end else begin
      OutValue.Num:=0;
     end;
     exit;
    end;
    pvtSTRING:begin
     if PPOCAString(p)^.UTF8=suISUTF8 then begin
      OutValue.Num:=PPOCAString(p)^.UTF8Length;
     end else begin
      OutValue.Num:=PPOCAString(p)^.DataLength;
     end;
     exit;
    end;
    else begin
    end;
   end;
  end;
 end;
 POCAGetMember(Context,Obj,Fld,OutValue,CacheIndex,HashCacheIndex,IsInherited,true);
end;

procedure POCARunGetMember(Context:PPOCAContext;const Obj,Fld:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex,HashCacheIndex:TPOCAUInt32;const IsInherited:boolean); {$ifdef caninline}inline;{$endif}
begin
 POCAGetMember(Context,Obj,Fld,OutValue,CacheIndex,HashCacheIndex,IsInherited,true);
end;

procedure POCARunSafeGetMember(Context:PPOCAContext;const Obj,Fld:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex,HashCacheIndex:TPOCAUInt32;const IsInherited:boolean); {$ifdef caninline}inline;{$endif}
begin
 OutValue.CastedUInt64:=POCAValueNullCastedUInt64;
 POCAGetMember(Context,Obj,Fld,OutValue,CacheIndex,HashCacheIndex,IsInherited,false);
end;

procedure POCARunSetMember(Context:PPOCAContext;const Obj,Fld,Value:TPOCAValue;const Constant:Boolean;var CacheIndex:TPOCAUInt32); {$ifdef caninline}inline;{$endif}
begin
 POCASetMember(Context,Obj,Fld,Value,Constant,CacheIndex,true);
end;

procedure POCARunGetThat(Context:PPOCAContext;const Frame:PPOCAFrame;out Value:TPOCAValue); {$ifdef caninline}inline;{$endif}
var Func:PPOCAFunction;
begin
 if POCAIsValueFunction(Frame^.Func) then begin
  Func:=POCAGetValueReferencePointer(Frame^.Func);
  Value:=Func^.Obj;
 end else begin
//Value:=POCAValueNull;
  Value.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

function POCARunCheckArray(Context:PPOCAContext;const r,Index:TPOCAValue):TPOCAInt32; {$ifdef caninline}inline;{$endif}
begin
 result:=trunc(POCAGetNumberValue(Context,Index));
 if result<0 then begin
  inc(result,POCAArraySize(r));
 end;
 if (result<0) or (result>=TPOCAInt32(POCAArraySize(r))) then begin
  POCARuntimeError(Context,'Array index '+TPOCARawByteString(IntToStr(result))+' is out of bounds with size '+TPOCARawByteString(IntToStr(POCAArraySize(r))));
 end;
end;

function POCARunSafeCheckArray(Context:PPOCAContext;const r,Index:TPOCAValue):TPOCAInt32; {$ifdef caninline}inline;{$endif}
begin
 result:=trunc(POCAGetNumberValue(Context,Index));
 if result<0 then begin
  inc(result,POCAArraySize(r));
 end;
 if (result<0) or (result>=TPOCAInt32(POCAArraySize(r))) then begin
  result:=-1;
 end;
end;

function POCARunCheckString(Context:PPOCAContext;const r,Index:TPOCAValue):TPOCAInt32;
var s:TPOCARawByteString;
begin
 s:=POCAGetStringValue(Context,r);
 try
  result:=trunc(POCAGetNumberValue(Context,Index));
  if result<0 then begin
   inc(result,length(s));
  end;
  if (result<0) or (result>=length(s)) then begin
   POCARuntimeError(Context,'String index '+TPOCARawByteString(IntToStr(result))+' is out of bounds with size '+TPOCARawByteString(IntToStr(length(s))));
  end;
 finally
  s:='';
 end;
end;

function POCARunCheckStringUTF8(Context:PPOCAContext;const r,Index:TPOCAValue):TPOCAInt32;
var l:TPOCAInt32;
begin
 l:=POCAGetStringUTF8Length(Context,r);
 try
  result:=trunc(POCAGetNumberValue(Context,Index));
  if result<0 then begin
   inc(result,l);
  end;
  if (result<0) or (result>=l) then begin
   POCARuntimeError(Context,'String index '+TPOCARawByteString(IntToStr(result))+' is out of bounds with size '+TPOCARawByteString(IntToStr(l)));
  end;
 finally
 end;
end;

function POCARunArrayGet(Context:PPOCAContext;const Box,Key:TPOCAValue):TPOCAValue;
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
    Index:TPOCAInt32;
begin
 if POCAIsValueScalarType(Key) then begin
{ if POCAGetValueType(Box)=pvtARRAY then}begin
   ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(Box));
   ArrayRecord:=ArrayInstance^.ArrayRecord;
   Index:=trunc(POCAGetNumberValue(Context,Key));
   if Index<0 then begin
    inc(Index,ArrayRecord^.Size);
   end;
   if (Index>=0) or (Index<ArrayRecord^.Size) then begin
    result:=ArrayRecord^.Data[Index];
   end else begin
    POCARuntimeError(Context,'Out of bounds');
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
{ end else begin
   POCARuntimeError(Context,'Not an array');
   result.CastedUInt64:=POCAValueNullCastedUInt64;}
  end;
 end else begin
  POCARuntimeError(Context,'Container index not scalar');
  result.CastedUInt64:=POCAValueNullCastedUInt64;
 end;
end;

procedure POCARunArraySet(Context:PPOCAContext;const Box,Key,Value:TPOCAValue);
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
    Index:TPOCAInt32;
begin
 if POCAIsValueScalarType(Key) then begin
 {if POCAGetValueType(Box)=pvtARRAY then}begin
   ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(Box));
   ArrayRecord:=ArrayInstance^.ArrayRecord;
   Index:=trunc(POCAGetNumberValue(Context,Key));
   if Index<0 then begin
    inc(Index,ArrayRecord^.Size);
   end;
   if (Index>=0) or (Index<ArrayRecord^.Size) then begin
    ArrayRecord^.Data[Index]:=Value;
    TPOCAGarbageCollector.WriteBarrier(PPOCAObject(TPOCAPointer(ArrayInstance)),Value);
   end else begin
    POCARuntimeError(Context,'Out of bounds');
   end;
{ end else begin
   POCARuntimeError(Context,'Not an array');}
  end;
 end else begin
  POCARuntimeError(Context,'Container index not scalar');
 end;
end;

function POCARunContainerGet(Context:PPOCAContext;const Box,Key:TPOCAValue):TPOCAValue;
var CodePoint,CodeUnit,Index:TPOCAInt32;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if not POCAIsValueScalarType(Key) then begin
  POCARuntimeError(Context,'Container index not scalar');
 end else begin
  case POCAGetValueType(Box) of
   pvtNUMBER:begin
    if not POCAHashGet(Context,Context.Instance^.Globals.NumberHash,Key,result) then begin
     POCARuntimeError(Context,'No such key member: '+POCAGetStringValue(Context,Key));
    end;
   end;
   pvtHASH:begin
    if not POCAHashGet(Context,Box,Key,result) then begin
     if not POCAHashGet(Context,Context.Instance^.Globals.HashHash,Key,result) then begin
      POCARuntimeError(Context,'No such key member: '+POCAGetStringValue(Context,Key));
     end;
    end;
   end;
   pvtARRAY:begin
    if POCAIsValueString(Key) then begin
     if not POCAHashGet(Context,Context.Instance^.Globals.ArrayHash,Key,result) then begin
      if not POCAGetArrayProperty(Context,Box,Key,result) then begin
       POCARuntimeError(Context,'No such key member: '+POCAGetStringValue(Context,Key));
      end;
     end;
    end else begin
     Index:=POCARunCheckArray(Context,Box,Key);
     if Index>=0 then begin
      result:=POCAArrayGet(Box,Index);
     end else begin
      result.CastedUInt64:=POCAValueNullCastedUInt64;
     end;
    end;
   end;
   pvtSTRING:begin
    if POCAIsValueString(Key) then begin
     if not POCAHashGet(Context,Context.Instance^.Globals.StringHash,Key,result) then begin
      if not POCAGetStringProperty(Context,Box,Key,result) then begin
       POCARuntimeError(Context,'No such key member: '+POCAGetStringValue(Context,Key));
      end;
     end;
    end else begin
     if PPOCAString(POCAGetValueReferencePointer(Box))^.UTF8=suISUTF8 then begin
      CodePoint:=POCARunCheckStringUTF8(Context,Box,Key);
      CodeUnit:=POCAStringUTF8GetCodeUnit(Context,Box,CodePoint);
      if (CodeUnit>0) and (CodeUnit<=length(PPOCAString(POCAGetValueReferencePointer(Box))^.Data)) then begin
       result.Num:=PUCUUTF8CodeUnitGetChar(PPOCAString(POCAGetValueReferencePointer(Box))^.Data,CodeUnit);
      end else begin
       result.Num:=PUCUUTF8CodePointGetChar(PPOCAString(POCAGetValueReferencePointer(Box))^.Data,CodePoint);
      end;
     end else begin
      result.Num:=ord(PPOCAString(POCAGetValueReferencePointer(Box))^.Data[POCARunCheckString(Context,Box,Key)+1]) and 1;
     end;
    end;
   end;
   pvtGHOST:begin
    if not POCAHashGet(Context,POCAGhostGetHashValue(Box),Key,result) then begin
     POCARuntimeError(Context,'No such key member: '+POCAGetStringValue(Context,Key));
    end;
   end;
   else begin
    POCARuntimeError(Context,'Extract from non-container');
   end;
  end;
 end;
end;

function POCARunContainerSafeGet(Context:PPOCAContext;const Box,Key:TPOCAValue):TPOCAValue;
var CodePoint,CodeUnit,Index:TPOCAInt32;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 if not POCAIsValueScalarType(Key) then begin
  POCARuntimeError(Context,'Container index not scalar');
 end else begin
  case POCAGetValueType(Box) of
   pvtNUMBER:begin
    if not POCAHashGet(Context,Context.Instance^.Globals.NumberHash,Key,result) then begin
     result.CastedUInt64:=POCAValueNullCastedUInt64;
    end;
   end;
   pvtHASH:begin
    if not POCAHashGet(Context,Box,Key,result) then begin
     if not POCAHashGet(Context,Context.Instance^.Globals.HashHash,Key,result) then begin
      result.CastedUInt64:=POCAValueNullCastedUInt64;
     end;
    end;
   end;
   pvtARRAY:begin
    if POCAIsValueString(Key) then begin
     if not POCAHashGet(Context,Context.Instance^.Globals.ArrayHash,Key,result) then begin
      if not POCAGetArrayProperty(Context,Box,Key,result) then begin
       result.CastedUInt64:=POCAValueNullCastedUInt64;
      end;
     end;
    end else begin
     Index:=POCARunSafeCheckArray(Context,Box,Key);
     if Index>=0 then begin
      result:=POCAArrayGet(Box,Index);
     end else begin
      result.CastedUInt64:=POCAValueNullCastedUInt64;
     end;
    end;
   end;
   pvtSTRING:begin
    if POCAIsValueString(Key) then begin
     if not POCAHashGet(Context,Context.Instance^.Globals.StringHash,Key,result) then begin
      if not POCAGetStringProperty(Context,Box,Key,result) then begin
       result.CastedUInt64:=POCAValueNullCastedUInt64;
      end;
     end;
    end else begin
     if PPOCAString(POCAGetValueReferencePointer(Box))^.UTF8=suISUTF8 then begin
      CodePoint:=POCARunCheckStringUTF8(Context,Box,Key);
      CodeUnit:=POCAStringUTF8GetCodeUnit(Context,Box,CodePoint);
      if (CodeUnit>0) and (CodeUnit<=length(PPOCAString(POCAGetValueReferencePointer(Box))^.Data)) then begin
       result.Num:=PUCUUTF8CodeUnitGetChar(PPOCAString(POCAGetValueReferencePointer(Box))^.Data,CodeUnit);
      end else begin
       result.Num:=PUCUUTF8CodePointGetChar(PPOCAString(POCAGetValueReferencePointer(Box))^.Data,CodePoint);
      end;
     end else begin
      result.Num:=ord(PPOCAString(POCAGetValueReferencePointer(Box))^.Data[POCARunCheckString(Context,Box,Key)+1]) and 1;
     end;
    end;
   end;
   pvtGHOST:begin
    if not POCAHashGet(Context,POCAGhostGetHashValue(Box),Key,result) then begin
     result.CastedUInt64:=POCAValueNullCastedUInt64;
    end;
   end;
   else begin
    result.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  end;
 end;
end;

procedure POCARunContainerSet(Context:PPOCAContext;const Box,Key,Value:TPOCAValue;const Constant:Boolean);
var CodePoint:TPOCAInt32;
    CharValue:TPOCAUInt32;
begin
 if not POCAIsValueScalarType(Key) then begin
  POCARuntimeError(Context,'Container index not scalar');
 end else begin
  case POCAGetValueType(Box) of
   pvtHASH:begin
    POCAHashSet(Context,Box,Key,Value,Constant);
   end;
   pvtARRAY:begin
    POCAArraySet(Box,POCARunCheckArray(Context,Box,Key),Value);
   end;
   pvtSTRING:begin
    if PPOCAString(POCAGetValueReferencePointer(Box))^.HashCode<>0 then begin
     POCARuntimeError(Context,'Cannot change immutable string');
    end else begin
     CharValue:=trunc(POCAGetNumberValue(Context,Value));
     if (PPOCAString(POCAGetValueReferencePointer(Box))^.UTF8=suISUTF8) or ((PPOCAString(POCAGetValueReferencePointer(Box))^.UTF8=suPOSSIBLEUTF8) and (CharValue>$7f)) then begin
      CodePoint:=POCARunCheckStringUTF8(Context,Box,Key);
      PPOCAString(POCAGetValueReferencePointer(Box))^.Data:=POCAStringUTF8CopyCodePointRange(Context,Box,0,CodePoint-1)+PUCUUTF32CharToUTF8(CharValue)+POCAStringUTF8CopyCodePointRange(Context,Box,CodePoint+1,PPOCAString(POCAGetValueReferencePointer(Box))^.UTF8Length-1);
      PPOCAString(POCAGetValueReferencePointer(Box))^.Dirty:=true;
      POCAStringUpdate(Context,Box);
     end else begin
      PPOCAString(POCAGetValueReferencePointer(Box))^.Data[POCARunCheckString(Context,Box,Key)+1]:=ansichar(TPOCAUInt8(CharValue));
     end;
    end;
   end;
   else begin
    POCARuntimeError(Context,'Insert into non-container');
   end;
  end;
 end;
end;

function POCARunEvalForEach(Context:PPOCAContext;const Obj:TPOCAValue;var Index,Value,Keys:TPOCAValue):boolean;
var CurrentIndex,Cell,Entity,CodePoint,CodeUnit:TPOCAInt32;
    ArrayRecord:PPOCAArrayRecord;
    Str:PPOCAString;
    HashRecord:PPOCAHashRecord;
begin
 result:=false;
 CurrentIndex:=trunc(Index.Num);
 case POCAGetValueType(Obj) of
  pvtARRAY:begin
   ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(Obj))^.ArrayRecord;
   if assigned(ArrayRecord) and ((CurrentIndex>=0) and (CurrentIndex<ArrayRecord^.Size)) then begin
    Index.Num:=CurrentIndex+1;
    Value:=ArrayRecord^.Data[CurrentIndex];
    result:=true;
   end;
  end;
  pvtSTRING:begin
   Str:=PPOCAString(POCAGetValueReferencePointer(Obj));
   if assigned(Str) then begin
    if Str^.UTF8=suISUTF8 then begin
     if ((CurrentIndex>=0) and (CurrentIndex<Str^.UTF8Length)) then begin
      Index.Num:=CurrentIndex+1;
      CodePoint:=CurrentIndex;
      CodeUnit:=POCAStringUTF8GetCodeUnit(Context,Obj,CodePoint);
      if (CodeUnit>0) and (CodeUnit<=Str^.DataLength) then begin
       Value.Num:=PUCUUTF8CodeUnitGetChar(Str^.Data,CodeUnit);
      end else begin
       Value.Num:=PUCUUTF8CodePointGetChar(Str^.Data,CodePoint);
      end;
      result:=true;
     end;
    end else begin
     if ((CurrentIndex>=0) and (CurrentIndex<Str^.DataLength)) then begin
      Index.Num:=CurrentIndex+1;
      CodeUnit:=CurrentIndex+1;
      Value.Num:=TPOCAUInt8(AnsiChar(Str^.Data[CodeUnit]));
      result:=true;
     end;
    end;
   end;
  end;
  pvtHASH:begin
   if CurrentIndex=0 then begin
    Keys:=POCANewArray(Context);
    POCAHashKeys(Context,Keys,Obj);
    POCAArraySort(Context,Keys);
   end;
   if POCAIsValueArray(Keys) then begin
    ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(Keys))^.ArrayRecord;
    if assigned(ArrayRecord) and ((CurrentIndex>=0) and (CurrentIndex<ArrayRecord^.Size)) then begin
     Index.Num:=CurrentIndex+1;
     result:=POCAHashGet(Context,Obj,POCAArrayGet(Keys,CurrentIndex),Value);
    end;
   end else begin
    HashRecord:=PPOCAHash(POCAGetValueReferencePointer(Obj))^.HashRecord;
    if assigned(HashRecord) then begin
     while ((CurrentIndex>=0) and (CurrentIndex<(2 shl HashRecord^.LogSize))) do begin
      Cell:=HashRecord^.EntityToCellIndex^[CurrentIndex];
      if Cell>=0 then begin
       Entity:=HashRecord^.CellToEntityIndex^[Cell];
       if Entity>=0 then begin
        Index.Num:=CurrentIndex+1;
        Value:=HashRecord^.Entities^[Entity].Value;
        result:=true;
        break;
       end;
      end;
      inc(CurrentIndex);
     end;
    end;
   end;
  end;
  else begin
   POCARuntimeError(Context,'foreach emumeration of non-array, non-string and non-hash');
  end;
 end;
end;

function POCARunEvalForKey(Context:PPOCAContext;const Obj:TPOCAValue;var Index,Value,Keys:TPOCAValue):boolean;
var CurrentIndex,Cell,Entity:TPOCAInt32;
    ArrayRecord:PPOCAArrayRecord;
    HashRecord:PPOCAHashRecord;
begin
 result:=false;
 CurrentIndex:=trunc(Index.Num);
 if POCAIsValueHash(Obj) then begin
  if CurrentIndex=0 then begin
   Keys:=POCANewArray(Context);
   POCAHashKeys(Context,Keys,Obj);
   POCAArraySort(Context,Keys);
  end;
  if POCAIsValueArray(Keys) then begin
   ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(Keys))^.ArrayRecord;
   if assigned(ArrayRecord) and ((CurrentIndex>=0) and (CurrentIndex<ArrayRecord^.Size)) then begin
    Index.Num:=CurrentIndex+1;
    Value:=ArrayRecord^.Data[CurrentIndex];
    result:=true;
   end;
  end else begin
   HashRecord:=PPOCAHash(POCAGetValueReferencePointer(Obj))^.HashRecord;
   if assigned(HashRecord) then begin
    while ((CurrentIndex>=0) and (CurrentIndex<(2 shl HashRecord^.LogSize))) do begin
     Cell:=HashRecord^.EntityToCellIndex^[CurrentIndex];
     if Cell>=0 then begin
      Entity:=HashRecord^.CellToEntityIndex^[Cell];
      if Entity>=0 then begin
       Index.Num:=CurrentIndex+1;
       Value:=HashRecord^.Entities^[Entity].Key;
       result:=true;
       break;
      end;
     end;
     inc(CurrentIndex);
    end;
   end;
  end;
 end else begin
  POCARuntimeError(Context,'forkey emumeration of non-hash');
 end;
end;

function POCARunEvalForIndex(Context:PPOCAContext;const Obj:TPOCAValue;var Index,Value:TPOCAValue):boolean;
var CurrentIndex:TPOCAInt32;
    ArrayRecord:PPOCAArrayRecord;
    Str:PPOCAString;
begin
 result:=false;
 CurrentIndex:=trunc(Index.Num);
 case POCAGetValueType(Obj) of
  pvtARRAY:begin
   ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(Obj))^.ArrayRecord;
   if assigned(ArrayRecord) and ((CurrentIndex>=0) and (CurrentIndex<ArrayRecord^.Size)) then begin
    Index.Num:=CurrentIndex+1;
    Value.Num:=CurrentIndex;
    result:=true;
   end;
  end;
  pvtSTRING:begin
   Str:=PPOCAString(POCAGetValueReferencePointer(Obj));
   if assigned(Str) then begin
    if Str^.UTF8=suISUTF8 then begin
     if ((CurrentIndex>=0) and (CurrentIndex<Str^.UTF8Length)) then begin
      Index.Num:=CurrentIndex+1;
      Value.Num:=CurrentIndex;
      result:=true;
     end;
    end else begin
     if ((CurrentIndex>=0) and (CurrentIndex<Str^.DataLength)) then begin
      Index.Num:=CurrentIndex+1;
      Value.Num:=CurrentIndex;
      result:=true;
     end;
    end;
   end;
  end;
  else begin
   POCARuntimeError(Context,'forindex emumeration of non-array and non-string');
  end;
 end;
end;

procedure POCARunEvalUnpack(Context:PPOCAContext;Frame:PPOCAFrame;Opcode:TPOCAUInt32;Operands:PPOCAUInt32Array);
var ArrayObject:TPOCAValue;
    i,Count:TPOCAInt32;
begin
 ArrayObject:=Frame^.Registers[Operands^[0]];
 Count:=(Opcode shr 8)-1;
 if (not POCAIsValueArray(ArrayObject)) or (TPOCAInt32(POCAArraySize(ArrayObject))<Count) then begin
  POCARuntimeError(Context,'Short or invalid multi-assignment array');
 end else begin
  for i:=0 to Count-1 do begin
   Frame^.Registers[Operands^[i+1]]:=POCAArrayGet(ArrayObject,i);
  end;
 end;
end;

procedure POCARunEvalSlice(Context:PPOCAContext;var Dst:TPOCAValue;const Src,Idx:TPOCAValue);
var DstType,CodePoint:TPOCAInt32;
begin
 DstType:=POCAGetValueType(Dst);
 if DstType=pvtNULL then begin
  case POCAGetValueType(Src) of
   pvtSTRING:begin
    Dst:=POCANewString(Context,'');
    DstType:=pvtSTRING;
   end;
   pvtARRAY:begin
    Dst:=POCANewArray(Context);
    DstType:=pvtARRAY;
   end;
   else begin
    POCARuntimeError(Context,'Cannot slice non-string-or-array');
   end;
  end;
 end;
 if DstType=POCAGetValueType(Src) then begin
  case DstType of
   pvtSTRING:begin
    if PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode<>0 then begin
     POCARuntimeError(Context,'Cannot slice to immutable strings');
    end else begin
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8<>suNOUTF8 then begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        CodePoint:=POCARunCheckString(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,CodePoint+1,1);
       end;
       suISUTF8:begin
        CodePoint:=POCARunCheckStringUTF8(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+POCAStringUTF8CopyCodePointRange(Context,Src,CodePoint,CodePoint);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        CodePoint:=POCARunCheckString(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+PUCUUTF8Correct(copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,CodePoint+1,1));
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
      end;
     end else begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        CodePoint:=POCARunCheckString(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,CodePoint+1,1);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       suISUTF8:begin
        CodePoint:=POCARunCheckStringUTF8(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+POCAStringUTF8CopyCodePointRange(Context,Src,CodePoint,CodePoint);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        CodePoint:=POCARunCheckString(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,CodePoint+1,1);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suNOUTF8;
       end;
      end;
     end;
     inc(PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8Length);
     PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode:=0;
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8=suISUTF8 then begin
      PPOCAString(POCAGetValueReferencePointer(Dst))^.Dirty:=true;
//    POCAStringUpdate(Context,Dst);
     end;
    end;
   end;
   pvtARRAY:begin
    POCAArrayPush(Dst,POCAArrayGet(Src,POCARunCheckArray(Context,Src,Idx)));
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Slice data types mismatch');
 end;
end;

procedure POCARunEvalSlice2(Context:PPOCAContext;var Dst:TPOCAValue;const Src,Start,EndR:TPOCAValue);
var Size:TPOCAInt32;
 function Bound(const ir:TPOCAValue;IsEnd:boolean;IsString:boolean):TPOCAInt32;
 begin
  if POCAIsValueNull(ir) then begin
   if IsEnd then begin
    result:=-1;
   end else begin
    result:=0;
   end;
  end else begin
   result:=trunc(POCAGetNumberValue(Context,ir));
  end;
  if POCAIsValueNull(ir) and (Size=0) then begin
   exit;
  end;
  if result<0 then begin
   inc(result,Size);
  end;
  if (result<0) or (result>=Size) then begin
   if IsString then begin
    POCARuntimeError(Context,'String index '+TPOCARawByteString(IntToStr(result))+' is out of bounds with size '+TPOCARawByteString(IntToStr(Size)));
   end else begin
    POCARuntimeError(Context,'Array index '+TPOCARawByteString(IntToStr(result))+' is out of bounds with size '+TPOCARawByteString(IntToStr(Size)));
   end;
  end;
 end;
var DstType,i,s,e,l:TPOCAInt32;
begin
 DstType:=POCAGetValueType(Dst);
 if DstType=pvtNULL then begin
  case POCAGetValueType(Src) of
   pvtSTRING:begin
    Dst:=POCANewString(Context,'');
    DstType:=pvtSTRING;
   end;
   pvtARRAY:begin
    Dst:=POCANewArray(Context);
    DstType:=pvtARRAY;
   end;
   else begin
    POCARuntimeError(Context,'Cannot slice non-string-or-array');
   end;
  end;
 end;
 if DstType=POCAGetValueType(Src) then begin
  case DstType of
   pvtSTRING:begin
    if PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode<>0 then begin
     POCARuntimeError(Context,'Cannot slice to immutable strings');
    end else begin
     if PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8=suISUTF8 then begin
      Size:=PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8Length;
     end else begin
      Size:=length(PPOCAString(POCAGetValueReferencePointer(Src))^.Data);
     end;
     s:=Bound(Start,false,true);
     e:=Bound(EndR,true,true);
     l:=(e-s)+1;
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8<>suNOUTF8 then begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
       end;
       suISUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+POCAStringUTF8CopyCodePointRange(Context,Src,s,e);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+PUCUUTF8Correct(copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l));
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
      end;
     end else begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       suISUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+POCAStringUTF8CopyCodePointRange(Context,Src,s,e);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suNOUTF8;
       end;
      end;
     end;
     inc(PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8Length,l);
     PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode:=0;
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8=suISUTF8 then begin
      PPOCAString(POCAGetValueReferencePointer(Dst))^.Dirty:=true;
//    POCAStringUpdate(Context,Dst);
     end;
    end;
   end;
   pvtARRAY:begin
    Size:=POCAArraySize(Src);
    for i:=Bound(Start,false,false) to Bound(EndR,true,false) do begin
     POCAArrayPush(Dst,POCAArrayGet(Src,i));
    end;
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Slice data types mismatch');
 end;
end;

procedure POCARunEvalSlice3(Context:PPOCAContext;var Dst:TPOCAValue;const Src,Start,Len:TPOCAValue);
var DstType,Size,i,s,e,l:TPOCAInt32;
begin
 DstType:=POCAGetValueType(Dst);
 if DstType=pvtNULL then begin
  case POCAGetValueType(Src) of
   pvtSTRING:begin
    Dst:=POCANewString(Context,'');
    DstType:=pvtSTRING;
   end;
   pvtARRAY:begin
    Dst:=POCANewArray(Context);
    DstType:=pvtARRAY;
   end;
   else begin
    POCARuntimeError(Context,'Cannot slice non-string-or-array');
   end;
  end;
 end;
 if DstType=POCAGetValueType(Src) then begin
  case DstType of
   pvtSTRING:begin
    if PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode<>0 then begin
     POCARuntimeError(Context,'Cannot slice to immutable strings');
    end else begin
     if PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8=suISUTF8 then begin
      Size:=PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8Length;
     end else begin
      Size:=length(PPOCAString(POCAGetValueReferencePointer(Src))^.Data);
     end;
     if POCAIsValueNull(Start) then begin
      s:=0;
     end else begin
      s:=trunc(POCAGetNumberValue(Context,Start));
     end;
     if POCAIsValueNull(Start) and (Size=0) then begin
      exit;
     end;
     if s<0 then begin
      inc(s,Size);
     end;
     if (s<0) or (s>=Size) then begin
      POCARuntimeError(Context,'String index '+TPOCARawByteString(IntToStr(s))+' is out of bounds with size '+TPOCARawByteString(IntToStr(Size)));
     end;
     if POCAIsValueNull(Len) then begin
      e:=Size-s;
     end else begin
      e:=trunc(POCAGetNumberValue(Context,Len));
     end;
     if e<=0 then begin
      inc(e,Size-s);
     end;
     e:=(s+e)-1;
     if e>=Size then begin
      e:=Size-1;
     end;
     l:=(e-s)+1;
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8<>suNOUTF8 then begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
       end;
       suISUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+POCAStringUTF8CopyCodePointRange(Context,Src,s,e);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+PUCUUTF8Correct(copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l));
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
      end;
     end else begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       suISUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+POCAStringUTF8CopyCodePointRange(Context,Src,s,e);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suNOUTF8;
       end;
      end;
     end;
     inc(PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8Length,l);
     PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode:=0;
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8=suISUTF8 then begin
      PPOCAString(POCAGetValueReferencePointer(Dst))^.Dirty:=true;
//    POCAStringUpdate(Context,Dst);
     end;
    end;
   end;
   pvtARRAY:begin
    Size:=POCAArraySize(Src);
    if POCAIsValueNull(Start) then begin
     s:=0;
    end else begin
     s:=trunc(POCAGetNumberValue(Context,Start));
    end;
    if POCAIsValueNull(Start) and (Size=0) then begin
     exit;
    end;
    if s<0 then begin
     inc(s,Size);
    end;
    if (s<0) or (s>=Size) then begin
     POCARuntimeError(Context,'Array index '+TPOCARawByteString(IntToStr(s))+' is out of bounds with size '+TPOCARawByteString(IntToStr(Size)));
    end;
    if POCAIsValueNull(Len) then begin
     e:=Size-s;
    end else begin
     e:=trunc(POCAGetNumberValue(Context,Len));
    end;
    if e<=0 then begin
     inc(e,Size-s);
    end;
    e:=(s+e)-1;
    if e>=Size then begin
     e:=Size-1;
    end;
    for i:=s to e do begin
     POCAArrayPush(Dst,POCAArrayGet(Src,i));
    end;
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Slice data types mismatch');
 end;
end;

function POCARunByteCode(Context:PPOCAContext):TPOCAValue; forward;

function POCARunTry(Context:PPOCAContext;Frame:PPOCAFrame;ResultReg,CatchReg,TryBlockPos,CatchBlockPos,FinallyBlockPos,EndPos:TPOCAUInt32):TPOCAUInt32;
var FrameTop:TPOCAInt32;
    rv,v:TPOCAValue;
begin
 FrameTop:=Context^.FrameTop;
 try
  try
   if TryBlockPos<>$ffffffff then begin
    Context^.FrameTop:=FrameTop;
    Frame^.InstructionPointer:=TryBlockPos;
    rv:=POCARunByteCode(Context);
   end else begin
  //rv:=POCAValueNull;
    rv.CastedUInt64:=POCAValueNullCastedUInt64;
   end;
  except
   on CurrentException:EPOCACoroutineTerminated do begin
    raise;
   end;
   on CurrentException:Exception do begin
    if CatchBlockPos=$ffffffff then begin
     raise;
    end else begin
     Context^.FrameTop:=FrameTop;
     Frame^.InstructionPointer:=CatchBlockPos;
     if CatchReg<>$ffffffff then begin
      if CurrentException is EPOCAError then begin
       if length(CurrentException.Message)>0 then begin
        v:=POCANewArray(Context);
        POCAArraySetSize(v,4);
        POCAArraySet(v,0,POCANewString(Context,PUCUUTF16ToUTF8(TPOCAUTF16String(CurrentException.Message))));
        if CurrentException is EPOCASyntaxError then begin
         POCAArraySet(v,1,POCANewUniqueString(Context,'SyntaxError'));
        end else if CurrentException is EPOCARuntimeError then begin
         POCAArraySet(v,1,POCANewUniqueString(Context,'RuntimeError'));
        end else if CurrentException is EPOCAScriptError then begin
         POCAArraySet(v,1,POCANewUniqueString(Context,'ScriptError'));
        end else begin
         POCAArraySet(v,1,POCANewUniqueString(Context,'Error'));
        end;
        if EPOCAError(CurrentException).SourceFile>=0 then begin
         POCAArraySet(v,2,POCAArrayGet(Context^.Instance^.Globals.SourceFiles,EPOCAError(CurrentException).SourceFile));
        end else begin
         POCAArraySet(v,2,POCAValueNull);
        end;
        POCAArraySet(v,3,POCANumber(EPOCAError(CurrentException).SourceLine));
       end else begin
        v:=EPOCAError(CurrentException).Value;
       end;
      end else begin
       v:=POCANewArray(Context);
       POCAArraySetSize(v,4);
       POCAArraySet(v,0,POCANewString(Context,PUCUUTF16ToUTF8(TPOCAUTF16String(CurrentException.Message))));
       POCAArraySet(v,1,POCANewUniqueString(Context,PUCUUTF16ToUTF8(TPOCAUTF16String(CurrentException.ClassName))));
       POCAArraySet(v,2,POCAValueNull);
       POCAArraySet(v,3,POCANumber(-1));
      end;
      Frame^.Registers[CatchReg]:=v;
     end;
     rv:=POCARunByteCode(Context);
    end;
   end;
  end;
 finally
  if FinallyBlockPos<>$ffffffff then begin
   Context^.FrameTop:=FrameTop;
   Frame^.InstructionPointer:=FinallyBlockPos;
   rv:=POCARunByteCode(Context);
  end;
  Context^.FrameTop:=FrameTop;
 end;
 result:=EndPos;
 Frame^.Registers[ResultReg]:=rv;
end;

procedure POCARunThrow(Context:PPOCAContext;Parameter:TPOCAValue);
var Value:TPOCAUInt32;
begin
 Value:=POCAStackDepth(Context);
 if POCAIsValueString(Parameter) then begin
  raise EPOCAScriptError.Create(POCAGetSourceFile(Context,Value),POCAGetSourceLine(Context,Value),-1,POCAGetStringValue(Context,Parameter));
 end else begin
  raise EPOCAScriptError.Create(POCAGetSourceFile(Context,Value),POCAGetSourceLine(Context,Value),-1,Parameter);
 end;
end;

procedure POCARunIn(Context:PPOCAContext;var r:TPOCAValue;const a,b:TPOCAValue);
var CurrentIndex:TPOCAInt32;
    c:TPOCAValue;
    d,e:TPOCAUInt32;
begin
//c:=POCAValueNull;
 c.CastedUInt64:=POCAValueNullCastedUInt64;
 if POCAIsValueArray(b) then begin
  if POCAIsValueArray(a) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
   r.Num:=1;
  end else begin
   r.Num:=0;
   CurrentIndex:=0;
   while CurrentIndex<TPOCAInt32(POCAArraySize(b)) do begin
    if POCACompare(Context,a,POCAArrayGet(b,CurrentIndex))=0 then begin
     r.Num:=1;
     break;
    end else begin
     inc(CurrentIndex);
    end;
   end;
  end;
 end else if POCAIsValueHash(b) then begin
  if POCAIsValueHash(a) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
   r.Num:=1;
  end else begin
   d:=$ffffffff;
   e:=$ffffffff;
   r.Num:=ord(POCAGetMember(Context,b,a,c,d,e,false,false)) and 1;
  end;
 end else if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
  r.Num:=ord(a.Num=b.Num) and 1;
 end else begin
  r.Num:=ord(POCACompare(Context,a,b)=0) and 1;
 end;
end;

procedure POCARunInRange(Context:PPOCAContext;var r:TPOCAValue;const a,b,c:TPOCAValue);
begin
 if POCAIsValueNumber(a) and POCAIsValueNumber(b) and POCAIsValueNumber(c) then begin
  r.Num:=ord((b.Num<=a.Num) and (a.Num<=c.Num)) and 1;
 end else begin
  r.Num:=ord((POCACompare(Context,b,a)<=0) and (POCACompare(Context,a,c)<=0)) and 1;
 end;
end;

function POCARunHashEventBinaryOp(Context:PPOCAContext;var Frame:PPOCAFrame;const Operands:PPOCAUInt32Array;const Operation:TPOCAMetaOp):boolean;
var HashEvents:PPOCAHashEvents;
begin
 HashEvents:=POCAHashGetHashEvents(Frame^.Registers[Operands^[1]],Frame^.Registers[Operands^[2]],Operation);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[Operation]) then begin
  Frame:=POCASetupFunctionCall(Context,Frame,3 shl 8,Operands,false,false,@HashEvents^[Operation]);
  result:=true;
 end else begin
  result:=false;
 end;
end;

function POCARunHashEventRightBinaryOp(Context:PPOCAContext;var Frame:PPOCAFrame;const Operands:PPOCAUInt32Array;const Operation:TPOCAMetaOp):boolean;
var HashEvents:PPOCAHashEvents;
begin
 HashEvents:=POCAHashGetHashEvents(Frame^.Registers[Operands^[2]],Operation);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[Operation]) then begin
  Frame:=POCASetupFunctionCall(Context,Frame,3 shl 8,Operands,false,false,@HashEvents^[Operation]);
  result:=true;
 end else begin
  result:=false;
 end;
end;

function POCARunHashEventUnaryOp(Context:PPOCAContext;var Frame:PPOCAFrame;const Operands:PPOCAUInt32Array;const Operation:TPOCAMetaOp):boolean;
var HashEvents:PPOCAHashEvents;
begin
 HashEvents:=POCAHashGetHashEvents(Frame^.Registers[Operands^[1]]);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[Operation]) then begin
  Frame:=POCASetupFunctionCall(Context,Frame,2 shl 8,Operands,false,false,@HashEvents^[Operation]);
  result:=true;
 end else begin
  result:=false;
 end;
end;

function POCARunHashEventInRangeOp(Context:PPOCAContext;var Frame:PPOCAFrame;const Operands:PPOCAUInt32Array;const Operation:TPOCAMetaOp):boolean;
var HashEvents:PPOCAHashEvents;
begin
 HashEvents:=POCAHashGetHashEvents(Frame^.Registers[Operands^[1]],Frame^.Registers[Operands^[2]],Frame^.Registers[Operands^[3]],Operation);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[Operation]) then begin
  Frame:=POCASetupFunctionCall(Context,Frame,4 shl 8,Operands,false,false,@HashEvents^[Operation]);
  result:=true;
 end else begin
  result:=false;
 end;
end;

{$ifdef POCAHasJIT}
{$ifdef cpu386}
{$warnings off}
function POCAGenerateNativeCode(Context:PPOCAContext;Code:PPOCACode):boolean;
type TFixupKind=(fkPTR,fkRET,fkOFS);
     TFixup=record
      Kind:TFixupKind;
      Ofs:TPOCAInt32;
      Dest:TPOCAPointer;
      ToOfs:TPOCAInt32;
     end;
     TFixups=array of TFixup;
var Fixups:TFixups;
    CountFixups,i:TPOCAInt32;
    Offsets:array of TPOCAUInt32;
    Opcode,Instruction:TPOCAUInt32;
    CodeBuffer:array of TPOCAUInt8;
    CodeBufferLen,OldCodeBufferLen:TPOCAInt32;
    CurrentPC,LastPC,Temp,RetOfs,Literal:TPOCAUInt32;
    CodeBegin,CodeEnd:TPOCAPointer;
    CodeVars:array[0..8] of TPOCAPointer;
    Operands:PPOCAInt32Array;
    v:TPOCAValue;
 procedure Add(const s:TPUCURawByteString);
 begin
  if length(s)>0 then begin
   if (CodeBufferLen+length(s))>=length(CodeBuffer) then begin
    SetLength(CodeBuffer,(CodeBufferLen+length(s)+4096) and not 4095);
   end;
   move(s[1],CodeBuffer[CodeBufferLen],length(s));
   inc(CodeBufferLen,length(s));
  end;
 end;
 procedure AddCode(CodeBegin,CodeEnd:TPOCAPointer);
 var CodeLen:TPOCAPtrInt;
{$ifdef windows}
     OldProtect,OldProtectDummy:TPOCAUInt32;
     OK:boolean;
{$endif}
 begin
  CodeLen:=TPOCAPtrInt(TPOCAPtrUInt(CodeEnd)-TPOCAPtrUInt(CodeBegin));
  if CodeLen>0 then begin
{$ifdef windows}
   OK:=VirtualProtect(CodeBegin,CodeLen,PAGE_EXECUTE_READWRITE,OldProtect);
{$endif}
{$ifdef unix}
   fpmprotect(CodeBegin,CodeLen,PROT_READ or PROT_WRITE or PROT_EXEC);
{$endif}
   if (CodeBufferLen+CodeLen)>=length(CodeBuffer) then begin
    SetLength(CodeBuffer,(CodeBufferLen+CodeLen+4096) and not 4095);
   end;
   move(CodeBegin^,CodeBuffer[CodeBufferLen],CodeLen);
   inc(CodeBufferLen,CodeLen);
{$ifdef windows}
   if OK then begin
    VirtualProtect(CodeBegin,CodeLen,OldProtect,OldProtectDummy);
   end;
{$endif}
  end;
 end;
 procedure AddDWord(const v:TPOCAUInt32);
 begin
  if (CodeBufferLen+sizeof(TPOCAUInt32))>=length(CodeBuffer) then begin
   SetLength(CodeBuffer,(CodeBufferLen+sizeof(TPOCAUInt32)+4096) and not 4095);
  end;
  move(v,CodeBuffer[CodeBufferLen],sizeof(TPOCAUInt32));
  inc(CodeBufferLen,sizeof(TPOCAUInt32));
 end;
 procedure DoItByVMOpcodeDispatcher;
 begin
  Code^.InterpretByteCodeMap[LastPC]:=true;
  
  Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
  AddDWord(LastPC);

  Add(#$31#$c0); // xor eax,eax

  Add(#$c3); // ret
 end;
begin
 try
  if assigned(Code^.NativeCode) then begin
   POCANativeCodeMemoryManagerFreeMemory(Code^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance^.Globals.NativeCodeMemoryManager,Code^.NativeCode);
   Code^.NativeCode:=nil;
   Code^.NativeCodeSize:=0;
  end;
  CodeBuffer:=nil;
  CodeBufferLen:=0;
  Fixups:=nil;
  CountFixups:=0;
  Offsets:=nil;
  SetLength(Offsets,Code^.ByteCodeSize);
  if length(Code^.InterpretByteCodeMap)<>Code^.ByteCodeSize then begin
   SetLength(Code^.InterpretByteCodeMap,Code^.ByteCodeSize);
  end;
  CurrentPC:=0;
  while CurrentPC<Code^.ByteCodeSize do begin
   LastPC:=CurrentPC;
   Code^.InterpretByteCodeMap[LastPC]:=false;
   Offsets[CurrentPC]:=CodeBufferLen;
   Instruction:=Code^.ByteCode^[CurrentPC];
   Operands:=@Code^.ByteCode^[CurrentPC+1];
   inc(CurrentPC,1+(Instruction shr 8));
   Opcode:=Instruction and $ff;
// writeln({LastPC,' ',}Opcode);
   case Opcode of
    popNOP:begin
    end;
    popADD:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$83); // fadd qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popSUB:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$a3); // fsub qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popMUL:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$8b); // fmul qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popDIV:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$b3); // fdiv qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popNEG:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$d9#$ee); // fldz

     Add(#$dc#$a3); // fsub qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popNOT:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fcomp qword ptr [POCADoubleZero]
        fstsw ax
        sahf
        setz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popCAT:begin
     DoItByVMOpcodeDispatcher;
    end;
    popLT:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setb al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popLTEQ:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setbe al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popGT:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnbe al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popGTEQ:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnb al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popEQ:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popNEQ:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popCMP:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSEQ:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSNEQ:begin
     DoItByVMOpcodeDispatcher;
    end;
    popEACH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popJMP:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$e9); // jmp Arg
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
      Add(#$00#$00#$00#$00);
     end;
    end;
    popJMPLOOP:begin
     asm
      jmp @Skip
       @CodeBegin:
        lea eax,[esi+TPOCAContext.Instance]
        mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
        test eax,eax
        jz @CodeEnd
         lea eax,[esi+TPOCAContext.Instance]
         db $e8,$00,$00,$00,$00
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     if CountFixups>=length(Fixups) then begin
      SetLength(Fixups,CountFixups+4096);
     end;
     Fixups[CountFixups].Kind:=fkPTR;
     Fixups[CountFixups].Ofs:=CodeBufferLen-4;
     Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
     inc(CountFixups);

     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$e9); // jmp Arg
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
      Add(#$00#$00#$00#$00);
     end;
    end;
    popJIFTRUE:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
      AddDWord((Operands^[1]*sizeof(double))+4);
      AddDWord(POCAValueReferenceTag);

      Add(#$75#$0a); // jnz +$0a

      Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
      AddDWord(LastPC);

      Add(#$31#$c0); // xor eax,eax

      Add(#$c3); // ret

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         db $0f,$85,$00,$00,$00,$00 // jnz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popJIFFALSE:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
      AddDWord((Operands^[1]*sizeof(double))+4);
      AddDWord(POCAValueReferenceTag);

      Add(#$75#$0a); // jnz +$0a

      Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
      AddDWord(LastPC);

      Add(#$31#$c0); // xor eax,eax

      Add(#$c3); // ret

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         db $0f,$84,$00,$00,$00,$00 // jz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popJIFTRUELOOP:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
      AddDWord((Operands^[1]*sizeof(double))+4);
      AddDWord(POCAValueReferenceTag);

      Add(#$75#$0a); // jnz +$0a

      Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
      AddDWord(LastPC);

      Add(#$31#$c0); // xor eax,eax

      Add(#$c3); // ret

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         jz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popJIFFALSELOOP:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
      AddDWord((Operands^[1]*sizeof(double))+4);
      AddDWord(POCAValueReferenceTag);

      Add(#$75#$0a); // jnz +$0a

      Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
      AddDWord(LastPC);

      Add(#$31#$c0); // xor eax,eax

      Add(#$c3); // ret

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         jnz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popFCALL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popMCALL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popRETURN:begin
     DoItByVMOpcodeDispatcher;
    end;
    popLOADCODE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popLOADCONST:begin
     v:=Code^.Constants^[Operands^[1]];
     if POCAIsValueCode(v) then begin
      DoItByVMOpcodeDispatcher;
     end else begin
      Add(#$c7#$83); // mov dword ptr [ebx+Reg+0],[v+0]
      AddDWord(Operands^[0]*sizeof(double));
      AddDWord(TPOCAUInt32(TPOCAPointer(@v)^));

      Add(#$c7#$83); // mov dword ptr [ebx+Reg+4],[v+4]
      AddDWord((Operands^[0]*sizeof(double))+4);
      AddDWord(TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(@v)^[4])^));
     end;
    end;
    popLOADONE:begin
     Add(#$c7#$83); // mov dword ptr [ebx+Reg+0],[POCADoubleOne+0]
     AddDWord(Operands^[0]*sizeof(double));
     AddDWord(TPOCAUInt32(TPOCAPointer(@POCADoubleOne)^));

     Add(#$c7#$83); // mov dword ptr [ebx+Reg+4],[POCADoubleOne+4]
     AddDWord((Operands^[0]*sizeof(double))+4);
     AddDWord(TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(@POCADoubleOne)^[4])^));
    end;
    popLOADZERO:begin
     Add(#$c7#$83); // mov dword ptr [ebx+Reg+0],[POCADoubleZero+0]
     AddDWord(Operands^[0]*sizeof(double));
     AddDWord(TPOCAUInt32(TPOCAPointer(@POCADoubleZero)^));

     Add(#$c7#$83); // mov dword ptr [ebx+Reg+4],[POCADoubleZero+4]
     AddDWord((Operands^[0]*sizeof(double))+4);
     AddDWord(TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(@POCADoubleZero)^[4])^));
    end;
    popLOADINT32:begin
     v.Num:=Operands^[1];

     Add(#$c7#$83); // mov dword ptr [ebx+Reg+0],[v+0]
     AddDWord(Operands^[0]*sizeof(double));
     AddDWord(TPOCAUInt32(TPOCAPointer(@v)^));

     Add(#$c7#$83); // mov dword ptr [ebx+Reg+4],[v+4]
     AddDWord((Operands^[0]*sizeof(double))+4);
     AddDWord(TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(@v)^[4])^));
    end;
    popLOADNULL:begin
     Add(#$c7#$83); // mov dword ptr [ebx+Reg+0],[POCAValueNull+0]
     AddDWord(Operands^[0]*sizeof(double));
     AddDWord(TPOCAUInt32(TPOCAPointer(@POCAValueNull)^));

     Add(#$c7#$83); // mov dword ptr [ebx+Reg+4],[POCAValueNull+4]
     AddDWord((Operands^[0]*sizeof(double))+4);
     AddDWord(TPOCAUInt32(TPOCAPointer(@PPOCAUInt8Array(@POCAValueNull)^[4])^));
    end;
    popLOADTHAT:begin
     DoItByVMOpcodeDispatcher;
    end;
    popLOADTHIS:begin
     Add(#$b8); // mov eax,RegisterOfs
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        mov ecx,dword ptr [edi+TPOCAFrame.Obj]
        mov dword ptr [ebx+eax],ecx
        mov ecx,dword ptr [edi+TPOCAFrame.Obj+4]
        mov dword ptr [ebx+eax+4],ecx
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popLOADSELF:begin
     Add(#$b8); // mov eax,RegisterOfs
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        mov ecx,dword ptr [edi+TPOCAFrame.Func]
        mov dword ptr [ebx+eax],ecx
        mov ecx,dword ptr [edi+TPOCAFrame.Func+4]
        mov dword ptr [ebx+eax+4],ecx
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popLOADLOCAL:begin
     Add(#$b8); // mov eax,RegisterOfs
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        mov ecx,dword ptr [edi+TPOCAFrame.Locals]
        mov dword ptr [ebx+eax],ecx
        mov ecx,dword ptr [edi+TPOCAFrame.Locals+4]
        mov dword ptr [ebx+eax+4],ecx
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popCOPY:begin
     if Operands^[0]<>Operands^[1] then begin
      Add(#$8b#$83); // mov eax,dword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$89#$83); // mov dword ptr [ebx+RegisterOfs],eax
      AddDWord(Operands^[0]*sizeof(double));

      Add(#$8b#$83); // mov eax,dword ptr [ebx+RegisterOfs]
      AddDWord((Operands^[1]*sizeof(double))+4);

      Add(#$89#$83); // mov dword ptr [ebx+RegisterOfs],eax
      AddDWord((Operands^[0]*sizeof(double))+4);
     end;
    end;
    popINSERT:begin
     DoItByVMOpcodeDispatcher;
    end;
    popEXTRACT:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGETLENGTH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGETMEMBER:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETMEMBER:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGETLOCAL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETLOCAL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGETLOCALVALUE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETLOCALVALUE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGETOUTERVALUE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETOUTERVALUE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popNEWARRAY:begin
     DoItByVMOpcodeDispatcher;
    end;
    popARRAYPUSH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popARRAYRANGEPUSH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popNEWHASH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popHASHAPPEND:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETSYM:begin
     DoItByVMOpcodeDispatcher;
    end;
    popINDEX:begin
     DoItByVMOpcodeDispatcher;
    end;
    popFCALLH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popMCALLH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popUNPACK:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSLICE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSLICE2:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSLICE3:begin
     DoItByVMOpcodeDispatcher;
    end;
    popTRY:begin
     DoItByVMOpcodeDispatcher;
    end;
    popTRYBLOCKEND:begin
     DoItByVMOpcodeDispatcher;
    end;
    popTHROW:begin
     DoItByVMOpcodeDispatcher;
    end;
    popDEC:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fsub qword ptr [POCADoubleOne]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popINC:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fadd qword ptr [POCADoubleOne]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popBAND:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        and dword ptr [esp+$04],eax
        and dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popBXOR:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        xor dword ptr [esp+$04],eax
        xor dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popBOR:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        or dword ptr [esp+$04],eax
        or dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popBNOT:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        not dword ptr [esp+$04]
        not dword ptr [esp+$08]
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popBSHL:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov ecx,dword ptr [esp+$04]
        shld eax,edx,cl
        mov dword ptr [esp+$04],eax
        mov dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popBSHR:begin
     DoItByVMOpcodeDispatcher;
    end;
    popBUSHR:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov ecx,dword ptr [esp+$04]
        shrd eax,edx,cl
        mov dword ptr [esp+$04],eax
        mov dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popMOD:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        @Repeat:
         fprem
         fstsw ax
         sahf
         jp @Repeat
         fstp st(1)
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popPOW:begin
     DoItByVMOpcodeDispatcher;
    end;
    popINHERITEDMETHOD:begin
     DoItByVMOpcodeDispatcher;
    end;
    popKEY:begin
     DoItByVMOpcodeDispatcher;
    end;
    popIN:begin
     DoItByVMOpcodeDispatcher;
    end;
    popINRANGE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popFTAILCALL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popMTAILCALL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popFTAILCALLH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popMTAILCALLH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popINSTANCEOF:begin
     DoItByVMOpcodeDispatcher;
    end;
    popBREAKPOINT:begin
     Add(#$cc); // int3
    end;
    popNUM:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     if Operands^[0]<>Operands^[1] then begin
      Add(#$8b#$83); // mov eax,dword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$89#$83); // mov dword ptr [ebx+RegisterOfs],eax
      AddDWord(Operands^[0]*sizeof(double));

      Add(#$8b#$83); // mov eax,dword ptr [ebx+RegisterOfs]
      AddDWord((Operands^[1]*sizeof(double))+4);

      Add(#$89#$83); // mov dword ptr [ebx+RegisterOfs],eax
      AddDWord((Operands^[0]*sizeof(double))+4);
     end;
    end;
    popN_NOT:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fcomp qword ptr [POCADoubleZero]
        fstsw ax
        sahf
        setz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_ADD:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$83); // fadd qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_SUB:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$a3); // fsub qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_MUL:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$8b); // fmul qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_DIV:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$b3); // fdiv qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_NEG:begin
     Add(#$d9#$ee); // fldz

     Add(#$dc#$a3); // fsub qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_LT:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setb al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_LTEQ:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setbe al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_GT:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnbe al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_GTEQ:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnb al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_EQ:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_NEQ:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_CMP:begin
     DoItByVMOpcodeDispatcher;
    end;
    popN_DEC:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fsub qword ptr [POCADoubleOne]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_INC:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fadd qword ptr [POCADoubleOne]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_BAND:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        and dword ptr [esp+$04],eax
        and dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_BXOR:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        xor dword ptr [esp+$04],eax
        xor dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_BOR:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        or dword ptr [esp+$04],eax
        or dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_BNOT:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        not dword ptr [esp+$04]
        not dword ptr [esp+$08]
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_BSHL:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov ecx,dword ptr [esp+$04]
        shld eax,edx,cl
        mov dword ptr [esp+$04],eax
        mov dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_BSHR:begin
     DoItByVMOpcodeDispatcher;
    end;
    popN_BUSHR:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov ecx,dword ptr [esp+$04]
        shrd eax,edx,cl
        mov dword ptr [esp+$04],eax
        mov dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_MOD:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        @Repeat:
         fprem
         fstsw ax
         sahf
         jp @Repeat
         fstp st(1)
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_POW:begin
     DoItByVMOpcodeDispatcher;
    end;
    popN_INRANGE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popN_JIFTRUE:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         db $0f,$85,$00,$00,$00,$00 // jnz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFFALSE:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         db $0f,$84,$00,$00,$00,$00 // jz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFTRUELOOP:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         jz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFFALSELOOP:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         jnz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFLT:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$82,$00,$00,$00,$00 // jb
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFLTEQ:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$86,$00,$00,$00,$00 // jbe
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFGT:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$87,$00,$00,$00,$00 // jnbe
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFGTEQ:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$83,$00,$00,$00,$00 // jnb
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFEQ:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$84,$00,$00,$00,$00 // jz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFNEQ:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$85,$00,$00,$00,$00 // jnz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFLTLOOP:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jnb @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFLTEQLOOP:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jnbe @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFGTLOOP:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jbe @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFGTEQLOOP:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jb @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFEQLOOP:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jnz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFNEQLOOP:begin
     if TPOCAUInt32(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));
      
      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popUPDATESTRING:begin
     DoItByVMOpcodeDispatcher;
    end;
    popREGEXP:begin
     DoItByVMOpcodeDispatcher;
    end;
    popREGEXPEQ:begin
     DoItByVMOpcodeDispatcher;
    end;
    popREGEXPNEQ:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSQRT:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$d9#$fa); // fsqrt

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_SQRT:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$d9#$fa); // fsqrt

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popGETPROTOTYPE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETPROTOTYPE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGETCONSTRUCTOR:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETCONSTRUCTOR:begin
     DoItByVMOpcodeDispatcher;
    end;
    popDELETE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popDELETEEX:begin
     DoItByVMOpcodeDispatcher;
    end;
    popDEFINED:begin
     DoItByVMOpcodeDispatcher;
    end;
    popDEFINEDEX:begin
     DoItByVMOpcodeDispatcher;
    end;
    popLOADGLOBAL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popLOADBASECLASS:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGETHASHKIND:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETHASHKIND:begin
     DoItByVMOpcodeDispatcher;
    end;
    popTYPEOF:begin
     DoItByVMOpcodeDispatcher;
    end;
    popIDOF:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGHOSTTYPEOF:begin
     DoItByVMOpcodeDispatcher;
    end;
    popELVIS:begin
     DoItByVMOpcodeDispatcher;
    end;
    popIS:begin
     DoItByVMOpcodeDispatcher;
    end;
    popJIFNULL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popJIFNOTNULL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSAFEEXTRACT:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSAFEGETMEMBER:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETCONSTLOCAL:begin
     DoItByVMOpcodeDispatcher;
    end;
    else begin
     DoItByVMOpcodeDispatcher;
    end;
   end;
  end;
  RetOfs:=CodeBufferLen;
  begin
   Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
   AddDWord(CurrentPC);

   Add(#$31#$c0); // xor eax,eax

   Add(#$f7#$d0); // not eax

   Add(#$c3); // ret
  end;
  SetLength(CodeBuffer,CodeBufferLen);
  Code.NativeCodeSize:=CodeBufferLen;
  Code.NativeCode:=POCANativeCodeMemoryManagerGetMemory(Code^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance^.Globals.NativeCodeMemoryManager,Code.NativeCodeSize);
  Move(CodeBuffer[0],Code.NativeCode^,Code.NativeCodeSize);
  SetLength(Code.ByteCodeToNativeCodeMap,Code.ByteCodeSize);
  for i:=0 to Code.ByteCodeSize-1 do begin
   Code.ByteCodeToNativeCodeMap[i]:=Offsets[i];
  end;
  for i:=0 to CountFixups-1 do begin
   case FixUps[i].Kind of
    fkPTR:begin
     TPOCAPtrUInt(TPOCAPointer(@PPOCAUInt8Array(Code.NativeCode)^[FixUps[i].Ofs])^):=(TPOCAPtrUInt(FixUps[i].Dest)-(TPOCAPtrUInt(TPOCAPointer(@PPOCAUInt8Array(Code.NativeCode)^[FixUps[i].Ofs]))+4));
    end;
    fkRET:begin
     TPOCAPtrUInt(TPOCAPointer(@PPOCAUInt8Array(Code.NativeCode)^[FixUps[i].Ofs])^):=(TPOCAPtrUInt(TPOCAPointer(@PPOCAUInt8Array(Code.NativeCode)^[RetOfs]))-(TPOCAPtrUInt(TPOCAPointer(@PPOCAUInt8Array(Code.NativeCode)^[FixUps[i].Ofs]))+4));
    end;
    fkOFS:begin
     TPOCAPtrUInt(TPOCAPointer(@PPOCAUInt8Array(Code.NativeCode)^[FixUps[i].Ofs])^):=(TPOCAPtrUInt(TPOCAPointer(@PPOCAUInt8Array(Code.NativeCode)^[Offsets[FixUps[i].ToOfs]]))-(TPOCAPtrUInt(TPOCAPointer(@PPOCAUInt8Array(Code.NativeCode)^[FixUps[i].Ofs]))+4));
    end;
   end;
  end;
  result:=true;
 finally
  SetLength(Fixups,0);
  SetLength(Offsets,0);
  SetLength(CodeBuffer,0);
 end;
end;
{$warnings on}

function POCARunNativeCode(Context:PPOCAContext;Frame:PPOCAFrame;Code:PPOCACode):TPOCABool32; register; assembler;
asm
 push ebx
 push esi
 push edi
 push ebp
 mov esi,eax // ESI = Context
 mov edi,edx // EDI = Frame
 mov eax,dword ptr [ecx+TPOCACode.NativeCode]
 mov ebx,dword ptr [edx+TPOCAFrame.Registers] // EBX = Register
 lea ebp,dword ptr [edx+TPOCAFrame.InstructionPointer] // EBP = Byte code ip
 mov ecx,dword ptr [ecx+TPOCACode.ByteCodeToNativeCodeMap]
 mov edx,dword ptr [ebp]
 add eax,dword ptr [ecx+edx*4]
 call eax
 not eax
 pop ebp
 pop edi
 pop esi
 pop ebx
end;
{$endif}
{$endif}

function POCARunByteCode(Context:PPOCAContext):TPOCAValue;
var Code:PPOCACode;
    Frame:PPOCAFrame;
    Opcode:TPOCAUInt32;
    Operands:PPOCAUInt32Array;
    Registers:PPOCAValues;
    a,b:TPOCAValue;
begin
//result:=POCAValueNull;
 result.CastedUInt64:=POCAValueNullCastedUInt64;
 Frame:=@Context^.FrameStack[Context^.FrameTop-1];
 Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
{$ifdef POCAHasJIT}
 if not assigned(Code^.NativeCode) then begin
  POCAGenerateNativeCode(Context,Code);
 end;
{$endif}
 Registers:=@Frame^.Registers[0];
 while {$ifdef POCAHasJIT}Code^.InterpretByteCodeMap[Frame^.InstructionPointer] or POCARunNativeCode(Context,Frame,Code){$else}true{$endif} do begin
  Opcode:=Code^.ByteCode^[Frame^.InstructionPointer];
  Operands:=@Code^.ByteCode^[Frame^.InstructionPointer+1];
  inc(Frame^.InstructionPointer,1+(Opcode shr 8));
  case TPOCAUInt8(Opcode and $ff) of
   popNOP:begin
   end;
   popADD:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=a.Num+b.Num;
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoADD) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=a.Num+b.Num;
    end;
   end;
   popSUB:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=a.Num-b.Num;
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoSUB) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=a.Num-b.Num;
    end;
   end;
   popMUL:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=a.Num*b.Num;
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoMUL) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=a.Num*b.Num;
    end;
   end;
   popDIV:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=a.Num/b.Num;
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoDIV) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=a.Num/b.Num;
    end;
   end;
   popNEG:begin
    if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoNEG) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     Registers^[Operands^[0]].Num:=-POCAGetNumberValue(Context,Registers^[Operands^[1]]);
    end;
   end;
   popNOT:begin
    if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoLNOT) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     Registers^[Operands^[0]].Num:=ord(not POCAGetBooleanValue(Context,Registers^[Operands^[1]])) and 1;
    end;
   end;
   popCAT:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoCONCAT) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     Registers^[Operands^[0]]:=POCARunEvalCat(Context,a,b);
    end;
    Context^.TemporarySavedObjectCount:=0;
   end;
   popLT:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num<b.Num) and 1;
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=0;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoLT) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<0) and 1;
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<0) and 1;
    end;
   end;
   popLTEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num<=b.Num) and 1;
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=1;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoLTEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<=0) and 1;
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<=0) and 1;
    end;
   end;
   popGT:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num>b.Num) and 1;
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=0;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoGT) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)>0) and 1;
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)>0) and 1;
    end;
   end;
   popGTEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num>=b.Num) and 1;
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=1;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoGTEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)>=0) and 1;
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)>=0) and 1;
    end;
   end;
   popEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num=b.Num) and 1;
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=1;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)=0) and 1;
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)=0) and 1;
    end;
   end;
   popNEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num<>b.Num) and 1;
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=0;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoNEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<>0) and 1;
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<>0) and 1;
    end;
   end;
   popCMP:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     if a.Num<b.Num then begin
      Registers^[Operands^[0]].Num:=-1;
     end else if a.Num>b.Num then begin
      Registers^[Operands^[0]].Num:=1;
     end else begin
      Registers^[Operands^[0]].Num:=0;
     end;
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=0;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoCOMPARE) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=POCACompare(Context,a,b);
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=POCACompare(Context,a,b);
    end;
   end;
   popSEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num=b.Num) and 1;
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=1;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoSEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCAStrictEqual(a,b)) and 1;
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCAStrictEqual(a,b)) and 1;
    end;
   end;
   popSNEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num<>b.Num) and 1;
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=0;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoSNEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(not POCAStrictEqual(a,b)) and 1;
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(not POCAStrictEqual(a,b)) and 1;
    end;
   end;
   popEACH:begin
    if POCARunEvalForEach(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],Registers^[Operands^[3]]) then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[4];
    end;
   end;
   popJMP:begin
    Frame^.InstructionPointer:=Operands^[0];
   end;
   popJMPLOOP:begin
    if Context^.Instance^.Globals.Bottleneck then begin
     POCAGarbageCollectorDoBottleneck(Context^.Instance);
    end;
    Frame^.InstructionPointer:=Operands^[0];
   end;
   popJIFTRUE:begin
    if POCAGetBooleanValue(Context,Registers^[Operands^[1]]) then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popJIFFALSE:begin
    if ((Registers^[Operands^[1]].CastedInt64 and $7fffffffffffffff)=0) or not POCAGetBooleanValue(Context,Registers^[Operands^[1]]) then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popJIFTRUELOOP:begin
    if POCAGetBooleanValue(Context,Registers^[Operands^[1]]) then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popJIFFALSELOOP:begin
    if ((Registers^[Operands^[1]].CastedInt64 and $7fffffffffffffff)=0) or not POCAGetBooleanValue(Context,Registers^[Operands^[1]]) then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popFCALL:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,false,false);
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popMCALL:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,true,false);
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popRETURN:begin
    a:=Registers^[Operands^[0]];
    if assigned(Context^.CallChild) then begin
     POCAContextDestroy(Context^.CallChild);
     Context^.CallChild:=nil;
    end;
    dec(Context^.FrameTop);
    if Context^.FrameTop<=0 then begin
     Context^.Active:=false;
     result:=a;
     exit;
    end;
    begin
     Frame:=@Context^.FrameStack[Context^.FrameTop-1];
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end;
    Registers^[Frame^.ResultRegister]:=a;
    Context^.TemporarySavedObjectCount:=0;
   end;
   popLOADCODE:begin
    Registers^[Operands^[0]]:=POCABindFunction(Context,Frame,Code^.Constants^[Operands^[1]],Code^.ClassFunction);
   end;
   popLOADCONST:begin
    Registers^[Operands^[0]]:=Code^.Constants^[Operands^[1]];
   end;
   popLOADONE:begin
    Registers^[Operands^[0]].Num:=1;
   end;
   popLOADZERO:begin
    Registers^[Operands^[0]].Num:=0;
   end;
   popLOADINT32:begin
    Registers^[Operands^[0]].Num:=TPOCAInt32(TPOCAUInt32(Operands^[1]));
   end;
   popLOADNULL:begin
//  Registers^[Operands^[0]]:=POCAValueNull;
    Registers^[Operands^[0]].CastedUInt64:=POCAValueNullCastedUInt64;
   end;
   popLOADTHAT:begin
    POCARunGetThat(Context,Frame,Registers^[Operands^[0]]);
   end;
   popLOADTHIS:begin
    Registers^[Operands^[0]]:=Frame^.Obj;
   end;
   popLOADSELF:begin
    Registers^[Operands^[0]]:=Frame^.Func;
   end;
   popLOADLOCAL:begin
    Registers^[Operands^[0]]:=Frame^.Locals;
   end;
   popCOPY:begin
    Registers^[Operands^[0]]:=Registers^[Operands^[1]];
   end;
   popARRAYINSERT:begin
    POCARunArraySet(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popARRAYEXTRACT:begin
    Registers^[Operands^[0]]:=POCARunArrayGet(Context,Registers^[Operands^[1]],Registers^[Operands^[2]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popINSERT:begin
    POCARunContainerSet(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],false);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popEXTRACT:begin
    Registers^[Operands^[0]]:=POCARunContainerGet(Context,Registers^[Operands^[1]],Registers^[Operands^[2]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popGETLENGTH:begin
    POCARunGetLength(Context,Registers^[Operands^[1]],Code^.Constants^[Operands^[2]],Registers^[Operands^[0]],Operands^[3],Operands^[4],false);
   end;
   popGETMEMBER:begin
    POCARunGetMember(Context,Registers^[Operands^[1]],Code^.Constants^[Operands^[2]],Registers^[Operands^[0]],Operands^[3],Operands^[4],false);
   end;
   popSETMEMBER:begin
    POCARunSetMember(Context,Registers^[Operands^[0]],Code^.Constants^[Operands^[1]],Registers^[Operands^[2]],false,Operands^[3]);
   end;
   popGETLOCAL:begin
    POCARunGetLocal(Context,Frame,Code^.Constants^[Operands^[1]],Registers^[Operands^[0]],Operands^[2]);
   end;
   popSETLOCAL:begin
    POCAHashSetCache(Context,Frame^.Locals,Code^.Constants^[Operands^[0]],Registers^[Operands^[1]],false,Operands^[2]);
   end;
   popGETLOCALVALUE:begin
{$ifdef POCAClosureArrayValues}
    Registers^[Operands^[0]]:=POCAArrayFastGet(Frame^.LocalValues,Operands^[1]);
{$else}
    Registers^[Operands^[0]]:=Frame^.LocalValues[Operands^[1]];
{$endif}
   end;
   popSETLOCALVALUE:begin
{$ifdef POCAClosureArrayValues}
    POCAArrayFastSet(Frame^.LocalValues,Operands^[0],Registers^[Operands^[1]]);
{$else}
    Frame^.LocalValues[Operands^[0]]:=Registers^[Operands^[1]];
{$endif}
   end;
   popGETOUTERVALUE:begin
{$ifdef POCAClosureArrayValues}
    Registers^[Operands^[0]]:=POCAArrayFastGet(POCAArrayFastGet(Frame^.OuterValueLevels,Operands^[1]),Operands^[2]);
{$else}
    Registers^[Operands^[0]]:=Frame^.OuterValueLevels[Operands^[1]][Operands^[2]];
{$endif}
   end;
   popSETOUTERVALUE:begin
{$ifdef POCAClosureArrayValues}
    POCAArrayFastSet(POCAArrayFastGet(Frame^.OuterValueLevels,Operands^[0]),Operands^[1],Registers^[Operands^[2]]);
{$else}
    Frame^.OuterValueLevels[Operands^[0]][Operands^[1]]:=Registers^[Operands^[2]];
{$endif}
   end;
   popNEWARRAY:begin
    Registers^[Operands^[0]]:=POCANewArray(Context);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popARRAYPUSH:begin
    POCAArrayPush(Registers^[Operands^[0]],Registers^[Operands^[1]]);
   end;
   popARRAYRANGEPUSH:begin
    POCAArrayRangePush(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]]);
   end;
   popNEWHASH:begin
    Registers^[Operands^[0]]:=POCANewHash(Context);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popHASHAPPEND:begin
    POCAHashSet(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],false);
   end;
   popSETSYM:begin
    POCARunSetSymbol(Context,Frame,Code^.Constants^[Operands^[0]],Registers^[Operands^[1]],false,Operands^[2]);
   end;
   popINDEX:begin
    if POCARunEvalForIndex(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]]) then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[3];
    end;
   end;
   popFCALLH:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,false,true);
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popMCALLH:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,true,true);
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popUNPACK:begin
    POCARunEvalUnpack(Context,Frame,Opcode,Operands);
   end;
   popSLICE:begin
    POCARunEvalSlice(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popSLICE2:begin
    POCARunEvalSlice2(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],Registers^[Operands^[3]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popSLICE3:begin
    POCARunEvalSlice3(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],Registers^[Operands^[3]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popTRY:begin
    Frame^.InstructionPointer:=POCARunTry(Context,Frame,Operands^[0],Operands^[1],Operands^[2],Operands^[3],Operands^[4],Operands^[5]);
   end;
   popTRYBLOCKEND:begin
    result:=Registers^[Operands^[0]];
    exit;
   end;
   popTHROW:begin
    result:=Registers^[Operands^[0]];
    POCARunThrow(Context,result);
    exit;
   end;
   popDEC:begin
    a:=Registers^[Operands^[1]];
    if POCAIsValueNumber(a) then begin
     Registers^[Operands^[0]].Num:=a.Num-1.0;
    end else if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoDEC) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     a.Num:=POCAGetNumberValue(Context,a);
     Registers^[Operands^[0]].Num:=a.Num-1.0;
    end;
   end;
   popINC:begin
    a:=Registers^[Operands^[1]];
    if POCAIsValueNumber(a) then begin
     Registers^[Operands^[0]].Num:=a.Num+1.0;
    end else if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoDEC) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     a.Num:=POCAGetNumberValue(Context,a);
     Registers^[Operands^[0]].Num:=a.Num+1.0;
    end;
   end;
   popBAND:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(a.Num)) and TPOCAInt64(System.trunc(b.Num));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBAND) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(a.Num)) and TPOCAInt64(System.trunc(b.Num));
    end;
   end;
   popBXOR:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(a.Num)) xor TPOCAInt64(System.trunc(b.Num));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBXOR) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(a.Num)) xor TPOCAInt64(System.trunc(b.Num));
    end;
   end;
   popBOR:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(a.Num)) or TPOCAInt64(System.trunc(b.Num));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBOR) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(a.Num)) or TPOCAInt64(System.trunc(b.Num));
    end;
   end;
   popBNOT:begin
    if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoBNOT) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     Registers^[Operands^[0]].Num:=TPOCAInt64(not TPOCAInt64(System.trunc(POCAGetNumberValue(Context,Registers^[Operands^[1]]))));
    end;
   end;
   popBSHL:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(a.Num)) shl TPOCAInt32(trunc(b.Num));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBSHL) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(a.Num)) shl TPOCAInt32(System.trunc(b.Num));
    end;
   end;
   popBSHR:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=sar64(TPOCAInt64(System.trunc(a.Num)),TPOCAInt32(System.trunc(b.Num)));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBSHR) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=sar64(TPOCAInt64(System.trunc(a.Num)),TPOCAInt32(System.trunc(b.Num)));
    end;
   end;
   popBUSHR:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(a.Num)) shr TPOCAInt32(System.trunc(b.Num));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBUSHR) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(a.Num)) shr TPOCAInt32(System.trunc(b.Num));
    end;
   end;
   popMOD:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=Modulo(a.Num,b.Num);
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoMOD) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=Modulo(a.Num,b.Num);
    end;
   end;
   popPOW:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=Math.Power(a.Num,b.Num);
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoPOW) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=Math.Power(a.Num,b.Num);
    end;
   end;
   popINHERITEDGETMEMBER:begin
    POCARunGetMember(Context,Registers^[Operands^[1]],Code^.Constants^[Operands^[2]],Registers^[Operands^[0]],Operands^[3],Operands^[4],true);
   end;
   popKEY:begin
    if POCARunEvalForKey(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],Registers^[Operands^[3]]) then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[4];
    end;
   end;
   popIN:begin
    if POCARunHashEventRightBinaryOp(Context,Frame,Operands,pmoIN) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     POCARunIn(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]]);
    end;
   end;
   popINRANGE:begin
    if POCARunHashEventInRangeOp(Context,Frame,Operands,pmoINRANGE) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     POCARunInRange(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],Registers^[Operands^[3]]);
    end;
   end;
   popFTAILCALL:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,false,false);
    dec(Context^.FrameTop);
    Frame:=@Context^.FrameStack[Context^.FrameTop-1];
    Frame^:=Context^.FrameStack[Context^.FrameTop];
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popMTAILCALL:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,true,false);
    dec(Context^.FrameTop);
    Frame:=@Context^.FrameStack[Context^.FrameTop-1];
    Frame^:=Context^.FrameStack[Context^.FrameTop];
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popFTAILCALLH:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,false,true);
    dec(Context^.FrameTop);
    Frame:=@Context^.FrameStack[Context^.FrameTop-1];
    Frame^:=Context^.FrameStack[Context^.FrameTop];
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popMTAILCALLH:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,true,true);
    dec(Context^.FrameTop);
    Frame:=@Context^.FrameStack[Context^.FrameTop-1];
    Frame^:=Context^.FrameStack[Context^.FrameTop];
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popINSTANCEOF:begin
    Registers^[Operands^[0]].Num:=ord(POCAObjectInstanceOf(Context,Registers^[Operands^[1]],Registers^[Operands^[2]])) and 1;
   end;
   popBREAKPOINT:begin
{$ifdef cpu386}
    asm
     db $cc
    end;
{$else}
    if (Opcode and $ff)=popBREAKPOINT then begin
    end;
{$endif}
   end;
   popNUM:begin
    Registers^[Operands^[0]].Num:=POCAGetNumberValue(Context,Registers^[Operands^[1]]);
   end;
   popN_NOT:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num=0) and 1;
   end;
   popN_ADD:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num+Registers^[Operands^[2]].Num;
   end;
   popN_SUB:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num-Registers^[Operands^[2]].Num;
   end;
   popN_MUL:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num*Registers^[Operands^[2]].Num;
   end;
   popN_DIV:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num/Registers^[Operands^[2]].Num;
   end;
   popN_NEG:begin
    Registers^[Operands^[0]].Num:=-Registers^[Operands^[1]].Num;
   end;
   popN_LT:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num<Registers^[Operands^[2]].Num) and 1;
   end;
   popN_LTEQ:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num<=Registers^[Operands^[2]].Num) and 1;
   end;
   popN_GT:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num>Registers^[Operands^[2]].Num) and 1;
   end;
   popN_GTEQ:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num>=Registers^[Operands^[2]].Num) and 1;
   end;
   popN_EQ:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num=Registers^[Operands^[2]].Num) and 1;
   end;
   popN_NEQ:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num<>Registers^[Operands^[2]].Num) and 1;
   end;
   popN_CMP:begin
    if Registers^[Operands^[1]].Num<Registers^[Operands^[2]].Num then begin
     Registers^[Operands^[0]].Num:=-1;
    end else if Registers^[Operands^[1]].Num>Registers^[Operands^[2]].Num then begin
     Registers^[Operands^[0]].Num:=1;
    end else begin
     Registers^[Operands^[0]].Num:=0;
    end;
   end;
   popN_DEC:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num-1.0;
   end;
   popN_INC:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num+1.0;
   end;
   popN_BAND:begin
    Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(Registers^[Operands^[1]].Num)) and TPOCAInt64(System.trunc(Registers^[Operands^[2]].Num));
   end;
   popN_BXOR:begin
    Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(Registers^[Operands^[1]].Num)) xor TPOCAInt64(System.trunc(Registers^[Operands^[2]].Num));
   end;
   popN_BOR:begin
    Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(Registers^[Operands^[1]].Num)) or TPOCAInt64(System.trunc(Registers^[Operands^[2]].Num));
   end;
   popN_BNOT:begin
    Registers^[Operands^[0]].Num:=TPOCAInt64(not TPOCAInt64(System.trunc(Registers^[Operands^[1]].Num)));
   end;
   popN_BSHL:begin
    Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(Registers^[Operands^[1]].Num)) shl TPOCAInt64(System.trunc(Registers^[Operands^[2]].Num));
   end;
   popN_BSHR:begin
    Registers^[Operands^[0]].Num:=sar64(TPOCAInt64(System.trunc(Registers^[Operands^[1]].Num)),TPOCAInt32(trunc(Registers^[Operands^[2]].Num)));
   end;
   popN_BUSHR:begin
    Registers^[Operands^[0]].Num:=TPOCAInt64(System.trunc(Registers^[Operands^[1]].Num)) shr TPOCAInt64(System.trunc(Registers^[Operands^[2]].Num));
   end;
   popN_MOD:begin
    Registers^[Operands^[0]].Num:=Modulo(Registers^[Operands^[1]].Num,Registers^[Operands^[2]].Num);
   end;
   popN_POW:begin
    Registers^[Operands^[0]].Num:=Math.Power(Registers^[Operands^[1]].Num,Registers^[Operands^[2]].Num);
   end;
   popN_INRANGE:begin
    Registers^[Operands^[0]].Num:=ord((Registers^[Operands^[2]].Num<=Registers^[Operands^[1]].Num) and (Registers^[Operands^[1]].Num<=Registers^[Operands^[3]].Num)) and 1;
   end;
   popN_JIFTRUE:begin
    if Registers^[Operands^[1]].Num<>0 then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFFALSE:begin
    if Registers^[Operands^[1]].Num=0 then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFTRUELOOP:begin
    if Registers^[Operands^[1]].Num<>0 then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFFALSELOOP:begin
    if Registers^[Operands^[1]].Num=0 then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFLT:begin
    if Registers^[Operands^[1]].Num<Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFLTEQ:begin
    if Registers^[Operands^[1]].Num<=Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFGT:begin
    if Registers^[Operands^[1]].Num>Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFGTEQ:begin
    if Registers^[Operands^[1]].Num>=Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFEQ:begin
    if Registers^[Operands^[1]].Num=Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFNEQ:begin
    if Registers^[Operands^[1]].Num<>Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFLTLOOP:begin
    if Registers^[Operands^[1]].Num<Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFLTEQLOOP:begin
    if Registers^[Operands^[1]].Num<=Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFGTLOOP:begin
    if Registers^[Operands^[1]].Num>Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFGTEQLOOP:begin
    if Registers^[Operands^[1]].Num>=Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFEQLOOP:begin
    if Registers^[Operands^[1]].Num=Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFNEQLOOP:begin
    if Registers^[Operands^[1]].Num<>Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popUPDATESTRING:begin
    if POCAIsValueString(Registers^[Operands^[0]]) then begin
     POCAStringUpdate(Context,Registers^[Operands^[0]]);
    end;
   end;
   popREGEXP:begin
    a:=Code^.RegExps^[Operands^[1]];
    if POCAGhostGetType(Code^.RegExps^[Operands^[1]])<>@POCARegExpGhost then begin
     a:=POCARegExpFunctionCOMPILE(Context,POCAValueNull,@Registers^[Operands^[2]],1,nil);
     POCAAtomicSetValue(Code^.RegExps^[Operands^[1]],a);
    end;
    Registers^[Operands^[0]]:=a;
   end;
   popREGEXPEQ:begin
    if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoREGEXPEQ) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else if POCAGhostGetType(Code^.RegExps^[Operands^[2]])=@POCARegExpGhost then begin
     Registers^[Operands^[0]]:=POCARegExpFunctionTEST(Context,POCAValueNull,@Registers^[Operands^[1]],2,nil);
    end else begin
     Registers^[Operands^[0]].Num:=0;
    end;
   end;
   popREGEXPNEQ:begin
    if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoREGEXPNEQ) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else if POCAGhostGetType(Code^.RegExps^[Operands^[2]])=@POCARegExpGhost then begin
     Registers^[Operands^[0]].Num:=ord(POCARegExpFunctionTEST(Context,POCAValueNull,@Registers^[Operands^[1]],2,nil).Num=0) and 1;
    end else begin
     Registers^[Operands^[0]].Num:=0;
    end;
   end;
   popSQRT:begin
    if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoSQRT) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     Registers^[Operands^[0]].Num:=sqrt(POCAGetNumberValue(Context,Registers^[Operands^[1]]));
    end;
   end;
   popN_SQRT:begin
    Registers^[Operands^[0]].Num:=sqrt(Registers^[Operands^[1]].Num);
   end;
   popGETPROTOTYPE:begin
    Registers^[Operands^[0]]:=POCAValueGetPrototypeValue(Context,Registers^[Operands^[1]],0);
   end;
   popSETPROTOTYPE:begin
    POCAValueSetPrototypeValue(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],0);
   end;
   popGETCONSTRUCTOR:begin
    Registers^[Operands^[0]]:=POCAValueGetConstructorValue(Context,Registers^[Operands^[1]],0);
   end;
   popSETCONSTRUCTOR:begin
    POCAValueSetConstructorValue(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],0);
   end;
   popDELETE:begin
    Registers^[Operands^[0]].Num:=ord(POCAHashDelete(Context,Registers^[Operands^[1]],Code^.Constants^[Operands^[2]])) and 1;
   end;
   popDELETEEX:begin
    case POCAGetValueType(Registers^[Operands^[1]]) of
     pvtNULL:begin
      Registers^[Operands^[0]].Num:=0;
     end;
     pvtHASH:begin
      Registers^[Operands^[0]].Num:=ord(POCAHashDelete(Context,Registers^[Operands^[1]],Registers^[Operands^[2]])) and 1;
     end;
     pvtARRAY:begin
      a.CastedInt64:=System.trunc(POCAGetNumberValue(Context,Registers^[Operands^[2]]));
      if (a.CastedInt64>=0) and (a.CastedInt64<POCAArraySize(Registers^[Operands^[1]])) then begin
       POCAArraySet(Registers^[Operands^[1]],a.CastedInt64,POCAValueNull);
       Registers^[Operands^[0]].Num:=1;
      end else begin
       Registers^[Operands^[0]].Num:=0;
      end;
     end;
     else begin
      Registers^[Operands^[0]].Num:=0;
     end;
    end;
   end;
   popDEFINED:begin
    Registers^[Operands^[0]].Num:=ord(POCAHashExist(Context,Registers^[Operands^[1]],Code^.Constants^[Operands^[2]])) and 1;
   end;
   popDEFINEDEX:begin
    case POCAGetValueType(Registers^[Operands^[1]]) of
     pvtNULL:begin
      Registers^[Operands^[0]].Num:=0;
     end;
     pvtHASH:begin
      Registers^[Operands^[0]].Num:=ord(POCAHashExist(Context,Registers^[Operands^[1]],Registers^[Operands^[2]])) and 1;
     end;
     pvtARRAY:begin
      a.CastedInt64:=System.trunc(POCAGetNumberValue(Context,Registers^[Operands^[2]]));
      if (a.CastedInt64>=0) and (a.CastedInt64<POCAArraySize(Registers^[Operands^[1]])) then begin
       b:=POCAArrayGet(Registers^[Operands^[1]],a.CastedInt64);
       Registers^[Operands^[0]].Num:=ord(not POCAIsValueNull(b)) and 1;
      end else begin
       Registers^[Operands^[0]].Num:=0;
      end;
     end;
     else begin
      Registers^[Operands^[0]].Num:=0;
     end;
    end;
   end;
   popLOADGLOBAL:begin
    Registers^[Operands^[0]]:=Context^.Instance.Globals.Namespace;
   end;
   popLOADBASECLASS:begin
    Registers^[Operands^[0]]:=Context^.Instance.Globals.BaseClass;
   end;
   popGETHASHKIND:begin
    Registers^[Operands^[0]].Num:=POCAHashGetKind(Registers^[Operands^[1]]);
   end;
   popSETHASHKIND:begin
    POCAHashSetKind(Context,Registers^[Operands^[0]],trunc(POCAGetNumberValue(Context,Registers^[Operands^[1]])));
   end;
   popTYPEOF:begin
    Registers^[Operands^[0]]:=POCATypeOf(Context,Registers^[Operands^[1]]);
   end;
   popIDOF:begin
    Registers^[Operands^[0]]:=POCAIDOf(Context,Registers^[Operands^[1]]);
   end;
   popGHOSTTYPEOF:begin
    Registers^[Operands^[0]]:=POCAGhostTypeOf(Context,Registers^[Operands^[1]]);
   end;
   popELVIS:begin
    if POCAGetBooleanValue(Context,Registers^[Operands^[1]]) then begin
     Registers^[Operands^[0]]:=Registers^[Operands^[1]];
    end else begin
     Registers^[Operands^[0]]:=Registers^[Operands^[2]];
    end;
   end;
   popIS:begin
    Registers^[Operands^[0]].Num:=ord(POCAObjectIs(Context,Registers^[Operands^[1]],Registers^[Operands^[2]])) and 1;
   end;
   popJIFNULL:begin
    if Registers^[Operands^[1]].CastedUInt64=POCAValueNullCastedUInt64 then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popJIFNOTNULL:begin
    if Registers^[Operands^[1]].CastedUInt64<>POCAValueNullCastedUInt64 then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popSAFEEXTRACT:begin
    Registers^[Operands^[0]]:=POCARunContainerSafeGet(Context,Registers^[Operands^[1]],Registers^[Operands^[2]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popSAFEGETMEMBER:begin
    POCARunSafeGetMember(Context,Registers^[Operands^[1]],Code^.Constants^[Operands^[2]],Registers^[Operands^[0]],Operands^[3],Operands^[4],false);
   end;
   popSETCONSTLOCAL:begin
    POCAHashSetCache(Context,Frame^.Locals,Code^.Constants^[Operands^[0]],Registers^[Operands^[1]],true,Operands^[2]);
   end;
   popCOUNT..255:begin
    POCARuntimeError(Context,'Invalid unknown opcode instruction');
   end;
  end;
 end;
end;

function POCARun(Context:PPOCAContext):TPOCAValue;
var OldFPUExceptionMask:TFPUExceptionMask;
    OldFPURoundingMode:TFPURoundingMode;
    OldFPUPrecisionMode:TFPUPrecisionMode;
begin
 OldFPUExceptionMask:=GetExceptionMask;
 OldFPURoundingMode:=GetRoundMode;
 OldFPUPrecisionMode:=GetPrecisionMode;
 try
  if OldFPUExceptionMask<>FPUExceptionMask then begin
   SetExceptionMask(FPUExceptionMask);
  end;
  if OldFPURoundingMode<>FPURoundingMode then begin
   SetRoundMode(FPURoundingMode);
  end;
  if OldFPUPrecisionMode<>FPUPrecisionMode then begin
   SetPrecisionMode(FPUPrecisionMode);
  end;
  result:=POCARunByteCode(Context);
 finally
  if OldFPUExceptionMask<>FPUExceptionMask then begin
   SetExceptionMask(OldFPUExceptionMask);
  end;
  if OldFPURoundingMode<>FPURoundingMode then begin
   SetRoundMode(OldFPURoundingMode);
  end;
  if OldFPUPrecisionMode<>FPUPrecisionMode then begin
   SetPrecisionMode(OldFPUPrecisionMode);
  end;
 end;
end;

function POCACall(Context:PPOCAContext;Func:TPOCAValue;Arguments:PPOCAValues;CountArguments:TPOCAInt32;Obj:TPOCAValue;Locals:TPOCAValue):TPOCAValue;
var i:TPOCAInt32;
    Frame:PPOCAFrame;
    CodePointer:PPOCACode;
    HashEvents:PPOCAHashEvents;
    NativeCode:PPOCANativeCode;
begin
 if not assigned(Context^.CallParent) then begin
  POCAGarbageCollectorLock(Context);
 end;
 try
  POCATemporarySave(Context,Func);
  for i:=0 to CountArguments-1 do begin
   POCATemporarySave(Context,Arguments^[i]);
  end;
  POCATemporarySave(Context,Obj);
  POCATemporarySave(Context,Locals);
  if POCAIsValueEventHash(Func) or POCAIsValueGhostEventHash(Func) then begin
   HashEvents:=POCAHashGetHashEvents(Func);
   if assigned(HashEvents) then begin
    if POCAIsValueNull(Obj) then begin
     Obj:=Func;
    end;
    Func:=HashEvents^[pmoCALL];
   end;
  end;
  if not (POCAIsValueFunction(Func) or POCAIsValueCode(Func) or POCAIsValueNativeCode(Func)) then begin
   if POCAIsValueNull(Obj) then begin
    POCARuntimeError(Context,'Function call on uncallable object');
   end else begin
    POCARuntimeError(Context,'Method call on uncallable object');
   end;
  end;
  if POCAIsValueFunction(Func) and POCAIsValueNativeCode(PPOCAFunction(POCAGetValueReferencePointer(Func))^.Code) then begin
   NativeCode:=PPOCANativeCode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Func))^.Code));
   result:=NativeCode^.FunctionPointer(Context,Obj,Arguments,CountArguments,NativeCode^.UserData);
  end else if POCAIsValueNativeCode(Func) then begin
   NativeCode:=PPOCANativeCode(POCAGetValueReferencePointer(Func));
   result:=NativeCode^.FunctionPointer(Context,Obj,Arguments,CountArguments,NativeCode^.UserData);
  end else begin
   begin
    if POCAIsValueNull(Locals) and not PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Func))^.Code))^.FastFunction then begin
     Locals:=POCANewHash(Context);
    end;
    if not POCAIsValueFunction(Func) then begin
     Func:=POCANewFunction(Context,Func);
     PPOCAFunction(POCAGetValueReferencePointer(Func))^.Namespace:=Locals;
     PPOCAFunction(POCAGetValueReferencePointer(Func))^.Obj:=Obj;
    end else begin
     if POCAIsValueNull(Obj) then begin
      Obj:=PPOCAFunction(POCAGetValueReferencePointer(Func))^.Obj;
     end;
    end;
   end;
   CodePointer:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Func))^.Code));
   begin
    Context^.FrameTop:=1;
    Frame:=@Context^.FrameStack[0];
    Frame^.Func:=Func;
    Frame^.Locals:=Locals;
    Frame^.Obj:=Obj;
    Frame^.InstructionPointer:=0;
    POCASetupRegisters(Frame,CodePointer);
    POCASetupFrameValues(Context,Frame,CodePointer);
   end;
   POCASetupArguments(Context,@Context^.FrameStack[0],CodePointer,Arguments,CountArguments);
   result:=POCARun(Context);
  end;
 finally
  if not assigned(Context^.CallParent) then begin
   POCAGarbageCollectorUnlock(Context);
  end;
 end;
end;

{$hints off}
function POCAGetFileContent(FileName:TPOCAUTF8String):TPOCARawByteString;
var OldFileMode:TPOCAUInt8;
    f:file;
begin
 result:='';
 OldFileMode:=FileMode;
 try
  FileMode:=0;
  AssignFile(f,PUCUUTF8ToUTF16(FileName));
  {$i-}Reset(f,1);{$i+};
  if IOResult=0 then begin
   SetLength(result,FileSize(f));
   if length(result)>0 then begin
    {$i-}BlockRead(f,result[1],length(result));{$i+}
    if IOResult<>0 then begin
     {$i-}CloseFile(f);{$i+}
     FileMode:=OldFileMode;
     exit;
    end;
   end;
   {$i-}CloseFile(f);{$i+}
  end;
 finally
  FileMode:=OldFileMode;
 end;
end;

function POCAIsPathSeparator(const aChar:AnsiChar):Boolean;
begin
 case aChar of
  '/','\':begin
   result:=true;
  end;
  else begin
   result:=false;
  end;
 end;
end;

function POCACorrectPathSeparators(const aPath:TPOCARawByteString):TPOCARawByteString;
const DestinationPathSeparator={$ifdef Windows}'\'{$else}'/'{$endif};
var Index:TPOCAInt32;
begin
 result:=aPath;
 for Index:=1 to length(result) do begin
  if POCAIsPathSeparator(result[Index]) then begin
   result[Index]:=DestinationPathSeparator;
  end;
 end;
end;

function POCAExpandRelativePath(const aRelativePath:TPOCARawByteString;const aBasePath:TPOCARawByteString):TPOCARawByteString;
var InputIndex,OutputIndex:TPOCAInt32;
    InputPath:TPOCARawByteString;
    PathSeparator:AnsiChar;
begin
 if (length(aRelativePath)>0) and
    (POCAIsPathSeparator(aRelativePath[1]) or
     ((length(aRelativePath)>1) and
      (aRelativePath[1] in ['a'..'z','A'..'Z']) and
      (aRelativePath[2]=':'))) then begin
  InputPath:=aRelativePath;
 end else begin
  if (length(aBasePath)>1) and not POCAIsPathSeparator(aBasePath[length(aBasePath)]) then begin
   PathSeparator:=#0;
   for InputIndex:=1 to length(aBasePath) do begin
    if POCAIsPathSeparator(aBasePath[InputIndex]) then begin
     PathSeparator:=aBasePath[InputIndex];
     break;
    end;
   end;
   if PathSeparator=#0 then begin
    for InputIndex:=1 to length(aRelativePath) do begin
     if POCAIsPathSeparator(aRelativePath[InputIndex]) then begin
      PathSeparator:=aRelativePath[InputIndex];
      break;
     end;
    end;
    if PathSeparator=#0 then begin
     PathSeparator:='/';
    end;
   end;
   InputPath:=aBasePath+PathSeparator;
  end else begin
   InputPath:=aBasePath;
  end;
  InputPath:=InputPath+aRelativePath;
 end;
 result:=InputPath;
 InputIndex:=1;
 OutputIndex:=1;
 while InputIndex<=length(InputPath) do begin
  if (((InputIndex+1)<=length(InputPath)) and (InputPath[InputIndex]='.') and POCAIsPathSeparator(InputPath[InputIndex+1])) or
     ((InputIndex=length(InputPath)) and (InputPath[InputIndex]='.')) then begin
   inc(InputIndex,2);
   if OutputIndex=1 then begin
    inc(OutputIndex,2);
   end;
  end else if (((InputIndex+1)<=length(InputPath)) and (InputPath[InputIndex]='.') and (InputPath[InputIndex+1]='.')) and
              ((((InputIndex+2)<=length(InputPath)) and POCAIsPathSeparator(InputPath[InputIndex+2])) or
               ((InputIndex+1)=length(InputPath))) then begin
   inc(InputIndex,3);
   if OutputIndex=1 then begin
    inc(OutputIndex,3);
   end else if OutputIndex>1 then begin
    dec(OutputIndex,2);
    while (OutputIndex>0) and not POCAIsPathSeparator(result[OutputIndex]) do begin
     dec(OutputIndex);
    end;
    inc(OutputIndex);
   end;
  end else if POCAIsPathSeparator(InputPath[InputIndex]) then begin
   if (InputIndex=1) and
      ((InputIndex+1)<=length(InputPath)) and
      POCAIsPathSeparator(InputPath[InputIndex+1]) and
      ((length(InputPath)=2) or
       (((InputIndex+2)<=Length(InputPath)) and not POCAIsPathSeparator(InputPath[InputIndex+2]))) then begin
    result[OutputIndex]:=InputPath[InputIndex];
    result[OutputIndex+1]:=InputPath[InputIndex+1];
    inc(InputIndex,2);
    inc(OutputIndex,2);
   end else begin
    if (OutputIndex=1) or ((OutputIndex>1) and not POCAIsPathSeparator(result[OutputIndex-1])) then begin
     result[OutputIndex]:=InputPath[InputIndex];
     inc(OutputIndex);
    end;
    inc(InputIndex);
   end;
  end else begin
   while (InputIndex<=length(InputPath)) and not POCAIsPathSeparator(InputPath[InputIndex]) do begin
    result[OutputIndex]:=InputPath[InputIndex];
    inc(InputIndex);
    inc(OutputIndex);
   end;
   if InputIndex<=length(InputPath) then begin
    result[OutputIndex]:=InputPath[InputIndex];
    inc(InputIndex);
    inc(OutputIndex);
   end;
  end;
 end;
 SetLength(result,OutputIndex-1);
end;

function POCAConvertPathToRelative(aAbsolutePath,aBasePath:TPOCARawByteString):TPOCARawByteString;
var AbsolutePathIndex,BasePathIndex:TPOCAInt32;
    PathSeparator:AnsiChar;
begin
 if length(aBasePath)=0 then begin
  result:=aAbsolutePath;
 end else begin
  aAbsolutePath:=POCAExpandRelativePath(aAbsolutePath);
  aBasePath:=POCAExpandRelativePath(aBasePath);
  PathSeparator:=#0;
  for BasePathIndex:=1 to length(aBasePath) do begin
   if POCAIsPathSeparator(aBasePath[BasePathIndex]) then begin
    PathSeparator:=aBasePath[BasePathIndex];
    break;
   end;
  end;
  if PathSeparator=#0 then begin
   for AbsolutePathIndex:=1 to length(aAbsolutePath) do begin
    if POCAIsPathSeparator(aAbsolutePath[AbsolutePathIndex]) then begin
     PathSeparator:=aAbsolutePath[AbsolutePathIndex];
     break;
    end;
   end;
   if PathSeparator=#0 then begin
    PathSeparator:='/';
   end;
  end;
  if length(aBasePath)>1 then begin
   if POCAIsPathSeparator(aBasePath[length(aBasePath)]) then begin
    if (length(aAbsolutePath)>1) and POCAIsPathSeparator(aAbsolutePath[length(aAbsolutePath)]) then begin
     if (aAbsolutePath=aBasePath) and (aAbsolutePath[1]<>'.') and (aBasePath[1]<>'.') then begin
      result:='.'+PathSeparator;
      exit;
     end;
    end;
   end else begin
    aBasePath:=aBasePath+PathSeparator;
   end;
  end;
  AbsolutePathIndex:=1;
  BasePathIndex:=1;
  while (BasePathIndex<=Length(aBasePath)) and
        (AbsolutePathIndex<=Length(aAbsolutePath)) and
        ((aBasePath[BasePathIndex]=aAbsolutePath[AbsolutePathIndex]) or
         (POCAIsPathSeparator(aBasePath[BasePathIndex]) and POCAIsPathSeparator(aAbsolutePath[AbsolutePathIndex]))) do begin
   inc(AbsolutePathIndex);
   inc(BasePathIndex);
  end;
  if ((BasePathIndex<=length(aBasePath)) and not POCAIsPathSeparator(aBasePath[BasePathIndex])) or
     ((AbsolutePathIndex<=length(aAbsolutePath)) and not POCAIsPathSeparator(aAbsolutePath[AbsolutePathIndex])) then begin
   while (BasePathIndex>1) and not POCAIsPathSeparator(aBasePath[BasePathIndex-1]) do begin
    dec(AbsolutePathIndex);
    dec(BasePathIndex);
   end;
  end;
  if BasePathIndex<=Length(aBasePath) then begin
   result:='';
   while BasePathIndex<=Length(aBasePath) do begin
    if POCAIsPathSeparator(aBasePath[BasePathIndex]) then begin
     result:=result+'..'+PathSeparator;
    end;
    inc(BasePathIndex);
   end;
  end else begin
   result:='.'+PathSeparator;
  end;
  if AbsolutePathIndex<=length(aAbsolutePath) then begin
   result:=result+copy(aAbsolutePath,AbsolutePathIndex,(length(aAbsolutePath)-AbsolutePathIndex)+1);
  end;
 end;
end;

function POCAExtractFilePath(aPath:TPOCARawByteString):TPOCARawByteString;
var Index:TPOCAInt32;
begin
 result:=aPath;
 for Index:=length(result) downto 1 do begin
  if POCAIsPathSeparator(result[Index]) then begin
   SetLength(result,Index);
   exit;
  end;
 end;
end;

procedure InitializePOCA;
const POCASignature:TPOCAUTF8String=' POCA - Version '+POCAVersion+' - Copyright (C) 2011-2023, Benjamin ''BeRo'' Rosseaux - benjamin@rosseaux.com - http://www.rosseaux.com ';
      FPUExceptionMask:TFPUExceptionMask=[exInvalidOp,exDenormalized,exZeroDivide,exOverflow,exUnderflow,exPrecision];
      FPURoundingMode:TFPURoundingMode=rmNearest;
      FPUPrecisionMode:TFPUPrecisionMode={$ifdef HAS_TYPE_EXTENDED}pmEXTENDED{$else}pmDOUBLE{$endif};
 procedure InitializeTokens;
 var i:TPOCAInt32;
     t:TPOCATokenType;
     p:PPOCATokenPrecedence;
     pbp:PPOCATokenBinaryPrefix;
 begin
  POCABinaryTokens:=[];
  POCAReverseTokens:=[];
  POCAPrefixTokens:=[];
  POCASuffixTokens:=[];
  for i:=low(POCATokenPrecedences) to high(POCATokenPrecedences) do begin
   p:=@POCATokenPrecedences[i];
   case p^.Rule of
    prBINARY:begin
     POCABinaryTokens:=POCABinaryTokens+p^.Tokens;
    end;
    prREVERSE:Begin
     POCAReverseTokens:=POCAReverseTokens+p^.Tokens;
    end;
    prPREFIX:begin
     POCAPrefixTokens:=POCAPrefixTokens+p^.Tokens;
    end;
    prSUFFIX:begin
     POCASuffixTokens:=POCASuffixTokens+p^.Tokens;
    end;
   end;
  end;
  POCABinaryOrPrefixTokens:=POCABinaryTokens+POCAPrefixTokens;
  for t:=low(TPOCATokenType) to high(TPOCATokenType) do begin
   POCABinaryToPrefixUnaryTokenCorrectionMap[t]:=t;
  end;
  for i:=low(POCATokenBinaryPrefixes) to high(POCATokenBinaryPrefixes) do begin
   pbp:=@POCATokenBinaryPrefixes[i];
   POCABinaryToPrefixUnaryTokenCorrectionMap[pbp^.BinaryToken]:=pbp^.PrefixToken;
   POCABinaryToPrefixUnaryTokenCorrectionMap[pbp^.PrefixToken]:=pbp^.PrefixToken;
  end;
 end;
 procedure InitializeKeywords;
  procedure AddKeywordToken(Token:TPOCATokenType;const Str:TPOCARawByteString);
  var Node:PPOCALexerKeywordTokenCharTreeNode;
      Index:TPOCAInt32;
      CurrentChar:ansichar;
  begin
   Node:=LexerKeywordTokenCharTreeRootNode;
   for Index:=1 to length(Str) do begin
    CurrentChar:=Str[Index];
    if CurrentChar in POCAKeywordChars then begin
     if Node^.HasChildren and assigned(Node^.Children[CurrentChar]) then begin
      Node:=Node^.Children[CurrentChar];
     end else begin
      New(Node^.Children[CurrentChar]);
      Node^.HasChildren:=true;
      Node:=Node^.Children[CurrentChar];
      FillChar(Node^,sizeof(TPOCALexerKeywordTokenCharTreeNode),#0);
      Node^.HasChildren:=false;
      Node^.Token:=ptNONE;
     end;
    end else begin
     break;
    end;
   end;
   if assigned(Node) and (Node<>LexerKeywordTokenCharTreeRootNode) then begin
    Node^.Token:=Token;
   end;
   LexerKeywordTokens[Token]:=Str;
  end;
 begin
  FillChar(LexerKeywordTokens,sizeof(TPOCALexerKeywordTokens),#0);
  LexerKeywordTokenCharTreeRootNode:=nil;
  New(LexerKeywordTokenCharTreeRootNode);
  FillChar(LexerKeywordTokenCharTreeRootNode^,sizeof(TPOCALexerKeywordTokenCharTreeNode),#0);
  LexerKeywordTokenCharTreeRootNode^.Token:=ptNONE;
  AddKeywordToken(ptIF,'if');
  AddKeywordToken(ptELSEIF,'elseif');
  AddKeywordToken(ptELSE,'else');
  AddKeywordToken(ptFOR,'for');
  AddKeywordToken(ptFOREACH,'foreach');
  AddKeywordToken(ptWHILE,'while');
  AddKeywordToken(ptRETURN,'return');
  AddKeywordToken(ptBREAK,'break');
  AddKeywordToken(ptCONTINUE,'continue');
  AddKeywordToken(ptFUNCTION,'function');
  AddKeywordToken(ptNULL,'null');
  AddKeywordToken(ptVAR,'var');
  AddKeywordToken(ptFORINDEX,'forindex');
  AddKeywordToken(ptLAND,'and');
  AddKeywordToken(ptLOR,'or');
  AddKeywordToken(ptTRY,'try');
  AddKeywordToken(ptCATCH,'catch');
  AddKeywordToken(ptFINALLY,'finally');
  AddKeywordToken(ptTHROW,'throw');
  AddKeywordToken(ptDO,'do');
  AddKeywordToken(ptWHEN,'when');
  AddKeywordToken(ptSWITCH,'switch');
  AddKeywordToken(ptCASE,'case');
  AddKeywordToken(ptDEFAULT,'default');
  AddKeywordToken(ptFALLTHROUGH,'fallthrough');
  AddKeywordToken(ptRETRY,'retry');
  AddKeywordToken(ptREGISTER,'register');
  AddKeywordToken(ptSCOPE,'scope');
  AddKeywordToken(ptCODE,'code');
  AddKeywordToken(ptTHAT,'that');
  AddKeywordToken(ptTHIS,'this');
  AddKeywordToken(ptSELF,'self');
  AddKeywordToken(ptLOCAL,'local');
  AddKeywordToken(ptDEFINED,'defined');
  AddKeywordToken(ptNEW,'new');
  AddKeywordToken(ptTRUE,'true');
  AddKeywordToken(ptFALSE,'false');
  AddKeywordToken(ptFASTFUNCTION,'fastfunction');
  AddKeywordToken(ptFORKEY,'forkey');
  AddKeywordToken(ptINSTANCEOF,'instanceof');
  AddKeywordToken(ptIN,'in');
  AddKeywordToken(ptIS,'is');
  AddKeywordToken(ptSUPER,'super');
  AddKeywordToken(ptPROTOTYPE,'prototype');
  AddKeywordToken(ptDELETE,'delete');
  AddKeywordToken(ptCLASS,'class');
  AddKeywordToken(ptMODULE,'module');
  AddKeywordToken(ptEXTENDS,'extends');
  AddKeywordToken(ptGLOBAL,'global');
  AddKeywordToken(ptBASECLASS,'baseclass');
  AddKeywordToken(ptLET,'let');
  AddKeywordToken(ptREG,'reg');
  AddKeywordToken(ptCONST,'const');
  AddKeywordToken(ptFUNC,'func');
  AddKeywordToken(ptFASTFUNC,'fastfunc');
  AddKeywordToken(ptTYPEOF,'typeof');
  AddKeywordToken(ptIDOF,'idof');
  AddKeywordToken(ptGHOSTTYPEOF,'ghosttypeof');
  AddKeywordToken(ptCONSTRUCTOR,'constructor');
  AddKeywordToken(ptBREAKPOINT,'breakpoint');
  AddKeywordToken(ptIMPORT,'import');
  AddKeywordToken(ptEXPORT,'export');
 end;
 procedure InitializeMetaOpNames;
 var i:TPOCAMetaOp;
 begin
  FillChar(MetaOpNames,sizeof(TPOCAMetaOpNames),#0);
  MetaOpNames[pmoADD]:='__add';
  MetaOpNames[pmoSUB]:='__sub';
  MetaOpNames[pmoMUL]:='__mul';
  MetaOpNames[pmoDIV]:='__div';
  MetaOpNames[pmoMOD]:='__mod';
  MetaOpNames[pmoPOW]:='__pow';
  MetaOpNames[pmoNEG]:='__neg';
  MetaOpNames[pmoLNOT]:='__lnot';
  MetaOpNames[pmoBNOT]:='__bnot';
  MetaOpNames[pmoBAND]:='__band';
  MetaOpNames[pmoBOR]:='__bor';
  MetaOpNames[pmoBXOR]:='__bxor';
  MetaOpNames[pmoBSHL]:='__bshl';
  MetaOpNames[pmoBSHR]:='__bshr';
  MetaOpNames[pmoBUSHR]:='__bushr';
  MetaOpNames[pmoDEC]:='__dec';
  MetaOpNames[pmoINC]:='__inc';
  MetaOpNames[pmoEQ]:='__eq';
  MetaOpNames[pmoNEQ]:='__neq';
  MetaOpNames[pmoSEQ]:='__seq';
  MetaOpNames[pmoSNEQ]:='__sneq';
  MetaOpNames[pmoLT]:='__lt';
  MetaOpNames[pmoLTEQ]:='__lteq';
  MetaOpNames[pmoGT]:='__gt';
  MetaOpNames[pmoGTEQ]:='__gteq';
  MetaOpNames[pmoIN]:='__in';
  MetaOpNames[pmoINRANGE]:='__inrange';
  MetaOpNames[pmoCONCAT]:='__concat';
  MetaOpNames[pmoCOMPARE]:='__compare';
  MetaOpNames[pmoEXIST]:='__exist';
  MetaOpNames[pmoGET]:='__get';
  MetaOpNames[pmoSET]:='__set';
  MetaOpNames[pmoDELETE]:='__delete';
  MetaOpNames[pmoSIZE]:='__size';
  MetaOpNames[pmoCALL]:='__call';
  MetaOpNames[pmoKEYS]:='__keys';
  MetaOpNames[pmoTONUMBER]:='__tonumber';
  MetaOpNames[pmoTOSTRING]:='__tostring';
  MetaOpNames[pmoREGEXPEQ]:='__regexpeq';
  MetaOpNames[pmoREGEXPNEQ]:='__regexpneq';
  MetaOpNames[pmoSQRT]:='__sqrt';
  begin
   MetaOpNamesHashMap:=TPOCAStringHashMap.Create(false);
   for i:=low(TPOCAMetaOpNames) to high(TPOCAMetaOpNames) do begin
    MetaOpNamesHashMap.SetValue(MetaOpNames[i],Integer(i));
   end;
  end;
 end;
var OldFPUExceptionMask:TFPUExceptionMask;
    OldFPURoundingMode:TFPURoundingMode;
    OldFPUPrecisionMode:TFPUPrecisionMode;
begin
 if (not POCAInitialized) and (length(POCASignature)>0) then begin
  POCAInitialized:=true;
{$ifdef POCAHasJIT}
{$ifdef unix}
{$ifdef darwin}
  fpmprotect:=dlsym(dlopen('libc.dylib',RTLD_NOW),'mprotect');
{$else}
  fpmprotect:=dlsym(dlopen('libc.so',RTLD_NOW),'mprotect');
{$endif}
  if not assigned(fpmprotect) then begin
   raise Exception.Create('Importing of mprotect from libc.so failed!');
  end;
{$endif}
{$endif}
  InitializeLocaleFormatSettings;
  InitializeTokens;
  InitializeKeywords;
  InitializeMetaOpNames;
  begin
   OldFPUExceptionMask:=GetExceptionMask;
   OldFPURoundingMode:=GetRoundMode;
   OldFPUPrecisionMode:=GetPrecisionMode;
   try
    if OldFPUExceptionMask<>FPUExceptionMask then begin
     SetExceptionMask(FPUExceptionMask);
    end;
    if OldFPURoundingMode<>FPURoundingMode then begin
     SetRoundMode(FPURoundingMode);
    end;
    if OldFPUPrecisionMode<>FPUPrecisionMode then begin
     SetPrecisionMode(FPUPrecisionMode);
    end;
   finally
    if OldFPUExceptionMask<>FPUExceptionMask then begin
     SetExceptionMask(OldFPUExceptionMask);
    end;
    if OldFPURoundingMode<>FPURoundingMode then begin
     SetRoundMode(OldFPURoundingMode);
    end;
    if OldFPUPrecisionMode<>FPUPrecisionMode then begin
     SetPrecisionMode(OldFPUPrecisionMode);
    end;
   end;
  end;
 end;
end;

procedure FinalizePOCA;
 procedure FreeLexerKeywordTokenCharTreeNode(var Node:PPOCALexerKeywordTokenCharTreeNode);
 var c:ansichar;
 begin
  if assigned(Node) then begin
   for c:=low(TPOCAKeywordChars) to high(TPOCAKeywordChars) do begin
    FreeLexerKeywordTokenCharTreeNode(Node^.Children[c]);
   end;
   Dispose(Node);
   Node:=nil;
  end;
 end;
var i:TPOCAMetaOp;
    t:TPOCATokenType;
begin
 if POCAInitialized then begin
  FreeLexerKeywordTokenCharTreeNode(LexerKeywordTokenCharTreeRootNode);
  for t:=low(LexerKeywordTokens) to high(LexerKeywordTokens) do begin
   LexerKeywordTokens[t]:='';
  end;
  for i:=low(TPOCAMetaOpNames) to high(TPOCAMetaOpNames) do begin
   MetaOpNames[i]:='';
  end;
  FreeAndNil(MetaOpNamesHashMap);
  POCAInitialized:=false;
 end;
end;

{$if defined(fpc) and defined(Unix)}
var OriginalTerm:TTermios;
{$ifend}

initialization
{$if defined(fpc) and defined(Unix)}
 OriginalTerm.c_line:=#0;
 TCGetAttr(0,OriginalTerm);
{$ifend}
 InitializePOCA;
finalization
 FinalizePOCA;
{$if defined(fpc) and defined(Unix)}
 TCSetAttr(0,TCSAFLUSH,OriginalTerm);
{$ifend}
end.

