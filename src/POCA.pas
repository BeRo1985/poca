(******************************************************************************
 *                                     POCA                                   *
 ******************************************************************************
 *            for version see POCAVersion constant string here below          *
 ******************************************************************************
 *                                zlib license                                *
 *============================================================================*
 *                                                                            *
 * Copyright (C) 2011-2023, Benjamin Rosseaux (benjamin@rosseaux.com)         *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 *                                                                            *
 ******************************************************************************
 *                  General guidelines for code contributors                  *
 *============================================================================*
 *                                                                            *
 * 1. Make sure you are legally allowed to make a contribution under the zlib *
 *    license.                                                                *
 * 2. The zlib license header goes at the top of each source file, with       *
 *    appropriate copyright notice.                                           *
 * 3. After a pull request, check the status of your pull request on          *
      http://github.com/BeRo1985/poca                                         *
 * 4. Write code, which is compatible with Delphi 7-XE7 and FreePascal >= 3.0 *
 *    so don't use generics/templates, operator overloading and another newer *
 *    syntax features than Delphi 7 has support for that, but if needed, make *
 *    it out-ifdef-able.                                                      *
 * 5. Don't use Delphi-only, FreePascal-only or Lazarus-only libraries/units, *
 *    but if needed, make it out-ifdef-able.                                  *
 * 6. No use of third-party libraries/units as possible, but if needed, make  *
 *    it out-ifdef-able.                                                      *
 * 7. Try to use const when possible.                                         *
 * 8. Make sure to comment out writeln, used while debugging.                 *
 * 9. Make sure the code compiles on 32-bit and 64-bit platforms (x86-32,     *
 *    x86-64, ARM, ARM64, etc.).                                              *
 *                                                                            *
 ******************************************************************************)
 unit POCA;
{$ifdef fpc}
 {$mode delphi}
 {$ifdef cpui386}
  {$define cpu386}
  {$define cpu32}
 {$endif}
 {$ifdef cpu386}
  {$asmmode intel}
  {$define cpu32}
 {$endif}
 {$ifdef cpuamd64}
  {$asmmode intel}
  {$define cpu64}
 {$endif}
 {$ifdef FPC_LITTLE_ENDIAN}
  {$define LITTLE_ENDIAN}
 {$else}
  {$ifdef FPC_BIG_ENDIAN}
   {$define BIG_ENDIAN}
  {$endif}
 {$endif}
 {-$pic off}
 {$define caninline}
 {$ifdef FPC_HAS_TYPE_EXTENDED}
  {$define HAS_TYPE_EXTENDED}
 {$else}
  {$undef HAS_TYPE_EXTENDED}
 {$endif}
 {$ifdef FPC_HAS_TYPE_DOUBLE}
  {$define HAS_TYPE_DOUBLE}
 {$else}
  {$undef HAS_TYPE_DOUBLE}
 {$endif}
 {$ifdef FPC_HAS_TYPE_SINGLE}
  {$define HAS_TYPE_SINGLE}
 {$else}
  {$undef HAS_TYPE_SINGLE}
 {$endif}
{$else}
 {$realcompatibility off}
 {$localsymbols on}
 {$define LITTLE_ENDIAN}
 {$if defined(cpux64)}
  {$define cpu64}
  {$define cpuamd64}
 {$elseif defined(cpu386)}
  {$define cpu32}
 {$else}
  {$ifndef cpu64}
   {$define cpu32}
  {$endif}
 {$ifend}
 {$define HAS_TYPE_EXTENDED}
 {$define HAS_TYPE_DOUBLE}
 {$define HAS_TYPE_SINGLE}
 {$ifndef BCB}
  {$ifdef ver120}
   {$define Delphi4or5}
  {$endif}
  {$ifdef ver130}
   {$define Delphi4or5}
  {$endif}
  {$ifdef ver140}
   {$define Delphi6}
  {$endif}
  {$ifdef ver150}
   {$define Delphi7}
  {$endif}
  {$ifdef ver170}
   {$define Delphi2005}
  {$endif}
 {$else}
  {$ifdef ver120}
   {$define Delphi4or5}
   {$define BCB4}
  {$endif}
  {$ifdef ver130}
   {$define Delphi4or5}
  {$endif}
 {$endif}
 {$ifdef conditionalexpressions}
  {$if CompilerVersion>=24}
   {$legacyifend on}
  {$ifend}
  {$if CompilerVersion>=14.0}
   {$if CompilerVersion=14.0}
    {$define Delphi6}
   {$ifend}
   {$define Delphi6AndUp}
  {$ifend}
  {$if CompilerVersion>=15.0}
   {$if CompilerVersion=15.0}
    {$define Delphi7}
   {$ifend}
   {$define Delphi7AndUp}
  {$ifend}
  {$if CompilerVersion>=17.0}
   {$if CompilerVersion=17.0}
    {$define Delphi2005}
   {$ifend}
   {$define Delphi2005AndUp}
  {$ifend}
  {$if CompilerVersion>=18.0}
   {$if CompilerVersion=18.0}
    {$define BDS2006}
    {$define Delphi2006}
   {$ifend}
   {$define Delphi2006AndUp}
  {$ifend}
  {$if CompilerVersion>=18.5}
   {$if CompilerVersion=18.5}
    {$define Delphi2007}
   {$ifend}
   {$define Delphi2007AndUp}
  {$ifend}
  {$if CompilerVersion=19.0}
   {$define Delphi2007Net}
  {$ifend}
  {$if CompilerVersion>=20.0}
   {$if CompilerVersion=20.0}
    {$define Delphi2009}
   {$ifend}
   {$define Delphi2009AndUp}
  {$ifend}
  {$if CompilerVersion>=21.0}
   {$if CompilerVersion=21.0}
    {$define Delphi2010}
   {$ifend}
   {$define Delphi2010AndUp}
  {$ifend}
  {$if CompilerVersion>=22.0}
   {$if CompilerVersion=22.0}
    {$define DelphiXE}
   {$ifend}
   {$define DelphiXEAndUp}
  {$ifend}
  {$if CompilerVersion>=23.0}
   {$if CompilerVersion=23.0}
    {$define DelphiXE2}
   {$ifend}
   {$define DelphiXE2AndUp}
  {$ifend}
  {$if CompilerVersion>=24.0}
   {$if CompilerVersion=24.0}
    {$define DelphiXE3}
   {$ifend}
   {$define DelphiXE3AndUp}
  {$ifend}
  {$if CompilerVersion>=25.0}
   {$if CompilerVersion=25.0}
    {$define DelphiXE4}
   {$ifend}
   {$define DelphiXE4AndUp}
  {$ifend}
  {$if CompilerVersion>=26.0}
   {$if CompilerVersion=26.0}
    {$define DelphiXE5}
   {$ifend}
   {$define DelphiXE5AndUp}
  {$ifend}
  {$if CompilerVersion>=27.0}
   {$if CompilerVersion=27.0}
    {$define DelphiXE6}
   {$ifend}
   {$define DelphiXE6AndUp}
  {$ifend}
  {$if CompilerVersion>=28.0}
   {$if CompilerVersion=28.0}
    {$define DelphiXE7}
   {$ifend}
   {$define DelphiXE7AndUp}
  {$ifend}
  {$if CompilerVersion>=29.0}
   {$if CompilerVersion=29.0}
    {$define DelphiXE8}
   {$ifend}
   {$define DelphiXE8AndUp}
  {$ifend}
  {$if CompilerVersion>=30.0}
   {$if CompilerVersion=30.0}
    {$define Delphi10Seattle}
   {$ifend}
   {$define Delphi10SeattleAndUp}
  {$ifend}
  {$if CompilerVersion>=31.0}
   {$if CompilerVersion=31.0}
    {$define Delphi10Berlin}
   {$ifend}
   {$define Delphi10BerlinAndUp}
  {$ifend}
  {$if CompilerVersion>=32.0}
   {$if CompilerVersion=32.0}
    {$define Delphi10Tokyo}
   {$ifend}
   {$define Delphi10TokyoAndUp}
  {$ifend}
  {$if CompilerVersion>=33.0}
   {$if CompilerVersion=33.0}
    {$define Delphi10Rio}
   {$ifend}
   {$define Delphi10RioAndUp}
  {$ifend}
 {$endif}
 {$ifndef Delphi4or5}
  {$ifndef BCB}
   {$define Delphi6AndUp}
  {$endif}
   {$ifndef Delphi6}
    {$define BCB6OrDelphi7AndUp}
    {$ifndef BCB}
     {$define Delphi7AndUp}
    {$endif}
    {$ifndef BCB}
     {$ifndef Delphi7}
      {$ifndef Delphi2005}
       {$define BDS2006AndUp}
      {$endif}
     {$endif}
    {$endif}
   {$endif}
 {$endif}
 {$ifdef Delphi6AndUp}
  {$warn symbol_platform off}
  {$warn symbol_deprecated off}
 {$endif}
{$endif}
{$ifdef win32}
 {$define windows}
{$endif}
{$ifdef win64}
 {$define windows}
{$endif}
{$ifdef wince}
 {$define windows}
{$endif}
{$rangechecks off}
{$extendedsyntax on}
{$writeableconst on}
{$hints off}
{$booleval off}
{$typedaddress off}
{$stackframes off}
{$varstringchecks on}
{$typeinfo on}
{$overflowchecks off}
{$longstrings on}
{$openstrings on}
{$ifndef HAS_TYPE_DOUBLE}
 {$error No double floating point precision}
{$endif}
{$define POCAGarbageCollectorListsDoNeedFallbackLocking}
{$undef POCAGarbageCollectorListsFallbackTwoLocking}
{$undef POCAGarbageCollectorListsUsePlainAssemblerCode}
{$undef UseRegister}
{$ifdef cpu386}
 {$undef POCAGarbageCollectorListsDoNeedFallbackLocking}
 {$define POCAGarbageCollectorListsUsePlainAssemblerCode}
 {$define POCAHasJIT}
 {$define UseRegister}
{$endif}
{$ifdef cpuamd64}
 {$undef POCAGarbageCollectorListsDoNeedFallbackLocking}
 {$define POCAGarbageCollectorListsUsePlainAssemblerCode}
 {-$define POCAHasJIT}
 {$define UseRegister}
{$endif}
{$undef POCAGarbageCollectorPoolBlockInstance}
{$define POCAGarbageCollectorPoolBlockReferenceCounting}
{-$define pocastrictutf8}

interface

uses {$ifdef unix}dynlibs,BaseUnix,Unix,UnixType,dl,{$else}Windows,{$endif}SysUtils,Classes,Math,Variants,TypInfo{$ifndef fpc},SyncObjs{$endif},FLRE,PasDblStrUtils,PUCU,PasMP;

const POCAVersion='2024-07-20-16-20-0000';

      POCA_MAX_RECURSION=1024;

      POCAHashMapItemsPerBucketsThreshold=5;
      POCAHashMapMaxSize=1 shl 16;

      POCA_PROTOTYPE_RECURSION_LIMIT=128;
      POCA_CONSTRUCTOR_RECURSION_LIMIT=128;

      popNOP=0;
      popADD=1;
      popSUB=2;
      popMUL=3;
      popDIV=4;
      popNEG=5;
      popNOT=6;
      popCAT=7;
      popLT=8;
      popLTEQ=9;
      popGT=10;
      popGTEQ=11;
      popEQ=12;
      popNEQ=13;
      popCMP=14;
      popSEQ=15;
      popSNEQ=16;
      popEACH=17;
      popJMP=18;
      popJMPLOOP=19;
      popJIFTRUE=20;
      popJIFFALSE=21;
      popJIFTRUELOOP=22;
      popJIFFALSELOOP=23;
      popFCALL=24;
      popMCALL=25;
      popRETURN=26;
      popLOADCONST=27;
      popLOADONE=28;
      popLOADZERO=29;
      popLOADINT32=30;
      popLOADNULL=31;
      popLOADTHAT=32;
      popLOADTHIS=33;
      popLOADSELF=34;
      popLOADLOCAL=35;
      popCOPY=36;
      popINSERT=37;
      popEXTRACT=38;
      popGETMEMBER=39;
      popSETMEMBER=40;
      popGETLOCAL=41;
      popSETLOCAL=42;
      popNEWARRAY=43;
      popARRAYPUSH=44;
      popARRAYRANGEPUSH=45;
      popNEWHASH=46;
      popHASHAPPEND=47;
      popSETSYM=48;
      popINDEX=49;
      popFCALLH=50;
      popMCALLH=51;
      popUNPACK=52;
      popSLICE=53;
      popSLICE2=54;
      popSLICE3=55;
      popTRY=56;
      popTRYBLOCKEND=57;
      popTHROW=58;
      popDEC=59;
      popINC=60;
      popBAND=61;
      popBXOR=62;
      popBOR=63;
      popBNOT=64;
      popBSHL=65;
      popBSHR=66;
      popBUSHR=67;
      popMOD=68;
      popPOW=69;
      popINHERITEDMETHOD=70;
      popKEY=71;
      popIN=72;
      popINRANGE=73;
      popFTAILCALL=74;
      popMTAILCALL=75;
      popFTAILCALLH=76;
      popMTAILCALLH=77;
      popINSTANCEOF=78;
      popBREAKPOINT=79;
      popNUM=80;
      popN_NOT=81;
      popN_ADD=82;
      popN_SUB=83;
      popN_MUL=84;
      popN_DIV=85;
      popN_NEG=86;
      popN_LT=87;
      popN_LTEQ=88;
      popN_GT=89;
      popN_GTEQ=90;
      popN_EQ=91;
      popN_NEQ=92;
      popN_CMP=93;
      popN_DEC=94;
      popN_INC=95;
      popN_BAND=96;
      popN_BXOR=97;
      popN_BOR=98;
      popN_BNOT=99;
      popN_BSHL=100;
      popN_BSHR=101;
      popN_BUSHR=102;
      popN_MOD=103;
      popN_POW=104;
      popN_INRANGE=105;
      popN_JIFTRUE=106;
      popN_JIFFALSE=107;
      popN_JIFTRUELOOP=108;
      popN_JIFFALSELOOP=109;
      popN_JIFLT=110;
      popN_JIFLTEQ=111;
      popN_JIFGT=112;
      popN_JIFGTEQ=113;
      popN_JIFEQ=114;
      popN_JIFNEQ=115;
      popN_JIFLTLOOP=116;
      popN_JIFLTEQLOOP=117;
      popN_JIFGTLOOP=118;
      popN_JIFGTEQLOOP=119;
      popN_JIFEQLOOP=120;
      popN_JIFNEQLOOP=121;
      popUPDATESTRING=122;
      popREGEXP=123;
      popREGEXPEQ=124;
      popREGEXPNEQ=125;
      popSQRT=126;
      popN_SQRT=127;
      popGETPROTOTYPE=128;
      popSETPROTOTYPE=129;
      popGETCONSTRUCTOR=130;
      popSETCONSTRUCTOR=131;
      popDELETE=132;
      popDELETEEX=133;
      popDEFINED=134;
      popDEFINEDEX=135;
      popLOADGLOBAL=136;
      popLOADBASECLASS=137;
      popGETHASHKIND=138;
      popSETHASHKIND=139;
      popTYPEOF=140;
      popIDOF=141;
      popGHOSTTYPEOF=142;
      popELVIS=143;
      popIS=144;
      popJIFNULL=145;
      popCOUNT=146;

      pvtNULL=0;
      pvtNUMBER=1;
      pvtREFERENCE=2;
      pvtSTRING=3;
      pvtARRAY=4;
      pvtHASH=5;
      pvtCODE=6;
      pvtFUNCTION=7;
      pvtNATIVECODE=8;
      pvtGHOST=9;
      pvtCOUNT=10;

      pvtFIRSTREF=pvtSTRING;

      phkHASH=0;
      phkCLASS=1;
      phkMODULE=2;

      POCAKeywordChars=['a'..'z'];

      POCAIdentifierCharsAtBegin=['a'..'z','A'..'Z','_'];
      POCAIdentifierCharsAfterBegin=['a'..'z','A'..'Z','0'..'9','_'];
      POCAIdentifierChars=POCAIdentifierCharsAtBegin+POCAIdentifierCharsAfterBegin;

{$ifdef cpu64}
      POCAValueReferenceMask=UInt64(UInt64(UInt64(1) shl 48)-1);
      POCAValueReferenceSignalMask=UInt64(not POCAValueReferenceMask);
{$else}
      POCAValueReferenceTag=longword($7fff6789); // $7ff56789
{$endif}

      pcsNONE=0;
      pcsOUTSIDE=1;
      pcsINSIDE=2;
      pcsINSIDETERMINATED=3;
      pcsTERMINATED=4;

      pgcbNONE=0;
      pgcbBLACK=1 shl 0;
      pgcbGRAY=1 shl 1;
      pgcbPERSISTENT=1 shl 2;
      pgcbPERSISTENTROOT=1 shl 3;

      pgcbWASPERSISTENT=1 shl 4;
      pgcbWASPERSISTENTROOT=1 shl 5;

      pgcbLIST=pgcbGRAY or pgcbBLACK or pgcbPERSISTENT or pgcbPERSISTENTROOT;

      pgcbNOWHITE=pgcbGRAY or pgcbBLACK or pgcbPERSISTENT or pgcbPERSISTENTROOT;

      pgcscSHIFT=8;
      pgcscMAX=longword($ffffff);
      pgcscONE=longword(1 shl pgcscSHIFT);
      pgcscMAXSHIFTED=longword(pgcscMAX shl pgcscSHIFT);

      pgcbBITS=pgcscONE-1;

type PPOCAInt8=^TPOCAInt8;
     TPOCAInt8={$ifdef fpc}Int8{$else}ShortInt{$endif};

     PPOCAUInt8=^TPOCAUInt8;
     TPOCAUInt8={$ifdef fpc}UInt8{$else}Byte{$endif};

     PPOCAInt16=^TPOCAInt16;
     TPOCAInt16={$ifdef fpc}Int16{$else}SmallInt{$endif};

     PPOCAUInt16=^TPOCAUInt16;
     TPOCAUInt16={$ifdef fpc}UInt16{$else}Word{$endif};

     PPOCAInt32=^TPOCAInt32;
     TPOCAInt32={$ifdef fpc}Int32{$else}LongInt{$endif};

     PPOCAUInt32=^TPOCAUInt32;
     TPOCAUInt32={$ifdef fpc}UInt32{$else}LongWord{$endif};

     PPOCAInt64=^TPOCAInt64;
     TPOCAInt64=Int64;

     PPOCAUInt64=^TPOCAUInt64;
     TPOCAUInt64=UInt64;

     PPOCAPtrUInt=^TPOCAPtrUInt;
     PPOCAPtrInt=^TPOCAPtrInt;

{$ifdef fpc}
     TPOCAPtrUInt=PtrUInt;
     TPOCAPtrInt=PtrInt;
{$else}
{$if Declared(CompilerVersion) and (CompilerVersion>=23.0)}
     TPOCAPtrUInt=NativeUInt;
     TPOCAPtrInt=NativeInt;
{$else}
{$ifdef cpu64}
     TPOCAPtrUInt=UInt64;
     TPOCAPtrInt=int64;
{$else}
     TPOCAPtrUInt=TPOCAUInt32;
     TPOCAPtrInt=TPOCAInt32;
{$endif}
{$ifend}
{$endif}

     PPOCANativeUInt=^TPOCANativeUInt;
     PPOCANativeInt=^TPOCANativeInt;
     TPOCANativeUInt=TPOCAPtrUInt;
     TPOCANativeInt=TPOCAPtrInt;

     PWords=^TWords;
     TWords=array[0..($7fffffff div sizeof(word))-1] of word;

     PLongbools=^TLongbools;
     TLongbools=array[0..($7fffffff div sizeof(longbool))-1] of longbool;

     PLongints=^TLongints;
     TLongints=array[0..($7fffffff div sizeof(longint))-1] of longint;

     PLongwords=^TLongwords;
     TLongwords=array[0..($7fffffff div sizeof(longword))-1] of longword;

     PPointer=^pointer;

     PPointers=^TPointers;
     TPointers=array[0..($7fffffff div sizeof(pointer))-1] of pointer;

     PPOCADoubleHiLo=^TPOCADoubleHiLo;
     TPOCADoubleHiLo=packed record
{$ifdef BIG_ENDIAN}
      Hi,Lo:longword;
{$else}
      Lo,Hi:longword;
{$endif}
     end;

     PPOCADoubleBytes=^TPOCADoubleBytes;
     TPOCADoubleBytes=array[0..sizeof(double)-1] of byte;

     TPOCAKeywordChars='a'..'z';

     PPOCAContext=^TPOCAContext;

     TPOCAUTF8String=TPUCUUTF8String;

     TPOCAUTF16String=TPUCUUTF16String;

     TPOCARawByteString=TPUCURawByteString;

     TPOCAUCS4Char=longint;

     TPOCAUCS4CharSigned=longword;

     TPOCAUCS4String=array of TPOCAUCS4Char;

     PPOCATokenType=^TPOCATokenType;
     TPOCATokenType=(
      ptNONE,
      ptTOP,
      ptAND,
      ptOR,
      ptNOT,
      ptLPAR,
      ptRPAR,
      ptLBRA,
      ptRBRA,
      ptLCURL,
      ptRCURL,
      ptMUL,
      ptPLUS,
      ptMINUS,
      ptNEG,
      ptDIV,
      ptNUM,
      ptCOLON,
      ptDOT,
      ptCOMMA,
      ptSEMI,
      ptASSIGN,
      ptLT,
      ptLTEQ,
      ptEQ,
      ptNEQ,
      ptGT,
      ptGTEQ,
      ptCMP,
      ptIF,
      ptELSEIF,
      ptELSE,
      ptFOR,
      ptFOREACH,
      ptWHILE,
      ptRETURN,
      ptBREAK,
      ptCONTINUE,
      ptFUNCTION,
      ptSYMBOL,
      ptLITERALNUM,
      ptLITERALSTR,
      ptEMPTY,
      ptNULL,
      ptELLIPSIS,
      ptQUESTION,
      ptVAR,
      ptPLUSEQ,
      ptMINUSEQ,
      ptMULEQ,
      ptDIVEQ,
      ptCATEQ,
      ptFORINDEX,
      ptLAND,
      ptLOR,
      ptTRY,
      ptCATCH,
      ptFINALLY,
      ptTHROW,
      ptDO,
      ptWHEN,
      ptSWITCH,
      ptCASE,
      ptDEFAULT,
      ptFALLTHROUGH,
      ptRETRY,
      ptPOSTDEC,
      ptPOSTINC,
      ptPREDEC,
      ptPREINC,
      ptBAND,
      ptBOR,
      ptBXOR,
      ptBNOT,
      ptBSHL,
      ptBSHR,
      ptBUSHR,
      ptBANDEQ,
      ptBOREQ,
      ptBXOREQ,
      ptBSHLEQ,
      ptBSHREQ,
      ptBUSHREQ,
      ptMOD,
      ptMODEQ,
      ptPOW,
      ptPOWEQ,
      ptREGISTER,
      ptBLOCK,
      ptINLINEBLOCK,
      ptSUPERTHAT,
      ptTHAT,
      ptTHIS,
      ptSELF,
      ptLOCAL,
      ptDEFINED,
      ptNEW,
      ptTRUE,
      ptFALSE,
      ptFASTFUNCTION,
      ptAT,
      ptATDOT,
      ptDOTDOT,
      ptSAFEDOT,
      ptSAFELBRA,
      ptSAFERBRA,
      ptFORKEY,
      ptINSTANCEOF,
      ptSEQ,
      ptSNEQ,
      ptIN,
      ptIS,
      ptSUPER,
      ptCAT,
      ptREGEXP,
      ptREGEXPEQ,
      ptREGEXPNEQ,
      ptPROTOTYPE,
      ptDELETE,
      ptCLASS,
      ptMODULE,
      ptEXTENDS,
      ptLAMBDA,
      ptFASTLAMBDA,
      ptCLASSFUNCTION,
      ptMODULEFUNCTION,
      ptGLOBAL,
      ptBASECLASS,
      ptLET,
      ptREG,
      ptCONST,
      ptFUNC,
      ptFASTFUNC,
      ptHASHKIND,
      ptTYPEOF,
      ptIDOF,
      ptGHOSTTYPEOF,
      ptCOLONCOLON,
      ptCONSTRUCTOR,
      ptBREAKPOINT,
      ptIMPORT,
      ptEXPORT,
      ptAUTOSEMI,
      ptELVIS,
      ptELVISEQ,
      ptSYMBOLNAME,
      ptSUPERCODESYMBOL
     );

     PPOCAMetaOp=^TPOCAMetaOp;
     TPOCAMetaOp=(
      pmoNONE,
      pmoADD,
      pmoSUB,
      pmoMUL,
      pmoDIV,
      pmoMOD,
      pmoPOW,
      pmoNEG,
      pmoLNOT,
      pmoBNOT,
      pmoBAND,
      pmoBOR,
      pmoBXOR,
      pmoBSHL,
      pmoBSHR,
      pmoBUSHR,
      pmoDEC,
      pmoINC,
      pmoEQ,
      pmoNEQ,
      pmoSEQ,
      pmoSNEQ,
      pmoLT,
      pmoLTEQ,
      pmoGT,
      pmoGTEQ,
      pmoIN,
      pmoINRANGE,
      pmoCONCAT,
      pmoCOMPARE,
      pmoEXIST,
      pmoGET,
      pmoSET,
      pmoDELETE,
      pmoSIZE,
      pmoCALL,
      pmoKEYS,
      pmoTONUMBER,
      pmoTOSTRING,
      pmoREGEXPEQ,
      pmoREGEXPNEQ,
      pmoSQRT
     );            

     PPOCATokenTypes=^TPOCATokenTypes;
     TPOCATokenTypes=set of TPOCATokenType;

     TPOCAStringTreeData=int64;

     PPOCAStringTreeNode=^TPOCAStringTreeNode;
     TPOCAStringTreeNode=record
      TheChar:ansichar;
      Data:TPOCAStringTreeData;
      DataExist:boolean;
      Previous,Next,Up,Down:PPOCAStringTreeNode;
     end;

     TPOCAStringTree=class
      private
       Root:PPOCAStringTreeNode;
       function CreateStringTreeNode(AChar:ansichar):PPOCAStringTreeNode;
       procedure DestroyStringTreeNode(Node:PPOCAStringTreeNode);
      public
       Hashing:boolean;
       constructor Create;
       destructor Destroy; override;
       procedure Clear;
       procedure DumpTree;
       procedure DumpList;
       procedure AppendTo(DestStringTree:TPOCAStringTree);
       procedure Optimize(DestStringTree:TPOCAStringTree);
       function Add(Content:TPOCARawByteString;Data:TPOCAStringTreeData;Replace:boolean=false):boolean;
       function Delete(Content:TPOCARawByteString):boolean;
       function Find(Content:TPOCARawByteString;var Data:TPOCAStringTreeData):boolean;
       function FindEx(Content:TPOCARawByteString;var Data:TPOCAStringTreeData;var Len:longint):boolean;
     end;

     PPOCAStringHashMapItem=^TPOCAStringHashMapItem;
     TPOCAStringHashMapItem=record
      Previous,Next,HashPrevious,HashNext:PPOCAStringHashMapItem;
      Hash:longword;
      Key:TPOCARawByteString;
      Value:int64;
     end;

     TPOCAStringHashMapHashBucket=record
      HashFirst,HashLast:PPOCAStringHashMapItem;
     end;

     TPOCAStringHashMapHashBuckets=array of TPOCAStringHashMapHashBucket;

     TPOCAStringHashMap=class
      private
       LastUsedItem:PPOCAStringHashMapItem;
       procedure GrowAndRehashIfNeeded;
      protected
       function GetValue(const Key:TPOCARawByteString):int64;
       procedure SetValue(const Key:TPOCARawByteString;const Value:int64);
      public
       First,Last:PPOCAStringHashMapItem;
       HashBuckets:TPOCAStringHashMapHashBuckets;
       HashSize:longword;
       HashSizeMask:longword;
       HashedItems:longword;
       HashBucketsUsed:longword;
       Optimize:longbool;
       constructor Create(AOptimize:longbool);
       destructor Destroy; override;
       procedure Clear;
       function GetKey(const Key:TPOCARawByteString):PPOCAStringHashMapItem;
       function NewKey(const Key:TPOCARawByteString;Force:boolean=false):PPOCAStringHashMapItem;
       function DeleteKey(const Item:PPOCAStringHashMapItem):boolean;
       property Values[const Key:TPOCARawByteString]:int64 read GetValue write SetValue; default;
     end;

     PPOCAPointerArray=^TPOCAPointerArray;
     TPOCAPointerArray=array[0..(2147483647 div sizeof(pointer))-1] of pointer;

     TPOCAPointerList=class
      private
       List:PPOCAPointerArray;
       ListCount,ListCapacity:longint;
       function GetItem(Index:longint):pointer;
       procedure SetItem(Index:longint;Value:pointer);
      public
       constructor Create;
       destructor Destroy; override;
       procedure Clear;
       function Add(Item:pointer):longint;
       procedure Insert(Index:longint;Item:pointer);
       function Find(Item:pointer):longint;
       function IndexOf(Item:pointer):longint;
       procedure Delete(Index:longint);
       function Remove(Item:pointer):longint;
       procedure Exchange(Index1,Index2:longint);
       procedure SetCapacity(NewCapacity:longint);
       procedure SetCount(NewCount:longint);
       property Count:longint read ListCount write SetCount;
       property Capacity:longint read ListCapacity write SetCapacity;
       property Items[Index:longint]:pointer read GetItem write SetItem; default;
     end;

     PPOCAInstance=^TPOCAInstance;

     PPOCACoroutine=^TPOCACoroutine;

     TPOCACoroutineEntrypoint=procedure(Coroutine:PPOCACoroutine);

     TPOCACoroutine=record
      Fiber,Back:pointer;
{$ifdef windows}
      FiberFPUCW,BackFPUCW:longword;
{$endif}
      Entrypoint:TPOCACoroutineEntrypoint;
      Parameter:pointer;
      State:longint;
      Event:{$ifdef fpc}PRTLEvent{$else}TEvent{$endif};
     end;

     TPOCAMetaOpNames=array[TPOCAMetaOp] of TPOCARawByteString;

     PPOCAValue=^TPOCAValue;
     PPOCAValues=^TPOCAValues;

{$ifdef POCAHasJIT}
     PPOCANativeCodeMemoryManagerBlock=^TPOCANativeCodeMemoryManagerBlock;
     TPOCANativeCodeMemoryManagerBlock=packed record
      Signature:TPOCAPtrUInt;
      Previous:PPOCANativeCodeMemoryManagerBlock;
      Next:PPOCANativeCodeMemoryManagerBlock;
      Size:TPOCAPtrUInt;
     end;

     PPOCANativeCodeMemoryManagerBlockContainer=^TPOCANativeCodeMemoryManagerBlockContainer;
     TPOCANativeCodeMemoryManagerBlockContainer=record
      Previous:PPOCANativeCodeMemoryManagerBlockContainer;
      Next:PPOCANativeCodeMemoryManagerBlockContainer;
      Base:pointer;
      Size:TPOCAPtrUInt;
      Used:TPOCAPtrUInt;
      First:PPOCANativeCodeMemoryManagerBlock;
      Last:PPOCANativeCodeMemoryManagerBlock;
     end;

     PPOCANativeCodeMemoryManager=^TPOCANativeCodeMemoryManager;
     TPOCANativeCodeMemoryManager=record
      Instance:PPOCAInstance;
      PageSize:TPOCAPtrUInt;
      Alignment:TPOCAPtrUInt;
      First,Last:PPOCANativeCodeMemoryManagerBlockContainer;
     end;
{$endif}

     PPOCAMRSWLock=^TPOCAMRSWLock;
     TPOCAMRSWLock=record
      State:longint; // Sign bit is writer flag! 1.31 bit layout (1 bit writer count . 31 bit reader count)
     end;

     PPOCAPoolBlock=^TPOCAPoolBlock;

     PPOCAGarbageCollectorLinkedList=^TPOCAGarbageCollectorLinkedList;
     TPOCAGarbageCollectorLinkedList=packed record
      Previous:PPOCAGarbageCollectorLinkedList;
      Next:PPOCAGarbageCollectorLinkedList;
     end;

     PPOCAGarbageCollectorHeader=^TPOCAGarbageCollectorHeader;
     TPOCAGarbageCollectorHeader=packed record
      LinkedList:TPOCAGarbageCollectorLinkedList;
      State:longword; // High 24 bits = survived cycles, low 8 bits = info bits
     end;

     PPOCAObjectHeader=^TPOCAObjectHeader;
     TPOCAObjectHeader=packed record
      GarbageCollector:TPOCAGarbageCollectorHeader;
      ValueType:TPOCAPtrInt;
{$ifndef POCAGarbageCollectorPoolBlockInstance}
      Instance:PPOCAInstance;
{$endif}
      PoolBlock:PPOCAPoolBlock;
     end;

     PPPOCAObject=^PPOCAObject;
     PPOCAObject=^TPOCAObject;
     TPOCAObject=packed record
      Header:TPOCAObjectHeader;
     end;

     PPPOCAObjects=^TPPOCAObjects;
     TPPOCAObjects=array[0..($7fffffff div sizeof(PPOCAObject))-1] of PPOCAObject;

     TPOCAStringUTF8Indices=array[0..2] of pointer;

     PPOCAString=^TPOCAString;
     TPOCAString=packed record
      Header:TPOCAObjectHeader;
      Data:TPOCARawByteString;
      DataLength:longint;
      HashCode:longword;
      UTF8Length:longint;
      UTF8CodePointsToCodeUnitsIndex:pointer;
      UTF8CodeUnitsToCodePointsIndex:pointer;
      UTF8CodePointsToCodeUnitsIndexSize:byte;
      UTF8CodeUnitsToCodePointsIndexSize:byte;
      UTF8:byte;
      Dirty:bytebool;
     end;

     PPOCAArrayRecord=^TPOCAArrayRecord;

     PPOCAArray=^TPOCAArray;
     TPOCAArray=packed record
      Header:TPOCAObjectHeader;
      ArrayRecord:PPOCAArrayRecord;
     end;

     PPOCAHashRecord=^TPOCAHashRecord;

     PPOCAHash=^TPOCAHash;

     PPOCACode=^TPOCACode;

     PPOCAFunction=^TPOCAFunction;

     PPOCANativeCode=^TPOCANativeCode;

     PPOCAGhost=^TPOCAGhost;

     TPOCAValueReference=packed record
      case byte of
       pvtREFERENCE:(Obj:PPOCAObject);
       pvtSTRING:(StringObject:PPOCAString);
       pvtARRAY:(ArrayObject:PPOCAArray);
       pvtHASH:(HashObject:PPOCAHash);
       pvtCODE:(CodeObject:PPOCACode);
       pvtFUNCTION:(FunctionObject:PPOCAFunction);
       pvtNATIVECODE:(NativeCodeObject:PPOCANativeCode);
       pvtGHOST:(GhostObject:PPOCAGhost);
       pvtCOUNT:(Ptr:pointer);
     end;

     TPOCAValue=packed record
      case byte of
       0:(Num:double);
       1:({$ifdef cpu64}Reference:TPOCAValueReference;{$else}{$ifdef LITTLE_ENDIAN}Reference:TPOCAValueReference;ReferenceTag:longword;{$else}ReferenceTag:longword;Reference:TPOCAValueReference;{$endif}{$endif});
       2:(CastedInt64:int64);
       2:(CastedUInt64:TPOCAUInt64);
       3:({$ifdef LITTLE_ENDIAN}CastedLo,CastedHi{$else}CastedHi,CastedLo{$endif}:longword);
     end;

     TPOCAValueArray=array of TPOCAValue;

     TPOCAValues=array[0..($7fffffff div sizeof(TPOCAValue))-1] of TPOCAValue;

     PPOCAHashEntity=^TPOCAHashEntity;
     TPOCAHashEntity=record
      Key:TPOCAValue;
      Value:TPOCAValue;
     end;

     PPOCAHashEntityIndex=^TPOCAHashEntityIndex;
     TPOCAHashEntityIndex=array[0..($7fffffff div sizeof(longint))-1] of longint;

     PPOCAHashEntities=^TPOCAHashEntities;
     TPOCAHashEntities=array[0..($7fffffff div sizeof(TPOCAHashEntity))-1] of TPOCAHashEntity;

     PPPOCAHashEntities=^TPPOCAHashEntities;
     TPPOCAHashEntities=array[0..($7fffffff div sizeof(PPOCAHashEntity))-1] of PPOCAHashEntity;

     PPOCAHashEvents=^TPOCAHashEvents;
     TPOCAHashEvents=array[TPOCAMetaOp] of TPOCAValue;

     TPOCAHashRecord=record
      RealSize:longint;
      LogSize:longint;
      Size:longint;
      CellToEntityIndex:PPOCAHashEntityIndex;
      EntityToCellIndex:PPOCAHashEntityIndex;
      Entities:PPOCAHashEntities;
      Events:PPOCAHashEvents;
     end;

     TPOCAHashChildren=record
      First,Last:PPOCAHash;
      Previous,Next:PPOCAHash;
     end;

     TPOCAHashCache=record
      MRSWLock:TPOCAMRSWLock;
      Ready:longbool;
      ChainCount:longint;
      ChainEntities:PPPOCAHashEntities;
     end;

     TPOCAHash=packed record
      Header:TPOCAObjectHeader;
      HashRecord:PPOCAHashRecord;
      Children:TPOCAHashChildren;
      Prototype:PPOCAHash;
      Constructor_:PPOCAObject;
      Events:PPOCAHash;
      Ghost:PPOCAGhost;
      Kind:longint;
      Cache:TPOCAHashCache;
     end;

     TPOCAArrayRecord=record
      Size:longint;
      Allocated:longint;
      Data:array[0..0] of TPOCAValue;
     end;

     PPOCACodeLine=^TPOCACodeLine;
     TPOCACodeLine=record
      InstructionPointer:longword;
      Line:longword;
     end;

     TPOCACodeLines=array of TPOCACodeLine;

     TPOCACode=packed record
      Header:TPOCAObjectHeader;
      Name:TPOCARawByteString;
      ClassFunction:longbool;
      FastFunction:longbool;
      IsEmpty:longbool;
      LocalsAsThisObj:longbool;
      CountRegisters:longword;
      CountArguments:longword;
      CountOptionalArguments:longword;
      NeedArgumentArray:longbool;
      HasArguments:longbool;
      ConstantCount:longword;
      ByteCode:PLongwords;
      ByteCodeSize:longword;
      Constants:PPOCAValues;
      HasArgumentLocals:longbool;
      ArgumentSymbols:PLongints;
      ArgumentLocals:PLongints;
      OptionalArgumentSymbols:PLongints;
      OptionalArgumentLocals:PLongints;
      OptionalArgumentValues:PLongints;
      RegExps:PPOCAValues;
      CountRegExps:longword;
      Lines:TPOCACodeLines;
      SourceFile:longint;
      RestArgSym:longword;
{$ifdef POCAHasJIT}
      NativeCode:pointer;
      NativeCodeSize:longword;
      ByteCodeToNativeCodeMap:array of longword;
      InterpretByteCodeMap:array of bytebool;
{$endif}
     end;

     TPOCAFunction=packed record
      Header:TPOCAObjectHeader;
      Code:TPOCAValue;
      Namespace:TPOCAValue;
      Obj:TPOCAValue;
      Next:TPOCAValue;
     end;

     PPOCAFrame=^TPOCAFrame;
     TPOCAFrame=record
      Func:TPOCAValue;
      Locals:TPOCAValue;
      Obj:TPOCAValue;
      InstructionPointer:longint;
      ResultRegister:longword;
      Registers:TPOCAValueArray;
      CountRegisters:longint;
      Arguments:TPOCAValueArray;
      CountArguments:longint;
     end;

     TPOCANativeFunction=function(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;

     TPOCANativeDestroyFunction=procedure(const UserData:pointer);

     TPOCANativeCode=record
      Header:TPOCAObjectHeader;
      FunctionPointer:TPOCANativeFunction;
      DestroyFunctionPointer:TPOCANativeDestroyFunction;
      UserData:pointer;
     end;

     PPOCAGhostType=^TPOCAGhostType;
     TPOCAGhostType=record
      Destroy:procedure(Ghost:pointer);
      CanDestroy:function(Ghost:pointer):longbool;
      Mark:function(Ghost:pointer):longbool;
      Name:TPOCARawByteString;
     end;

     PPOCAGhostPtrType=^TPOCAGhostPtrType;
     TPOCAGhostPtrType=(pgptRAW,pgptOBJECT);

     TPOCAGhost=record
      Header:TPOCAObjectHeader;
      GhostType:PPOCAGhostType;
      PtrType:TPOCAGhostPtrType;
      Ptr:pointer;
      Hash:PPOCAHash;
     end;

     TPOCAPoolBlock=record
      GrayList:PPOCAGarbageCollectorLinkedList;
{$ifdef POCAGarbageCollectorPoolBlockReferenceCounting}
      ReferenceCounter:longint;
{$endif}
{$ifdef POCAGarbageCollectorPoolBlockInstance}
      Instance:PPOCAInstance;
{$endif}
      Data:pointer;
      Size:longint;
      Spin:longint;
      Previous:PPOCAPoolBlock;
      Next:PPOCAPoolBlock;
     end;

     PPOCAPool=^TPOCAPool;
     TPOCAPool=record
      Instance:PPOCAInstance;
      ValueType:longint;
      ElementRealSize:longint;
      ElementSize:longint;
      Size:longint;
      FreeObjects:PPPOCAObjects;
      FreeSize:longint;
      FreeCount:longint;
      FreeLock:longint;
      FirstBlock:PPOCAPoolBlock;
      LastBlock:PPOCAPoolBlock;
     end;

     PPOCAPools=^TPOCAPools;
     TPOCAPools=array[0..pvtCOUNT-1] of TPOCAPool;

     PPOCAContextObjectPool=^TPOCAContextObjectPool;
     TPOCAContextObjectPool=record
      Objects:PPPOCAObjects;
      Size:TPOCAPtrInt;
      Count:TPOCAPtrInt;
     end;

     PPOCAContextObjectPools=^TPOCAContextObjectPools;
     TPOCAContextObjectPools=array[0..pvtCOUNT-1] of TPOCAContextObjectPool;

     TPOCAGarbageCollectorState=(pgcsRESET,pgcsINIT,pgcsMARKROOTS,pgcsMARKCONTEXTS,pgcsMARKPERSISTENTS,pgcsMARKPROTECTED,pgcsMARKGREYS,pgcsSWEEPINIT,pgcsMARKWHITEGHOSTS,pgcsMARKWHITEGHOSTGREYS,pgcsSWEEP,pgcsFLIP,pgcsDONE);

     PPOCAGarbageCollector=^TPOCAGarbageCollector;
     TPOCAGarbageCollector=record
     
      // Ephemeral generation
      WhiteLists:array[boolean] of PPOCAGarbageCollectorLinkedList;
      GrayList:PPOCAGarbageCollectorLinkedList;
      BlackLists:array[boolean] of PPOCAGarbageCollectorLinkedList;

      // Persistent generation
      PersistentLists:array[boolean] of PPOCAGarbageCollectorLinkedList;
      PersistentRootLists:array[boolean] of PPOCAGarbageCollectorLinkedList;

      // Sweeping stuff
      WhiteGhostList:PPOCAGarbageCollectorLinkedList;
      SweepLists:array[boolean] of PPOCAGarbageCollectorLinkedList;

      // Other stuff
      State:TPOCAGarbageCollectorState;
      Lock:pointer;
      ProtectList:TPOCAPointerList;
      Allocated:longint;
      FreeCount:longint;
      AllocationCounter:longint;
      PersistentCycleCounter:longint;
      PersistentForceScan:longbool;
      StepFactor:longint;
      IntervalFactor:longint;
      GhostFactor:longint;
      SweepFactor:longint;
      FlipFactor:longint;
      PersistentThreshold:longint;
      PersistentInterval:longint;
      FullCollect:longbool;
      LocalContextPoolSize:longint;
      ContextCacheSize:longint;
      MinimumBlockSize:longint;
      ScanContextGrays:longint;
      ScanPoolGrays:longint;
      
     end;

     TPOCARequestGarbageCollection=(brgcNONE,brgcCYCLE,brgcFULLEPHEMERAL,brgcFULL);

     PPOCAGlobals=^TPOCAGlobals;
     TPOCAGlobals=record
      Instance:PPOCAInstance;

      Pools:TPOCAPools;

{$ifdef POCAHasJIT}
      NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;
{$endif}

      GarbageCollector:TPOCAGarbageCollector;

      DeadBlocks:PPointer;
      DeadSize:longint;
      DeadCount:longint;
      DeadAllocationCount:longint;

      ThreadCount:longint;
      WaitCount:longint;
      RequestGarbageCollection:TPOCARequestGarbageCollection;
      Bottleneck:longbool;
      Lock:pointer;
      Semaphore:pointer;

      SourceFiles:TPOCAValue;

      UniqueStringArray:TPOCAValue;
      UniqueStringHashMap:TPOCAStringHashMap;
      UniqueStringLock:pointer;

      ArgumentsValueReference:TPOCAValue;
      ConstructorValueReference:TPOCAValue;

      NullValueReference:TPOCAValue;
      ReferenceValueReference:TPOCAValue;
      NumberValueReference:TPOCAValue;
      StringValueReference:TPOCAValue;
      ArrayValueReference:TPOCAValue;
      GhostClassValueReference:TPOCAValue;
      ClassValueReference:TPOCAValue;
      GhostModuleValueReference:TPOCAValue;
      ModuleValueReference:TPOCAValue;
      GhostHashValueReference:TPOCAValue;
      HashValueReference:TPOCAValue;
      FunctionValueReference:TPOCAValue;
      ClassGhostValueReference:TPOCAValue;  
      ModuleGhostValueReference:TPOCAValue;
      HashGhostValueReference:TPOCAValue;
      GhostValueReference:TPOCAValue;
      CodeValueReference:TPOCAValue;
      NativeCodeValueReference:TPOCAValue;
      UnknownValueReference:TPOCAValue;

      Symbols:TPOCAValue;

      Save:TPOCAValue;

      Namespace:TPOCAValue;

      HiddenNamespace:TPOCAValue;

      BaseClass:TPOCAValue;

      ArrayHash:TPOCAValue;
      NumberHash:TPOCAValue;
      StringHash:TPOCAValue;
      RegExpHash:TPOCAValue;
      CoroutineHash:TPOCAValue;
      ThreadHash:TPOCAValue;
      LockHash:TPOCAValue;
      SemaphoreHash:TPOCAValue;

      FreeContextCount:longint;
      FreeContexts:PPOCAContext;

      FirstContext:PPOCAContext;
      LastContext:PPOCAContext;
     end;

     PPOCAFrameStack=^TPOCAFrameStack;
     TPOCAFrameStack=array[0..POCA_MAX_RECURSION-1] of TPOCAFrame;

     TPOCAContext=record
      Instance:PPOCAInstance;

      Active:longbool;

      GarbageCollectorLockCount:longint;

      ContextObjectPools:TPOCAContextObjectPools;

      FrameStack:TPOCAFrameStack;
      FrameTop:longint;

      TemporarySavedObjects:PPPOCAObjects;
      TemporarySavedObjectCount:longint;
      TemporarySavedObjectSize:longint;

      GrayList:PPOCAGarbageCollectorLinkedList;

      CallDepth:longint;
      CallParent:PPOCAContext;
      CallChild:PPOCAContext;

      CoroutineData:pointer;

      ThreadData:pointer;

      UserData:pointer;

      NextFree:PPOCAContext;

      Previous:PPOCAContext;
      Next:PPOCAContext;
     end;

     TPOCAInstance=record
      Globals:TPOCAGlobals;
      SourceFiles:TStringList;
      IncludeDirectories:TStringList;
      AutomaticSemicolonInsertion:boolean;
     end;

     EPOCAError=class(Exception)
      public
       SourceFile,SourceLine,SourceColumn:longint;
       Value:TPOCAValue;
       constructor Create(const AMessage:TPOCAUTF8String); overload;
       constructor Create(const ASourceFile,ASourceLine,ASourceColumn:longint;const AMessage:TPOCAUTF8String); overload;
       constructor Create(const AValue:TPOCAValue); overload;
       constructor Create(const ASourceFile,ASourceLine,ASourceColumn:longint;const AValue:TPOCAValue); overload;
     end;

     EPOCASyntaxError=class(EPOCAError);

     EPOCARuntimeError=class(EPOCAError);

     EPOCAScriptError=class(EPOCAError);

     EPOCARegExpNFACollectError=class(EPOCAError);

     TPOCANativeObjectMethod=function(const Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint):TPOCAValue of object;

     PPOCANativeObjectProperty=^TPOCANativeObjectProperty;
     TPOCANativeObjectProperty=record
      Key:TPOCAValue;
      PropInfo:PPropInfo;
      Method:TPOCANativeObjectMethod;
      Value:TPOCAValue;
     end;

     TPOCANativeObjectProperties=array of TPOCANativeObjectProperty;

     TPOCANativeObject=class
      private
       fInstance:PPOCAInstance;
       fExpandable:boolean;
       fPropList:PPropList;
       fPropListLen:longint;
       fPropHashMap:TPOCAStringHashMap;
       fProperties:TPOCANativeObjectProperties;
       fCountProperties:longint;
       fGhostType:TPOCAGhostType;
       fGhostValue:TPOCAValue;
       fHashValue:TPOCAValue;
       fEventsHashValue:TPOCAValue;
      public
       constructor Create(const pInstance:PPOCAInstance;const pContext:PPOCAContext;const pPrototype,pConstructor:PPOCAValue;const pExpandable:boolean); reintroduce; virtual;
       destructor Destroy; override;
       function Mark:boolean; virtual;
       function FindPropertyIndex(const Context:PPOCAContext;const Key:TPOCAValue;const CacheIndex:PLongword=nil):longint; virtual;
       function GetPropertyValue(const Context:PPOCAContext;const PropertyIndex:longint;var Value:TPOCAValue):boolean; virtual;
       function SetPropertyValue(const Context:PPOCAContext;const PropertyIndex:longint;const Value:TPOCAValue):boolean; virtual;
       property Instance:PPOCAInstance read fInstance;
       property Expandable:boolean read fExpandable;
       property GhostValue:TPOCAValue read fGhostValue;
       property HashValue:TPOCAValue read fHashValue;
       property EventsHashValue:TPOCAValue read fEventsHashValue;
     end;

const POCAValueNull:TPOCAValue=({$ifdef cpu64}Reference:(Ptr:pointer(TPOCAPtrUInt(POCAValueReferenceSignalMask)));{$else}{$ifdef LITTLE_ENDIAN}Reference:(Ptr:nil);ReferenceTag:POCAValueReferenceTag;{$else}ReferenceTag:POCAValueReferenceTag;Reference:(Ptr:nil);{$endif}{$endif});

      POCATypeSizes:array[pvtNULL..pvtGHOST] of longint=(-1, // pvtNULL
                                                         -1, // pvtNUMBER
                                                         -1, // pvtREFERENCE
                                                         sizeof(TPOCAString),
                                                         sizeof(TPOCAArray),
                                                         sizeof(TPOCAHash),
                                                         sizeof(TPOCACode),
                                                         sizeof(TPOCAFunction),
                                                         sizeof(TPOCANativeCode),
                                                         sizeof(TPOCAGhost));

      POCADefaultFormatSettings:TFormatSettings=(
{$ifdef DelphiXEAndUp}
        CurrencyString:'$';
        CurrencyFormat:1;
        CurrencyDecimals:2;
        DateSeparator:'-';
        TimeSeparator:':';
        ListSeparator:',';
        ShortDateFormat:'d/m/y';
        LongDateFormat:'dd" "mmmm" "yyyy';
        TimeAMString:'AM';
        TimePMString:'PM';
        ShortTimeFormat:'hh:nn';
        LongTimeFormat:'hh:nn:ss';
        ShortMonthNames:('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec');
        LongMonthNames:('January','February','March','April','May','June','July','August','September','October','November','December');
        ShortDayNames:('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
        LongDayNames:('Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday');
        ThousandSeparator:',';
        DecimalSeparator:'.';
        TwoDigitYearCenturyWindow:50;
        NegCurrFormat:5;
{$else}
       CurrencyFormat:1;
       NegCurrFormat:5;
       ThousandSeparator:',';
       DecimalSeparator:'.';
       CurrencyDecimals:2;
       DateSeparator:'-';
       TimeSeparator:':';
       ListSeparator:',';
       CurrencyString:'$';
       ShortDateFormat:'d/m/y';
       LongDateFormat:'dd" "mmmm" "yyyy';
       TimeAMString:'AM';
       TimePMString:'PM';
       ShortTimeFormat:'hh:nn';
       LongTimeFormat:'hh:nn:ss';
       ShortMonthNames:('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec');
       LongMonthNames:('January','February','March','April','May','June','July','August','September','October','November','December');
       ShortDayNames:('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
       LongDayNames:('Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday');
       TwoDigitYearCenturyWindow:50;
{$endif}
      );

      POCALocaleCharset:TPOCAUTF8String='UTF8';

{$ifdef BIG_ENDIAN}
      POCADoubleNaN:TPOCADoubleBytes=($7f,$ff,$ff,$ff,$ff,$ff,$ff,$ff);
      POCADoubleInfPos:TPOCADoubleBytes=($7f,$f0,$00,$00,$00,$00,$00,$00);
      POCADoubleInfNeg:TPOCADoubleBytes=($ff,$f0,$00,$00,$00,$00,$00,$00);
      POCADoubleMax:TPOCADoubleBytes=($7f,$ef,$ff,$ff,$ff,$ff,$ff,$ff);
      POCADoubleMin:TPOCADoubleBytes=($00,$00,$00,$00,$00,$00,$00,$01);
{$else}
      POCADoubleNaN:TPOCADoubleBytes=($ff,$ff,$ff,$ff,$ff,$ff,$ff,$7f);
      POCADoubleInfPos:TPOCADoubleBytes=($00,$00,$00,$00,$00,$00,$f0,$7f);
      POCADoubleInfNeg:TPOCADoubleBytes=($00,$00,$00,$00,$00,$00,$f0,$ff);
      POCADoubleMax:TPOCADoubleBytes=($ff,$ff,$ff,$ff,$ff,$ff,$ef,$7f);
      POCADoubleMin:TPOCADoubleBytes=($01,$00,$00,$00,$00,$00,$00,$00);
{$endif}
      POCADoubleZero:double=0.0;
      POCADoubleOne:double=1.0;

var POCALocaleFormatSettings:TFormatSettings;

{$ifdef POCAHasJIT}
{$ifdef unix}
    fpmprotect:function(__addr:pointer;__len:cardinal;__prot:longint):longint; cdecl;// external 'c' name 'mprotect';
{$endif}
{$endif}

function POCARoundUpToPowerOfTwo(x:TPOCAPtrUInt):TPOCAPtrUInt; {$ifdef caninline}inline;{$endif}
function POCARoundUpToMask(x,m:TPOCAPtrUInt):TPOCAPtrUInt; {$ifdef caninline}inline;{$endif}

function POCAIsNaN(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsFinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsPosInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsNegInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsPosZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsNegZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsNegative(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}

function POCADoubleAbsolute(const AValue:double):double; {$ifdef caninline}inline;{$endif}

function POCADoubleToString(const AValue:double):TPOCARawByteString;

function POCARegExpCompile(Context:PPOCAContext;const s:TPOCARawByteString;IsUTF8:longint):TFLRE;

function POCAGetValueType(const v:TPOCAValue):longint; {$ifdef caninline}inline;{$endif}
function POCAGetValueReferencePointer(const v:TPOCAValue):pointer; {$ifdef caninline}inline;{$endif}
procedure POCASetValueReferencePointer(out v:TPOCAValue;const Ptr:pointer); {$ifdef caninline}inline;{$endif}
procedure POCASetValueNumber(out v:TPOCAValue;const n:double); {$ifdef caninline}inline;{$endif}

function POCAIsValueReference(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueNumber(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueObject(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueObjectAndGetReferencePointer(const v:TPOCAValue;var p):boolean;
function POCAIsValueNull(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueReferenceType(const v:TPOCAValue;t:longint):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueSimpleHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueEventHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueGhostEventHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAGetValueHashType(const v:TPOCAValue):longint; {$ifdef caninline}inline;{$endif}
function POCAIsValueCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueFunction(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueFunctionOrNativeCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueNativeCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueGhost(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueScalarType(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAIsValueIdentical(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}

function POCALockCreate:pointer;
procedure POCALockDestroy(var Lock:pointer);
procedure POCALockEnter(Lock:pointer);
procedure POCALockLeave(Lock:pointer);

function POCASemaphoreCreate:pointer;
procedure POCASemaphoreDestroy(var Semaphore:pointer);
procedure POCASemaphoreDown(Semaphore:pointer);
procedure POCASemaphoreUp(Semaphore:pointer;Count:longint);

procedure POCAWait; {$ifdef cpu386}register;{$endif}

procedure POCAMRSWLockInit(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockDone(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockReadLock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockReadUnlock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockWriteLock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockWriteUnlock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockReadToWrite(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
procedure POCAMRSWLockWriteToRead(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;{$endif}
function POCAMRSWLockReaders(MRSWLock:PPOCAMRSWLock):longint; {$ifdef cpu386}register;{$endif}
function POCAMRSWLockWriters(MRSWLock:PPOCAMRSWLock):longint; {$ifdef cpu386}register;{$endif}

procedure POCAGarbageCollectorWriteBarrier(const ParentObj:PPOCAObject;const Value:TPOCAValue);

procedure POCATemporarySave(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}

procedure POCAProtect(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}
procedure POCAUnprotect(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}

function POCATypeOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;

function POCAIDOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;

function POCAGhostTypeOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;

function POCAObject(Instance:PPOCAInstance;ValueType:longint;Obj:PPOCAObject):TPOCAValue;

function POCAIsValueTrue(Context:PPOCAContext;const Value:TPOCAValue):boolean; {$ifdef UseRegister}register;{$endif}

function POCABooleanValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCANumberValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCAStringValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}

function POCAGetBooleanValue(Context:PPOCAContext;const Value:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAGetNumberValue(Context:PPOCAContext;const Value:TPOCAValue):double; {$ifdef caninline}inline;{$endif}
function POCAGetStringValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCARawByteString; {$ifdef caninline}inline;{$endif}
function POCAGetVariantValue(Context:PPOCAContext;const Value:TPOCAValue):Variant; {$ifdef caninline}inline;{$endif}

function POCAIsStringUTF8(Context:PPOCAContext;const Value:TPOCAValue):boolean;
function POCAGetStringUTF8(Context:PPOCAContext;const Value:TPOCAValue):longint;
function POCAGetStringUTF8Length(Context:PPOCAContext;const Value:TPOCAValue):longint;

function POCANew(Context:PPOCAContext;ValueType:longint;var Obj:PPOCAObject):TPOCAValue;

function POCAStringUTF8GetCodeUnit(Context:PPOCAContext;const Value:TPOCAValue;CodePoint:longint):longint;
function POCAStringUTF8GetCodePoint(Context:PPOCAContext;const Value:TPOCAValue;CodeUnit:longint):longint;
function POCAStringUTF8CopyCodePointRange(Context:PPOCAContext;const Value:TPOCAValue;FromCodePoint,ToCodePoint:longint):TPOCARawByteString;
procedure POCAStringUpdate(Context:PPOCAContext;const Value:TPOCAValue);

function POCANewNumber(Context:PPOCAContext;const Data:double=0.0):TPOCAValue;
function POCANewString(Context:PPOCAContext;const Data:TPOCARawByteString=''):TPOCAValue;
function POCANewUniqueString(Context:PPOCAContext;const Data:TPOCARawByteString=''):TPOCAValue;
function POCANewArray(Context:PPOCAContext):TPOCAValue;
function POCANewHash(Context:PPOCAContext):TPOCAValue;
function POCANewCode(Context:PPOCAContext):TPOCAValue;
function POCANewNativeCode(Context:PPOCAContext;const FunctionPointer:TPOCANativeFunction;const DestroyFunctionPointer:TPOCANativeDestroyFunction=nil;const UserData:pointer=nil):TPOCAValue;
function POCANewFunction(Context:PPOCAContext;const Code:TPOCAValue):TPOCAValue;
function POCANewGhost(Context:PPOCAContext;const GhostType:PPOCAGhostType;const Ptr:pointer;const Hash:PPOCAHash=nil;const PtrType:TPOCAGhostPtrType=pgptRAW):TPOCAValue;
function POCANewNativeObject(Context:PPOCAContext;const NativeObjectValue:TPOCANativeObject):TPOCAValue;
function POCANewValueFromVariant(Context:PPOCAContext;const VariantValue:Variant):TPOCAValue;

function POCAGhostGetType(const r:TPOCAValue):PPOCAGhostType; {$ifdef caninline}inline;{$endif}
function POCAGhostGetPointer(const r:TPOCAValue):pointer; {$ifdef caninline}inline;{$endif}
function POCAGhostGetHash(const r:TPOCAValue):PPOCAHash; {$ifdef caninline}inline;{$endif}
function POCAGhostGetHashValue(const r:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCAGhostSetHash(const r:TPOCAValue;const h:PPOCAHash):boolean; {$ifdef caninline}inline;{$endif}
function POCAGhostSetHashValue(const r,h:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}

procedure POCAAtomicSetValue(var Dst:TPOCAValue;const Src:TPOCAValue);
function POCANil:TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCAEndToken:TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCANumber(Num:double):TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCAString(Context:PPOCAContext;const Str:TPOCARawByteString):TPOCAValue; {$ifdef caninline}inline;{$endif}
function POCAEqual(const a,b:TPOCAValue):boolean; overload;
function POCAStrictEqual(const a,b:TPOCAValue):boolean; overload;
function POCACompareString(const a,b:TPOCARawByteString):longint;
function POCACompare(Context:PPOCAContext;const a,b:TPOCAValue):longint;
function POCAEqual(const a:TPOCAValue;const s:TPOCARawByteString):boolean; overload;
function POCAStrictEqual(const a:TPOCAValue;const s:TPOCARawByteString):boolean; overload;
function POCAStringEqual(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
function POCAObjectEqual(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}

procedure POCASetUserData(Context:PPOCAContext;p:pointer); {$ifdef caninline}inline;{$endif}
function POCAGetUserData(Context:PPOCAContext):pointer; {$ifdef caninline}inline;{$endif}

procedure POCAAddSymbol(Context:PPOCAContext;const Dst:TPOCAValue;Symbol:TPOCARawByteString;const Value:TPOCAValue); {$ifdef caninline}inline;{$endif}

procedure POCAAddNativeFunction(Context:PPOCAContext;const Hash:TPOCAValue;const FunctionName:TPOCARawByteString;const FunctionPointer:TPOCANativeFunction;const DestroyFunctionPointer:TPOCANativeDestroyFunction=nil;const UserData:pointer=nil); {$ifdef caninline}inline;{$endif}

function POCAInternSymbol(Context:PPOCAContext;Instance:PPOCAInstance;const Symbol:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}

function POCAMarkValue(Instance:PPOCAInstance;const Value:TPOCAValue):longbool;

function POCAArrayGet(const ArrayObject:TPOCAValue;i:longint):TPOCAValue;
procedure POCAArraySet(const ArrayObject:TPOCAValue;i:longint;const Value:TPOCAValue);
function POCAArraySize(const ArrayObject:TPOCAValue):longword;
function POCAArrayPush(const ArrayObject:TPOCAValue;const Value:TPOCAValue):longword;
function POCAArrayRangePush(Context:PPOCAContext;const ArrayObject:TPOCAValue;const FromValue,ToValue:TPOCAValue):longword;
procedure POCAArraySetSize(const ArrayObject:TPOCAValue;Size:longint);
function POCAArrayPop(const ArrayObject:TPOCAValue):TPOCAValue;
procedure POCAArraySort(Context:PPOCAContext;const ArrayObject:TPOCAValue);

function POCAHashString(const Str:TPOCARawByteString):longword;
function POCAHashNumber(const Num:double):longword;
function POCAHashObj(const Obj:pointer):longword;

procedure POCAHashLockInvalidate(Hash:PPOCAHash);
procedure POCAHashInvalidate(Hash:PPOCAHash);

procedure POCAHashRebuildCache(Hash:PPOCAHash);

procedure POCAHashClearPrototype(Hash:PPOCAHash);
function POCAHashSetPrototype(Context:PPOCAContext;const Hash:TPOCAValue;const Prototype:PPOCAHash):longbool;
function POCAHashSetPrototypeValue(Context:PPOCAContext;const Hash,Prototype:TPOCAValue):longbool;
function POCAHashGetPrototype(const Hash:TPOCAValue):PPOCAHash;
function POCAHashGetPrototypeValue(const Hash:TPOCAValue):TPOCAValue;

procedure POCAHashClearConstructor(Hash:PPOCAHash);
function POCAHashSetConstructor(Context:PPOCAContext;const Hash:TPOCAValue;const Constructor_:PPOCAObject):longbool;
function POCAHashSetConstructorValue(Context:PPOCAContext;const Hash,Constructor_:TPOCAValue):longbool;
function POCAHashGetConstructor(const Hash:TPOCAValue):PPOCAObject;
function POCAHashGetConstructorValue(const Hash:TPOCAValue):TPOCAValue;

function POCAHashSetHashEvents(Context:PPOCAContext;const ToHash,FromHash:TPOCAValue):longbool;
function POCAHashGetHashEventsHash(const Hash:TPOCAValue):TPOCAValue;
function POCAHashGetHashEvents(const Hash:TPOCAValue):PPOCAHashEvents; overload;
function POCAHashGetHashEvents(const Hash:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;
function POCAHashGetHashEvents(const v1,v2:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;
function POCAHashGetHashEvents(const v1,v2,v3:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;

function POCAHashSetGhost(Context:PPOCAContext;const Hash:TPOCAValue;Ghost:PPOCAGhost):longbool;
function POCAHashSetGhostValue(Context:PPOCAContext;const Hash,Ghost:TPOCAValue):longbool;
function POCAHashGetGhost(const Hash:TPOCAValue):PPOCAGhost;
function POCAHashGetGhostValue(const Hash:TPOCAValue):TPOCAValue;

function POCAHashSetKind(Context:PPOCAContext;const Hash:TPOCAValue;Kind:longint):longbool;
function POCAHashGetKind(const Hash:TPOCAValue):longint;

function POCAHashRawSize(const Hash:TPOCAValue):longint;
function POCAHashRawExist(const Hash:TPOCAValue;const Key:TPOCAValue):boolean;
function POCAHashRawGet(const Hash:TPOCAValue;const Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
function POCAHashRawSet(const Hash,Key,Value:TPOCAValue):boolean;
function POCAHashRawDelete(const Hash,Key:TPOCAValue):boolean;
procedure POCAHashRawKeys(const Dst,Hash:TPOCAValue);
function POCAHashSize(Context:PPOCAContext;const Hash:TPOCAValue):longint;
function POCAHashExist(Context:PPOCAContext;const Hash,Key:TPOCAValue):boolean;
function POCAHashGet(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
function POCAHashGetInherited(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
function POCAHashSet(Context:PPOCAContext;const Hash,Key,Value:TPOCAValue):boolean;
function POCAHashDelete(Context:PPOCAContext;const Hash,Key:TPOCAValue):boolean;
procedure POCAHashOwnKeys(Context:PPOCAContext;const Dst,Hash:TPOCAValue);
procedure POCAHashKeys(Context:PPOCAContext;const Dst,Hash:TPOCAValue);
function POCAHashGetString(Context:PPOCAContext;const Hash:TPOCAValue;const Key:TPOCARawByteString):TPOCAValue;
procedure POCAHashSetString(Context:PPOCAContext;const Hash:TPOCAValue;const Key:TPOCARawByteString;const Value:TPOCAValue);
procedure POCAHashCombine(Context:PPOCAContext;const Hash,Source:TPOCAValue);
function POCAHashInstanceOf(Context:PPOCAContext;const Hash,OfHash:TPOCAValue):longbool;
function POCAHashIs(Context:PPOCAContext;const Hash,OfObject:TPOCAValue):longbool;

function POCAObjectInstanceOf(Context:PPOCAContext;const Value,OfValue:TPOCAValue):longbool; {$ifdef caninline}inline;{$endif}
function POCAObjectIs(Context:PPOCAContext;const Value,OfValue:TPOCAValue):longbool; {$ifdef caninline}inline;{$endif}

function POCAContextCreate(Instance:PPOCAInstance):PPOCAContext;
procedure POCAContextDestroy(Context:PPOCAContext);
function POCAContextSub(Super:PPOCAContext):PPOCAContext;

function POCAInstanceCreate:PPOCAInstance;
procedure POCAInstanceDestroy(var Instance:PPOCAInstance);

function POCACompile(Instance:PPOCAInstance;Context:PPOCAContext;const Source:TPOCARawByteString;const SourceFileName:TPOCARawByteString=''):TPOCAValue;

procedure POCASave(Context:PPOCAContext;Obj:TPOCAValue);

function POCAStackDepth(Context:PPOCAContext):longint;

function POCAFindFrame(Context:PPOCAContext;var OutContext:PPOCAContext;FrameNumber:longint):longint;

function POCAGetSourceLine(Context:PPOCAContext;FrameNumber:longint):longint;

function POCAGetSourceFile(Context:PPOCAContext;FrameNumber:longint):longint;

function POCABindToContext(Context:PPOCAContext;Code:TPOCAValue):TPOCAValue;

function POCACall(Context:PPOCAContext;Func:TPOCAValue;Arguments:PPOCAValues;CountArguments:longint;Obj:TPOCAValue;Locals:TPOCAValue):TPOCAValue;

procedure POCARuntimeError(Context:PPOCAContext;const Msg:TPOCAUTF8String);

function POCARun(Context:PPOCAContext):TPOCAValue;

function POCAGetFileContent(FileName:TPOCAUTF8String):TPOCARawByteString;

procedure InitializePOCA;
procedure FinalizePOCA;

implementation

//const EPSILON=1e-18;
const ConstructorValueSymbolString:TPOCARawByteString='$|constuctor|$';

type TPOCALexerKeywordTokens=array[TPOCATokenType] of TPOCARawByteString;

     PPOCALexerKeywordTokenCharTreeNode=^TPOCALexerKeywordTokenCharTreeNode;
     TPOCALexerKeywordTokenCharTreeNode=record
      Children:array[TPOCAKeywordChars] of PPOCALexerKeywordTokenCharTreeNode;
      HasChildren:boolean;
      Token:TPOCATokenType;
     end;

const POCAInitialized:boolean=false;

{$ifdef POCAHasJIT}
      bncmmMemoryBlockSignature:TPOCAPtrUInt={$ifdef cpu64}$1337bab3deadc0d3{$else}$deadc0d3{$endif};

      bncmmMINBLOCKCONTAINERSIZE=1048576;
{$endif}

      FPUExceptionMask:TFPUExceptionMask=[exInvalidOp,exDenormalized,exZeroDivide,exOverflow,exUnderflow,exPrecision];
      FPURoundingMode:TFPURoundingMode=rmNearest;
      FPUPrecisionMode:TFPUPrecisionMode={$ifdef HAS_TYPE_EXTENDED}pmEXTENDED{$else}pmDOUBLE{$endif};

//    HASH_MAGIC=longword(2654435769);

      CELL_EMPTY=-1;
      CELL_DELETED=-2;

      ENT_EMPTY=-1;
      ENT_DELETED=-2;

var LexerKeywordTokens:TPOCALexerKeywordTokens;
    LexerKeywordTokenCharTreeRootNode:PPOCALexerKeywordTokenCharTreeNode;

    MetaOpNames:TPOCAMetaOpNames;
    MetaOpNamesHashMap:TPOCAStringHashMap;

{$warnings off}
procedure InitializeLocaleFormatSettings;
{$ifdef windows}
{$ifdef fpc}
var i:longint;
begin
 POCALocaleCharset:='ISO-8859-1';
 POCALocaleFormatSettings:=POCADefaultFormatSettings;
 for i:= 1 to 12 do begin
  POCALocaleFormatSettings.ShortMonthNames[i]:=SysUtils.ShortMonthNames[i];
  POCALocaleFormatSettings.LongMonthNames[i]:=SysUtils.LongMonthNames[i];
 end;
 for i:=1 to 7 do begin
  POCALocaleFormatSettings.ShortDayNames[i]:=SysUtils.ShortDayNames[i];
  POCALocaleFormatSettings.LongDayNames[i]:=SysUtils.LongDayNames[i];
 end;
 POCALocaleFormatSettings.DateSeparator:=SysUtils.DateSeparator;
 POCALocaleFormatSettings.ShortDateFormat:=SysUtils.ShortDateFormat;
 POCALocaleFormatSettings.LongDateFormat:=SysUtils.LongDateFormat;
 POCALocaleFormatSettings.TimeSeparator:=SysUtils.TimeSeparator;
 POCALocaleFormatSettings.TimeAMString:=SysUtils.TimeAMString;
 POCALocaleFormatSettings.TimePMString:=SysUtils.TimePMString;
 POCALocaleFormatSettings.ShortTimeFormat:=SysUtils.ShortTimeFormat;
 POCALocaleFormatSettings.LongTimeFormat:=SysUtils.LongTimeFormat;
 POCALocaleFormatSettings.CurrencyString:=SysUtils.CurrencyString;
 POCALocaleFormatSettings.CurrencyFormat:=SysUtils.CurrencyFormat;
 POCALocaleFormatSettings.NegCurrFormat:=SysUtils.NegCurrFormat;
 POCALocaleFormatSettings.ThousandSeparator:=SysUtils.ThousandSeparator;
 POCALocaleFormatSettings.DecimalSeparator:=SysUtils.DecimalSeparator;
 POCALocaleFormatSettings.CurrencyDecimals:=SysUtils.CurrencyDecimals;
 POCALocaleFormatSettings.ListSeparator:=SysUtils.ListSeparator;
end;
{$else}
var HourFormat,TimePrefix,TimePostfix:TPOCAUTF8String;
    LID:LCID;
    i,LCP,Day:longint;
begin
 POCALocaleFormatSettings:=POCADefaultFormatSettings;
 LID:=GetThreadLocale;
 if not TryStrToInt(GetLocaleStr(LID,LOCALE_IDEFAULTANSICODEPAGE,inttostr(GetACP)),LCP) then begin
  LCP:=GetACP;
 end;
 if LCP>0 then begin
  POCALocaleCharset:='WINDOWS-'+inttostr(LCP);
 end else begin
  POCALocaleCharset:='ISO_8859_1';
 end;
{$ifdef DelphiXEAndUp}
 for i:=1 to 12 do begin
  POCALocaleFormatSettings.ShortMonthNames[i]:=GetLocaleStr(LID,LOCALE_SABBREVMONTHNAME1+i-1,FormatSettings.ShortMonthNames[i]);
  POCALocaleFormatSettings.LongMonthNames[i]:=GetLocaleStr(LID,LOCALE_SMONTHNAME1+i-1,FormatSettings.LongMonthNames[i]);
 end;
 for i:=1 to 7 do begin
  Day:=(i+5) mod 7;
  POCALocaleFormatSettings.ShortDayNames[i]:=GetLocaleStr(LID,LOCALE_SABBREVDAYNAME1+Day,FormatSettings.ShortDayNames[i]);
  POCALocaleFormatSettings.LongDayNames[i]:=GetLocaleStr(LID,LOCALE_SDAYNAME1+Day,FormatSettings.LongDayNames[i]);
 end;
{$else}
 for i:=1 to 12 do begin
  POCALocaleFormatSettings.ShortMonthNames[i]:=GetLocaleStr(LID,LOCALE_SABBREVMONTHNAME1+i-1,ShortMonthNames[i]);
  POCALocaleFormatSettings.LongMonthNames[i]:=GetLocaleStr(LID,LOCALE_SMONTHNAME1+i-1,LongMonthNames[i]);
 end;
 for i:=1 to 7 do begin
  Day:=(i+5) mod 7;
  POCALocaleFormatSettings.ShortDayNames[i]:=GetLocaleStr(LID,LOCALE_SABBREVDAYNAME1+Day,ShortDayNames[i]);
  POCALocaleFormatSettings.LongDayNames[i]:=GetLocaleStr(LID,LOCALE_SDAYNAME1+Day,LongDayNames[i]);
 end;
{$endif}
 POCALocaleFormatSettings.DateSeparator:=GetLocaleChar(LID,LOCALE_SDATE,'/');
 POCALocaleFormatSettings.ShortDateFormat:=GetLocaleStr(LID,LOCALE_SSHORTDATE,'m/d/yy');
 POCALocaleFormatSettings.LongDateFormat:=GetLocaleStr(LID,LOCALE_SLONGDATE,'mmmm d, yyyy');
 POCALocaleFormatSettings.TimeSeparator:=GetLocaleChar(LID,LOCALE_STIME,':');
 POCALocaleFormatSettings.TimeAMString:=GetLocaleStr(LID,LOCALE_S1159,'AM');
 POCALocaleFormatSettings.TimePMString:=GetLocaleStr(LID,LOCALE_S2359,'PM');
 if StrToIntDef(GetLocaleStr(LID,LOCALE_ITLZERO,'0'),0)=0 then begin
  HourFormat:='h';
 end else begin
  HourFormat:='hh';
 end;
 TimePostfix:='';
 TimePrefix:='';
 if StrToIntDef(GetLocaleStr(LID,LOCALE_ITIME,'0'),0)=0 then begin
  if StrToIntDef(GetLocaleStr(LID,LOCALE_ITIMEMARKPOSN,'0'),0)=0 then begin
   TimePostfix:=' AMPM';
  end else begin
   TimePrefix:='AMPM ';
  end;
 end;
 POCALocaleFormatSettings.ShortTimeFormat:=TimePrefix+HourFormat+':nn'+TimePrefix;
 POCALocaleFormatSettings.LongTimeFormat:=TimePrefix+HourFormat+':nn:ss'+TimePrefix;
 POCALocaleFormatSettings.CurrencyString:=GetLocaleStr(LID,LOCALE_SCURRENCY,'');
 POCALocaleFormatSettings.CurrencyFormat:=StrToIntDef(GetLocaleStr(LID,LOCALE_ICURRENCY,'0'),0);
 POCALocaleFormatSettings.NegCurrFormat:=StrToIntDef(GetLocaleStr(LID,LOCALE_INEGCURR,'0'),0);
 POCALocaleFormatSettings.ThousandSeparator:=GetLocaleChar(LID,LOCALE_STHOUSAND,',');
 POCALocaleFormatSettings.DecimalSeparator:=GetLocaleChar(LID,LOCALE_SDECIMAL,'.');
 POCALocaleFormatSettings.CurrencyDecimals:=StrToIntDef(GetLocaleStr(LID,LOCALE_ICURRDIGITS,'0'),0);
 POCALocaleFormatSettings.ListSeparator:=GetLocaleChar(LID,LOCALE_SLIST,',');
end;
{$endif}
{$else}
var i:longint;
begin
 POCALocaleCharset:='ISO-8859-1';
 POCALocaleFormatSettings:=POCADefaultFormatSettings;
 for i:= 1 to 12 do begin
  POCALocaleFormatSettings.ShortMonthNames[i]:=SysUtils.ShortMonthNames[i];
  POCALocaleFormatSettings.LongMonthNames[i]:=SysUtils.LongMonthNames[i];
 end;
 for i:=1 to 7 do begin
  POCALocaleFormatSettings.ShortDayNames[i]:=SysUtils.ShortDayNames[i];
  POCALocaleFormatSettings.LongDayNames[i]:=SysUtils.LongDayNames[i];
 end;
 POCALocaleFormatSettings.DateSeparator:=SysUtils.DateSeparator;
 POCALocaleFormatSettings.ShortDateFormat:=SysUtils.ShortDateFormat;
 POCALocaleFormatSettings.LongDateFormat:=SysUtils.LongDateFormat;
 POCALocaleFormatSettings.TimeSeparator:=SysUtils.TimeSeparator;
 POCALocaleFormatSettings.TimeAMString:=SysUtils.TimeAMString;
 POCALocaleFormatSettings.TimePMString:=SysUtils.TimePMString;
 POCALocaleFormatSettings.ShortTimeFormat:=SysUtils.ShortTimeFormat;
 POCALocaleFormatSettings.LongTimeFormat:=SysUtils.LongTimeFormat;
 POCALocaleFormatSettings.CurrencyString:=SysUtils.CurrencyString;
 POCALocaleFormatSettings.CurrencyFormat:=SysUtils.CurrencyFormat;
 POCALocaleFormatSettings.NegCurrFormat:=SysUtils.NegCurrFormat;
 POCALocaleFormatSettings.ThousandSeparator:=SysUtils.ThousandSeparator;
 POCALocaleFormatSettings.DecimalSeparator:=SysUtils.DecimalSeparator;
 POCALocaleFormatSettings.CurrencyDecimals:=SysUtils.CurrencyDecimals;
 POCALocaleFormatSettings.ListSeparator:=SysUtils.ListSeparator;
end;
{$endif}
{$warnings on}

function PosEx(const SubStr,s:TPOCARawByteString;Offset:longint=1):longint;
var i,x,LenSubStr:longint;
begin
 if Offset=1 then begin
  result:=System.Pos(SubStr,s);
 end else begin
  result:=0;
  LenSubStr:=length(SubStr);
  for i:=Offset to (length(s)-LenSubStr)+1 do begin
   if s[i]=SubStr[1] then begin
    x:=1;
    while (x<LenSubStr) and (s[i+x]=SubStr[x+1]) do begin
     inc(x);
    end;
    if x=LenSubStr then begin
     result:=i;
     break;
    end;
   end;
  end;
 end;
end;

{$if defined(fpc) and defined(Linux)}
type TReadLine_readline=function(_para1:PAnsiChar):PAnsiChar; cdecl;
     TReadLine_add_history=procedure(_para1:PAnsiChar); cdecl;
     TReadLine_free=procedure(_para1:Pointer); cdecl;

var ReadLine_readline:TReadLine_readline=nil;
    ReadLine_add_history:TReadLine_add_history=nil;
    ReadLine_free:TReadLine_free=nil;
    ReadLine_LibHandle:TLibHandle=NilHandle;
    ReadLine_CLibHandle:TLibHandle=NilHandle;
    ReadLine_Initialized_State:TPasMPInt32=0;

procedure ReadLine_Initialize;
var Index:TPOCAInt32;
begin
 if TPasMPInterlocked.CompareExchange(ReadLine_Initialized_State,1,0)=0 then begin
  try
   try
    ReadLine_LibHandle:=SafeLoadLibrary('libreadline.so');
    if ReadLine_LibHandle<>NilHandle then begin
     @ReadLine_readline:=GetProcAddress(ReadLine_LibHandle,'readline');
     @ReadLine_add_history:=GetProcAddress(ReadLine_LibHandle,'add_history');
    end;
    for Index:=-1 to 128 do begin
     if Index<0 then begin
      ReadLine_CLibHandle:=SafeLoadLibrary('libc.so');
     end else begin
      ReadLine_CLibHandle:=SafeLoadLibrary('libc.so.'+IntToStr(Index));
     end;
     if ReadLine_CLibHandle<>NilHandle then begin
      break;
     end;
    end;
    if ReadLine_CLibHandle<>NilHandle then begin
     @ReadLine_free:=GetProcAddress(ReadLine_CLibHandle,'free');
    end;
   except
   end;
  finally
   TPasMPInterlocked.Write(ReadLine_Initialized_State,2);
  end;
 end else begin
  while TPasMPInterlocked.Read(ReadLine_Initialized_State)<>2 do begin
   TPasMP.Relax;
  end;
 end;
end;
{$ifend}

function ReadLine(const aPrompt:TPOCAUTF8String):TPOCAUTF8String;
{$if defined(fpc) and defined(Linux)}
var s:TPOCAUTF16String;
    p:PAnsiChar;
begin
 ReadLine_Initialize;
 if assigned(ReadLine_readline) and assigned(ReadLine_add_history) and assigned(ReadLine_free) then begin
  if length(aPrompt)>0 then begin
   p:=ReadLine_readline(PAnsiChar(aPrompt));
  end else begin
   p:=ReadLine_readline(nil);
  end;
  if assigned(p) then begin
   result:=PUCUUTF8Correct(p);
   if length(trim(result))>0 then begin
    ReadLine_add_history(p);
   end;
   ReadLine_free(p);
  end else begin
   result:='';
  end;
 end else begin
  s:='';
  if length(aPrompt)>0 then begin
   System.Write(aPrompt);
  end;
  System.ReadLn(s);
  result:=PUCUUTF16ToUTF8(s);
 end;
end;
{$else}
var s:TPOCAUTF16String;
begin
 s:='';
 System.ReadLn(s);
 result:=PUCUUTF16ToUTF8(s);
end;
{$ifend}

function CompareEx(const SubStr,s:TPOCARawByteString;Offset:longint=1):boolean;
var i,x,LenSubStr:longint;
begin
 result:=false;
 i:=Offset;
 LenSubStr:=length(SubStr);
 if (i<=((Length(s)-LenSubStr)+1)) and (s[i]=SubStr[1]) then begin
  x:=1;
  while (x<LenSubStr) and (s[i+x]=SubStr[x+1]) do begin
   inc(x);
  end;
  result:=x=LenSubStr;
 end;
end;

function POCARoundUpToPowerOfTwo(x:TPOCAPtrUInt):TPOCAPtrUInt; {$ifdef caninline}inline;{$endif}
begin
 dec(x);
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
{$ifdef cpu64}
 x:=x or (x shr 32);
{$endif}
 result:=x+1;
end;

function POCARoundUpToMask(x,m:TPOCAPtrUInt):TPOCAPtrUInt; {$ifdef caninline}inline;{$endif}
begin
 if (x and (m-1))<>0 then begin
  result:=(x+m) and not (m-1);
 end else begin
  result:=x;
 end;
end;

{$ifdef cpu64}
function POCAIsNaN(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=((PPOCAINT64(@AValue)^ and $7ff0000000000000)=$7ff0000000000000) and ((PPOCAINT64(@AValue)^ and $000fffffffffffff)<>$0000000000000000);
end;

function POCAIsInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCAINT64(@AValue)^ and $7fffffffffffffff)=$7ff0000000000000;
end;

function POCAIsFinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCAINT64(@AValue)^ and $7ff0000000000000)<>$7ff0000000000000;
end;

function POCAIsPosInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=PPOCAINT64(@AValue)^=int64($7ff0000000000000);
end;

function POCAIsNegInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
{$ifdef fpc}
 result:=UInt64(pointer(@AValue)^)=UInt64($fff0000000000000);
{$else}
 result:=PPOCAINT64(@AValue)^=int64($fff0000000000000);
{$endif}
end;

function POCAIsPosZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=PPOCAINT64(@AValue)^=int64($0000000000000000);
end;

function POCAIsNegZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
{$ifdef fpc}
 result:=UInt64(pointer(@AValue)^)=UInt64($8000000000000000);
{$else}
 result:=PPOCAINT64(@AValue)^=int64($8000000000000000);
{$endif}
end;

function POCAIsZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
{$ifdef fpc}
 result:=(UInt64(pointer(@AValue)^) and UInt64($7fffffffffffffff))=UInt64($0000000000000000);
{$else}
 result:=(PPOCAINT64(@AValue)^ and int64($7fffffffffffffff))=int64($0000000000000000);
{$endif}
end;

function POCAIsNegative(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
{$ifdef fpc}
 result:=(UInt64(pointer(@AValue)^) and UInt64($8000000000000000))<>0;
{$else}
 result:=(PPOCAINT64(@AValue)^ shr 63)<>0;
{$endif}
end;
{$else}
{$ifdef TrickyNumberChecks}
function POCAIsNaN(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
var l:longword;
begin
 l:=PPOCADoubleHiLo(@AValue)^.Lo;
 result:=(longword($7ff00000-longword(longword(PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff) or ((l or (-l)) shr 31))) shr 31)<>0;
end;

function POCAIsInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=longword((longword(PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff) xor $7ff00000) or PPOCADoubleHiLo(@AValue)^.Lo)=0;
end;

function POCAIsFinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(longword((PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff)-$7ff00000) shr 31)<>0;
end;

function POCAIsPosInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
var h:longword;
begin
 h:=PPOCADoubleHiLo(@AValue)^.Hi;
 result:=longword(((longword(h and $7fffffff) xor $7ff00000) or PPOCADoubleHiLo(@AValue)^.Lo) or longword(h shr 31))=0;
end;

function POCAIsNegInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
var h:longword;
begin
 h:=PPOCADoubleHiLo(@AValue)^.Hi;
 result:=longword(((longword(h and $7fffffff) xor $7ff00000) or PPOCADoubleHiLo(@AValue)^.Lo) or longword(longword(not h) shr 31))=0;
end;

function POCAIsPosZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
var h:longword;
begin
 h:=PPOCADoubleHiLo(@AValue)^.Hi;
 result:=longword(longword(longword(h and $7fffffff) or PPOCADoubleHiLo(@AValue)^.Lo) or longword(h shr 31))=0;
end;

function POCAIsNegZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
var h:longword;
begin
 h:=PPOCADoubleHiLo(@AValue)^.Hi;
 result:=longword(longword(longword(h and $7fffffff) or PPOCADoubleHiLo(@AValue)^.Lo) or longword(longword(not h) shr 31))=0;
end;

function POCAIsZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=longword(longword(PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff) or PPOCADoubleHiLo(@AValue)^.Lo)=0;
end;

function POCAIsNegative(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=longword(PPOCADoubleHiLo(@AValue)^.Hi and longword($80000000))<>0;
end;
{$else}
function POCAIsNaN(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=((PPOCADoubleHiLo(@AValue)^.Hi and $7ff00000)=$7ff00000) and (((PPOCADoubleHiLo(@AValue)^.Hi and $000fffff) or PPOCADoubleHiLo(@AValue)^.Lo)<>0);
end;

function POCAIsInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=((PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff)=$7ff00000) and (PPOCADoubleHiLo(@AValue)^.Lo=0);
end;

function POCAIsFinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi and $7ff00000)<>$7ff00000;
end;

function POCAIsPosInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi=$7ff00000) and (PPOCADoubleHiLo(@AValue)^.Lo=0);
end;

function POCAIsNegInfinite(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi=$fff00000) and (PPOCADoubleHiLo(@AValue)^.Lo=0);
end;

function POCAIsPosZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi or PPOCADoubleHiLo(@AValue)^.Lo)=0;
end;

function POCAIsNegZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi=$80000000) and (PPOCADoubleHiLo(@AValue)^.Lo=0);
end;

function POCAIsZero(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=((PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff) or PPOCADoubleHiLo(@AValue)^.Lo)=0;
end;

function POCAIsNegative(const AValue:double):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(PPOCADoubleHiLo(@AValue)^.Hi and $80000000)<>0;
end;
{$endif}
{$endif}

function POCADoubleAbsolute(const AValue:double):double; {$ifdef caninline}inline;{$endif}
begin
{$ifdef cpu64}
 PPOCAINT64(@result)^:=PPOCAINT64(@AValue)^ and $7fffffffffffffff;
{$else}
 PPOCADoubleHiLo(@result)^.Hi:=PPOCADoubleHiLo(@AValue)^.Hi and $7fffffff;
 PPOCADoubleHiLo(@result)^.Lo:=PPOCADoubleHiLo(@AValue)^.Lo;
{$endif}
end;

function Floor(FloatValue:double):double; {$ifdef caninline}inline;{$endif}
begin
 result:=System.int(FloatValue);
 if System.frac(FloatValue)<0 then begin
  result:=result-1;
 end;
end;

function Ceil(FloatValue:double):double; {$ifdef caninline}inline;{$endif}
begin
 result:=System.int(FloatValue);
 if System.frac(FloatValue)>0 then begin
  result:=result+1;
 end;
end;

function Modulo(x,y:double):double;{$ifdef cpu386}stdcall; assembler;
asm
 fld qword ptr y
 fld qword ptr x
 @Repeat:
  fprem
  fstsw ax
  sahf
  jp @Repeat
 fstp st(1)
end;
{$else}
begin
 result:=x-(Floor(x/y)*y);
end;
{$endif}

function POCADoubleToString(const AValue:double):TPOCARawByteString;
begin
 result:=ConvertDoubleToString(AValue,omStandard,0);
end;

procedure GetMemAligned(var p;Size:TPOCAPtrInt;Align:TPOCAPtrUInt=16);
{$ifdef DelphiXE2AndUp}
begin
 GetMem(pointer(p),Size);
end;
{$else}
var Original,Aligned:pointer;
    Temp:PPointer;
    Mask:TPOCAPtrUInt;
begin
 if (Align and (Align-1))<>0 then begin
  dec(Align);
  Align:=Align or (Align shr 1);
  Align:=Align or (Align shr 2);
  Align:=Align or (Align shr 4);
  Align:=Align or (Align shr 8);
  Align:=Align or (Align shr 16);
{$ifdef cpu64}
  Align:=Align or (Align shr 32);
{$endif}
  inc(Align);
 end;
 Mask:=Align-1;
 inc(Size,((Align shl 1)+sizeof(pointer)));
 GetMem(Original,Size);
 FillChar(Original^,Size,#0);
 Aligned:=pointer(TPOCAPtrUInt(TPOCAPtrUInt(Original)+sizeof(pointer)));
 if (Align>1) and ((TPOCAPtrUInt(Aligned) and Mask)<>0) then begin
  inc(TPOCAPtrUInt(Aligned),TPOCAPtrUInt(TPOCAPtrUInt(Align)-(TPOCAPtrUInt(Aligned) and Mask)));
 end;
 Temp:=pointer(TPOCAPtrUInt(TPOCAPtrUInt(Aligned)-sizeof(pointer)));
 Temp^:=Original;
 Temp:=pointer(@p);
 Temp^:=Aligned;
end;
{$endif}

procedure FreeMemAligned(const p);
{$ifdef DelphiXE2AndUp}
begin
 FreeMem(pointer(p));
end;
{$else}
var pp:pointer;
begin
 pp:=pointer(pointer(@p)^);
 if assigned(pp) then begin
  pp:=pointer(pointer(TPOCAPtrUInt(TPOCAPtrUInt(pp)-sizeof(pointer)))^);
  FreeMem(pp);
 end;
end;
{$endif}

{$ifdef POCAHasJIT}
procedure POCANativeCodeMemoryManagerFreeBlockContainer(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;BlockContainer:PPOCANativeCodeMemoryManagerBlockContainer); forward;

function POCANativeCodeMemoryManagerCreate(Instance:PPOCAInstance):PPOCANativeCodeMemoryManager;
{$ifdef windows}
var SystemInfo:TSystemInfo;
{$else}
{$ifdef unix}
{$endif}
{$endif}
begin
 New(result);
 FillChar(result^,sizeof(TPOCANativeCodeMemoryManager),#0);
 result^.Instance:=Instance;
{$ifdef windows}
 GetSystemInfo(SystemInfo);
 result^.PageSize:=POCARoundUpToPowerOfTwo(SystemInfo.dwPageSize);
{$else}
{$ifdef unix}
 result^.PageSize:=4096;
{$else}
 result^.PageSize:=4096;
{$endif}
{$endif}
{$ifdef cpu386}
 result^.Alignment:=16;
{$else}
{$ifdef cpuamd64}
 result^.Alignment:=16;
{$else}
{$ifdef cpuarm}
 result^.Alignment:=16;
{$else}
 result^.Alignment:=PageSize;
{$endif}
{$endif}
{$endif}
 result^.First:=nil;
 result^.Last:=nil;
end;

procedure POCANativeCodeMemoryManagerDestroy(var NativeCodeMemoryManager:PPOCANativeCodeMemoryManager);
begin
 if assigned(NativeCodeMemoryManager) then begin
  while assigned(NativeCodeMemoryManager^.First) do begin
   POCANativeCodeMemoryManagerFreeBlockContainer(NativeCodeMemoryManager,NativeCodeMemoryManager^.First);
  end;
  Dispose(NativeCodeMemoryManager);
  NativeCodeMemoryManager:=nil;
 end;
end;

function POCANativeCodeMemoryManagerAllocateBlockContainer(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;BlockContainerSize:TPOCAPtrUInt):PPOCANativeCodeMemoryManagerBlockContainer;
var Size:TPOCAPtrUInt;
    Block:PPOCANativeCodeMemoryManagerBlock;
begin
 if BlockContainerSize>0 then begin
  Size:=POCARoundUpToMask(BlockContainerSize,NativeCodeMemoryManager^.PageSize);
  New(result);
{$ifdef windows}
  result^.Base:=VirtualAlloc(nil,Size,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
{$else}
{$ifdef unix}
  result^.Base:=fpmmap(nil,Size,PROT_READ or PROT_WRITE or PROT_EXEC,MAP_PRIVATE or MAP_ANONYMOUS,-1,0);
{$else}
  GetMem(result^.Base,Size);
{$endif}
{$endif}
  result^.Size:=Size;
  result^.Used:=sizeof(TPOCANativeCodeMemoryManagerBlock)*2;
  if assigned(NativeCodeMemoryManager^.Last) then begin
   NativeCodeMemoryManager^.Last^.Next:=result;
   result^.Previous:=NativeCodeMemoryManager^.Last;
   NativeCodeMemoryManager^.Last:=result;
   result^.Next:=nil;
  end else begin
   NativeCodeMemoryManager^.First:=result;
   NativeCodeMemoryManager^.Last:=result;
   result^.Previous:=nil;
   result^.Next:=nil;
  end;
  FillChar(result^.Base^,result^.Size,#0);
  result^.First:=result^.Base;
  result^.Last:=pointer(@pansichar(result^.Base)[result^.Size-sizeof(TPOCANativeCodeMemoryManagerBlock)]);
  Block:=result^.First;
  Block^.Signature:=bncmmMemoryBlockSignature;
  Block^.Previous:=nil;
  Block^.Next:=result^.Last;
  Block^.Size:=0;
  Block:=result^.Last;
  Block^.Signature:=bncmmMemoryBlockSignature;
  Block^.Previous:=result^.First;
  Block^.Next:=nil;
  Block^.Size:=0;
 end else begin
  result:=nil;
 end;
end;

procedure POCANativeCodeMemoryManagerFreeBlockContainer(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;BlockContainer:PPOCANativeCodeMemoryManagerBlockContainer);
begin
 if assigned(BlockContainer^.Previous) then begin
  BlockContainer^.Previous^.Next:=BlockContainer^.Next;
 end else if NativeCodeMemoryManager^.First=BlockContainer then begin
  NativeCodeMemoryManager^.First:=BlockContainer^.Next;
 end;
 if assigned(BlockContainer^.Next) then begin
  BlockContainer^.Next^.Previous:=BlockContainer^.Previous;
 end else if NativeCodeMemoryManager^.Last=BlockContainer^.Previous then begin
  NativeCodeMemoryManager^.Last:=BlockContainer^.Previous;
 end;
{$ifdef windows}
 VirtualFree(BlockContainer^.Base,0,MEM_RELEASE);
{$else}
{$ifdef unix}
 fpmunmap(BlockContainer^.Base,BlockContainer^.Size);
{$else}
 FreeMem(BlockContainer^.Base);
{$endif}
{$endif}
 Dispose(BlockContainer);
end;

function POCANativeCodeMemoryManagerGetMemory(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;Size:TPOCAPtrUInt):pointer;
var BlockContainer:PPOCANativeCodeMemoryManagerBlockContainer;
    CurrentBlock,NewBlock:PPOCANativeCodeMemoryManagerBlock;
    DestSize,BlockContainerSize:TPOCAPtrUInt;
begin
 result:=nil;
 if Size>0 then begin
  DestSize:=Size+sizeof(TPOCANativeCodeMemoryManagerBlock);
  BlockContainer:=NativeCodeMemoryManager^.First;
  repeat
   while assigned(BlockContainer) do begin
    if (BlockContainer^.Used+DestSize)<=BlockContainer^.Size then begin
     CurrentBlock:=BlockContainer^.First;
     while assigned(CurrentBlock) and (CurrentBlock^.Signature=bncmmMemoryBlockSignature) and assigned(CurrentBlock^.Next) do begin
      NewBlock:=pointer(TPOCAPtrUInt(POCARoundUpToMask(TPOCAPtrUInt(pointer(@pansichar(CurrentBlock)[(sizeof(TPOCANativeCodeMemoryManagerBlock)*2)+CurrentBlock^.Size])),NativeCodeMemoryManager^.Alignment)-sizeof(TPOCANativeCodeMemoryManagerBlock)));
      if (TPOCAPtrUInt(CurrentBlock^.Next)-TPOCAPtrUInt(NewBlock))>=DestSize then begin
       NewBlock^.Signature:=bncmmMemoryBlockSignature;
       NewBlock^.Previous:=CurrentBlock;
       NewBlock^.Next:=CurrentBlock^.Next;
       NewBlock^.Size:=Size;
       CurrentBlock^.Next^.Previous:=NewBlock;
       CurrentBlock^.Next:=NewBlock;
       result:=pointer(@pansichar(NewBlock)[sizeof(TPOCANativeCodeMemoryManagerBlock)]);
       inc(BlockContainer^.Used,DestSize);
       exit;
      end else begin
       CurrentBlock:=CurrentBlock^.Next;
      end;
     end;
    end;
    BlockContainer:=BlockContainer^.Next;
   end;
   if DestSize<=bncmmMINBLOCKCONTAINERSIZE then begin
    BlockContainerSize:=bncmmMINBLOCKCONTAINERSIZE;
   end else begin
    BlockContainerSize:=POCARoundUpToPowerOfTwo(DestSize);
   end;
   BlockContainer:=POCANativeCodeMemoryManagerAllocateBlockContainer(NativeCodeMemoryManager,BlockContainerSize);
   if not assigned(BlockContainer) then begin
    break;
   end;
  until false;
 end;
end;

procedure POCANativeCodeMemoryManagerFreeMemory(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;p:pointer);
var BlockContainer:PPOCANativeCodeMemoryManagerBlockContainer;
    CurrentBlock:PPOCANativeCodeMemoryManagerBlock;
begin
 BlockContainer:=NativeCodeMemoryManager^.First;
 while assigned(BlockContainer) do begin
  if ((TPOCAPtrUInt(BlockContainer^.Base)+sizeof(TPOCANativeCodeMemoryManagerBlock))<=TPOCAPtrUInt(p)) and ((TPOCAPtrUInt(p)+sizeof(TPOCANativeCodeMemoryManagerBlock))<(TPOCAPtrUInt(BlockContainer^.Base)+BlockContainer^.Size)) then begin
   CurrentBlock:=pointer(TPOCAPtrUInt(TPOCAPtrUInt(p)-sizeof(TPOCANativeCodeMemoryManagerBlock)));
   if (CurrentBlock^.Signature=bncmmMemoryBlockSignature) and (CurrentBlock<>BlockContainer^.First) and (CurrentBlock<>BlockContainer^.Last) then begin
    dec(BlockContainer^.Used,CurrentBlock^.Size+sizeof(TPOCANativeCodeMemoryManagerBlock));
    CurrentBlock^.Signature:=0;
    CurrentBlock^.Previous^.Next:=CurrentBlock^.Next;
    CurrentBlock^.Next^.Previous:=CurrentBlock^.Previous;
    if (assigned(BlockContainer^.First) and (BlockContainer^.First^.Next=BlockContainer^.Last)) or not assigned(BlockContainer^.First) then begin
     POCANativeCodeMemoryManagerFreeBlockContainer(NativeCodeMemoryManager,BlockContainer);
    end;
    exit;
   end;
  end;
  BlockContainer:=BlockContainer^.Next;
 end;
end;

function POCANativeCodeMemoryManagerReallocateMemory(NativeCodeMemoryManager:PPOCANativeCodeMemoryManager;p:pointer;Size:TPOCAPtrUInt):pointer;
var BlockContainer:PPOCANativeCodeMemoryManagerBlockContainer;
    CurrentBlock:PPOCANativeCodeMemoryManagerBlock;
    DestSize:TPOCAPtrUInt;
begin
 result:=nil;
 if assigned(p) then begin
  if Size=0 then begin
   POCANativeCodeMemoryManagerFreeMemory(NativeCodeMemoryManager,p);
  end else begin
   DestSize:=Size+sizeof(TPOCANativeCodeMemoryManagerBlock);
   BlockContainer:=NativeCodeMemoryManager^.First;
   while assigned(BlockContainer) do begin
    if ((TPOCAPtrUInt(BlockContainer^.Base)+sizeof(TPOCANativeCodeMemoryManagerBlock))<=TPOCAPtrUInt(p)) and ((TPOCAPtrUInt(p)+sizeof(TPOCANativeCodeMemoryManagerBlock))<(TPOCAPtrUInt(BlockContainer^.Base)+BlockContainer^.Size)) then begin
     CurrentBlock:=pointer(TPOCAPtrUInt(TPOCAPtrUInt(p)-sizeof(TPOCANativeCodeMemoryManagerBlock)));
     if (CurrentBlock^.Signature=bncmmMemoryBlockSignature) and (CurrentBlock<>BlockContainer^.First) and (CurrentBlock<>BlockContainer^.Last) then begin
      if (TPOCAPtrUInt(CurrentBlock^.Next)-TPOCAPtrUInt(CurrentBlock))>=DestSize then begin
       CurrentBlock^.Size:=Size;
       result:=p;
       exit;
      end else begin
       result:=POCANativeCodeMemoryManagerGetMemory(NativeCodeMemoryManager,Size);
       if assigned(result) then begin
        if CurrentBlock^.Size<Size then begin
         Move(p^,result^,CurrentBlock^.Size);
        end else begin
         Move(p^,result^,Size);
        end;
       end;
       POCANativeCodeMemoryManagerFreeMemory(NativeCodeMemoryManager,p);
       exit;
      end;
     end;
    end;
    BlockContainer:=BlockContainer^.Next;
   end;
  end;
  POCANativeCodeMemoryManagerFreeMemory(NativeCodeMemoryManager,p);
 end else if Size<>0 then begin
  result:=POCANativeCodeMemoryManagerGetMemory(NativeCodeMemoryManager,Size);
 end;
end;
{$endif}

procedure POCAGarbageCollectorLinkedListReset(List:PPOCAGarbageCollectorLinkedList); //{$ifdef caninline}inline;{$endif}
begin
 List^.Previous:=List;
 List^.Next:=List;
end;

procedure POCAGarbageCollectorLinkedListRemove(Obj:PPOCAObject); {$ifdef caninline}inline;{$endif}
var Node:PPOCAGarbageCollectorLinkedList absolute Obj;
begin
 Node^.Previous^.Next:=Node^.Next;
 Node^.Next^.Previous:=Node^.Previous;
 Node^.Previous:=Node;
 Node^.Next:=Node;
end;

procedure POCAGarbageCollectorLinkedListPush(List:PPOCAGarbageCollectorLinkedList;Obj:PPOCAObject); {$ifdef caninline}inline;{$endif}
var Node:PPOCAGarbageCollectorLinkedList absolute Obj;
begin
 Node^.Previous:=List^.Previous;
 Node^.Next:=List;
 List^.Previous^.Next:=Node;
 List^.Previous:=Node;
end;

function POCAGarbageCollectorLinkedListPop(List:PPOCAGarbageCollectorLinkedList;out Obj:PPOCAObject):boolean; {$ifdef caninline}inline;{$endif}
var Node:PPOCAGarbageCollectorLinkedList;
begin
 Node:=List^.Next;
 result:=Node<>List;
 if result then begin
  Obj:=pointer(Node);
  Node^.Previous^.Next:=Node^.Next;
  Node^.Next^.Previous:=Node^.Previous;
  Node^.Previous:=Node;
  Node^.Next:=Node;
 end else begin
  Obj:=nil;
 end;
end;

procedure POCAGarbageCollectorLinkedListMove(FromList,ToList:PPOCAGarbageCollectorLinkedList); //{$ifdef caninline}inline;{$endif}
var First,Last:PPOCAGarbageCollectorLinkedList;
begin
 if FromList^.Next<>FromList then begin
  First:=FromList^.Next;
  Last:=FromList^.Previous;
  First^.Previous:=ToList^.Previous;
  ToList^.Previous^.Next:=First;
  Last^.Next:=ToList;
  ToList^.Previous:=Last;
  FromList^.Previous:=FromList;
  FromList^.Next:=FromList;
 end;
end;
{var Obj:PPOCAObject;
begin
 while POCAGarbageCollectorLinkedListPop(FromList,Obj) do begin
  POCAGarbageCollectorLinkedListPush(ToList,Obj);
 end;
end;}

procedure POCAGarbageCollectorLinkedListMoveMark(FromList,ToList:PPOCAGarbageCollectorLinkedList;BitsToAdd:longword); //{$ifdef caninline}inline;{$endif}
var Obj:PPOCAObject;
begin
 Obj:=nil;
 while POCAGarbageCollectorLinkedListPop(FromList,Obj) do begin
  POCAGarbageCollectorLinkedListPush(ToList,Obj);
  Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or BitsToAdd;
 end;
end;

procedure POCAGarbageCollectorWriteBarrierMark(const GarbageCollector:PPOCAGarbageCollector;const Obj:PPOCAObject);
var PoolBlock:PPOCAPoolBlock;
begin
 // Obj: white -> gray
 PoolBlock:=Obj^.Header.PoolBlock;
 while TPasMPInterlocked.CompareExchange(PoolBlock^.Spin,-1,0)<>0 do begin
 end;
 try
  // Re-check after locking
  if (Obj^.Header.GarbageCollector.State and pgcbNOWHITE)=0 then begin
   // Move to gray list
   TPasMPInterlocked.Exchange(GarbageCollector^.ScanPoolGrays,-1);
   POCAGarbageCollectorLinkedListRemove(Obj);
   POCAGarbageCollectorLinkedListPush(PoolBlock^.GrayList,Obj);
   Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbGRAY;
  end;
 finally
  TPasMPInterlocked.Exchange(PoolBlock^.Spin,0);
 end;
end;

procedure POCAGarbageCollectorWriteBarrierMarkParent(const GarbageCollector:PPOCAGarbageCollector;const ParentObj:PPOCAObject);
var PoolBlock:PPOCAPoolBlock;
begin
 // ParentObj: white -> gray
 PoolBlock:=ParentObj^.Header.PoolBlock;
 while TPasMPInterlocked.CompareExchange(PoolBlock^.Spin,-1,0)<>0 do begin
 end;
 try
  TPasMPInterlocked.Exchange(GarbageCollector^.ScanPoolGrays,-1);
  POCAGarbageCollectorLinkedListRemove(ParentObj);
  POCAGarbageCollectorLinkedListPush(PoolBlock^.GrayList,ParentObj);
  ParentObj^.Header.GarbageCollector.State:=(ParentObj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbGRAY;
 finally
  TPasMPInterlocked.Exchange(PoolBlock^.Spin,0);
 end;
end;

procedure POCAGarbageCollectorWriteBarrierPersistent(const GarbageCollector:PPOCAGarbageCollector;const ParentObj:PPOCAObject);
var PoolBlock:PPOCAPoolBlock;
begin
 PoolBlock:=ParentObj^.Header.PoolBlock;
 while TPasMPInterlocked.CompareExchange(PoolBlock^.Spin,-1,0)<>0 do begin
 end;
 try
  POCALockEnter(GarbageCollector^.Lock);
  try
   // Re-check after locking
   if (ParentObj^.Header.GarbageCollector.State and pgcbPERSISTENT)<>0 then begin
    // Move from persistent non-root list to persistent root list (a ka remembered set)
    POCAGarbageCollectorLinkedListRemove(ParentObj);
    POCAGarbageCollectorLinkedListPush(GarbageCollector^.PersistentRootLists[ParentObj^.Header.ValueType=pvtGHOST],ParentObj);
    ParentObj^.Header.GarbageCollector.State:=(ParentObj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbPERSISTENTROOT;
   end;
  finally
   POCALockLeave(GarbageCollector^.Lock);
  end;
 finally
  TPasMPInterlocked.Exchange(PoolBlock^.Spin,0);
 end;
end;

procedure POCAGarbageCollectorWriteBarrier(const ParentObj:PPOCAObject;const Value:TPOCAValue);
var GarbageCollector:PPOCAGarbageCollector;
    Obj:PPOCAObject;
begin
 if POCAIsValueObjectAndGetReferencePointer(Value,Obj) then begin
  GarbageCollector:=@ParentObj^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance^.Globals.GarbageCollector;

  // Write-barrier (forward barrier: white -> gray)
  // Pre-check before locking
  if (Obj^.Header.GarbageCollector.State and pgcbNOWHITE)=0 then begin
   if assigned(ParentObj) then begin
    if (ParentObj^.Header.GarbageCollector.State and pgcbBLACK)<>0 then begin
     // The parent holder object is in the black object list, so mark our to-store-object gray
     POCAGarbageCollectorWriteBarrierMark(GarbageCollector,Obj);
    end else if (ParentObj^.Header.GarbageCollector.State and pgcbNOWHITE)=0 then begin
     // The parent holder object is in the white object list, so mark the parent holder object gray
     POCAGarbageCollectorWriteBarrierMarkParent(GarbageCollector,ParentObj);
    end;
   end else begin
    // Mark our object gray, if ParentObj is null
    POCAGarbageCollectorWriteBarrierMark(GarbageCollector,Obj);
   end;
  end;

  // Persistent -> ephemeral inter-generation-reference write-barrier
  // Pre-check before locking
  if assigned(ParentObj) and
     (((Obj^.Header.GarbageCollector.State and (pgcbPERSISTENT or pgcbPERSISTENTROOT))=0) and
      ((ParentObj^.Header.GarbageCollector.State and pgcbPERSISTENT)<>0)) then begin
   POCAGarbageCollectorWriteBarrierPersistent(GarbageCollector,ParentObj);
  end;

 end;
end;

{$if defined(cpuamd64) and not defined(fpc)}
procedure POCA_x86_64_Pause; assembler; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifndef fpc}
 .noframe
{$endif}
 rep nop
end;
{$ifend}

procedure POCAWait; {$ifdef cpu386}register;{$endif}
{$ifdef unix}
{$ifndef usecthreads}
var timeout:timeval;
{$endif}
{$endif}
begin
{$ifdef win32}
 sleep(0);
{$else}
{$ifdef unix}
{$ifdef usecthreads}
 sched_yield;
{$else}
 timeout.tv_sec:=0;
 timeout.tv_usec:=0;
 fpselect(0,nil,nil,nil,@timeout);
{$endif}
{$else}
{$ifdef cpu386}
 asm
  rep nop // aka PAUSE instruction
 end;
{$else}
{$ifdef cpuamd64}
{$ifdef fpc}
 asm
  rep nop // aka PAUSE instruction
 end;
{$else}
 POCA_x86_64_Pause;
{$endif}
{$endif}
{$endif}
{$endif}
{$endif}
end;

procedure POCAMRSWLockInit(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 xor ecx,ecx
 lock xchg dword ptr [eax+TPOCAMRSWLock.State],ecx
end;
{$else}
begin
 TPasMPInterlocked.Exchange(MRSWLock^.State,0);
end;
{$endif}

procedure POCAMRSWLockDone(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 xor ecx,ecx
 lock xchg dword ptr [eax+TPOCAMRSWLock.State],ecx
end;
{$else}
begin
 TPasMPInterlocked.Exchange(MRSWLock^.State,0);
end;
{$endif}

procedure POCAMRSWLockReadLock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 @TryLoop:
 lock inc dword ptr [eax+TPOCAMRSWLock.State]
 js @TryUndo
 jmp @TryLoopDone
 @TryUndo:
 lock dec dword ptr [eax+TPOCAMRSWLock.State]
 @WaitLoop:
 cmp dword ptr [eax+TPOCAMRSWLock.State],0
 js @WaitLoop
 jmp @TryLoop
 @TryLoopDone:
end;
{$else}
var Current:longint;
begin
 repeat
  Current:=MRSWLock^.State and $fffffffe;
 until TPasMPInterlocked.CompareExchange(MRSWLock^.State,Current+2,Current)=Current;
end;
{$endif}

procedure POCAMRSWLockReadUnlock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 lock dec dword ptr [eax+TPOCAMRSWLock.State]
end;
{$else}
begin
 TPasMPInterlocked.Add(MRSWLock^.State,-2);
end;
{$endif}

procedure POCAMRSWLockWriteLock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 @TryLoop:
 lock bts dword ptr [eax+TPOCAMRSWLock.State],31
 jc @WaitLoop
 test dword ptr [eax+TPOCAMRSWLock.State],$7fffffff
 jnz @TryUndo
 jmp @TryLoopDone
 @TryUndo:
 lock btr dword ptr [eax+TPOCAMRSWLock.State],31
 @WaitLoop:
 cmp dword ptr [eax+TPOCAMRSWLock.State],0
 jnz @WaitLoop
 jmp @TryLoop
 @TryLoopDone:
end;
{$else}
var Current:longint;
begin
 repeat
  Current:=MRSWLock^.State and $fffffffe;
 until TPasMPInterlocked.CompareExchange(MRSWLock^.State,Current or 1,Current)=Current;
 while MRSWLock^.State<>1 do begin
 end;
end;
{$endif}

procedure POCAMRSWLockWriteUnlock(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 lock btr dword ptr [eax+TPOCAMRSWLock.State],31
end;
{$else}
begin
 TPasMPInterlocked.Exchange(MRSWLock^.State,0);
end;
{$endif}

procedure POCAMRSWLockReadToWrite(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 // Don't use lock cmpxchg! To avoid dead locks :-)
 lock dec dword ptr [eax+TPOCAMRSWLock.State]
 @TryLoop:
 lock bts dword ptr [eax+TPOCAMRSWLock.State],31
 jc @WaitLoop
 test dword ptr [eax+TPOCAMRSWLock.State],$7fffffff
 jnz @TryUndo
 jmp @TryLoopDone
 @TryUndo:
 lock btr dword ptr [eax+TPOCAMRSWLock.State],31
 @WaitLoop:
 cmp dword ptr [eax+TPOCAMRSWLock.State],0
 jnz @WaitLoop
 jmp @TryLoop
 @TryLoopDone:
end;
{$else}
var Current:longint;
begin
 repeat
  Current:=MRSWLock^.State and $fffffffe;
 until TPasMPInterlocked.CompareExchange(MRSWLock^.State,(Current-2) or 1,Current)=Current;
 while MRSWLock^.State<>1 do begin
 end;
end;
{$endif}

procedure POCAMRSWLockWriteToRead(MRSWLock:PPOCAMRSWLock); {$ifdef cpu386}register;
asm
 mov ecx,1
 lock xchg dword ptr [eax+TPOCAMRSWLock.State],ecx
end;
{$else}
begin
 TPasMPInterlocked.Exchange(MRSWLock^.State,2);
end;
{$endif}

function POCAMRSWLockReaders(MRSWLock:PPOCAMRSWLock):longint; {$ifdef cpu386}register;{$endif}
begin
{$ifdef cpu386}
 result:=longint(longword(MRSWLock^.State and $7fffffff));
{$else}
 result:=longint(longword(MRSWLock^.State shr 1));
{$endif}
end;

function POCAMRSWLockWriters(MRSWLock:PPOCAMRSWLock):longint; {$ifdef cpu386}register;{$endif}
begin
{$ifdef cpu386}
 result:=longint(longword(MRSWLock^.State shr 31));
{$else}
 result:=longint(longword(MRSWLock^.State and 1));
{$endif}
end;

constructor TPOCAPointerList.Create;
begin
 inherited Create;
 List:=nil;
 ListCount:=0;
 ListCapacity:=0;
 Clear;
end;

destructor TPOCAPointerList.Destroy;
begin
 Clear;
 inherited Destroy;
end;

procedure TPOCAPointerList.Clear;
begin
 ListCount:=0;
 ListCapacity:=0;
 if assigned(List) then begin
  FreeMem(List);
  List:=nil;
 end;
end;

procedure TPOCAPointerList.SetCapacity(NewCapacity:longint);
begin
 if (NewCapacity>=0) and (NewCapacity<MaxListSize) then begin
  ReallocMem(List,NewCapacity*sizeof(pointer));
  ListCapacity:=NewCapacity;
  if ListCapacity<ListCount then begin
   ListCount:=ListCapacity;
  end;
  if ListCapacity<NewCapacity then begin
   FillChar(List^[ListCapacity],(NewCapacity-ListCapacity)*sizeof(pointer),#0);
  end;
 end;
end;

procedure TPOCAPointerList.SetCount(NewCount:longint);
var NewCapacity:longint;
begin
 if NewCount<ListCount then begin
  if NewCount<1024 then begin
   NewCapacity:=1024;
  end else begin
   NewCapacity:=POCARoundUpToPowerOfTwo(NewCount);
  end;
  if NewCapacity<>ListCapacity then begin
   ReallocMem(List,NewCapacity*sizeof(pointer));
   ListCapacity:=NewCapacity;
  end;
 end else if NewCount>ListCount then begin
  if NewCount>ListCapacity then begin
   if NewCount<1024 then begin
    NewCapacity:=1024;
   end else begin
    NewCapacity:=POCARoundUpToPowerOfTwo(NewCount);
   end;
   ReallocMem(List,NewCapacity*sizeof(pointer));
   if ListCount<NewCapacity then begin
    FillChar(List^[ListCount],(NewCapacity-ListCount)*sizeof(pointer),#0);
   end else if ListCapacity<NewCapacity then begin
    FillChar(List^[ListCapacity],(NewCapacity-ListCapacity)*sizeof(pointer),#0);
   end;
   ListCapacity:=NewCapacity;
  end;
 end;
 ListCount:=NewCount;
end;

function TPOCAPointerList.Add(Item:pointer):longint;
begin
 result:=ListCount;
 SetCount(result+1);
 List^[result]:=Item;
end;

procedure TPOCAPointerList.Insert(Index:longint;Item:pointer);
var i:longint;
begin
 if (Index>=0) and (Index<ListCount) then begin
  SetCount(ListCount+1);
  for i:=ListCount-1 downto Index do begin
   List^[i+1]:=List^[i];
  end;
  List^[Index]:=Item;
 end else if Index=ListCount then begin
  Add(Item);
 end else if Index>ListCount then begin
  SetCount(Index);
  Add(Item);
 end;
end;

function TPOCAPointerList.Find(Item:pointer):longint;
var i:longint;
begin
 for i:=0 to ListCount-1 do begin
  if List^[i]=Item then begin
   result:=i;
   exit;
  end;
 end;
 result:=-1;
end;

function TPOCAPointerList.IndexOf(Item:pointer):longint;
begin
 result:=Find(Item);
end;

procedure TPOCAPointerList.Delete(Index:longint);
var i,j,k:longint;
begin
 if (Index>=0) and (Index<ListCount) then begin
  k:=ListCount-1;
  j:=Index;
  List^[Index]:=nil;
  for i:=j to k-1 do begin
   List^[i]:=List^[i+1];
  end;
  SetCount(k);
 end;
end;

function TPOCAPointerList.Remove(Item:pointer):longint;
begin
 result:=Find(Item);
 if result>=0 then begin
  Delete(result);
 end;
end;

procedure TPOCAPointerList.Exchange(Index1,Index2:longint);
var TempPointer:pointer;
begin
 if (Index1>=0) and (Index1<ListCount) and (Index2>=0) and (Index2<ListCount) then begin
  TempPointer:=List^[Index1];
  List^[Index1]:=List^[Index2];
  List^[Index2]:=TempPointer;
 end;
end;

function TPOCAPointerList.GetItem(Index:longint):pointer;
begin
 if (Index>=0) and (Index<ListCount) then begin
  result:=List^[Index];
 end else begin
  result:=nil;
 end;
end;

procedure TPOCAPointerList.SetItem(Index:longint;Value:pointer);
begin
 if (Index>=0) and (Index<ListCount) then begin
  List^[Index]:=Value;
 end;
end;

function POCARegExpCompile(Context:PPOCAContext;const s:TPOCARawByteString;IsUTF8:longint):TFLRE;
begin
 result:=nil;
 try
  result:=TFLRE.Create(s,[rfDELIMITERS]);
 except
  on e:Exception do begin
   FreeAndNil(result);
   POCARuntimeError(Context,TPOCAUTF8String(e.Message));
  end;
 end;
end;

{$ifdef unix}
{-$define UseThreadsForCoroutines}
{$else}
{$undef UseThreadsForCoroutines}
{$endif}

{$ifndef UseThreadsForCoroutines}
{$ifdef windows}
function CreateFiber(dwStackSize:longword;lpStartAddress,lpParameter:pointer):pointer; stdcall; external 'kernel32.dll' name 'CreateFiber';
procedure DeleteFiber(lpFiber:pointer); stdcall; external 'kernel32.dll' name 'DeleteFiber';
procedure SwitchToFiber(lpFiber:pointer); stdcall; external 'kernel32.dll' name 'SwitchToFiber';
function ConvertThreadToFiber(lpParameter:pointer):pointer; stdcall; external 'kernel32.dll' name 'ConvertThreadToFiber';

function GetCurrentFiber:pointer; assembler; register;
asm
{$ifdef cpu386}
 mov eax,dword ptr fs:[$10] // $1016
{$else}
{$ifdef cpuamd64}
 mov rax,qword ptr gs:[$20]
{$endif}
{$endif}
end;

function GetFiberData:pointer; assembler; register;
asm
{$ifdef cpu386}
 mov eax,dword ptr fs:[$10] // $1016
 mov eax,dword ptr [eax]
{$else}
{$ifdef cpuamd64}
 mov rax,qword ptr gs:[$20]
 mov rax,qword ptr [rax]
{$endif}
{$endif}
end;
{$else}
{$ifdef cpu386}
type PPOCACoroutineContextJmpBuf=^TPOCACoroutineContextJmpBuf;
     TPOCACoroutineContextJmpBuf=record
      RegEBX,RegESI,RegEDI,RegESP,RegEBP,RegEIP:longword;
      FPUCW:word;
     end;

     PPOCACoroutineContext=^TPOCACoroutineContext;
     TPOCACoroutineContext=record
      JmpBuf:TPOCACoroutineContextJmpBuf;
      Stack:pointer;
      StackSize:longint;
     end;

function POCACoroutineContextSetJmp(JmpBuf:PPOCACoroutineContextJmpBuf):longint; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
 fstcw word ptr [eax+TPOCACoroutineContextJmpBuf.FPUCW]
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegEBX],ebx
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegESI],esi
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegEDI],edi
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegEBP],ebp
 lea edx,dword ptr [esp+4]
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegESP],edx
 mov edx,dword ptr [esp]
 mov dword ptr [eax+TPOCACoroutineContextJmpBuf.RegEIP],edx
 xor eax,eax
end;

procedure POCACoroutineContextLongJmp(JmpBuf:PPOCACoroutineContextJmpBuf;ResultValue:longint); assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
 xchg edx,eax
 fldcw word ptr [edx+TPOCACoroutineContextJmpBuf.FPUCW]
 mov ebx,dword ptr [edx+TPOCACoroutineContextJmpBuf.RegEBX]
 mov esi,dword ptr [edx+TPOCACoroutineContextJmpBuf.RegESI]
 mov edi,dword ptr [edx+TPOCACoroutineContextJmpBuf.RegEDI]
 mov ebp,dword ptr [edx+TPOCACoroutineContextJmpBuf.RegEBP]
 mov esp,dword ptr [edx+TPOCACoroutineContextJmpBuf.RegESP]
 jmp dword ptr [edx+TPOCACoroutineContextJmpBuf.RegEIP]
end;

function POCACoroutineContextCreate(StackSize:longint;Entrypoint,Parameter:pointer):PPOCACoroutineContext;
begin
 New(result);
 FillChar(result^,sizeof(TPOCACoroutineContext),#0);
 if assigned(Entrypoint) then begin
  result^.StackSize:=StackSize;
  GetMem(result^.Stack,StackSize);
  FillChar(result^.Stack^,StackSize,#0);
  POCACoroutineContextSetJmp(@result^.JmpBuf);
  result^.JmpBuf.RegESP:={$ifdef fpc}TPOCAPtrUInt{$else}longword{$endif}(result^.Stack)+longword(StackSize-longint(sizeof(pointer)*2));
  pointer(pointer({$ifdef fpc}TPOCAPtrUInt{$else}longword{$endif}({$ifdef fpc}TPOCAPtrUInt{$else}longword{$endif}(result^.JmpBuf.RegESP+sizeof(pointer))))^):=Parameter;
  result^.JmpBuf.RegEBP:=0;
  result^.JmpBuf.RegEIP:={$ifdef fpc}TPOCAPtrUInt{$else}longword{$endif}(Entrypoint);
 end;
end;

procedure POCACoroutineContextDestroy(Context:PPOCACoroutineContext);
begin
 if assigned(Context) then begin
  if assigned(Context^.Stack) then begin
   FreeMem(Context^.Stack);
   Context^.Stack:=nil;
  end;
  Dispose(Context);
  Context:=nil;
 end;
end;

procedure POCACoroutineContextSwitch(FromContext,ToContext:PPOCACoroutineContext);
begin
 if POCACoroutineContextSetJmp(@FromContext^.JmpBuf)=0 then begin
  POCACoroutineContextLongJmp(@ToContext^.JmpBuf,1);
 end;
end;

procedure POCACoroutineContextGet(Context:PPOCACoroutineContext);
begin
 POCACoroutineContextSetJmp(@Context^.JmpBuf);
end;
{$else}
{$ifdef cpuamd64}
type PPOCACoroutineContextJmpBuf=^TPOCACoroutineContextJmpBuf;
     TPOCACoroutineContextJmpBuf=record
      RegRBX{$ifdef win64},RegRCX{$endif},RegRBP,RegR12,RegR13,RegR14,RegR15,RegRSP,RegRIP{$ifdef win64},RegRSI,RegRDI{$else},RegRDI{$endif}:UInt64;
     end;

     PPOCACoroutineContext=^TPOCACoroutineContext;
     TPOCACoroutineContext=record
      JmpBuf:TPOCACoroutineContextJmpBuf;
      Stack:pointer;
      StackSize:longint;
     end;

function POCACoroutineContextSetJmp(JmpBuf:PPOCACoroutineContextJmpBuf):longint; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifdef win64}
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRBX],rbx
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRCX],rcx
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRBP],rbp
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR12],r12
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR13],r13
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR14],r14
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR15],r15
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRSI],rsi
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRDI],rdi
 lea rdx,qword ptr [rsp+8]
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRSP],rdx
 mov r8,qword ptr [rsp+0]
 mov qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRIP],r8
 xor rax,rax
{$else}
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRBX],rbx
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRBP],rbp
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR12],r12
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR13],r13
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR14],r14
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR15],r15
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRDI],rdi
 lea rdx,qword ptr [rsp+8]
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRSP],rdx
 mov rsi,qword ptr [rsp+0]
 mov qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRIP],rsi
 xor rax,rax
{$endif}
end;

procedure POCACoroutineContextLongJmp(JmpBuf:PPOCACoroutineContextJmpBuf;ResultValue:longint); assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifdef win64}
 mov rbx,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRBX]
 mov rbp,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRBP]
 mov r12,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR12]
 mov r13,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR13]
 mov r14,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR14]
 mov r15,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegR15]
 test edx,edx
 mov eax,1
 cmove edx,eax
 mov eax,edx
 mov rsp,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRSP]
 mov rdx,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRIP]
 mov rsi,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRSI]
 push qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRCX]
 mov rdi,qword ptr [rcx+TPOCACoroutineContextJmpBuf.RegRDI]
 pop rcx
 jmp rdx
{$else}
 mov rbx,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRBX]
 mov rbp,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRBP]
 mov r12,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR12]
 mov r13,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR13]
 mov r14,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR14]
 mov r15,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegR15]
 test esi,esi
 mov eax,1
 cmove esi,eax
 mov eax,esi
 mov rsp,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRSP]
 push qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRDI]
 mov rdx,qword ptr [rdi+TPOCACoroutineContextJmpBuf.RegRIP]
 pop rdi
 jmp rdx
{$endif}
end;

function POCACoroutineContextCreate(StackSize:longint;Entrypoint,Parameter:pointer):PPOCACoroutineContext;
begin
 New(result);
 FillChar(result^,sizeof(TPOCACoroutineContext),#0);
 if assigned(Entrypoint) then begin
  result^.StackSize:=StackSize;
  GetMem(result^.Stack,StackSize);
  FillChar(result^.Stack^,StackSize,#0);
  POCACoroutineContextSetJmp(@result^.JmpBuf);
  result^.JmpBuf.RegRSP:={$ifdef fpc}TPOCAPtrUInt{$else}int64{$endif}(result^.Stack)+{$ifdef fpc}TPOCAPtrUInt{$else}int64{$endif}(StackSize-{$ifdef fpc}TPOCAPtrInt{$else}int64{$endif}(sizeof(pointer)*2));
  pointer(pointer({$ifdef fpc}TPOCAPtrUInt{$else}longword{$endif}({$ifdef fpc}TPOCAPtrUInt{$else}int64{$endif}(result^.JmpBuf.RegRSP+sizeof(pointer))))^):=Parameter;
{$ifdef win64}
  result^.JmpBuf.RegRCX:={$ifdef fpc}TPOCAPtrUInt{$else}{$endif}(Parameter);
{$else}
  result^.JmpBuf.RegRDI:={$ifdef fpc}TPOCAPtrUInt{$else}{$endif}(Parameter);
{$endif}
  result^.JmpBuf.RegRBP:=0;
  result^.JmpBuf.RegRIP:={$ifdef fpc}TPOCAPtrUInt{$else}{$endif}(Entrypoint);
 end;
end;

procedure POCACoroutineContextDestroy(Context:PPOCACoroutineContext);
begin
 if assigned(Context) then begin
  if assigned(Context^.Stack) then begin
   FreeMem(Context^.Stack);
   Context^.Stack:=nil;
  end;
  Dispose(Context);
  Context:=nil;
 end;
end;

procedure POCACoroutineContextSwitch(FromContext,ToContext:PPOCACoroutineContext);
begin
 if POCACoroutineContextSetJmp(@FromContext^.JmpBuf)=0 then begin
  POCACoroutineContextLongJmp(@ToContext^.JmpBuf,1);
 end;
end;

procedure POCACoroutineContextGet(Context:PPOCACoroutineContext);
begin
 POCACoroutineContextSetJmp(@Context^.JmpBuf);
end;
{$else}
{$define UseThreadsForCoroutines}
{$endif}
{$endif}
{$endif}
{$endif}

procedure POCACoroutineYield(Coroutine:PPOCACoroutine); forward;

procedure POCACoroutineEntrypoint(Coroutine:PPOCACoroutine); {$ifndef UseThreadsForCoroutines}{$ifdef cpuamd64}register;{$else}{$ifdef windows}stdcall;{$else}cdecl;{$endif}{$endif}{$endif}
begin
 if assigned(Coroutine) then begin
  if assigned(Coroutine^.Entrypoint) then begin
   Coroutine^.Entrypoint(Coroutine);
  end;
  TPasMPInterlocked.Exchange(Coroutine^.State,pcsINSIDETERMINATED);
  POCACoroutineYield(Coroutine);
 end;
end;

{$ifdef UseThreadsForCoroutines}
type PPOCACoroutineContext=^TPOCACoroutineContext;
     TPOCACoroutineContext=record
      Coroutine:PPOCACoroutine;
      Handle:THandle;
      ThreadID:{$ifdef fpc}TThreadID{$else}THandle{$endif};
      ResumeEvent,YieldEvent:{$ifdef fpc}PRTLEvent{$else}TEvent{$endif};
     end;

{$ifdef fpc}
function POCACoroutineContextEntrypoint(CoroutineContext:Pointer):TPOCAPtrInt;
{$else}
function POCACoroutineContextEntrypoint(CoroutineContext:Pointer):longword;
{$endif}
begin
 if assigned(CoroutineContext) then begin
{$ifdef fpc}
  RTLEventWaitFor(PPOCACoroutineContext(CoroutineContext)^.ResumeEvent);
{$else}
  PPOCACoroutineContext(CoroutineContext)^.ResumeEvent.WaitFor;
  PPOCACoroutineContext(CoroutineContext)^.ResumeEvent.ResetEvent;
{$endif}
  POCACoroutineEntrypoint(PPOCACoroutineContext(CoroutineContext)^.Coroutine);
  EndThread(0);
 end;
end;

function POCACoroutineContextCreate(StackSize:longint;Entrypoint:pointer;Coroutine:PPOCACoroutine):PPOCACoroutineContext;
begin
 New(result);
 FillChar(result^,sizeof(TPOCACoroutineContext),#0);
 if assigned(Entrypoint) then begin
  result^.Coroutine:=Coroutine;
  result^.ResumeEvent:={$ifdef fpc}RTLEventCreate{$else}TEvent.Create(nil,true,false,''){$endif};
  result^.YieldEvent:={$ifdef fpc}RTLEventCreate{$else}TEvent.Create(nil,true,false,''){$endif};
{$ifdef fpc}
  result^.Handle:=BeginThread(POCACoroutineContextEntrypoint,result,result^.ThreadID);
{$else}
  result^.Handle:=BeginThread(nil,StackSize,@POCACoroutineContextEntrypoint,result,0,result^.ThreadID);
{$endif}
 end;
end;

procedure POCACoroutineContextDestroy(Context:PPOCACoroutineContext);
begin
 if assigned(Context) then begin
  try
{$ifdef fpc}
   System.KillThread(Context^.Handle);
{$else}
   TerminateThread(Context^.Handle,0);
{$endif}
  except
  end;
{$ifdef fpc}
  CloseThread(Context^.Handle);
{$else}
{$ifdef win32}
  CloseHandle(Context^.Handle);
{$endif}
{$endif}
{$ifdef fpc}
  RTLEventDestroy(Context^.ResumeEvent);
  RTLEventDestroy(Context^.YieldEvent);
{$else}
  FreeAndNil(Context^.ResumeEvent);
  FreeAndNil(Context^.YieldEvent);
{$endif}
  Dispose(Context);
  Context:=nil;
 end;
end;
{$endif}

function POCACoroutineCreate(EntryPoint:pointer;StackSize:longint;Parameter:pointer):PPOCACoroutine;
begin
 if StackSize=0 then begin
  StackSize:=65536;
 end;
 New(result);
 FillChar(result^,sizeof(TPOCACoroutine),#0);
 result^.Entrypoint:=EntryPoint;
 result^.Parameter:=Parameter;
 result^.State:=pcsOUTSIDE;
 result^.Event:={$ifdef fpc}RTLEventCreate{$else}TEvent.Create(nil,true,false,''){$endif};
{$ifdef UseThreadsForCoroutines}
 result^.Fiber:=POCACoroutineContextCreate(StackSize,@POCACoroutineEntrypoint,result);
 result^.Back:=nil;
{$else}
{$ifdef windows}
 result^.Fiber:=CreateFiber(StackSize,@POCACoroutineEntrypoint,result);
 if not assigned(result^.Fiber) then begin
  RaiseLastOSError;
 end;
{$else}
 result^.Fiber:=POCACoroutineContextCreate(StackSize,@POCACoroutineEntrypoint,result);
 result^.Back:=POCACoroutineContextCreate(0,nil,nil);
{$endif}
{$endif}
end;

procedure POCACoroutineDestroy(Coroutine:PPOCACoroutine);
begin
 if assigned(Coroutine) then begin
{$ifdef UseThreadsForCoroutines}
  POCACoroutineContextDestroy(Coroutine^.Fiber);
  Coroutine^.Fiber:=nil;
{$else}
{$ifdef windows}
  if assigned(Coroutine^.Fiber) then begin
   DeleteFiber(Coroutine^.Fiber);
   Coroutine^.Fiber:=nil;
  end;
{$else}
  POCACoroutineContextDestroy(Coroutine^.Fiber);
  POCACoroutineContextDestroy(Coroutine^.Back);
  Coroutine^.Fiber:=nil;
  Coroutine^.Back:=nil;
{$endif}
{$endif}
{$ifdef fpc}
  RTLEventDestroy(Coroutine^.Event);
{$else}
  FreeAndNil(Coroutine^.Event);
{$endif}
  Dispose(Coroutine);
  Coroutine:=nil;
 end;
end;

procedure POCACoroutineRaise(const s:TPOCAUTF8String);
begin
 raise Exception.Create(String(s));
end;

procedure POCACoroutineResume(Coroutine:PPOCACoroutine);
{$ifdef windows}
var Current:pointer;
{$endif}
begin
 if assigned(Coroutine) then begin
  if Coroutine^.State=pcsTERMINATED then begin
   POCACoroutineRaise('Coroutine is already terminated');
  end else begin
   while TPasMPInterlocked.CompareExchange(Coroutine^.State,pcsINSIDE,pcsOUTSIDE)=pcsINSIDE do begin
{$ifdef fpc}
    RTLEventWaitFor(Coroutine^.Event);
{$else}
    Coroutine^.Event.WaitFor(INFINITE);
{$endif}
   end;
{$ifndef fpc}
   Coroutine^.Event.ResetEvent;
{$endif}
   if assigned(Coroutine^.Fiber) then begin
{$ifdef UseThreadsForCoroutines}
{$ifdef fpc}
    RTLEventSetEvent(PPOCACoroutineContext(Coroutine^.Fiber)^.ResumeEvent);
    RTLEventWaitFor(PPOCACoroutineContext(Coroutine^.Fiber)^.YieldEvent);
{$else}
    PPOCACoroutineContext(Coroutine^.Fiber)^.ResumeEvent.SetEvent;
    PPOCACoroutineContext(Coroutine^.Fiber)^.YieldEvent.WaitFor(INFINITE);
    PPOCACoroutineContext(Coroutine^.Fiber)^.YieldEvent.ResetEvent;
{$endif}
{$else}
{$ifdef windows}
    Current:=GetCurrentFiber;
    if (not assigned(Current)) or (Current=pointer(TPOCAPtrUInt($1e00))) then begin
     Coroutine^.Back:=ConvertThreadToFiber(nil);
    end else begin
     Coroutine^.Back:=Current;
    end;
    Coroutine^.BackFPUCW:=Get8087CW;
    SwitchToFiber(Coroutine^.Fiber);
    Set8087CW(Coroutine^.BackFPUCW);
{$else}
    POCACoroutineContextGet(Coroutine^.Back);
    POCACoroutineContextSwitch(Coroutine^.Back,Coroutine^.Fiber);
{$endif}
{$endif}
   end;
   case Coroutine^.State of
    pcsINSIDE:begin
     TPasMPInterlocked.Exchange(Coroutine^.State,pcsOUTSIDE);
    end;
    pcsINSIDETERMINATED:begin
     TPasMPInterlocked.Exchange(Coroutine^.State,pcsTERMINATED);
    end;
   end;
{$ifdef fpc}
   RTLEventSetEvent(Coroutine^.Event);
{$else}
   Coroutine^.Event.SetEvent;
{$endif}
  end;
 end;
end;

procedure POCACoroutineYield(Coroutine:PPOCACoroutine);
begin
 if assigned(Coroutine) then begin
{$ifdef UseThreadsForCoroutines}
{$ifdef fpc}
  RTLEventSetEvent(PPOCACoroutineContext(Coroutine^.Fiber)^.YieldEvent);
  RTLEventWaitFor(PPOCACoroutineContext(Coroutine^.Fiber)^.ResumeEvent);
{$else}
  PPOCACoroutineContext(Coroutine^.Fiber)^.YieldEvent.SetEvent;
  PPOCACoroutineContext(Coroutine^.Fiber)^.ResumeEvent.WaitFor(INFINITE);
  PPOCACoroutineContext(Coroutine^.Fiber)^.ResumeEvent.ResetEvent;
{$endif}
{$else}
  if Coroutine^.State in [pcsINSIDE,pcsINSIDETERMINATED] then begin
{$ifdef windows}
   Coroutine^.FiberFPUCW:=Get8087CW;
   SwitchToFiber(Coroutine^.Back);
   Set8087CW(Coroutine^.FiberFPUCW);
{$else}
   POCACoroutineContextSwitch(Coroutine^.Fiber,Coroutine^.Back);
{$endif}
  end else begin
   POCACoroutineRaise('The program control flow is outside coroutine');
  end;
{$endif}
 end;
end;

type PPOCACoroutineData=^TPOCACoroutineData;
     TPOCACoroutineData=record
      Context:PPOCAContext;
      Data:TPOCAValue;
      Func:TPOCAValue;
      Coroutine:PPOCACoroutine;
      Arguments:TPOCAValueArray;
      FromValue:TPOCAValue;
      ToValue:TPOCAValue;
      ExceptionHolder:Exception;
     end;

constructor TPOCAStringTree.Create;
begin
 inherited Create;
 Root:=nil;
 Clear;
end;

destructor TPOCAStringTree.Destroy;
begin
 Clear;
 inherited Destroy;
end;

function TPOCAStringTree.CreateStringTreeNode(AChar:ansichar):PPOCAStringTreeNode;
begin
 getmem(result,sizeof(TPOCAStringTreeNode));
 result^.TheChar:=AChar;
 result^.Data:=0;
 result^.DataExist:=false;
 result^.Previous:=nil;
 result^.Next:=nil;
 result^.Up:=nil;
 result^.Down:=nil;
end;

procedure TPOCAStringTree.DestroyStringTreeNode(Node:PPOCAStringTreeNode);
begin
 if not assigned(Node) then exit;
 DestroyStringTreeNode(Node^.Next);
 DestroyStringTreeNode(Node^.Down);
 freemem(Node);
end;

procedure TPOCAStringTree.Clear;
begin
 DestroyStringTreeNode(Root);
 Root:=nil;
end;

procedure TPOCAStringTree.DumpTree;
var Ident:longint;
 procedure DumpNode(Node:PPOCAStringTreeNode);
 var SubNode:PPOCAStringTreeNode;
     IdentCounter,IdentOld:longint;
 begin
  for IdentCounter:=1 to Ident do begin
   write(' ');
  end;
  write(Node^.TheChar);
  IdentOld:=Ident;
  SubNode:=Node^.Next;
  while assigned(SubNode) do begin
   write(SubNode.TheChar);
   if not assigned(SubNode^.Next) then begin
    break;
   end;
   inc(Ident);
   SubNode:=SubNode^.Next;
  end;
  writeln;
  inc(Ident);
  while assigned(SubNode) and (SubNode<>Node) do begin
   if assigned(SubNode^.Down) then begin
    DumpNode(SubNode^.Down);
   end;
   SubNode:=SubNode^.Previous;
   dec(Ident);
  end;
  Ident:=IdentOld;
  if assigned(Node^.Down) then begin
   DumpNode(Node^.Down);
  end;
 end;
begin
 Ident:=0;
 DumpNode(Root);
end;

procedure TPOCAStringTree.DumpList;
 procedure DumpNode(Node:PPOCAStringTreeNode;ParentStr:TPOCARawByteString);
 begin
  if assigned(Node) then begin
   ParentStr:=ParentStr;
   if Node^.DataExist then begin
    writeln(ParentStr+TPOCARawByteString(Node^.TheChar));
   end;
   if assigned(Node^.Next) then begin
    DumpNode(Node^.Next,ParentStr+TPOCARawByteString(Node^.TheChar));
   end;
   if assigned(Node^.Down) then begin
    DumpNode(Node^.Down,ParentStr);
   end;
  end;
 end;
begin
 if assigned(Root) then begin
  DumpNode(Root,'');
 end;
end;

procedure TPOCAStringTree.AppendTo(DestStringTree:TPOCAStringTree);
 procedure DumpNode(Node:PPOCAStringTreeNode;ParentStr:TPOCARawByteString);
 begin
  if assigned(Node) then begin
   ParentStr:=ParentStr;
   if Node^.DataExist then begin
    DestStringTree.Add(ParentStr+Node^.TheChar,Node^.Data);
   end;
   if assigned(Node^.Next) then begin
    DumpNode(Node^.Next,ParentStr+Node^.TheChar);
   end;
   if assigned(Node^.Down) then begin
    DumpNode(Node^.Down,ParentStr);
   end;
  end;
 end;
begin
 if assigned(DestStringTree) and assigned(Root) then begin
  DumpNode(Root,'');
 end;
end;

procedure TPOCAStringTree.Optimize(DestStringTree:TPOCAStringTree);
 procedure DumpNode(Node:PPOCAStringTreeNode;ParentStr:TPOCARawByteString);
 begin
  if assigned(Node) then begin
   ParentStr:=ParentStr;
   if Node^.DataExist then begin
    DestStringTree.Add(ParentStr+Node^.TheChar,Node^.Data);
   end;
   if assigned(Node^.Next) then begin
    DumpNode(Node^.Next,ParentStr+Node^.TheChar);
   end;
   if assigned(Node^.Down) then begin
    DumpNode(Node^.Down,ParentStr);
   end;
  end;
 end;
begin
 if assigned(DestStringTree) then begin
  DestStringTree.Clear;
  if assigned(Root) then begin
   DumpNode(Root,'');
  end;
 end;
end;

function TPOCAStringTree.Add(Content:TPOCARawByteString;Data:TPOCAStringTreeData;Replace:boolean=false):boolean;
var StringLength,Position,PositionCounter:longint;
    NewNode,LastNode,Node:PPOCAStringTreeNode;
    StringChar,NodeChar:ansichar;
begin
 result:=false;
 StringLength:=length(Content);
 if StringLength>0 then begin
  LastNode:=nil;
  Node:=Root;
  for Position:=1 to StringLength do begin
   StringChar:=Content[Position];
   if assigned(Node) then begin
    NodeChar:=Node^.TheChar;
    if NodeChar=StringChar then begin
     LastNode:=Node;
     Node:=Node^.Next;
   end else begin
     while (NodeChar<StringChar) and assigned(Node^.Down) do begin
      Node:=Node^.Down;
      NodeChar:=Node^.TheChar;
     end;
     if NodeChar=StringChar then begin
      LastNode:=Node;
      Node:=Node^.Next;
     end else begin
      NewNode:=CreateStringTreeNode(StringChar);
      if NodeChar<StringChar then begin
       NewNode^.Down:=Node^.Down;
       NewNode^.Up:=Node;
       if assigned(NewNode^.Down) then begin
        NewNode^.Down^.Up:=NewNode;
       end;
       NewNode^.Previous:=Node^.Previous;
       Node^.Down:=NewNode;
      end else if NodeChar>StringChar then begin
       NewNode^.Down:=Node;
       NewNode^.Up:=Node^.Up;
       if assigned(NewNode^.Up) then begin
        NewNode^.Up^.Down:=NewNode;
       end;
       NewNode^.Previous:=Node^.Previous;
       if not assigned(NewNode^.Up) then begin
        if assigned(NewNode^.Previous) then begin
         NewNode^.Previous^.Next:=NewNode;
        end else begin
         Root:=NewNode;
        end;
       end;
       Node^.Up:=NewNode;
      end;
      LastNode:=NewNode;
      Node:=LastNode^.Next;
     end;
    end;
   end else begin
    for PositionCounter:=Position to StringLength do begin
     NewNode:=CreateStringTreeNode(Content[PositionCounter]);
     if assigned(LastNode) then begin
      NewNode^.Previous:=LastNode;
      LastNode^.Next:=NewNode;
      LastNode:=LastNode^.Next;
     end else begin
      if not assigned(Root) then begin
       Root:=NewNode;
       LastNode:=Root;
      end;
     end;
    end;
    break;
   end;
  end;
  if assigned(LastNode) then begin
   if Replace or not LastNode^.DataExist then begin
    LastNode^.Data:=Data;
    LastNode^.DataExist:=true;
    result:=true;
   end;
  end;
 end;
end;

function TPOCAStringTree.Delete(Content:TPOCARawByteString):boolean;
var StringLength,Position:longint;
    Node:PPOCAStringTreeNode;
    StringChar,NodeChar:ansichar;
begin
 result:=false;
 StringLength:=length(Content);
 if StringLength>0 then begin
  Node:=Root;
  for Position:=1 to StringLength do begin
   StringChar:=Content[Position];
   if assigned(Node) then begin
    NodeChar:=Node^.TheChar;
    while (NodeChar<>StringChar) and assigned(Node^.Down) do begin
     Node:=Node^.Down;
     NodeChar:=Node^.TheChar;
    end;
    if NodeChar=StringChar then begin
     if (Position=StringLength) and Node^.DataExist then begin
      Node^.DataExist:=false;
      result:=true;
      exit;
     end;
     Node:=Node^.Next;
    end else begin
     break;
    end;
   end else begin
    break;
   end;
  end;
 end;
end;

function TPOCAStringTree.Find(Content:TPOCARawByteString;var Data:TPOCAStringTreeData):boolean;
var StringLength,Position:longint;
    Node:PPOCAStringTreeNode;
    StringChar,NodeChar:ansichar;
begin
 result:=false;
 StringLength:=length(Content);
 if StringLength>0 then begin
  Node:=Root;
  for Position:=1 to StringLength do begin
   StringChar:=Content[Position];
   if assigned(Node) then begin
    NodeChar:=Node^.TheChar;
    while (NodeChar<>StringChar) and assigned(Node^.Down) do begin
     Node:=Node^.Down;
     NodeChar:=Node^.TheChar;
    end;
    if NodeChar=StringChar then begin
     if (Position=StringLength) and Node^.DataExist then begin
      Data:=Node^.Data;
      result:=true;
      exit;
     end;
     Node:=Node^.Next;
    end else begin
     break;
    end;
   end else begin
    break;
   end;
  end;
 end;
end;

function TPOCAStringTree.FindEx(Content:TPOCARawByteString;var Data:TPOCAStringTreeData;var Len:longint):boolean;
var StringLength,Position:longint;
    Node:PPOCAStringTreeNode;
    StringChar,NodeChar:ansichar;
begin
 result:=false;
 Len:=0;
 StringLength:=length(Content);
 if StringLength>0 then begin
  Node:=Root;
  for Position:=1 to StringLength do begin
   StringChar:=Content[Position];
   if assigned(Node) then begin
    NodeChar:=Node^.TheChar;
    while (NodeChar<>StringChar) and assigned(Node^.Down) do begin
     Node:=Node^.Down;
     NodeChar:=Node^.TheChar;
    end;
    if NodeChar=StringChar then begin
     if Node^.DataExist then begin
      Len:=Position;
      Data:=Node^.Data;
      result:=true;
     end;
     Node:=Node^.Next;
    end else begin
     break;
    end;
   end else begin
    break;
   end;
  end;
 end;
end;

constructor TPOCAStringHashMap.Create(AOptimize:longbool);
var Hash:longword;
begin
 inherited Create;
 FillChar(HashBuckets,sizeof(TPOCAStringHashMapHashBuckets),#0);
 First:=nil;
 Last:=nil;
 HashSize:=256;
 HashSizeMask:=HashSize-1;
 HashedItems:=0;
 HashBucketsUsed:=0;
 HashBuckets:=nil;
 SetLength(HashBuckets,HashSize);
 for Hash:=0 to HashSizeMask do begin
  HashBuckets[Hash].HashFirst:=nil;
  HashBuckets[Hash].HashLast:=nil;
 end;
 LastUsedItem:=nil;
 Optimize:=AOptimize;
end;

destructor TPOCAStringHashMap.Destroy;
begin
 Clear;
 SetLength(HashBuckets,0);
 inherited Destroy;
end;

procedure TPOCAStringHashMap.Clear;
var Hash:longword;
    Item,NextItem:PPOCAStringHashMapItem;
begin
 Item:=First;
 while assigned(Item) do begin
  NextItem:=Item^.Next;
  Item^.Next:=nil;
  Item^.Key:='';
  Item^.Value:=0;
  Dispose(Item);
  Item:=NextItem;
 end;
 First:=nil;
 Last:=nil;
 LastUsedItem:=nil;
 HashSize:=256;
 HashSizeMask:=HashSize-1;
 HashedItems:=0;
 HashBucketsUsed:=0;
 SetLength(HashBuckets,HashSize);
 for Hash:=0 to HashSizeMask do begin
  HashBuckets[Hash].HashFirst:=nil;
  HashBuckets[Hash].HashLast:=nil;
 end;
end;

procedure TPOCAStringHashMap.GrowAndRehashIfNeeded;
var Hash:longword;
    Item:PPOCAStringHashMapItem;
begin
 if (HashSize<POCAHashMapMaxSize) and (HashedItems>=(HashBucketsUsed*POCAHashMapItemsPerBucketsThreshold)) then begin
  LastUsedItem:=nil;
  for Hash:=0 to HashSizeMask do begin
   HashBuckets[Hash].HashFirst:=nil;
   HashBuckets[Hash].HashLast:=nil;
  end;
  inc(HashSize,HashSize);
  if HashSize>POCAHashMapMaxSize then begin
   HashSize:=POCAHashMapMaxSize;
  end;
  HashSizeMask:=HashSize-1;
  SetLength(HashBuckets,HashSize);
  for Hash:=0 to HashSizeMask do begin
   HashBuckets[Hash].HashFirst:=nil;
   HashBuckets[Hash].HashLast:=nil;
  end;
  HashedItems:=0;
  Item:=First;
  while assigned(Item) do begin
   inc(HashedItems);
   Item^.HashPrevious:=nil;
   Item^.HashNext:=nil;
   Item:=Item^.Next;
  end;
  HashBucketsUsed:=0;
  Item:=First;
  while assigned(Item) do begin
   Hash:=POCAHashString(Item^.Key) and HashSizeMask;
   Item^.Hash:=Hash;
   if assigned(HashBuckets[Hash].HashLast) then begin
    HashBuckets[Hash].HashLast^.HashNext:=Item;
    Item^.HashPrevious:=HashBuckets[Hash].HashLast;
    HashBuckets[Hash].HashLast:=Item;
    Item^.HashNext:=nil;
   end else begin
    inc(HashBucketsUsed);
    HashBuckets[Hash].HashFirst:=Item;
    HashBuckets[Hash].HashLast:=Item;
    Item^.HashPrevious:=nil;
    Item^.HashNext:=nil;
   end;
   Item:=Item^.Next;
  end;
 end;
end;

function TPOCAStringHashMap.GetKey(const Key:TPOCARawByteString):PPOCAStringHashMapItem;
var Hash:longword;
begin
 if assigned(LastUsedItem) and (LastUsedItem^.Key=Key) then begin
  result:=LastUsedItem;
  Hash:=result^.Hash;
 end else begin
  Hash:=POCAHashString(Key) and HashSizeMask;
  result:=HashBuckets[Hash].HashFirst;
  while assigned(result) and (result^.Key<>Key) do begin
   result:=result^.HashNext;
  end;
 end;
 if Optimize and assigned(result) then begin
  LastUsedItem:=result;
  if HashBuckets[Hash].HashFirst<>result then begin
   if assigned(result^.HashPrevious) then begin
    result^.HashPrevious^.HashNext:=result^.HashNext;
   end;
   if assigned(result^.HashNext) then begin
    result^.HashNext^.HashPrevious:=result^.HashPrevious;
   end else if HashBuckets[Hash].HashLast=result then begin
    HashBuckets[Hash].HashLast:=result^.HashPrevious;
   end;
   HashBuckets[Hash].HashFirst^.HashPrevious:=result;
   result^.HashNext:=HashBuckets[Hash].HashFirst;
   result^.HashPrevious:=nil;
   HashBuckets[Hash].HashFirst:=result;
  end;
 end;
end;

function TPOCAStringHashMap.NewKey(const Key:TPOCARawByteString;Force:boolean=false):PPOCAStringHashMapItem;
var Hash:longword;
begin
 if Force then begin
  result:=nil;
  Hash:=POCAHashString(Key) and HashSizeMask;
 end else if assigned(LastUsedItem) and (LastUsedItem^.Key=Key) then begin
  result:=LastUsedItem;
  Hash:=result^.Hash;
 end else begin
  Hash:=POCAHashString(Key) and HashSizeMask;
  result:=HashBuckets[Hash].HashFirst;
  if not assigned(result) then begin
   inc(HashBucketsUsed);
  end;
  while assigned(result) and (result^.Key<>Key) do begin
   result:=result^.HashNext;
  end;
 end;
 if not assigned(result) then begin
  inc(HashedItems);
  New(result);
  fillchar(result^,sizeof(TPOCAStringHashMapItem),#0);
  result^.Hash:=Hash;
  result^.Key:=Key;
  if assigned(HashBuckets[Hash].HashLast) then begin
   HashBuckets[Hash].HashLast^.HashNext:=result;
   result^.HashPrevious:=HashBuckets[Hash].HashLast;
   result^.HashNext:=nil;
   HashBuckets[Hash].HashLast:=result;
  end else begin
   HashBuckets[Hash].HashFirst:=result;
   HashBuckets[Hash].HashLast:=result;
   result^.HashPrevious:=nil;
   result^.HashNext:=nil;
  end;
  if assigned(Last) then begin
   Last^.Next:=result;
   result^.Previous:=Last;
   result^.Next:=nil;
   Last:=result;
  end else begin
   First:=result;
   Last:=result;
   result^.Previous:=nil;
   result^.Next:=nil;
  end;
  LastUsedItem:=result;
 end;
 GrowAndRehashIfNeeded;
end;

function TPOCAStringHashMap.DeleteKey(const Item:PPOCAStringHashMapItem):boolean;
begin
 result:=assigned(Item);
 if result then begin
  if LastUsedItem=Item then begin
   if assigned(Item^.Next) then begin
    LastUsedItem:=Item^.Next;
   end else begin
    LastUsedItem:=Item^.Previous;
   end;
  end;
  if assigned(Item^.Previous) then begin
   Item^.Previous^.Next:=Item^.Next;
  end else if First=Item then begin
   First:=Item^.Next;
  end;
  if assigned(Item^.Next) then begin
   Item^.Next^.Previous:=Item^.Previous;
  end else if Last=Item then begin
   Last:=Item^.Previous;
  end;
  Item^.Next:=nil;
  Item^.Previous:=nil;
  if assigned(Item^.HashPrevious) then begin
   Item^.HashPrevious^.HashNext:=Item^.HashNext;
  end else if HashBuckets[Item^.Hash].HashFirst=Item then begin
   HashBuckets[Item^.Hash].HashFirst:=Item^.HashNext;
  end;
  if assigned(Item^.HashNext) then begin
   Item^.HashNext^.HashPrevious:=Item^.HashPrevious;
  end else if HashBuckets[Item^.Hash].HashLast=Item then begin
   HashBuckets[Item^.Hash].HashLast:=Item^.HashPrevious;
  end;
  Item^.HashNext:=nil;
  Item^.HashPrevious:=nil;
  Item^.Key:='';
  Item^.Value:=0;
  Dispose(Item);
  dec(HashedItems);
 end;
end;

function TPOCAStringHashMap.GetValue(const Key:TPOCARawByteString):int64;
var Item:PPOCAStringHashMapItem;
begin
 Item:=GetKey(Key);
 if assigned(Item) then begin
  result:=Item^.Value;
 end else begin
  result:=-1;
 end;
end;

procedure TPOCAStringHashMap.SetValue(const Key:TPOCARawByteString;const Value:int64);
var Item:PPOCAStringHashMapItem;
begin
 Item:=GetKey(Key);
 if not assigned(Item) then begin
  Item:=NewKey(Key,true);
 end;
 if assigned(Item) then begin
  Item^.Value:=Value;
 end;
end;

function POCAGetValueType(const v:TPOCAValue):longint; {$ifdef caninline}inline;{$endif}
{$ifdef cpu64}
var p:PPOCAObject;
begin
 if (UInt64(pointer(@v.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask then begin
  p:=pointer(TPOCAPtrUInt(v.Reference.Obj) and POCAValueReferenceMask);
  if assigned(p) then begin
   result:=p^.Header.ValueType;
  end else begin
   result:=pvtNULL;
  end;
 end else begin
  result:=pvtNUMBER;
 end;
end;
{$else}
begin
 if v.ReferenceTag=POCAValueReferenceTag then begin
  if assigned(v.Reference.Obj) then begin
   result:=v.Reference.Obj^.Header.ValueType;
  end else begin
   result:=pvtNULL;
  end;
 end else begin
  result:=pvtNUMBER;
 end;
end;
{$endif}

function POCAGetValueReferencePointer(const v:TPOCAValue):pointer; {$ifdef caninline}inline;{$endif}
begin
 result:={$ifdef cpu64}pointer(TPOCAPtrUInt(v.Reference.Ptr) and POCAValueReferenceMask){$else}v.Reference.Ptr{$endif};
end;

procedure POCASetValueReferencePointer(out v:TPOCAValue;const Ptr:pointer); {$ifdef caninline}inline;{$endif}
begin
{$ifdef cpu64}
 v.Reference.Ptr:=pointer(TPOCAPtrUInt((TPOCAPtrUInt(Ptr) and POCAValueReferenceMask) or POCAValueReferenceSignalMask));
{$else}
 v.ReferenceTag:=POCAValueReferenceTag;
 v.Reference.Ptr:=Ptr;
{$endif}
end;

procedure POCASetValueNumber(out v:TPOCAValue;const n:double); {$ifdef caninline}inline;{$endif}
begin
{$ifdef cpu64}
 UInt64(pointer(@v.Num)^):=UInt64(pointer(@n)^);
{$else}
{v.ReferenceTag:=not POCAValueReferenceTag;
 v.Num:=n;(*{}
 int64(pointer(@v.Num)^):=int64(pointer(@n)^);(**)
{$endif}
end;

function POCAIsValueReference(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:={$ifdef cpu64}(UInt64(pointer(@v.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask{$else}v.ReferenceTag=POCAValueReferenceTag{$endif};
end;

function POCAIsValueNumber(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:={$ifdef cpu64}(UInt64(pointer(@v.Num)^) and POCAValueReferenceSignalMask)<>POCAValueReferenceSignalMask{$else}v.ReferenceTag<>POCAValueReferenceTag{$endif};
end;

function POCAIsValueObject(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:={$ifdef cpu64}((UInt64(pointer(@v.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and assigned(pointer(TPOCAPtrUInt(v.Reference.Ptr) and POCAValueReferenceMask)){$else}(v.ReferenceTag=POCAValueReferenceTag) and assigned(v.Reference.Ptr){$endif};
end;

function POCAIsValueObjectAndGetReferencePointer(const v:TPOCAValue;var p):boolean;
begin
 pointer(p):={$ifdef cpu64}pointer(TPOCAPtrUInt(v.Reference.Ptr) and POCAValueReferenceMask){$else}v.Reference.Ptr{$endif};
 result:={$ifdef cpu64}((UInt64(pointer(@v.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and assigned(pointer(p)){$else}(v.ReferenceTag=POCAValueReferenceTag) and assigned(pointer(p)){$endif};
end;

function POCAIsValueNull(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:={$ifdef cpu64}((UInt64(pointer(@v.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and not assigned(pointer(TPOCAPtrUInt(v.Reference.Ptr) and POCAValueReferenceMask)){$else}(v.ReferenceTag=POCAValueReferenceTag) and not assigned(v.Reference.Ptr){$endif};
end;

function POCAIsValueReferenceType(const v:TPOCAValue;t:longint):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=t);
end;

function POCAIsValueString(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtSTRING);
end;

function POCAIsValueArray(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtARRAY);
end;

function POCAIsValueHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtHASH);
end;

function POCAIsValueSimpleHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
var Hash:PPOCAHash;
begin
 Hash:=PPOCAHash(POCAGetValueReferencePointer(v));
 result:=(POCAIsValueObject(v) and (Hash^.Header.ValueType=pvtHASH)) and not assigned(Hash^.Events);
end;

function POCAIsValueEventHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
var Hash:PPOCAHash;
begin
 Hash:=PPOCAHash(POCAGetValueReferencePointer(v));
 result:=(POCAIsValueObject(v) and (Hash^.Header.ValueType=pvtHASH)) and assigned(Hash^.Events);
end;

function POCAIsValueGhostEventHash(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
var Ghost:PPOCAGhost;
begin         
 Ghost:=PPOCAGhost(POCAGetValueReferencePointer(v));
 result:=(POCAIsValueObject(v) and (Ghost^.Header.ValueType=pvtGHOST)) and assigned(Ghost^.Hash) and assigned(Ghost^.Hash^.Events);
end;

function POCAGetValueHashType(const v:TPOCAValue):longint; {$ifdef caninline}inline;{$endif}
var Hash:PPOCAHash;
begin
 Hash:=PPOCAHash(POCAGetValueReferencePointer(v));
 if POCAIsValueObject(v) and (Hash^.Header.ValueType=pvtHASH) then begin
  if assigned(Hash^.Events) then begin
   result:=2;
  end else begin
   result:=1;
  end;
 end else begin
  result:=0;
 end;
end;

function POCAIsValueCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtCODE);
end;

function POCAIsValueFunction(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtFUNCTION);
end;

function POCAIsValueFunctionOrNativeCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType in [pvtFUNCTION,pvtNATIVECODE]);
end;

function POCAIsValueNativeCode(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtNATIVECODE);
end;

function POCAIsValueGhost(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueObject(v) and (PPOCAObject(POCAGetValueReferencePointer(v))^.Header.ValueType=pvtGHOST);
end;

function POCAIsValueScalarType(const v:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueNumber(v) or POCAIsValueString(v);
end;

function POCAIsValueIdentical(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(POCAIsValueReference(a) and POCAIsValueReference(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b));
end;

function Hex2Byte(c:ansichar):byte;
begin
 case c of
  '0'..'9':begin
   result:=ord(c)-ord('0');
  end;
  'a'..'f':begin
   result:=(ord(c)-ord('a'))+$a;
  end;
  'A'..'F':begin
   result:=(ord(c)-ord('A'))+$a;
  end;
  else begin
   result:=0;
  end;
 end;
end;

function sar(Value,Shift:longint):longint;
{$ifdef HasSAR} inline;
begin
result:=SARLongint(Value,Shift);
end;
{$else}
{$ifdef cpu386}
{$ifdef fpc} assembler; register; //inline;
asm
 mov ecx,edx
 sar eax,cl
end;// ['eax','edx','ecx'];
{$else} assembler; register;
asm
 mov ecx,edx
 sar eax,cl
end;
{$endif}
{$else}
{$ifdef cpuarm} assembler; //inline;
asm
 mov r0,r0,asr R1
end;// ['r0','R1'];
{$else}{$ifdef caninline}inline;{$endif}
begin
{$ifdef HasSAR}
 result:=SARLongint(Value,Shift);
{$else}
 Shift:=Shift and 31;
 result:=(longword(Value) shr Shift) or (longword(longint(longword(0-longword(longword(Value) shr 31)) and longword(0-longword(ord(Shift<>0))))) shl (32-Shift));
{$endif}
end;
{$endif}
{$endif}
{$endif}

function sar64(Value:int64;Shift:longint):int64; {$ifdef caninline}inline;{$endif}
begin
{$ifdef HasSAR}
 result:=SARInt64(Value,Shift);
{$else}
 Shift:=Shift and 63;
 result:=int64(UInt64(UInt64(UInt64(Value) shr Shift) or (UInt64(int64(UInt64(0-UInt64(UInt64(Value) shr 63)) and UInt64(int64(0-(ord(Shift<>0){ and 1}))))) shl (64-Shift))));
{$endif}
end;

constructor EPOCAError.Create(const AMessage:TPOCAUTF8String);
begin
 inherited Create(String(AMessage));
 SourceFile:=-1;
 SourceLine:=-1;
 SourceColumn:=-1;
end;

constructor EPOCAError.Create(const ASourceFile,ASourceLine,ASourceColumn:longint;const AMessage:TPOCAUTF8String);
begin
 inherited Create(String(AMessage));
 SourceFile:=ASourceFile;
 SourceLine:=ASourceLine;
 SourceColumn:=ASourceColumn;
end;

constructor EPOCAError.Create(const AValue:TPOCAValue);
begin
 inherited Create('');
 SourceFile:=-1;
 SourceLine:=-1;
 SourceColumn:=-1;
 Value:=AValue;
end;

constructor EPOCAError.Create(const ASourceFile,ASourceLine,ASourceColumn:longint;const AValue:TPOCAValue);
begin
 inherited Create('');
 SourceFile:=ASourceFile;
 SourceLine:=ASourceLine;
 SourceColumn:=ASourceColumn;
 Value:=AValue;
end;

function POCALockCreate:pointer;
begin
 result:=TPasMPCriticalSection.Create;
end;

procedure POCALockDestroy(var Lock:pointer);
begin
 if assigned(Lock) then begin
  TPasMPCriticalSection(Lock).Free;
  Lock:=nil;
 end;
end;

procedure POCALockEnter(Lock:pointer);
begin
 if assigned(Lock) then begin
  TPasMPCriticalSection(Lock).Acquire;
 end;
end;

procedure POCALockLeave(Lock:pointer);
begin
 if assigned(Lock) then begin
  TPasMPCriticalSection(Lock).Release;
 end;
end;

function POCASemaphoreCreate:pointer;
begin
 result:=TPasMPSemaphore.Create(0,$7fffffff);
end;

procedure POCASemaphoreDestroy(var Semaphore:pointer);
begin
 if assigned(Semaphore) then begin
  TPasMPSemaphore(Semaphore).Free;
  Semaphore:=nil;
 end;
end;

procedure POCASemaphoreDown(Semaphore:pointer);
begin
 if assigned(Semaphore) then begin
  TPasMPSemaphore(Semaphore).Acquire(1);
 end;
end;

procedure POCASemaphoreUp(Semaphore:pointer;Count:longint);
begin
 if assigned(Semaphore) then begin
  TPasMPSemaphore(Semaphore).Release(Count);
 end;
end;

type PPOCAThreadData=^TPOCAThreadData;
     TPOCAThreadData=record
      Handle:{$ifdef fpc}TThreadID{$else}THandle{$endif};
      StartSemaphore:pointer;
      Started:TPasMPBool32;
      Terminated:TPasMPBool32;
      ThreadID:{$ifdef fpc}TThreadID{$else}Cardinal{$endif};
      Context:PPOCAContext;
      Data:TPOCAValue;
      Func:TPOCAValue;
      Arguments:TPOCAValueArray;
     end;

{$ifdef fpc}
function POCAThreadProc(ThreadData:Pointer):TPOCAPtrInt;
{$else}
function POCAThreadProc(ThreadData:Pointer):longword;
{$endif}
begin
 result:=0;
 try
  POCASemaphoreDown(PPOCAThreadData(ThreadData)^.StartSemaphore);
  TPasMPInterlocked.Write(PPOCAThreadData(ThreadData)^.Started,true);
  try
   if length(PPOCAThreadData(ThreadData)^.Arguments)>0 then begin
    POCACall(PPOCAThreadData(ThreadData)^.Context,PPOCAThreadData(ThreadData)^.Func,@PPOCAThreadData(ThreadData)^.Arguments[0],length(PPOCAThreadData(ThreadData)^.Arguments),POCAValueNull,POCAValueNull);
   end else begin
    POCACall(PPOCAThreadData(ThreadData)^.Context,PPOCAThreadData(ThreadData)^.Func,nil,0,POCAValueNull,POCAValueNull);
   end;
  except
  end;
  TPasMPInterlocked.Write(PPOCAThreadData(ThreadData)^.Terminated,true);
  POCAContextDestroy(PPOCAThreadData(ThreadData)^.Context);
  PPOCAThreadData(ThreadData)^.Context:=nil;
 finally
 end;
 EndThread(result);
end;

procedure POCAFinalizeString(Obj:PPOCAString);
begin
 Obj^.Data:='';
 if assigned(Obj^.UTF8CodePointsToCodeUnitsIndex) then begin
  FreeMem(Obj^.UTF8CodePointsToCodeUnitsIndex);
  Obj^.UTF8CodePointsToCodeUnitsIndex:=nil;
 end;
 if assigned(Obj^.UTF8CodePointsToCodeUnitsIndex) then begin
  FreeMem(Obj^.UTF8CodeUnitsToCodePointsIndex);
  Obj^.UTF8CodeUnitsToCodePointsIndex:=nil;
 end;
end;

procedure POCAFinalizeArray(Obj:PPOCAArray);
begin
 if assigned(Obj^.ArrayRecord) then begin
  FreeMem(Obj^.ArrayRecord);
  Obj^.ArrayRecord:=nil;
 end;
end;

procedure POCAFinalizeHash(Obj:PPOCAHash);
begin
 POCAHashClearPrototype(Obj);
 if assigned(Obj^.HashRecord) then begin
  FreeMem(Obj^.HashRecord);
  Obj^.HashRecord:=nil;
 end;
 if assigned(Obj^.Cache.ChainEntities) then begin
  FreeMem(Obj^.Cache.ChainEntities);
  Obj^.Cache.ChainEntities:=nil;
 end;
end;

procedure POCACodeGCClean(Obj:PPOCACode);
begin
 if assigned(Obj^.ByteCode) then begin
  FreeMem(Obj^.ByteCode);
  Obj^.ByteCode:=nil;
 end;
 if assigned(Obj^.Constants) then begin
  FreeMem(Obj^.Constants);
  Obj^.Constants:=nil;
 end;
 if assigned(Obj^.ArgumentSymbols) then begin
  FreeMem(Obj^.ArgumentSymbols);
  Obj^.ArgumentSymbols:=nil;
 end;
 if assigned(Obj^.ArgumentLocals) then begin
  FreeMem(Obj^.ArgumentLocals);
  Obj^.ArgumentLocals:=nil;
 end;
 if assigned(Obj^.OptionalArgumentSymbols) then begin
  FreeMem(Obj^.OptionalArgumentSymbols);
  Obj^.OptionalArgumentSymbols:=nil;
 end;
 if assigned(Obj^.OptionalArgumentLocals) then begin
  FreeMem(Obj^.OptionalArgumentLocals);
  Obj^.OptionalArgumentLocals:=nil;
 end;
 if assigned(Obj^.OptionalArgumentValues) then begin
  FreeMem(Obj^.OptionalArgumentValues);
  Obj^.OptionalArgumentValues:=nil;
 end;
 if assigned(Obj^.RegExps) then begin
  FreeMem(Obj^.RegExps);
  Obj^.RegExps:=nil;
 end;
 if length(Obj^.Lines)>0 then begin
  SetLength(Obj^.Lines,0);
  Obj^.Lines:=nil;
 end;
{$ifdef POCAHasJIT}
 if assigned(Obj^.NativeCode) then begin
  POCANativeCodeMemoryManagerFreeMemory(Obj^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance^.Globals.NativeCodeMemoryManager,Obj^.NativeCode);
  Obj^.NativeCode:=nil;
 end;
 if length(Obj^.ByteCodeToNativeCodeMap)>0 then begin
  SetLength(Obj^.ByteCodeToNativeCodeMap,0);
  Obj^.ByteCodeToNativeCodeMap:=nil;
 end;
 if length(Obj^.InterpretByteCodeMap)>0 then begin
  SetLength(Obj^.InterpretByteCodeMap,0);
  Obj^.InterpretByteCodeMap:=nil;
 end;
{$endif}
end;

procedure POCAFuncGCClean(Obj:PPOCAFunction);
begin
end;

procedure POCANativeCodeGCClean(Obj:PPOCANativeCode);
begin
 if assigned(Obj^.UserData) then begin
  if assigned(Obj^.DestroyFunctionPointer) then begin
   Obj^.DestroyFunctionPointer(Obj^.UserData);
   Obj^.DestroyFunctionPointer:=nil;
  end;
  Obj^.UserData:=nil;
 end;
end;

procedure POCAGhostGCClean(Obj:PPOCAGhost);
begin
 if assigned(Obj^.Ptr) then begin
  if assigned(Obj^.GhostType) then begin
   if assigned(addr(Obj^.GhostType.Destroy)) then begin
    Obj^.GhostType.Destroy(Obj^.Ptr);
   end;
   Obj^.GhostType:=nil;
  end;
  Obj^.Ptr:=nil;
 end;
end;

procedure POCAPoolNewBlock(Pool:PPOCAPool;Size:longint); {$ifdef UseRegister}register;{$endif}
var PoolBlockSize,GrayListSize,BlockSize,i:longint;
    Block:PPOCAPoolBlock;
    Obj:PPOCAObject;
begin
 if Pool^.ElementRealSize>0 then begin
  if Size<Pool.Instance^.Globals.GarbageCollector.MinimumBlockSize then begin
   Size:=Pool.Instance^.Globals.GarbageCollector.MinimumBlockSize;
   if Size<16 then begin
    Size:=16;
   end;
  end;
  begin
   PoolBlockSize:=POCARoundUpToMask(sizeof(TPOCAPoolBlock),16);
   GrayListSize:=POCARoundUpToMask(sizeof(TPOCAGarbageCollectorLinkedList),16);
   BlockSize:=PoolBlockSize+GrayListSize+(Size*Pool^.ElementSize);
   GetMemAligned(Block,BlockSize,16);
   FillChar(Block^,BlockSize,#0);
   Block^.GrayList:=pointer(TPOCAPtrUInt(TPOCAPtrUInt(Block)+TPOCAPtrUInt(PoolBlockSize)));
   POCAGarbageCollectorLinkedListReset(Block^.GrayList);
{$ifdef POCAGarbageCollectorPoolBlockReferenceCounting}
   Block^.ReferenceCounter:=0;
{$endif}
{$ifdef POCAGarbageCollectorPoolBlockInstance}
   Block^.Instance:=Pool^.Instance;
{$endif}
   Block^.Data:=pointer(@PAnsiChar(Block)[PoolBlockSize+GrayListSize]);
   Block^.Size:=Size;
   Block^.Spin:=0;
   Block^.Next:=nil;
   if assigned(Pool^.LastBlock) then begin
    Block^.Previous:=Pool^.LastBlock;
    Block^.Previous^.Next:=Block;
    Pool^.FirstBlock:=Block;
   end else begin
    Block^.Previous:=nil;
    Pool^.FirstBlock:=Block;
   end;
   Pool^.LastBlock:=Block;
   TPasMPInterlocked.Add(Pool^.Size,Block^.Size);
  end;
  begin
   if Pool^.FreeSize<Pool^.Size then begin
    i:=POCARoundUpToPowerOfTwo(Pool^.Size);
    ReallocMem(Pool^.FreeObjects,SizeOf(PPOCAObject)*i);
    FillChar(Pool^.FreeObjects^[Pool^.FreeSize],SizeOf(PPOCAObject)*(i-Pool^.FreeSize),AnsiChar(#0));
    Pool^.FreeSize:=i;
   end;
  end;
  begin
   for i:=0 to Size-1 do begin
    Obj:=PPOCAObject(pointer(@pansichar(Block^.Data)[i*Pool^.ElementSize]));
    Obj^.Header.ValueType:=Pool^.ValueType;
{$ifndef POCAGarbageCollectorPoolBlockInstance}
    Obj^.Header.Instance:=Pool^.Instance;
{$endif}
    Obj^.Header.PoolBlock:=Block;
    POCAGarbageCollectorLinkedListReset(@Obj^.Header.GarbageCollector.LinkedList);
    Pool^.FreeObjects^[Pool^.FreeCount]:=Obj;
    inc(Pool^.FreeCount);
   end;
   TPasMPInterlocked.Add(Pool^.Instance^.Globals.GarbageCollector.Allocated,Size);
   TPasMPInterlocked.Add(Pool^.Instance^.Globals.GarbageCollector.FreeCount,Size);
   Pool^.FreeLock:=0;
  end;
 end;
end;

procedure POCAPoolCleanElement(Pool:PPOCAPool;Obj:PPOCAObject); {$ifdef UseRegister}register;{$endif} forward;

procedure POCAPoolFreeBlock(Pool:PPOCAPool;Block:PPOCAPoolBlock); {$ifdef UseRegister}register;{$endif}
var Element:longint;
    Obj:PPOCAObject;
begin
 POCAGarbageCollectorLinkedListMove(Block^.GrayList,Pool^.Instance.Globals.GarbageCollector.GrayList);
 for Element:=0 to Block^.Size-1 do begin
  Obj:=PPOCAObject(pointer(@pansichar(Block^.Data)[Element*Pool^.ElementSize]));
{$ifndef POCAGarbageCollectorPoolBlockInstance}
  Obj^.Header.Instance:=Pool^.Instance;
{$endif}
  POCAPoolCleanElement(Pool,Obj);
 end;
 if assigned(Block^.Previous) then begin
  Block^.Previous^.Next:=Block^.Next;
 end else if Pool^.FirstBlock=Block then begin
  Pool^.FirstBlock:=Block^.Next;
 end;
 if assigned(Block^.Next) then begin
  Block^.Next^.Previous:=Block^.Previous;
 end else if Pool^.LastBlock=Block then begin
  Pool^.LastBlock:=Block^.Next;
 end;
 TPasMPInterlocked.Add(Pool^.Size,-Block^.Size);
 FreeMemAligned(Block);
end;

procedure POCAPoolCleanElement(Pool:PPOCAPool;Obj:PPOCAObject); {$ifdef UseRegister}register;{$endif}
begin
 if assigned(Obj) then begin
  case Pool^.ValueType of
   pvtSTRING:begin
    POCAFinalizeString(pointer(Obj));
   end;
   pvtARRAY:begin
    POCAFinalizeArray(pointer(Obj));
   end;
   pvtHASH:begin
    POCAFinalizeHash(pointer(Obj));
   end;
   pvtCODE:begin
    POCACodeGCClean(pointer(Obj));
   end;
   pvtFUNCTION:begin
    POCAFuncGCClean(pointer(Obj));
   end;
   pvtNATIVECODE:begin
    POCANativeCodeGCClean(pointer(Obj));
   end;
   pvtGHOST:begin
    POCAGhostGCClean(pointer(Obj));
   end;
  end;
  if assigned(Obj^.Header.GarbageCollector.LinkedList.Previous) then begin
   POCAGarbageCollectorLinkedListRemove(Obj);
  end;
  if sizeof(TPOCAObjectHeader)<Pool^.ElementRealSize then begin
   FillChar(pansichar(Obj)[sizeof(TPOCAObjectHeader)],Pool^.ElementRealSize-sizeof(TPOCAObjectHeader),#0);
  end;
  Obj^.Header.GarbageCollector.State:=0;
 end;
end;

procedure POCAPoolFreeElement(Pool:PPOCAPool;Obj:PPOCAObject); {$ifdef UseRegister}register;{$endif}
begin            
 POCAPoolCleanElement(Pool,Obj);
{$ifdef POCAGarbageCollectorPoolBlockReferenceCounting}
 if TPasMPInterlocked.Decrement(Obj^.Header.PoolBlock^.ReferenceCounter)=0 then begin
  POCAPoolFreeBlock(Pool,Obj^.Header.PoolBlock);
 end else{$endif} begin
  Pool^.FreeObjects^[Pool^.FreeCount]:=Obj;
  inc(Pool^.FreeCount);
  TPasMPInterlocked.Increment(Pool^.Instance^.Globals.GarbageCollector.FreeCount);
 end;
end;

procedure POCAPoolInit(Instance:PPOCAInstance;Pool:PPOCAPool;ValueType:longint); {$ifdef UseRegister}register;{$endif}
begin
 FillChar(Pool^,sizeof(TPOCAPool),#0);
 Pool^.Instance:=Instance;
 Pool^.ValueType:=ValueType;
 Pool^.ElementRealSize:=POCATypeSizes[ValueType];
 if Pool^.ElementRealSize<0 then begin
  Pool^.ElementSize:=-1;
 end else begin
  Pool^.ElementSize:=POCARoundUpToMask(Pool^.ElementRealSize,16);
 end;
 Pool^.FreeObjects:=nil;
 Pool^.FreeSize:=0;
 Pool^.FreeCount:=0;
 Pool^.FreeLock:=0;
 Pool^.Size:=0;
 Pool^.FirstBlock:=nil;
 Pool^.LastBlock:=nil;
 POCAPoolNewBlock(Pool,Pool.Instance^.Globals.GarbageCollector.MinimumBlockSize);
end;

procedure POCAPoolDone(Pool:PPOCAPool); {$ifdef UseRegister}register;{$endif}
var Instance:PPOCAInstance;
    CurrentBlock,NextBlock:PPOCAPoolBlock;
    Element:longint;
    Obj:PPOCAObject;
begin
 Instance:=Pool^.Instance;
 if Pool^.ElementRealSize>0 then begin
  Pool^.FreeCount:=0;
  CurrentBlock:=Pool^.FirstBlock;
  while assigned(CurrentBlock) do begin
   NextBlock:=CurrentBlock^.Next;
   if assigned(CurrentBlock^.Data) then begin
    for Element:=0 to CurrentBlock^.Size-1 do begin
     Obj:=PPOCAObject(pointer(@pansichar(CurrentBlock^.Data)[Element*Pool^.ElementSize]));
{$ifndef POCAGarbageCollectorPoolBlockInstance}
     Obj^.Header.Instance:=Instance;
{$endif}
     POCAPoolCleanElement(Pool,Obj);
    end;
    CurrentBlock^.Data:=nil;
   end;
   CurrentBlock^.Size:=0;
   CurrentBlock^.Next:=nil;
   FreeMemAligned(CurrentBlock);
   CurrentBlock:=NextBlock;
  end;
 end;
 if assigned(Pool^.FreeObjects) then begin
  FreeMem(Pool^.FreeObjects);
  Pool^.FreeObjects:=nil;
 end;
 FillChar(Pool^,sizeof(TPOCAPool),#0);
end;

procedure POCAFreeDead(Instance:PPOCAInstance); {$ifdef UseRegister}register;{$endif}
var i:longint;
    p:pointer;
begin
 for i:=0 to Instance^.Globals.DeadCount-1 do begin
  p:=PPointers(Instance^.Globals.DeadBlocks)^[i];
  if assigned(p) then begin
   PPointers(Instance^.Globals.DeadBlocks)^[i]:=nil;
   FreeMem(p);
  end;
 end;
 Instance^.Globals.DeadCount:=0;
end;

function POCAGarbageCollectorFree(Instance:PPOCAInstance):longint; {$ifdef UseRegister}register;{$endif}
var GarbageCollector:PPOCAGarbageCollector;
begin
 GarbageCollector:=@Instance^.Globals.GarbageCollector;
 result:=GarbageCollector^.FreeCount;
end;

function POCAGarbageCollectorUsed(Instance:PPOCAInstance):longint; {$ifdef UseRegister}register;{$endif}
var GarbageCollector:PPOCAGarbageCollector;
begin
 GarbageCollector:=@Instance^.Globals.GarbageCollector;
 result:=GarbageCollector^.Allocated-GarbageCollector^.FreeCount;
end;

function POCAMarkValue(Instance:PPOCAInstance;const Value:TPOCAValue):longbool;
 function MarkObjectAsGray(Obj:PPOCAObject):longbool;
 var GarbageCollector:PPOCAGarbageCollector;
 begin
  GarbageCollector:=@Instance^.Globals.GarbageCollector;
  if assigned(Obj) then begin
   result:=(Obj^.Header.GarbageCollector.State and (pgcbPERSISTENT or pgcbPERSISTENTROOT))=0;
   if result and ((Obj^.Header.GarbageCollector.State and (pgcbGRAY or pgcbBLACK))=0) then begin
    POCAGarbageCollectorLinkedListRemove(Obj);
    POCAGarbageCollectorLinkedListPush(GarbageCollector^.GrayList,Obj);
    Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbGRAY;
   end;
  end else begin
   result:=false;
  end;
 end;
begin
 if POCAIsValueObject(Value) then begin
  result:=MarkObjectAsGray(PPOCAObject(POCAGetValueReferencePointer(Value)));
 end else begin
  result:=false;
 end;
end;

function POCACoroutineGhostMark(Data:pointer):longbool; forward;
function POCAThreadGhostMark(Data:pointer):longbool; forward;

function POCAGarbageCollectorCollectCycle(Instance:PPOCAInstance):boolean; {$ifdef UseRegister}register;{$endif}
var GarbageCollector:PPOCAGarbageCollector;
 function MarkObjectAsGray(Obj:PPOCAObject):boolean;
 begin
  if assigned(Obj) then begin
   result:=(Obj^.Header.GarbageCollector.State and (pgcbPERSISTENT or pgcbPERSISTENTROOT))=0;
   if result and ((Obj^.Header.GarbageCollector.State and (pgcbGRAY or pgcbBLACK))=0) then begin
    POCAGarbageCollectorLinkedListRemove(Obj);
    POCAGarbageCollectorLinkedListPush(GarbageCollector^.GrayList,Obj);
    Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbGRAY;
   end;
  end else begin
   result:=false;
  end;
 end;
 function MarkValue(const Value:TPOCAValue):boolean;
 begin
  if POCAIsValueObject(Value) then begin
   result:=MarkObjectAsGray(PPOCAObject(POCAGetValueReferencePointer(Value)));
  end else begin
   result:=false;
  end;
 end;
 function MarkArrayAsGray(Obj:PPOCAArray):boolean;
 var ArrayRecord:PPOCAArrayRecord;
     i:longint;
 begin
  result:=false;
  ArrayRecord:=Obj^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   for i:=0 to ArrayRecord^.Size-1 do begin
    if MarkValue(ArrayRecord^.Data[i]) then begin
     result:=true;
    end;
   end;
  end;
 end;
 function MarkHashAsGray(Obj:PPOCAHash):boolean;
 var HashRec:PPOCAHashRecord;
     HashEntity:PPOCAHashEntity;
     i:longint;
     j:longint;
     mo:TPOCAMetaOp;
 begin
  result:=false;
  HashRec:=Obj^.HashRecord;
  if assigned(HashRec) then begin
   for i:=0 to (2 shl HashRec^.LogSize)-1 do begin
    j:=HashRec^.CellToEntityIndex^[i];
    if j>=0 then begin
     HashEntity:=@HashRec^.Entities^[j];
     if MarkValue(HashEntity^.Key) then begin
      result:=true;
     end;
     if MarkValue(HashEntity^.Value) then begin
      result:=true;
     end;
    end;
   end;
   if assigned(HashRec^.Events) then begin
    for mo:=low(TPOCAHashEvents) to high(TPOCAHashEvents) do begin
     if MarkValue(HashRec^.Events[mo]) then begin
      result:=true;
     end;
    end;
   end;
  end;
  if assigned(Obj^.Prototype) then begin
   if MarkObjectAsGray(pointer(Obj^.Prototype)) then begin
    result:=true;
   end;
  end;
  if assigned(Obj^.Events) then begin
   if MarkObjectAsGray(pointer(Obj^.Events)) then begin
    result:=true;
   end;
  end;
  if assigned(Obj^.Ghost) then begin
   if MarkObjectAsGray(pointer(Obj^.Ghost)) then begin
    result:=true;
   end;
  end;
 end;
 function MarkCodeAsGray(Obj:PPOCACode):boolean;
 var i:longint;
 begin
  result:=false;
  for i:=0 to Obj^.ConstantCount-1 do begin
   if MarkValue(Obj^.Constants^[i]) then begin
    result:=true;
   end;
  end;
  for i:=0 to Obj^.CountRegExps-1 do begin
   if MarkValue(Obj^.RegExps^[i]) then begin
    result:=true;
   end;
  end;
 end;
 function MarkFunctionAsGray(Obj:PPOCAFunction):boolean;
 begin
  result:=false;
  if MarkValue(Obj^.Code) then begin
   result:=true;
  end;
  if MarkValue(Obj^.Namespace) then begin
   result:=true;
  end;
  if MarkValue(Obj^.Obj) then begin
   result:=true;
  end;
  if MarkValue(Obj^.Next) then begin
   result:=true;
  end;
 end;
 function MarkGhostAsGray(Obj:PPOCAGhost):boolean;
 begin
  result:=false;
  if assigned(Obj^.GhostType) and assigned(addr(Obj^.GhostType^.Mark)) then begin
   if Obj^.GhostType^.Mark(Obj^.Ptr) then begin
    result:=true;
   end;
  end;
  if assigned(Obj^.Hash) then begin
   if MarkObjectAsGray(pointer(Obj^.Hash)) then begin
    result:=true;
   end;
  end;
 end;
 procedure TryMarkGhostAsGray(Obj:PPOCAObject);
 begin
  if Obj^.Header.ValueType=pvtGHOST then begin
   MarkGhostAsGray(pointer(Obj));
  end;
 end;
 function MarkObjectContent(Obj:PPOCAObject):boolean;
 begin
  case Obj^.Header.ValueType of
   pvtREFERENCE:begin
    result:=MarkObjectAsGray(pointer(Obj));
   end;
   pvtSTRING:begin
    result:=MarkObjectAsGray(pointer(Obj));
   end;
   pvtARRAY:begin
    result:=MarkArrayAsGray(pointer(Obj));
   end;
   pvtHASH:begin
    result:=MarkHashAsGray(pointer(Obj));
   end;
   pvtCODE:begin
    result:=MarkCodeAsGray(pointer(Obj));
   end;
   pvtFUNCTION:begin
    result:=MarkFunctionAsGray(pointer(Obj));
   end;
   pvtNATIVECODE:begin
    result:=MarkObjectAsGray(pointer(Obj));
   end;
   pvtGHOST:begin
    result:=MarkGhostAsGray(pointer(Obj));
   end;
   else begin
    result:=false;
   end;
  end;
 end;
 procedure MarkObject(Obj:PPOCAObject);
 var Temp:longword;
 begin
  case Obj^.Header.GarbageCollector.State and (pgcbPERSISTENT or pgcbPERSISTENTROOT or pgcbWASPERSISTENT or pgcbWASPERSISTENTROOT) of
   pgcbWASPERSISTENT:begin
    POCAGarbageCollectorLinkedListRemove(Obj);
    POCAGarbageCollectorLinkedListPush(GarbageCollector^.PersistentLists[Obj^.Header.ValueType=pvtGHOST],Obj);
    Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not (pgcbLIST or (pgcbWASPERSISTENT or pgcbWASPERSISTENTROOT))) or pgcbPERSISTENT;
    MarkObjectContent(Obj);
   end;
   pgcbWASPERSISTENT or pgcbWASPERSISTENTROOT,pgcbWASPERSISTENTROOT:begin
    POCAGarbageCollectorLinkedListRemove(Obj);
    POCAGarbageCollectorLinkedListPush(GarbageCollector^.PersistentRootLists[Obj^.Header.ValueType=pvtGHOST],Obj);
    Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not (pgcbLIST or (pgcbWASPERSISTENT or pgcbWASPERSISTENTROOT))) or pgcbPERSISTENTROOT;
    MarkObjectContent(Obj);
   end;
   0:begin
    if (GarbageCollector^.PersistentThreshold>0) and
       (TPOCAPtrUInt(Obj^.Header.GarbageCollector.State shr 8)>=TPOCAPtrUInt(GarbageCollector^.PersistentThreshold)) then begin
     POCAGarbageCollectorLinkedListRemove(Obj);
     POCAGarbageCollectorLinkedListPush(GarbageCollector^.PersistentLists[Obj^.Header.ValueType=pvtGHOST],Obj);
     Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and (pgcbBITS and not pgcbLIST)) or pgcbPERSISTENT;
    end else begin
     Temp:=Obj^.Header.GarbageCollector.State+pgcscONE;
     if Temp<=pgcscMAXSHIFTED then begin
      Obj^.Header.GarbageCollector.State:=Temp;
     end;
     POCAGarbageCollectorLinkedListRemove(Obj);
     POCAGarbageCollectorLinkedListPush(GarbageCollector^.BlackLists[Obj^.Header.ValueType=pvtGHOST],Obj);
     Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbBLACK;
    end;
    MarkObjectContent(Obj);
   end;
  end;
 end;
 procedure MarkTemporarySavedObjects(Context:PPOCAContext);
 var i:longint;
 begin
  for i:=0 to Context^.TemporarySavedObjectCount-1 do begin
   MarkObjectAsGray(Context^.TemporarySavedObjects^[i]);
  end;
 end;
 procedure MarkRoots;
 begin
  MarkValue(Instance^.Globals.Namespace);
  MarkValue(Instance^.Globals.HiddenNamespace);
  MarkValue(Instance^.Globals.BaseClass);
  MarkValue(Instance^.Globals.ArrayHash);
  MarkValue(Instance^.Globals.NumberHash);
  MarkValue(Instance^.Globals.StringHash);
  MarkValue(Instance^.Globals.RegExpHash);
  MarkValue(Instance^.Globals.CoroutineHash);
  MarkValue(Instance^.Globals.ThreadHash);
  MarkValue(Instance^.Globals.LockHash);
  MarkValue(Instance^.Globals.SemaphoreHash);
  MarkValue(Instance^.Globals.Save);
  MarkValue(Instance^.Globals.Symbols);
  MarkValue(Instance^.Globals.ArgumentsValueReference);
  MarkValue(Instance^.Globals.ConstructorValueReference);
  MarkValue(Instance^.Globals.NullValueReference);
  MarkValue(Instance^.Globals.ReferenceValueReference);
  MarkValue(Instance^.Globals.NumberValueReference);
  MarkValue(Instance^.Globals.StringValueReference);
  MarkValue(Instance^.Globals.ArrayValueReference);
  MarkValue(Instance^.Globals.GhostClassValueReference);
  MarkValue(Instance^.Globals.ClassValueReference);
  MarkValue(Instance^.Globals.GhostModuleValueReference);
  MarkValue(Instance^.Globals.ModuleValueReference);
  MarkValue(Instance^.Globals.GhostHashValueReference);
  MarkValue(Instance^.Globals.HashValueReference);
  MarkValue(Instance^.Globals.FunctionValueReference);
  MarkValue(Instance^.Globals.ClassGhostValueReference);
  MarkValue(Instance^.Globals.ModuleGhostValueReference);
  MarkValue(Instance^.Globals.HashGhostValueReference);
  MarkValue(Instance^.Globals.GhostValueReference);
  MarkValue(Instance^.Globals.CodeValueReference);
  MarkValue(Instance^.Globals.NativeCodeValueReference);
  MarkValue(Instance^.Globals.UnknownValueReference);
  MarkValue(Instance^.Globals.SourceFiles);
  MarkValue(Instance^.Globals.UniqueStringArray);
 end;
 function MarkContexts:boolean;
 var Context:PPOCAContext;
     Frame:PPOCAFrame;
     i,j:longint;
 begin
  Context:=Instance^.Globals.FirstContext;
  while assigned(Context) do begin
   for i:=0 to Context^.FrameTop-1 do begin
    Frame:=@Context^.FrameStack[i];
    MarkValue(Frame^.Func);
    MarkValue(Frame^.Locals);
    MarkValue(Frame^.Obj);
    for j:=0 to Frame^.CountRegisters-1 do begin
     MarkValue(Frame^.Registers[j]);
    end;
    for j:=0 to Frame^.CountArguments-1 do begin
     MarkValue(Frame^.Arguments[j]);
    end;   
   end;               
   if assigned(PPOCACoroutineData(Context^.CoroutineData)) and (assigned(PPOCACoroutineData(Context^.CoroutineData)^.Coroutine) and (PPOCACoroutineData(Context^.CoroutineData)^.Coroutine^.State<>pcsTERMINATED)) then begin
    POCACoroutineGhostMark(Context^.ThreadData);
   end;
   if assigned(PPOCAThreadData(Context^.ThreadData)) and not PPOCAThreadData(Context^.ThreadData)^.Terminated then begin
    POCAThreadGhostMark(Context^.ThreadData);
   end;
   MarkTemporarySavedObjects(Context);
   POCAGarbageCollectorLinkedListMove(Context^.GrayList,GarbageCollector^.GrayList);
   Context:=Context^.Next;
  end;
  result:=GarbageCollector^.GrayList.Next<>GarbageCollector^.GrayList;
 end;
 function MarkPoolGrays:boolean;
 var ValueType:longint;
     Pool:PPOCAPool;
     PoolBlock:PPOCAPoolBlock;
 begin
  if GarbageCollector^.ScanPoolGrays<>0 then begin
   GarbageCollector^.ScanPoolGrays:=0;
   for ValueType:=pvtFIRSTREF to pvtCOUNT-1 do begin
    Pool:=@Instance^.Globals.Pools[ValueType];
    PoolBlock:=Pool^.FirstBlock;
    while assigned(PoolBlock) do begin
     POCAGarbageCollectorLinkedListMove(PoolBlock^.GrayList,GarbageCollector^.GrayList);
     PoolBlock:=PoolBlock^.Next;
    end;
   end;
   result:=GarbageCollector^.GrayList.Next<>GarbageCollector^.GrayList;
  end else begin
   result:=false;
  end;
 end;
 function MarkContextGrays:boolean;
 var Context:PPOCAContext;
 begin
  if GarbageCollector^.ScanContextGrays<>0 then begin
   GarbageCollector^.ScanContextGrays:=0;
   Context:=Instance^.Globals.FirstContext;
   while assigned(Context) do begin
    POCAGarbageCollectorLinkedListMove(Context^.GrayList,GarbageCollector^.GrayList);
    Context:=Context^.Next;
   end;
   result:=GarbageCollector^.GrayList.Next<>GarbageCollector^.GrayList;
  end else begin
   result:=false;
  end;
 end;
 procedure MarkPersistents;
 var Ghost:boolean;
     Obj,NextObj:PPOCAObject;
     List:PPOCAGarbageCollectorLinkedList;
 begin
  for Ghost:=false to true do begin
   List:=GarbageCollector^.PersistentRootLists[Ghost];
   Obj:=pointer(List^.Next);      
   while pointer(Obj)<>List do begin
    NextObj:=pointer(Obj^.Header.GarbageCollector.LinkedList.Next);
    if not MarkObjectContent(Obj) then begin
     // No more references to ephemeral generation objects, so move from the
     // persistent root list to the persistent list
     POCAGarbageCollectorLinkedListRemove(Obj);
     POCAGarbageCollectorLinkedListPush(GarbageCollector^.PersistentLists[Ghost],Obj);
     Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbPERSISTENT;
    end;
    Obj:=NextObj;
   end;
  end;
 end;
 procedure MarkProtected;
 var Obj:PPOCAObject;
     i:longint;
 begin
  for i:=0 to Instance^.Globals.GarbageCollector.ProtectList.Count-1 do begin
   Obj:=Instance^.Globals.GarbageCollector.ProtectList[i];
   if assigned(Obj) then begin
    MarkObjectAsGray(Obj);
   end;
  end;
 end;
 procedure Reset;
 var Ghost:boolean;
     Obj:PPOCAObject;
 begin
  GarbageCollector^.PersistentCycleCounter:=0;
  for Ghost:=false to true do begin
   POCAGarbageCollectorLinkedListMove(GarbageCollector^.BlackLists[Ghost],GarbageCollector^.WhiteLists[Ghost]);
   POCAGarbageCollectorLinkedListMove(GarbageCollector^.PersistentLists[Ghost],GarbageCollector^.WhiteLists[Ghost]);
   POCAGarbageCollectorLinkedListMove(GarbageCollector^.PersistentRootLists[Ghost],GarbageCollector^.WhiteLists[Ghost]);
   Obj:=pointer(GarbageCollector^.WhiteLists[Ghost].Next);
   while pointer(Obj)<>GarbageCollector^.WhiteLists[Ghost] do begin
    Obj^.Header.GarbageCollector.State:=Obj^.Header.GarbageCollector.State and (pgcbBITS and not pgcbLIST);
    Obj:=pointer(Obj^.Header.GarbageCollector.LinkedList.Next);
   end;
  end;
  Obj:=pointer(GarbageCollector^.GrayList.Next);
  while pointer(Obj)<>GarbageCollector^.GrayList do begin
   Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and (pgcbBITS and not pgcbLIST)) or pgcbGRAY;
   Obj:=pointer(Obj^.Header.GarbageCollector.LinkedList.Next);
  end;
 end;
var i:longint;
//  WhiteGhostList:PPOCAGarbageCollectorLinkedList;
    Obj:PPOCAObject;
    Ghost:boolean;
begin
 GarbageCollector:=@Instance^.Globals.GarbageCollector;
 result:=true;
 POCALockEnter(GarbageCollector^.Lock);
 try
  if GarbageCollector^.PersistentForceScan and (GarbageCollector^.State<>pgcsINIT) then begin
   GarbageCollector^.State:=pgcsINIT;
  end;
  repeat
   case GarbageCollector^.State of
    pgcsRESET:begin
     Reset;
     GarbageCollector^.State:=pgcsINIT;
    end;
    pgcsINIT:begin
     if GarbageCollector^.PersistentInterval>0 then begin
      inc(GarbageCollector^.PersistentCycleCounter);
     end else begin
      GarbageCollector^.PersistentCycleCounter:=0;
     end;
     if GarbageCollector^.PersistentForceScan or ((GarbageCollector^.PersistentInterval>0) and (GarbageCollector^.PersistentCycleCounter>=GarbageCollector^.PersistentInterval)) or (Instance^.Globals.RequestGarbageCollection=brgcFULL) then begin
      GarbageCollector^.PersistentForceScan:=false;
      GarbageCollector^.PersistentCycleCounter:=0;
      for Ghost:=false to true do begin
       POCAGarbageCollectorLinkedListMoveMark(GarbageCollector^.PersistentLists[Ghost],GarbageCollector^.WhiteLists[Ghost],pgcbWASPERSISTENT);
       POCAGarbageCollectorLinkedListMoveMark(GarbageCollector^.PersistentRootLists[Ghost],GarbageCollector^.WhiteLists[Ghost],pgcbWASPERSISTENTROOT);
      end;
     end;
     GarbageCollector^.State:=pgcsMARKROOTS;
    end;
    pgcsMARKROOTS:begin
     MarkRoots;
     GarbageCollector^.State:=pgcsMARKCONTEXTS;
    end;
    pgcsMARKCONTEXTS:begin
     MarkContexts;
     GarbageCollector^.State:=pgcsMARKPERSISTENTS;
    end;
    pgcsMARKPERSISTENTS:begin
     MarkPersistents;
     GarbageCollector^.State:=pgcsMARKPROTECTED;
    end;
    pgcsMARKPROTECTED:begin
     MarkProtected;
     GarbageCollector^.State:=pgcsMARKGREYS;
    end;
    pgcsMARKGREYS,pgcsMARKWHITEGHOSTGREYS:begin
     if GarbageCollector^.State=pgcsMARKGREYS then begin
      MarkPoolGrays;
      MarkContextGrays;
     end;
     if GarbageCollector^.GrayList.Next=GarbageCollector^.GrayList then begin
      if GarbageCollector^.State=pgcsMARKWHITEGHOSTGREYS then begin
       GarbageCollector^.State:=pgcsSWEEP;
      end else begin
       GarbageCollector^.State:=pgcsSWEEPINIT;
      end;
     end else begin
      case Instance^.Globals.RequestGarbageCollection of
       brgcCYCLE:begin
        i:=POCAGarbageCollectorUsed(Instance);
        if i<>0 then begin
         i:=(i*GarbageCollector^.StepFactor) shr 8;
         if i<1024 then begin
          i:=1024;
         end;
        end;
       end;
       else {brgcFULLEPHEMERAL:}begin
        i:=-1;
       end;
      end;
      while (i<>0) and POCAGarbageCollectorLinkedListPop(GarbageCollector^.GrayList,Obj) do begin
       dec(i);
       MarkObject(pointer(Obj));
      end;
      if GarbageCollector^.GrayList.Next=GarbageCollector^.GrayList then begin
       if GarbageCollector^.State=pgcsMARKWHITEGHOSTGREYS then begin
        GarbageCollector^.State:=pgcsSWEEP;
       end else begin
        GarbageCollector^.State:=pgcsSWEEPINIT;
       end;
       if GarbageCollector^.StepFactor>=256 then begin
        continue;
       end;
      end;
      break;
     end;
    end;
    pgcsSWEEPINIT:begin
     // Scan contexts again before we are beginning sweeping (due to VM registers)
     if MarkContexts then begin
      GarbageCollector^.State:=pgcsMARKGREYS;
     end else begin
      GarbageCollector^.State:=pgcsFLIP;
      for Ghost:=false to true do begin
       if GarbageCollector^.WhiteLists[Ghost]^.Next<>GarbageCollector^.WhiteLists[Ghost] then begin
        if Ghost then begin
         POCAGarbageCollectorLinkedListMove(GarbageCollector^.WhiteLists[Ghost],GarbageCollector^.WhiteGhostList);
         GarbageCollector^.State:=pgcsMARKWHITEGHOSTS;
        end else begin
         POCAGarbageCollectorLinkedListMove(GarbageCollector^.WhiteLists[Ghost],GarbageCollector^.SweepLists[Ghost]);
         if GarbageCollector^.State=pgcsFLIP then begin
          GarbageCollector^.State:=pgcsSWEEP;
         end;
        end;
       end;
      end;
     end;
    end;
    pgcsMARKWHITEGHOSTS:begin
     case Instance^.Globals.RequestGarbageCollection of
      brgcCYCLE:begin
       i:=POCAGarbageCollectorUsed(Instance);
       if i<>0 then begin
        i:=(i*GarbageCollector^.GhostFactor) shr 8;
        if i<1024 then begin
         i:=1024;
        end;
       end;
      end;
      else {brgcFULLEPHEMERAL:}begin
       i:=-1;
      end;
     end;
     while (i<>0) and POCAGarbageCollectorLinkedListPop(GarbageCollector^.WhiteGhostList,Obj) do begin
      dec(i);
      if (((Obj^.Header.ValueType=pvtGHOST) and assigned(PPOCAGhost(Obj)^.GhostType)) and assigned(addr(PPOCAGhost(Obj)^.GhostType^.CanDestroy))) and not PPOCAGhost(Obj)^.GhostType^.CanDestroy(PPOCAGhost(Obj)^.Ptr) then begin
       POCAGarbageCollectorLinkedListRemove(Obj);
       POCAGarbageCollectorLinkedListPush(GarbageCollector^.GrayList,Obj);
      end else begin
       POCAGarbageCollectorLinkedListRemove(Obj);
       POCAGarbageCollectorLinkedListPush(GarbageCollector^.SweepLists[Obj^.Header.ValueType=pvtGHOST],Obj);
       TryMarkGhostAsGray(Obj);
      end;
     end;
     if GarbageCollector^.WhiteGhostList^.Next=GarbageCollector^.WhiteGhostList then begin
      if GarbageCollector^.GrayList^.Next=GarbageCollector^.GrayList then begin
       GarbageCollector^.State:=pgcsSWEEP;
      end else begin
       GarbageCollector^.State:=pgcsMARKWHITEGHOSTGREYS;
      end;
      if GarbageCollector^.GhostFactor>=256 then begin
       continue;
      end;
     end;
     break;
    end;
    pgcsSWEEP:begin
     case Instance^.Globals.RequestGarbageCollection of
      brgcCYCLE:begin
       i:=POCAGarbageCollectorUsed(Instance);
       if i<>0 then begin
        i:=(i*GarbageCollector^.SweepFactor) shr 8;
        if i<1024 then begin
         i:=1024;
        end;
       end;
      end;
      else {brgcFULLEPHEMERAL:}begin
       i:=-1;
      end;
     end;
     GarbageCollector^.State:=pgcsFLIP;
     for Ghost:=true downto false do begin
      while (i<>0) and POCAGarbageCollectorLinkedListPop(GarbageCollector^.SweepLists[Ghost],Obj) do begin
       dec(i);
       POCAPoolFreeElement(@Instance^.Globals.Pools[Obj^.Header.ValueType],Obj);
      end;
      if GarbageCollector^.SweepLists[Ghost]^.Next<>GarbageCollector^.SweepLists[Ghost] then begin
       GarbageCollector^.State:=pgcsSWEEP;
      end;
      if i=0 then begin
       break;
      end;
     end;
     if (GarbageCollector^.State=pgcsFLIP) and (GarbageCollector^.SweepFactor>=256) then begin
      continue;
     end else begin
      break;
     end;
    end;
    pgcsFLIP:begin
     case Instance^.Globals.RequestGarbageCollection of
      brgcCYCLE:begin
       i:=0;
       for Ghost:=false to true do begin
        if GarbageCollector^.BlackLists[Ghost]^.Next<>GarbageCollector^.BlackLists[Ghost] then begin
         inc(i);
         break;
        end;
       end;
       GarbageCollector^.State:=pgcsDONE;
       if i>0 then begin
        i:=POCAGarbageCollectorUsed(Instance);
        if i<>0 then begin
         i:=(i*GarbageCollector^.FlipFactor) shr 8;
         if i<1024 then begin
          i:=1024;
         end;
        end;
        for Ghost:=false to true do begin
         while (i<>0) and POCAGarbageCollectorLinkedListPop(GarbageCollector^.BlackLists[Ghost],Obj) do begin
          dec(i);
          POCAGarbageCollectorLinkedListRemove(Obj);
          POCAGarbageCollectorLinkedListPush(GarbageCollector^.WhiteLists[Ghost],Obj);
          Obj^.Header.GarbageCollector.State:=Obj^.Header.GarbageCollector.State and not pgcbLIST;
         end;
         if GarbageCollector^.BlackLists[Ghost]^.Next<>GarbageCollector^.BlackLists[Ghost] then begin
          GarbageCollector^.State:=pgcsFLIP;
          break;
         end;
        end;
       end;
      end;
      else {brgcFULLEPHEMERAL:}begin
       for Ghost:=false to true do begin
        POCAGarbageCollectorLinkedListMoveMark(GarbageCollector^.BlackLists[Ghost],GarbageCollector^.WhiteLists[Ghost],0);
       end;
       GarbageCollector^.State:=pgcsDONE;
      end;
     end;
    end;
    pgcsDONE:begin
     GarbageCollector^.State:=pgcsINIT;
     result:=false;
     break;
    end;
    else begin
     result:=false;
     break;
    end;
   end;
  until false;
 finally
  POCALockLeave(GarbageCollector^.Lock);
 end;
end;

procedure POCAGarbageCollectorCollectAll(Instance:PPOCAInstance); {$ifdef UseRegister}register;{$endif}
var GarbageCollector:PPOCAGarbageCollector;
    i:longint;
begin
 GarbageCollector:=@Instance^.Globals.GarbageCollector;
 if GarbageCollector^.State<>pgcsINIT then begin
  while POCAGarbageCollectorCollectCycle(Instance) do begin
  end;
  GarbageCollector^.State:=pgcsINIT;
//GarbageCollector^.State:=pgcsRESET;
 end;
 while POCAGarbageCollectorCollectCycle(Instance) do begin
 end;
 begin
  Instance^.Globals.DeadAllocationCount:=0;
  for i:=0 to pvtCOUNT-1 do begin
   inc(Instance^.Globals.DeadAllocationCount,Instance^.Globals.Pools[i].Size div 2);
  end;
  if Instance^.Globals.DeadSize<Instance^.Globals.DeadAllocationCount then begin
   Instance^.Globals.DeadSize:=Instance^.Globals.DeadAllocationCount;
   if Instance^.Globals.DeadSize<256 then begin
    Instance^.Globals.DeadSize:=256;
   end;
   FreeMem(Instance^.Globals.DeadBlocks);
   GetMem(Instance^.Globals.DeadBlocks,Instance^.Globals.DeadSize*sizeof(pointer));
   FillChar(Instance^.Globals.DeadBlocks^,Instance^.Globals.DeadSize*sizeof(pointer),#0);
  end;
 end;
end;

procedure POCAGarbageCollectorBottleneck(Instance:PPOCAInstance); {$ifdef UseRegister}register;{$endif}
begin
 TPasMPInterlocked.Exchange(longint(Instance^.Globals.Bottleneck),longint(longbool(true)));
 while Instance^.Globals.Bottleneck and (Instance^.Globals.WaitCount<(Instance^.Globals.ThreadCount-1)) do begin
  TPasMPInterlocked.Increment(Instance^.Globals.WaitCount);
  POCALockLeave(Instance^.Globals.Lock);
  try
   POCASemaphoreDown(Instance^.Globals.Semaphore);
  finally
   POCALockEnter(Instance^.Globals.Lock);
  end;
  TPasMPInterlocked.Decrement(Instance^.Globals.WaitCount);
 end;
 if Instance^.Globals.WaitCount>=(Instance^.Globals.ThreadCount-1) then begin
  POCAFreeDead(Instance);
  case Instance^.Globals.RequestGarbageCollection of
   brgcCYCLE:begin
    POCAGarbageCollectorCollectCycle(Instance);
   end;
   brgcFULLEPHEMERAL,brgcFULL:begin
    POCAGarbageCollectorCollectAll(Instance);
   end;
  end;
  if Instance^.Globals.WaitCount<>0 then begin
   POCASemaphoreUp(Instance^.Globals.Semaphore,Instance^.Globals.WaitCount);
  end;
  TPasMPInterlocked.Exchange(longint(Instance^.Globals.Bottleneck),longint(longbool(false)));
 end;
end;

procedure POCAGarbageCollectorCheckBottleneck(Instance:PPOCAInstance); {$ifdef UseRegister}register;{$endif}
begin
 if Instance^.Globals.Bottleneck then begin
  POCALockEnter(Instance^.Globals.Lock);
  try
   POCAGarbageCollectorBottleneck(Instance);
  finally
   POCALockLeave(Instance^.Globals.Lock);
  end;
 end;
end;

procedure POCAGarbageCollectorDoBottleneck(Instance:PPOCAInstance); {$ifdef UseRegister}register;{$endif}
begin
 POCALockEnter(Instance^.Globals.Lock);
 try
  POCAGarbageCollectorBottleneck(Instance);
 finally
  POCALockLeave(Instance^.Globals.Lock);
 end;
end;

procedure POCAGarbageCollectorLock(Context:PPOCAContext); {$ifdef UseRegister}register;{$endif}
var Instance:PPOCAInstance;
begin
 Instance:=Context^.Instance;
 POCALockEnter(Instance^.Globals.Lock);
 try
  TPasMPInterlocked.Increment(Instance^.Globals.ThreadCount);
  TPasMPInterlocked.Increment(Context^.GarbageCollectorLockCount);
 finally
  POCALockLeave(Instance^.Globals.Lock);
 end;
 POCAGarbageCollectorCheckBottleneck(Instance);
end;

procedure POCAGarbageCollectorUnlock(Context:PPOCAContext); {$ifdef UseRegister}register;{$endif}
var Instance:PPOCAInstance;
begin
 if Context^.GarbageCollectorLockCount>0 then begin
  Instance:=Context^.Instance;
  POCALockEnter(Instance^.Globals.Lock);
  try
   TPasMPInterlocked.Decrement(Context^.GarbageCollectorLockCount);
   TPasMPInterlocked.Decrement(Instance^.Globals.ThreadCount);
   if (Instance^.Globals.WaitCount>0) and (Instance^.Globals.ThreadCount=Instance^.Globals.WaitCount) then begin
    POCASemaphoreUp(Instance^.Globals.Semaphore,1);
   end;
  finally
   POCALockLeave(Instance^.Globals.Lock);
  end;
 end;
end;

procedure POCAGarbageCollectorSwapFree(Instance:PPOCAInstance;Target:PPointer;Value:pointer); {$ifdef UseRegister}register;{$endif}
var Old:pointer;
begin
 POCALockEnter(Instance^.Globals.Lock);
 try
  Old:=Target^;
  Target^:=Value;
  if assigned(Old) then begin
   if Instance^.Globals.WaitCount>=(Instance^.Globals.ThreadCount-1) then begin
    FreeMem(Old);
    POCAFreeDead(Instance);
   end else begin
    while Instance^.Globals.DeadCount>=Instance^.Globals.DeadSize do begin
     POCAGarbageCollectorBottleneck(Instance);
    end;
    PPointers(Instance^.Globals.DeadBlocks)^[Instance^.Globals.DeadCount]:=Old;
    inc(Instance^.Globals.DeadCount);
   end;
  end;
 finally
  POCALockLeave(Instance^.Globals.Lock);
 end;
end;

procedure POCATemporarySave(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}
var Obj:PPOCAObject;
begin
 if POCAIsValueObjectAndGetReferencePointer(Value,Obj) then begin
  if (not assigned(Context^.TemporarySavedObjects)) or ((Context^.TemporarySavedObjectCount+1)>=Context^.TemporarySavedObjectSize) then begin
   Context^.TemporarySavedObjectSize:=POCARoundUpToPowerOfTwo(Context^.TemporarySavedObjectCount+1);
   if Context^.TemporarySavedObjectSize<16 then begin
    Context^.TemporarySavedObjectSize:=16;
   end;
   ReallocMem(Context^.TemporarySavedObjects,Context^.TemporarySavedObjectSize*sizeof(PPOCAObject));
  end;
  Context^.TemporarySavedObjects^[Context^.TemporarySavedObjectCount]:=Obj;
  inc(Context^.TemporarySavedObjectCount);
 end;
end;

procedure POCAProtect(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}
var GarbageCollector:PPOCAGarbageCollector;
begin
 GarbageCollector:=@Context^.Instance^.Globals.GarbageCollector;
 POCALockEnter(GarbageCollector^.Lock);
 try
  if POCAIsValueObject(Value) then begin
   if GarbageCollector^.ProtectList.Find(POCAGetValueReferencePointer(Value))<0 then begin
    GarbageCollector^.ProtectList.Add(POCAGetValueReferencePointer(Value));
    case GarbageCollector^.State of
     pgcsMARKGREYS:begin
      GarbageCollector^.State:=pgcsMARKPROTECTED;
     end;
     pgcsINIT,pgcsMARKROOTS,pgcsMARKCONTEXTS,pgcsMARKPERSISTENTS,pgcsMARKPROTECTED:begin
     end;
     else begin
      GarbageCollector^.State:=pgcsINIT;
     end;
    end;
   end;
  end;
 finally
  POCALockLeave(GarbageCollector^.Lock);
 end;
end;

procedure POCAUnprotect(Context:PPOCAContext;const Value:TPOCAValue); {$ifdef UseRegister}register;{$endif}
var GarbageCollector:PPOCAGarbageCollector;
begin
 GarbageCollector:=@Context^.Instance^.Globals.GarbageCollector;
 POCALockEnter(GarbageCollector^.Lock);
 try
  if POCAIsValueObject(Value) then begin
   GarbageCollector^.ProtectList.Remove(POCAGetValueReferencePointer(Value));
  end;
 finally
  POCALockLeave(GarbageCollector^.Lock);
 end;
end;

function POCAConvertEvent(Context:PPOCAContext;const Value:TPOCAValue;const Operation:TPOCAMetaOp;var ResultValue:TPOCAValue):boolean;
var HashEvents:PPOCAHashEvents;
    SubContext:PPOCAContext;
begin
 HashEvents:=POCAHashGetHashEvents(Value,Operation);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[Operation]) then begin
  SubContext:=POCAContextSub(Context);
  try
   ResultValue:=POCACall(SubContext,HashEvents^[Operation],@Value,1,POCAValueNull,POCAValueNull);
   result:=true;
  finally
   POCAContextDestroy(SubContext);
  end;
 end else begin
  result:=false;
 end;
end;

function POCAConvertToNumberEvent(Context:PPOCAContext;const Value:TPOCAValue;var ResultValue:double):boolean;
var HashEvents:PPOCAHashEvents;
    SubContext:PPOCAContext;
    v:TPOCAValue;
begin
 result:=false;
 HashEvents:=POCAHashGetHashEvents(Value,pmoTONUMBER);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[pmoTONUMBER]) then begin
  SubContext:=POCAContextSub(Context);
  try
   v:=POCACall(SubContext,HashEvents^[pmoTONUMBER],@Value,1,POCAValueNull,POCAValueNull);
   if POCAIsValueNumber(v) then begin
    ResultValue:=v.Num;
    result:=true;
   end;
  finally
   POCAContextDestroy(SubContext);
  end;
 end;
end;

function POCAConvertToStringEvent(Context:PPOCAContext;const Value:TPOCAValue;var ResultValue:TPOCARawByteString):boolean;
var HashEvents:PPOCAHashEvents;
    SubContext:PPOCAContext;
    v:TPOCAValue;
begin
 result:=false;
 HashEvents:=POCAHashGetHashEvents(Value,pmoTOSTRING);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[pmoTOSTRING]) then begin
  SubContext:=POCAContextSub(Context);
  try
   v:=POCACall(SubContext,HashEvents^[pmoTOSTRING],@Value,1,POCAValueNull,POCAValueNull);
   if POCAIsValueString(v) then begin
    ResultValue:=PPOCAString(POCAGetValueReferencePointer(v))^.Data;
    result:=true;
   end;
  finally
   POCAContextDestroy(SubContext);
  end;
 end;
end;

function POCATypeOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=Context^.Instance.Globals.NullValueReference;
  end;
  pvtREFERENCE:begin
   result:=Context^.Instance.Globals.ReferenceValueReference;
  end;
  pvtNUMBER:begin
   result:=Context^.Instance.Globals.NumberValueReference;
  end;
  pvtSTRING:begin
   result:=Context^.Instance.Globals.StringValueReference;
  end;
  pvtARRAY:begin
   result:=Context^.Instance.Globals.ArrayValueReference;
  end;
  pvtHASH:begin
   case POCAHashGetKind(Value) of
    phkCLASS:begin
     if assigned(POCAHashGetGhost(Value)) then begin
      result:=Context^.Instance.Globals.GhostClassValueReference;
     end else begin
      result:=Context^.Instance.Globals.ClassValueReference;
     end;
    end;
    phkMODULE:begin
     if assigned(POCAHashGetGhost(Value)) then begin
      result:=Context^.Instance.Globals.GhostModuleValueReference;
     end else begin
      result:=Context^.Instance.Globals.ModuleValueReference;
     end;
    end;
    else begin
     if assigned(POCAHashGetGhost(Value)) then begin
      result:=Context^.Instance.Globals.GhostHashValueReference;
     end else begin
      result:=Context^.Instance.Globals.HashValueReference;
     end;
    end;
   end;
  end;
  pvtFUNCTION:begin
   result:=Context^.Instance.Globals.FunctionValueReference;
  end;
  pvtGHOST:begin
   if assigned(POCAGhostGetHash(Value)) then begin
    case POCAGhostGetHash(Value)^.Kind of
     phkCLASS:begin
      result:=Context^.Instance.Globals.ClassGhostValueReference;
     end;
     phkMODULE:begin
      result:=Context^.Instance.Globals.ModuleGhostValueReference;
     end;
     else begin
      result:=Context^.Instance.Globals.HashGhostValueReference;
     end;
    end;
   end else begin
    result:=Context^.Instance.Globals.GhostValueReference;
   end;
  end;
  pvtCODE:begin
   result:=Context^.Instance.Globals.CodeValueReference;
  end;
  pvtNATIVECODE:begin
   result:=Context^.Instance.Globals.NativeCodeValueReference;
  end;
  else begin
   result:=Context^.Instance.Globals.UnknownValueReference;
  end;
 end;
end;

function POCAIDOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;
var s:TPOCARawByteString;
    Ghost:PPOCAGhost;
begin
 if not POCAIsValueReference(Value) then begin
  POCARuntimeError(Context,'Bad arguments to "idof"');
  result:=POCAValueNull;
 end else begin
  case POCAGetValueType(Value) of
   pvtNULL:begin
    s:='null';
   end;
   pvtREFERENCE:begin
    s:='reference';
   end;
   pvtNUMBER:begin
    s:='number';
   end;
   pvtSTRING:begin
    s:='string';
   end;
   pvtARRAY:begin
    s:='array';
   end;
   pvtHASH:begin
    case POCAHashGetKind(Value) of
     phkCLASS:begin
      if assigned(POCAHashGetGhost(Value)) then begin
       s:='ghostclass';
      end else begin
       s:='class';
      end;
     end;
     phkMODULE:begin
      if assigned(POCAHashGetGhost(Value)) then begin
       s:='ghostmodule';
      end else begin
       s:='module';
      end;
     end;
     else begin
      if assigned(POCAHashGetGhost(Value)) then begin
       s:='ghosthash';
      end else begin
       s:='hash';
      end;
     end;
    end;
   end;
   pvtFUNCTION:begin
    s:='function';
   end;
   pvtGHOST:begin
    if assigned(POCAGhostGetHash(Value)) then begin
     case POCAGhostGetHash(Value)^.Kind of
      phkCLASS:begin
       s:='classghost';
      end;
      phkMODULE:begin
       s:='moduleghost';
      end;
      else begin
       s:='hashghost';
      end;
     end;
    end else begin
     s:='ghost';
    end;
    Ghost:=PPOCAGhost(POCAGetValueReferencePointer(Value));
    if length(Ghost^.GhostType^.Name)>0 then begin
     s:=s+'('+Ghost^.GhostType^.Name+')';
    end else begin
     s:=s+'('+TPOCARawByteString(IntToHex(TPOCAPtrUInt(Ghost^.GhostType),{$ifdef cpu64}16{$else}8{$endif}))+')';
    end;
   end;
   pvtCODE:begin
    s:='code';
   end;
   pvtNATIVECODE:begin
    s:='nativecode';
   end;
   else begin
    s:='unknown';
   end;
  end;
  result:=POCANewString(Context,s+':0x'+TPOCARawByteString(IntToHex(TPOCAPtrUInt(POCAGetValueReferencePointer(Value)),{$ifdef cpu64}16{$else}8{$endif})));
 end;
end;

function POCAGhostTypeOf(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue;
var Ghost:PPOCAGhost;
begin
 if POCAIsValueGhost(Value) then begin
  Ghost:=PPOCAGhost(POCAGetValueReferencePointer(Value));
  if length(Ghost^.GhostType^.Name)>0 then begin
   result:=POCANewString(Context,Ghost^.GhostType^.Name);
  end else begin
   result:=POCANewString(Context,'0x'+TPOCARawByteString(IntToHex(TPOCAPtrUInt(Ghost^.GhostType),{$ifdef cpu64}16{$else}8{$endif})));
  end;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCAObject(Instance:PPOCAInstance;ValueType:longint;Obj:PPOCAObject):TPOCAValue;
begin
 POCASetValueReferencePointer(result,Obj);
 if assigned(Obj) then begin
  Obj^.Header.ValueType:=ValueType;
{$ifndef POCAGarbageCollectorPoolBlockInstance}
  Obj^.Header.Instance:=Instance;
{$endif}  
 end;
end;

function POCAIsValueTrue(Context:PPOCAContext;const Value:TPOCAValue):boolean; {$ifdef UseRegister}register;{$endif}
var Num:double;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=false;
  end;
  pvtNUMBER:begin
   result:=Value.Num<>0;
  end;
  pvtSTRING:begin
   result:=true;
  end;
  else begin
   Num:=0;
   if POCAConvertToNumberEvent(Context,Value,Num) then begin
    result:=Num<>0;
   end else begin
    result:=false;
   end;
  end;
 end;
end;

function POCABooleanValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
var Num:double;
    OK:TPasDblStrUtilsBoolean;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
// result:=POCAValueNull;
   result.Num:=0;
  end;
  pvtNUMBER:begin
   result.Num:=ord(Value.Num<>0);
  end;
  pvtSTRING:begin
   if length(PPOCAString(POCAGetValueReferencePointer(Value))^.Data)=0 then begin
    result.Num:=0;
   end else begin
    Num:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(Value))^.Data,rmNearest,@OK);
    if OK then begin
     result.Num:=ord(Num<>0);
    end else begin
     result.Num:=ord(length(PPOCAString(POCAGetValueReferencePointer(Value))^.Data)>0);
    end;
   end;
  end;
  else begin
   result.Num:=0;
   if not POCAConvertToNumberEvent(Context,Value,result.Num) then begin
    result.Num:=1;
   end;
  end;
 end;
end;

function POCANumberValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
var OK:TPasDblStrUtilsBoolean;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=POCAValueNull;
  end;
  pvtNUMBER:begin
   result:=Value;
  end;
  pvtSTRING:begin
   POCASetValueNumber(result,ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(Value))^.Data,rmNearest,@OK));
   if not OK then begin
    result:=POCAValueNull;
   end;
  end;
  else begin
   result:=POCAValueNull;
   POCAConvertEvent(Context,Value,pmoTONUMBER,result);
  end;
 end;
end;

function POCAStringValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=POCAValueNull;
  end;
  pvtNUMBER:begin
   result:=POCANewString(Context,POCADoubleToString(Value.Num));
  end;
  pvtSTRING:begin
   result:=Value;
  end;
  else begin
   result:=POCAValueNull;
   POCAConvertEvent(Context,Value,pmoTOSTRING,result);
  end;
 end;
end;

function POCAGetBooleanValue(Context:PPOCAContext;const Value:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
var Num:double;
    OK:TPasDblStrUtilsBoolean;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=false;
  end;
  pvtNUMBER:begin
   result:=Value.Num<>0;
  end;
  pvtSTRING:begin
   if length(PPOCAString(POCAGetValueReferencePointer(Value))^.Data)=0 then begin
    result:=false;
   end else begin
    Num:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(Value))^.Data,rmNearest,@OK);
    if OK then begin
     result:=Num<>0;
    end else begin
     result:=length(PPOCAString(POCAGetValueReferencePointer(Value))^.Data)>0;
    end;
   end;
  end;
  else begin
   Num:=0;
   if POCAConvertToNumberEvent(Context,Value,Num) then begin
    result:=Num<>0;
   end else begin
    result:=true;
   end;
  end;
 end;
end;

function POCAGetNumberValue(Context:PPOCAContext;const Value:TPOCAValue):double; {$ifdef caninline}inline;{$endif}
const NAN=0/0;
var OK:TPasDblStrUtilsBoolean;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=0;
  end;
  pvtNUMBER:begin
   result:=Value.Num;
  end;
  pvtSTRING:begin
   result:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(Value))^.Data,rmNearest,@OK);
   if not OK then begin
    result:=NAN;
   end;
  end;
  else begin
   result:=1;
   POCAConvertToNumberEvent(Context,Value,result);
  end;
 end;
end;

function POCAGetStringValue(Context:PPOCAContext;const Value:TPOCAValue):TPOCARawByteString; {$ifdef caninline}inline;{$endif}
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:='';
  end;
  pvtNUMBER:begin
   result:=POCADoubleToString(Value.Num);
  end;
  pvtSTRING:begin
   result:=PPOCAString(POCAGetValueReferencePointer(Value))^.Data;
  end;
  else begin
   result:='';
   POCAConvertToStringEvent(Context,Value,result);
  end;
 end;
end;

function POCAGetVariantValue(Context:PPOCAContext;const Value:TPOCAValue):Variant; {$ifdef caninline}inline;{$endif}
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=Variants.Null;
  end;
  pvtNUMBER:begin
   result:=Value.Num;
  end;
  pvtSTRING:begin
   result:=PPOCAString(POCAGetValueReferencePointer(Value))^.Data;
  end;
  else begin
   result:=Variants.Null;
  end;
 end;
end;

function POCAIsStringUTF8(Context:PPOCAContext;const Value:TPOCAValue):boolean;
var s:TPOCARawByteString;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=false;
  end;
  pvtNUMBER:begin
   result:=false;
  end;
  pvtSTRING:begin
   result:=(PPOCAString(POCAGetValueReferencePointer(Value))^.UTF8=suISUTF8) or ((PPOCAString(POCAGetValueReferencePointer(Value))^.UTF8=suPOSSIBLEUTF8) and PUCUIsUTF8(PPOCAString(POCAGetValueReferencePointer(Value))^.Data));
  end;
  else begin
   s:='';
   POCAConvertToStringEvent(Context,Value,s);
   result:=PUCUIsUTF8(s);
  end;
 end;
end;

function POCAGetStringUTF8(Context:PPOCAContext;const Value:TPOCAValue):longint;
var s:TPOCARawByteString;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=suNOUTF8;
  end;
  pvtNUMBER:begin
   result:=suNOUTF8;
  end;
  pvtSTRING:begin
   result:=PPOCAString(POCAGetValueReferencePointer(Value))^.UTF8;
  end;
  else begin
   s:='';
   POCAConvertToStringEvent(Context,Value,s);
   result:=PUCUUTF8Get(s);
  end;
 end;
end;

function POCAGetStringUTF8Length(Context:PPOCAContext;const Value:TPOCAValue):longint;
var s:TPOCARawByteString;
begin
 case POCAGetValueType(Value) of
  pvtNULL:begin
   result:=0;
  end;
  pvtNUMBER:begin
   result:=0;
  end;
  pvtSTRING:begin
   if PPOCAString(POCAGetValueReferencePointer(Value))^.UTF8=suISUTF8 then begin
    result:=PPOCAString(POCAGetValueReferencePointer(Value))^.UTF8Length;
   end else begin
    result:=PPOCAString(POCAGetValueReferencePointer(Value))^.DataLength;
   end;
  end;
  else begin
   s:='';
   POCAConvertToStringEvent(Context,Value,s);
   if PUCUIsUTF8(s) then begin
    result:=PUCUUTF8Length(s);
   end else begin
    result:=length(s);
   end;
  end;
 end;
end;

procedure POCAReleaseContextObjectPools(Instance:PPOCAInstance); forward;

procedure POCAGarbageCollectorContextAllocate(Context:PPOCAContext;ValueType:longint);
var ContextObjectPool:PPOCAContextObjectPool;
    Pool:PPOCAPool;
    Count:longint;
begin
 POCALockEnter(Context^.Instance^.Globals.Lock);
 try
  Count:=Context^.Instance^.Globals.GarbageCollector.LocalContextPoolSize;
  ContextObjectPool:=@Context^.ContextObjectPools[ValueType];
  Pool:=@Context^.Instance^.Globals.Pools[ValueType];
  if ContextObjectPool^.Size<Count then begin
   ContextObjectPool^.Size:=Count;
   ReallocMem(ContextObjectPool^.Objects,ContextObjectPool^.Size*SizeOf(PPOCAObject));
  end;
  while ContextObjectPool^.Count<Count do begin
   while Pool^.FreeCount=0 do begin
    if Context^.Instance^.Globals.GarbageCollector.FullCollect then begin
     Context^.Instance^.Globals.RequestGarbageCollection:=brgcFULLEPHEMERAL;
     POCAGarbageCollectorBottleneck(Context^.Instance);
     if Pool^.FreeCount=0 then begin
      Context^.Instance^.Globals.RequestGarbageCollection:=brgcFULL;
      POCAGarbageCollectorBottleneck(Context^.Instance);
     end;
    end;
    if Pool^.FreeCount=0 then begin
     POCAReleaseContextObjectPools(Context^.Instance);
     if Pool^.FreeCount=0 then begin
      POCAPoolNewBlock(Pool,Pool^.Size div 8);
     end;
    end;
   end;
   dec(Pool^.FreeCount);
   ContextObjectPool^.Objects^[ContextObjectPool^.Count]:=Pool^.FreeObjects^[Pool^.FreeCount];
   inc(ContextObjectPool^.Count);
  end;
 finally
  POCALockLeave(Context^.Instance^.Globals.Lock);
 end;
end;

function POCANew(Context:PPOCAContext;ValueType:longint;var Obj:PPOCAObject):TPOCAValue;
var GarbageCollector:PPOCAGarbageCollector;
    ContextObjectPool:PPOCAContextObjectPool;
    Count:longint;
begin
 GarbageCollector:=@Context^.Instance^.Globals.GarbageCollector;
 if GarbageCollector^.IntervalFactor>0 then begin
  TPasMPInterlocked.Increment(GarbageCollector^.AllocationCounter);
  Count:=(POCAGarbageCollectorUsed(Context^.Instance)*GarbageCollector^.IntervalFactor) shr 8;
  if Count<1024 then begin
   Count:=1024;
  end else if Count>=GarbageCollector^.Allocated then begin
   Count:=GarbageCollector^.Allocated;
  end;
  if GarbageCollector^.AllocationCounter>=Count then begin
   TPasMPInterlocked.Exchange(GarbageCollector^.AllocationCounter,0);
   Context^.Instance^.Globals.RequestGarbageCollection:=brgcCYCLE;
   POCAGarbageCollectorBottleneck(Context^.Instance);
  end;
 end;

 ContextObjectPool:=@Context^.ContextObjectPools[ValueType];

 if ContextObjectPool^.Count=0 then begin
  POCAGarbageCollectorContextAllocate(Context,ValueType);
 end;

 dec(ContextObjectPool^.Count);

 Obj:=ContextObjectPool^.Objects^[ContextObjectPool^.Count];

 TPasMPInterlocked.Exchange(GarbageCollector^.ScanContextGrays,-1);

 POCAGarbageCollectorLinkedListPush(Context^.GrayList,Obj);
 Obj^.Header.GarbageCollector.State:=(Obj^.Header.GarbageCollector.State and not pgcbLIST) or pgcbGRAY;

 TPasMPInterlocked.Decrement(GarbageCollector^.FreeCount);

{$ifdef POCAGarbageCollectorPoolBlockReferenceCounting}
 TPasMPInterlocked.Increment(Obj^.Header.PoolBlock^.ReferenceCounter);
{$endif}

 POCASetValueReferencePointer(result,Obj);

end;

function POCAStringUTF8GetCodeUnit(Context:PPOCAContext;const Value:TPOCAValue;CodePoint:longint):longint;
var Str:PPOCAString;
begin
 if POCAIsValueString(Value) then begin
  Str:=POCAGetValueReferencePointer(Value);
  if Str^.UTF8=suISUTF8 then begin
   result:=0;
   if (CodePoint>=0) and (CodePoint<Str^.UTF8Length) then begin
    if assigned(Str^.UTF8CodePointsToCodeUnitsIndex) then begin
     case Str^.UTF8CodePointsToCodeUnitsIndexSize of
      1:begin
       result:=byte(pointer(@pansichar(Str^.UTF8CodePointsToCodeUnitsIndex)[CodePoint])^);
      end;
      2:begin
       result:=word(pointer(@pansichar(Str^.UTF8CodePointsToCodeUnitsIndex)[CodePoint shl 1])^);
      end;
      4:begin
       result:=longword(pointer(@pansichar(Str^.UTF8CodePointsToCodeUnitsIndex)[CodePoint shl 2])^);
      end;
     end;
    end else begin
     result:=PUCUUTF8GetCodeUnit(Str^.Data,CodePoint);
    end;
   end else begin
    if CodePoint<0 then begin
     result:=0;
    end else begin
     result:=Str^.DataLength+1;
    end;
   end;
  end else begin
   result:=CodePoint+1;
  end;
 end else begin
  result:=0;
 end;
end;

function POCAStringUTF8GetCodePoint(Context:PPOCAContext;const Value:TPOCAValue;CodeUnit:longint):longint;
var Str:PPOCAString;
begin
 if POCAIsValueString(Value) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(Value));
  if Str^.UTF8=suISUTF8 then begin
   result:=-1;
   if (CodeUnit>0) and (CodeUnit<=Str^.DataLength) then begin
    if assigned(Str^.UTF8CodeUnitsToCodePointsIndex) then begin
     case Str^.UTF8CodeUnitsToCodePointsIndexSize of
      1:begin
       result:=byte(pointer(@pansichar(Str^.UTF8CodeUnitsToCodePointsIndex)[CodeUnit])^);
      end;
      2:begin
       result:=word(pointer(@pansichar(Str^.UTF8CodeUnitsToCodePointsIndex)[CodeUnit shl 1])^);
      end;
      4:begin
       result:=longword(pointer(@pansichar(Str^.UTF8CodeUnitsToCodePointsIndex)[CodeUnit shl 2])^);
      end;
     end;
    end else begin
     result:=PUCUUTF8GetCodePoint(Str^.Data,CodeUnit);
    end;
   end else begin
    if CodeUnit<0 then begin
     result:=-1;
    end else begin
     result:=Str^.UTF8Length;
    end;
   end;
  end else begin
   result:=CodeUnit-1;
  end;
 end else begin
  result:=-1;
 end;
end;

function POCAStringUTF8CopyCodePointRange(Context:PPOCAContext;const Value:TPOCAValue;FromCodePoint,ToCodePoint:longint):TPOCARawByteString;
var Str:PPOCAString;
    FromCodeUnit,ToCodeUnit:longint;
begin
 if ((FromCodePoint>=0) and (ToCodePoint>=FromCodePoint)) and POCAIsValueString(Value) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(Value));
  if Str^.UTF8=suISUTF8 then begin
   FromCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Value,FromCodePoint);
   ToCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Value,ToCodePoint+1);
  end else begin
   FromCodeUnit:=FromCodePoint+1;
   ToCodeUnit:=ToCodePoint+2;
  end;
  if (FromCodeUnit>0) and (ToCodeUnit>=FromCodeUnit) then begin
   result:=System.Copy(Str^.Data,FromCodeUnit,ToCodeUnit-FromCodeUnit);
  end else begin
   result:='';
  end;
 end else begin
  result:='';
 end;
end;

procedure POCAStringUpdate(Context:PPOCAContext;const Value:TPOCAValue);
var Str:PPOCAString;
    s:TPOCARawByteString;
    UTF8State:longword;
    UTF8CodeUnit,UTF8CodePoint:longint;
begin
 if POCAIsValueString(Value) then begin
  Str:=POCAGetValueReferencePointer(Value);
  if Str^.Dirty then begin
   if assigned(Str^.UTF8CodePointsToCodeUnitsIndex) then begin
    FreeMem(Str^.UTF8CodePointsToCodeUnitsIndex);
    Str^.UTF8CodePointsToCodeUnitsIndex:=nil;
   end;
   if assigned(Str^.UTF8CodePointsToCodeUnitsIndex) then begin
    FreeMem(Str^.UTF8CodeUnitsToCodePointsIndex);
    Str^.UTF8CodeUnitsToCodePointsIndex:=nil;
   end;
{$ifdef pocastrictutf8}
   UTF8CodePoint:=0;
   while true do {$endif}begin
    s:=Str^.Data;
    Str^.DataLength:=length(s);
    UTF8State:=ucACCEPT;
    UTF8CodePoint:=0;
    for UTF8CodeUnit:=1 to length(s) do begin
     UTF8State:=PUCUUTF8DFATransitions[UTF8State+PUCUUTF8DFACharClasses[s[UTF8CodeUnit]]];
     case UTF8State of
      ucACCEPT:begin
       inc(UTF8CodePoint);
      end;
      ucERROR:begin
       break;
      end;
     end;
    end;
    if UTF8State=ucACCEPT then begin
     if length(s)<>UTF8CodePoint then begin
      Str^.UTF8:=suISUTF8;
     end else begin
      Str^.UTF8:=suPOSSIBLEUTF8;
     end;
    end else begin
{$ifdef pocastrictutf8}
     Str^.UTF8:=suISUTF8;
     Str^.Data:=PUCUUTF8Correct(Str^.Data);
     continue;
{$else}
     Str^.UTF8:=suNOUTF8;
{$endif}
    end;
{$ifdef pocastrictutf8}
    break;
{$endif}
   end;
   if Str^.UTF8=suISUTF8 then begin
    Str^.UTF8Length:=UTF8CodePoint;
    if Str^.DataLength<256 then begin
     Str^.UTF8CodePointsToCodeUnitsIndexSize:=1;
    end else if Str^.DataLength<65536 then begin
     Str^.UTF8CodePointsToCodeUnitsIndexSize:=2;
    end else begin
     Str^.UTF8CodePointsToCodeUnitsIndexSize:=4;
    end;
    if Str^.UTF8Length<256 then begin
     Str^.UTF8CodeUnitsToCodePointsIndexSize:=1;
    end else if Str^.UTF8Length<65536 then begin
     Str^.UTF8CodeUnitsToCodePointsIndexSize:=2;
    end else begin
     Str^.UTF8CodeUnitsToCodePointsIndexSize:=4;
    end;
    GetMem(Str^.UTF8CodePointsToCodeUnitsIndex,(Str^.UTF8Length+1)*Str^.UTF8CodePointsToCodeUnitsIndexSize);
    GetMem(Str^.UTF8CodeUnitsToCodePointsIndex,(Str^.DataLength+1)*Str^.UTF8CodeUnitsToCodePointsIndexSize);
    FillChar(Str^.UTF8CodePointsToCodeUnitsIndex^,(Str^.UTF8Length+1)*Str^.UTF8CodePointsToCodeUnitsIndexSize,#0);
    FillChar(Str^.UTF8CodeUnitsToCodePointsIndex^,(Str^.DataLength+1)*Str^.UTF8CodeUnitsToCodePointsIndexSize,#0);
    UTF8CodePoint:=0;
    UTF8CodeUnit:=1;
    while UTF8CodeUnit<=Str^.DataLength do begin
     case Str^.UTF8CodePointsToCodeUnitsIndexSize of
      1:begin
       byte(pointer(@pansichar(Str^.UTF8CodePointsToCodeUnitsIndex)[UTF8CodePoint])^):=UTF8CodeUnit;
      end;
      2:begin
       word(pointer(@pansichar(Str^.UTF8CodePointsToCodeUnitsIndex)[UTF8CodePoint shl 1])^):=UTF8CodeUnit;
      end;
      4:begin
       longword(pointer(@pansichar(Str^.UTF8CodePointsToCodeUnitsIndex)[UTF8CodePoint shl 2])^):=UTF8CodeUnit;
      end;
     end;
     case Str^.UTF8CodeUnitsToCodePointsIndexSize of
      1:begin
       byte(pointer(@pansichar(Str^.UTF8CodeUnitsToCodePointsIndex)[(UTF8CodeUnit-1)])^):=UTF8CodePoint;
      end;
      2:begin
       word(pointer(@pansichar(Str^.UTF8CodeUnitsToCodePointsIndex)[(UTF8CodeUnit-1) shl 1])^):=UTF8CodePoint;
      end;
      4:begin
       longword(pointer(@pansichar(Str^.UTF8CodeUnitsToCodePointsIndex)[(UTF8CodeUnit-1) shl 2])^):=UTF8CodePoint;
      end;
     end;
     inc(UTF8CodeUnit,PUCUUTF8CharSteps[Str^.Data[UTF8CodeUnit]]);
     inc(UTF8CodePoint);
    end;
    begin
     case Str^.UTF8CodePointsToCodeUnitsIndexSize of
      1:begin
       byte(pointer(@pansichar(Str^.UTF8CodePointsToCodeUnitsIndex)[UTF8CodePoint])^):=UTF8CodeUnit;
      end;
      2:begin
       word(pointer(@pansichar(Str^.UTF8CodePointsToCodeUnitsIndex)[UTF8CodePoint shl 1])^):=UTF8CodeUnit;
      end;
      4:begin
       longword(pointer(@pansichar(Str^.UTF8CodePointsToCodeUnitsIndex)[UTF8CodePoint shl 2])^):=UTF8CodeUnit;
      end;
     end;
     case Str^.UTF8CodeUnitsToCodePointsIndexSize of
      1:begin
       byte(pointer(@pansichar(Str^.UTF8CodeUnitsToCodePointsIndex)[(UTF8CodeUnit-1)])^):=UTF8CodePoint;
      end;
      2:begin
       word(pointer(@pansichar(Str^.UTF8CodeUnitsToCodePointsIndex)[(UTF8CodeUnit-1) shl 1])^):=UTF8CodePoint;
      end;
      4:begin
       longword(pointer(@pansichar(Str^.UTF8CodeUnitsToCodePointsIndex)[(UTF8CodeUnit-1) shl 2])^):=UTF8CodePoint;
      end;
     end;
    end;
   end else begin
    Str^.UTF8Length:=Str^.DataLength;
   end;
   Str^.Dirty:=false;
  end;
 end;
end;

function POCANewNumber(Context:PPOCAContext;const Data:double=0.0):TPOCAValue;
begin
 result.Num:=Data;
end;

function POCANewString(Context:PPOCAContext;const Data:TPOCARawByteString=''):TPOCAValue;
var Str:PPOCAString;
begin
 result:=POCANew(Context,pvtSTRING,PPOCAObject(Str));
//Str:=POCAGetValueReferencePointer(result);
 Str^.Data:=Data;
 Str^.DataLength:=length(Data);
 Str^.HashCode:=POCAHashString(Data);
 Str^.Dirty:=true;
 POCAStringUpdate(Context,result);
end;

function POCANewUniqueString(Context:PPOCAContext;const Data:TPOCARawByteString=''):TPOCAValue;
var Str:PPOCAString;
    Item:PPOCAStringHashMapItem;
    Value:int64;
begin
 POCALockEnter(Context^.Instance^.Globals.UniqueStringLock);
 try
  Item:=Context^.Instance^.Globals.UniqueStringHashMap.GetKey(Data);
  if assigned(Item) then begin
   POCALockLeave(Context^.Instance^.Globals.UniqueStringLock);
   try
    result:=POCAArrayGet(Context^.Instance^.Globals.UniqueStringArray,Item^.Value);
   finally
    POCALockEnter(Context^.Instance^.Globals.UniqueStringLock);
   end;
  end else begin
   POCALockLeave(Context^.Instance^.Globals.UniqueStringLock);
   try
    result:=POCANew(Context,pvtSTRING,PPOCAObject(Str));
//  Str:=POCAGetValueReferencePointer(result);
    Str^.Data:=Data;
    Str^.DataLength:=length(Str^.Data);
    Str^.HashCode:=POCAHashString(Data);
    Str^.Dirty:=true;
    POCAStringUpdate(Context,result);
    Value:=POCAArrayPush(Context^.Instance^.Globals.UniqueStringArray,result);
   finally
    POCALockEnter(Context^.Instance^.Globals.UniqueStringLock);
   end;
   Item:=Context^.Instance^.Globals.UniqueStringHashMap.NewKey(Data);
   Item^.Value:=Value;
  end;
 finally
  POCALockLeave(Context^.Instance^.Globals.UniqueStringLock);
 end;
end;

function POCANewArray(Context:PPOCAContext):TPOCAValue;
var Obj:PPOCAArray;
begin
 result:=POCANew(Context,pvtARRAY,PPOCAObject(Obj));
 Obj^.ArrayRecord:=nil;
end;

function POCANewHash(Context:PPOCAContext):TPOCAValue;
var Hash:PPOCAHash;
begin
 result:=POCANew(Context,pvtHASH,PPOCAObject(Hash));
{Hash^.HashRecord:=nil;
 Hash^.Prototype:=nil;
 Hash^.Constructor_:=nil;
 Hash^.Children.First:=nil;
 Hash^.Children.Last:=nil;
 Hash^.Children.Previous:=nil;
 Hash^.Children.Next:=nil;
 Hash^.Structure:=nil;
 Hash^.Events:=nil;
 Hash^.Ghost:=nil;}
end;

function POCANewCode(Context:PPOCAContext):TPOCAValue;
var Obj:PPOCACode;
begin
 result:=POCANew(Context,pvtCODE,PPOCAObject(Obj));
end;

function POCANewNativeCode(Context:PPOCAContext;const FunctionPointer:TPOCANativeFunction;const DestroyFunctionPointer:TPOCANativeDestroyFunction=nil;const UserData:pointer=nil):TPOCAValue;
var Obj:PPOCANativeCode;
begin
 result:=POCANew(Context,pvtNATIVECODE,PPOCAObject(Obj));
 Obj^.FunctionPointer:=FunctionPointer;
 Obj^.DestroyFunctionPointer:=DestroyFunctionPointer;
 Obj^.UserData:=UserData;
end;

function POCANewFunction(Context:PPOCAContext;const Code:TPOCAValue):TPOCAValue;
var Func:PPOCAFunction;
begin
 result:=POCANew(Context,pvtFUNCTION,PPOCAObject(Func));
 Func^.Code:=Code;
 Func^.Namespace:=POCAValueNull;
 Func^.Obj:=POCAValueNull;
 Func^.Next:=POCAValueNull;
end;

function POCANewGhost(Context:PPOCAContext;const GhostType:PPOCAGhostType;const Ptr:pointer;const Hash:PPOCAHash=nil;const PtrType:TPOCAGhostPtrType=pgptRAW):TPOCAValue;
var Ghost:PPOCAGhost;
begin
 result:=POCANew(Context,pvtGHOST,PPOCAObject(Ghost));
 Ghost^.GhostType:=GhostType;
 Ghost^.PtrType:=PtrType;
 Ghost^.Ptr:=Ptr;
 Ghost^.Hash:=Hash;
end;

function POCANewNativeObject(Context:PPOCAContext;const NativeObjectValue:TPOCANativeObject):TPOCAValue;
begin
 if assigned(NativeObjectValue) then begin
  result:=NativeObjectValue.GhostValue;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCANewValueFromVariant(Context:PPOCAContext;const VariantValue:Variant):TPOCAValue;
begin
 case VarType(VariantValue) of
  varNull:begin
   result:=POCAValueNull;
  end;
  varSmallInt,varInteger,varShortInt,varByte,varWord,varLongWord,varInt64{$ifdef fpc},varQWord{$endif}:begin
   result.Num:=VariantValue;
  end;
  varSingle,varDouble,varDATE,varCurrency:begin
   result.Num:=VariantValue;
  end;
  varBoolean:begin
   result.Num:=ord(boolean(VariantValue));
  end;
  varString,varOleStr:begin
   result:=POCANewString(Context,TPOCARawByteString(VariantValue));
  end;
  else begin
   result:=POCAValueNull;
  end;
 end;
end;

function POCAGhostGetType(const r:TPOCAValue):PPOCAGhostType; {$ifdef caninline}inline;{$endif}
begin
 if POCAIsValueGhost(r) then begin
  result:=PPOCAGhost(POCAGetValueReferencePointer(r))^.GhostType;
 end else begin
  result:=nil;
 end;
end;

function POCAGhostGetPointer(const r:TPOCAValue):pointer; {$ifdef caninline}inline;{$endif}
begin
 if POCAIsValueGhost(r) then begin
  result:=PPOCAGhost(POCAGetValueReferencePointer(r))^.Ptr;
 end else begin
  result:=nil;
 end;
end;

function POCAGhostGetHash(const r:TPOCAValue):PPOCAHash; {$ifdef caninline}inline;{$endif}
begin
 if POCAIsValueGhost(r) then begin
  result:=PPOCAGhost(POCAGetValueReferencePointer(r))^.Hash;
 end else begin
  result:=nil;
 end;
end;

function POCAGhostGetHashValue(const r:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
var p:pointer;
begin
 result:=POCAValueNull;
 if POCAIsValueGhost(r) then begin
  p:=PPOCAGhost(POCAGetValueReferencePointer(r))^.Hash;
  if assigned(p) then begin
   POCASetValueReferencePointer(result,p);
  end;
 end;
end;

function POCAGhostSetHash(const r:TPOCAValue;const h:PPOCAHash):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueGhost(r);
 if result then begin
  PPOCAGhost(POCAGetValueReferencePointer(r))^.Hash:=h;
 end;
end;

function POCAGhostSetHashValue(const r,h:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAIsValueGhost(r) and POCAIsValueHash(h);
 if result then begin
  PPOCAGhost(POCAGetValueReferencePointer(r))^.Hash:=PPOCAHash(POCAGetValueReferencePointer(h));
 end;
end;

procedure POCAAtomicSetValue(var Dst:TPOCAValue;const Src:TPOCAValue);
begin
 TPasMPInterlocked.Write(Dst.CastedInt64,Src.CastedInt64);
end;

function POCANil:TPOCAValue; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAValueNull;
end;

function POCAEndToken:TPOCAValue; {$ifdef caninline}inline;{$endif}
begin
 POCASetValueReferencePointer(result,pointer(TPOCAPtrUInt(1)));
end;

function POCANumber(Num:double):TPOCAValue; {$ifdef caninline}inline;{$endif}
begin
 POCASetValueNumber(result,Num);
end;

function POCAString(Context:PPOCAContext;const Str:TPOCARawByteString):TPOCAValue;
begin
 result:=POCANewString(Context,Str);
end;

function POCAEqual(const a,b:TPOCAValue):boolean; overload;
var na,nb:double;
    OK:TPasDblStrUtilsBoolean;
begin
 if ((POCAIsValueNumber(a) and POCAIsValueNumber(b)) and (a.Num=b.Num)) or
    ((POCAIsValueObject(a) and POCAIsValueObject(b)) and (a.Reference.Obj=b.Reference.Obj)) or
    (POCAIsValueNull(a) and POCAIsValueNull(b)) then begin
  result:=true;
 end else if POCAIsValueString(a) and POCAIsValueString(b) then begin
  result:=PPOCAString(POCAGetValueReferencePointer(a))^.Data=PPOCAString(POCAGetValueReferencePointer(b))^.Data;
 end else begin
  case POCAGetValueType(a) of
   pvtNULL:begin
    na:=0;
   end;
   pvtNUMBER:begin
    na:=a.Num;
   end;
   pvtSTRING:begin
    na:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(a))^.Data,rmNearest,@OK);
    if not OK then begin
     result:=false;
     exit;
    end;
   end;
   else begin
    result:=false;
    exit;
   end;
  end;
  case POCAGetValueType(b) of
   pvtNULL:begin
    nb:=0;
   end;
   pvtNUMBER:begin
    nb:=b.Num;
   end;
   pvtSTRING:begin
    nb:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(b))^.Data,rmNearest,@OK);
    if not OK then begin
     result:=false;
     exit;
    end;
   end;
   else begin
    result:=false;
    exit;
   end;
  end;
  result:=na=nb;
 end;
end;

function POCAStrictEqual(const a,b:TPOCAValue):boolean; overload;
var t:longint;
begin
 t:=POCAGetValueType(a);
 if t=POCAGetValueType(b) then begin
  case t of
   pvtNULL:begin
    result:=true;
   end;
   pvtNUMBER:begin
    result:=a.Num=b.Num;
   end;
   pvtSTRING:begin
    result:=PPOCAString(POCAGetValueReferencePointer(a))^.Data=PPOCAString(POCAGetValueReferencePointer(b))^.Data;
   end;
   else begin
    result:=(POCAIsValueObject(a) and POCAIsValueObject(b)) and (a.Reference.Obj=b.Reference.Obj);
   end;
  end;
 end else begin
  result:=false;
 end;
end;

function POCACompareString(const a,b:TPOCARawByteString):longint;
var c1,c2:pansichar;
begin
 result:=0;
 c1:=pansichar(a);
 c2:=pansichar(b);
 if c1<>c2 then begin
  if not assigned(c1) then begin
   if assigned(c2) then begin
    result:=-1;
   end;
  end else begin
   if not assigned(c2) then begin
    result:=1;
   end else begin
    while (result=0) and ((ord(c1^) and ord(c2^))<>0) do begin
     result:=ord(c1^)-ord(c2^);
     inc(c1);
     inc(c2);
    end;
    if (result=0) and (c1^<>c2^) then begin
     if c1^=#0 then begin
      result:=-1;
     end else begin
      result:=1;
     end;
    end else if result<>0 then begin
     if result<0 then begin
      result:=-1;
     end else begin
      result:=1;
     end;
    end;
   end;
  end;
 end;
end;
            
function POCACompareEvent(Context:PPOCAContext;const a,b:TPOCAValue):longint;
var HashEvents:PPOCAHashEvents;
    SubContext:PPOCAContext;
    Values:array[0..1] of TPOCAValue;
begin
 HashEvents:=POCAHashGetHashEvents(a,b,pmoCOMPARE);
 if not assigned(HashEvents) then begin
  POCARuntimeError(Context,'Simple hashs cann''t use for this comparsion operation');
 end;
 if not POCAIsValueFunctionOrNativeCode(HashEvents^[pmoCOMPARE]) then begin
  POCARuntimeError(Context,'No matching hash event for this comparsion operation found');
 end;
 SubContext:=POCAContextSub(Context);
 try
  Values[0]:=a;
  Values[1]:=b;
  result:=trunc(POCAGetNumberValue(SubContext,POCACall(SubContext,HashEvents^[pmoCOMPARE],@Values[0],2,POCAValueNull,POCAValueNull)));
 finally
  POCAContextDestroy(SubContext);
 end;
end;

function POCACompare(Context:PPOCAContext;const a,b:TPOCAValue):longint;
var na,nb:double;
    OK:TPasDblStrUtilsBoolean;
begin
 if POCAIsValueString(a) and POCAIsValueString(b) then begin
  result:=POCACompareString(PPOCAString(POCAGetValueReferencePointer(a))^.Data,PPOCAString(POCAGetValueReferencePointer(b))^.Data);
 end else if ((POCAIsValueNumber(a) and POCAIsValueNumber(b)) and (a.Num=b.Num)) or
             ((POCAIsValueObject(a) and POCAIsValueObject(b)) and (a.Reference.Obj=b.Reference.Obj)) or
             (POCAIsValueNull(a) and POCAIsValueNull(b)) then begin
  result:=0;
 end else begin
  if POCAIsValueEventHash(a) or POCAIsValueEventHash(b) then begin
   result:=POCACompareEvent(Context,a,b);
  end else if POCAIsValueNumber(a) or POCAIsValueNumber(b) then begin
   case POCAGetValueType(a) of
    pvtNULL:begin
     na:=0;
    end;
    pvtNUMBER:begin
     na:=a.Num;
    end;
    pvtSTRING:begin
     na:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(a))^.Data,rmNearest,@OK);
     if not OK then begin
      result:=-1;
      exit;
     end;
    end;
    else begin
     result:=-1;
     exit;
    end;
   end;
   case POCAGetValueType(b) of
    pvtNULL:begin
     nb:=0;
    end;
    pvtNUMBER:begin
     nb:=b.Num;
    end;
    pvtSTRING:begin
     nb:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(b))^.Data,rmNearest,@OK);
     if not OK then begin
      result:=1;
      exit;
     end;
    end;
    else begin
     result:=1;
     exit;
    end;
   end;
   if na=nb then begin
    result:=0;
   end else begin
    if na<nb then begin
     result:=-1;
    end else begin
     result:=1;
    end;
   end;
  end else if POCAIsValueObject(a) and POCAIsValueObject(b) then begin
   if a.Reference.Obj=b.Reference.Obj then begin
    result:=0;
   end else begin
    if TPOCAPtrUInt(POCAGetValueReferencePointer(a))<TPOCAPtrUInt(POCAGetValueReferencePointer(b)) then begin
     result:=-1;
    end else begin
     result:=1;
    end;
   end;
  end else begin
   result:=a.CastedInt64-b.CastedInt64;
   if result<>0 then begin
    if result<0 then begin
     result:=-1;
    end else begin
     result:=1;
    end;
   end;
  end;
 end;
end;

function POCAEqual(const a:TPOCAValue;const s:TPOCARawByteString):boolean; overload;
var na,nb:double;
    OK:TPasDblStrUtilsBoolean;
begin
 if POCAIsValueString(a) and (PPOCAString(POCAGetValueReferencePointer(a))^.Data=s) then begin
  result:=true;
 end else begin
  if POCAIsValueNumber(a) then begin
   na:=a.Num;
  end else begin
   if not POCAIsValueString(a) then begin
    result:=false;
    exit;
   end;
   na:=ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(a))^.Data,rmNearest,@OK);
   if not OK then begin
    result:=false;
    exit;
   end;
  end;
  nb:=ConvertStringToDouble(s,rmNearest,@OK);
  if not OK then begin
   result:=false;
   exit;
  end;
  result:=na=nb;
 end;
end;

function POCAStrictEqual(const a:TPOCAValue;const s:TPOCARawByteString):boolean; overload;
begin
 result:=POCAIsValueString(a) and (PPOCAString(POCAGetValueReferencePointer(a))^.Data=s);
end;

function POCAStringEqual(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(POCAIsValueString(a) and POCAIsValueString(b)) and (PPOCAString(POCAGetValueReferencePointer(a))^.Data=PPOCAString(POCAGetValueReferencePointer(b))^.Data);
end;

function POCAObjectEqual(const a,b:TPOCAValue):boolean; {$ifdef caninline}inline;{$endif}
begin
 result:=(POCAIsValueObject(a) and POCAIsValueObject(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b));
end;

procedure POCASetUserData(Context:PPOCAContext;p:pointer); {$ifdef caninline}inline;{$endif}
begin
 Context^.UserData:=p;
end;

function POCAGetUserData(Context:PPOCAContext):pointer; {$ifdef caninline}inline;{$endif}
begin
 result:=Context^.UserData;
 if (not assigned(result)) and assigned(Context^.CallParent) then begin
  result:=POCAGetUserData(Context);
 end;
end;

procedure POCAAddSymbol(Context:PPOCAContext;const Dst:TPOCAValue;Symbol:TPOCARawByteString;const Value:TPOCAValue); {$ifdef caninline}inline;{$endif}
begin
 POCAHashSet(Context,Dst,POCAInternSymbol(Context,Context^.Instance,POCANewString(Context,Symbol)),Value);
end;

procedure POCAAddNativeFunction(Context:PPOCAContext;const Hash:TPOCAValue;const FunctionName:TPOCARawByteString;const FunctionPointer:TPOCANativeFunction;const DestroyFunctionPointer:TPOCANativeDestroyFunction=nil;const UserData:pointer=nil); {$ifdef caninline}inline;{$endif}
begin
 POCAAddSymbol(Context,Hash,FunctionName,POCANewFunction(Context,POCANewNativeCode(Context,FunctionPointer,DestroyFunctionPointer,UserData)));
end;

function POCAArrayNewRecord(Old:PPOCAArrayRecord):PPOCAArrayRecord;
var i,OldSize,NewSize:longword;
begin
 if assigned(Old) then begin
  OldSize:=Old^.Size;
 end else begin
  OldSize:=0;
 end;
 NewSize:=((OldSize*3) shr 1)+1;
 GetMem(result,sizeof(TPOCAArrayRecord)+(NewSize*sizeof(TPOCAValue)));
 FillChar(result^,sizeof(TPOCAArrayRecord)+(NewSize*sizeof(TPOCAValue)),#0);
 result^.Allocated:=NewSize;
 result^.Size:=OldSize;
 i:=0;
 while i<OldSize do begin
  result^.Data[i]:=Old^.Data[i];
  inc(i);
 end;
end;

function POCAArrayResize(ArrayObject:PPOCAArray):PPOCAArrayRecord;
begin
 result:=POCAArrayNewRecord(ArrayObject^.ArrayRecord);
 POCAGarbageCollectorSwapFree(ArrayObject^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,@ArrayObject^.ArrayRecord,result);
end;

function POCAArrayGet(const ArrayObject:TPOCAValue;i:longint):TPOCAValue;
var ArrayRecord:PPOCAArrayRecord;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject))^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   while i<0 do begin
    inc(i,ArrayRecord^.Size);
   end;
   if (i>=0) and (i<ArrayRecord^.Size) then begin
    result:=ArrayRecord^.Data[i];
    exit;
   end;
  end;
 end;
 result:=POCAValueNull;
end;

procedure POCAArraySet(const ArrayObject:TPOCAValue;i:longint;const Value:TPOCAValue);
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   while i<0 do begin
    inc(i,ArrayRecord^.Size);
   end;
   if (i>=0) and (i<ArrayRecord^.Size) then begin
    ArrayRecord^.Data[i]:=Value;
    POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(ArrayInstance)),Value);
   end;
  end;
 end;
end;

function POCAArraySize(const ArrayObject:TPOCAValue):longword;
var ArrayRecord:PPOCAArrayRecord;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject))^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   result:=ArrayRecord^.Size;
   exit;
  end;
 end;
 result:=0;
end;

function POCAArrayPush(const ArrayObject:TPOCAValue;const Value:TPOCAValue):longword;
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  while (not assigned(ArrayRecord)) or (ArrayRecord^.Size>=ArrayRecord^.Allocated) do begin
   ArrayRecord:=POCAArrayResize(ArrayInstance);
  end;
  if assigned(ArrayRecord) then begin
   ArrayRecord^.Data[ArrayRecord^.Size]:=Value;
   POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(ArrayInstance)),Value);
   result:=ArrayRecord^.Size;
   TPasMPInterlocked.Increment(ArrayRecord^.Size);
   exit;
  end;
 end;
 result:=0;
end;

function POCAArrayRangePush(Context:PPOCAContext;const ArrayObject:TPOCAValue;const FromValue,ToValue:TPOCAValue):longword;
var Value:TPOCAValue;
    ToNumber:double;
    sFrom,sTo:TPUCURawByteString;
    c:longword;
    UTF8:boolean;
begin
 if POCAIsValueArray(ArrayObject) then begin
  if POCAIsValueNumber(FromValue) or POCAIsValueNumber(ToValue) then begin
   Value.Num:=POCAGetNumberValue(Context,FromValue);
   ToNumber:=POCAGetNumberValue(Context,ToValue);
   while POCAIsFinite(Value.Num) and (Value.Num<=ToNumber) do begin
    POCAArrayPush(ArrayObject,Value);
    Value.Num:=Value.Num+1;
   end;
  end else if POCAIsValueString(FromValue) or POCAIsValueString(ToValue) then begin
   sFrom:=POCAGetStringValue(Context,FromValue);
   sTo:=POCAGetStringValue(Context,ToValue);
   if POCAIsValueString(FromValue) and POCAIsValueString(ToValue) then begin
    UTF8:=(PPOCAString(POCAGetValueReferencePointer(FromValue))^.UTF8=suISUTF8) and (PPOCAString(POCAGetValueReferencePointer(ToValue))^.UTF8=suISUTF8);
   end else begin
    UTF8:=PUCUIsUTF8(sFrom) and PUCUIsUTF8(sTo);
   end;
   while (length(sFrom)>0) and (sFrom<=sTo) do begin
    POCAArrayPush(ArrayObject,POCANewString(Context,sFrom));
    if (not UTF8) or (ord(sFrom[1])<127) then begin
     inc(sFrom[1]);
    end else begin
     c:=PUCUUTF8CodeUnitGetChar(sFrom,1);
     inc(c);
     PUCUUTF8Delete(sFrom,1);
     sFrom:=PUCUUTF32CharToUTF8(c)+sFrom;
    end;
   end;
  end else begin
   POCARuntimeError(Context,'Invalid array range');
  end;
 end;
 result:=0;
end;

procedure POCAArraySetSize(const ArrayObject:TPOCAValue;Size:longint);
var ArrayInstance:PPOCAArray;
    ArrayRecord,NewVecRec:PPOCAArrayRecord;
    i:longint;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  GetMem(NewVecRec,sizeof(TPOCAArrayRecord)+(Size*sizeof(TPOCAValue)));
  FillChar(NewVecRec^,sizeof(TPOCAArrayRecord)+(Size*sizeof(TPOCAValue)),#0);
  NewVecRec^.Size:=Size;
  NewVecRec^.Allocated:=Size;
  if assigned(ArrayRecord) then begin
   for i:=0 to Size-1 do begin
    if i<ArrayRecord^.Size then begin
     NewVecRec^.Data[i]:=ArrayRecord^.Data[i];
    end else begin
     NewVecRec^.Data[i]:=POCAValueNull;
    end;
   end;
  end else begin
   for i:=0 to Size-1 do begin
    NewVecRec^.Data[i]:=POCAValueNull;
   end;
  end;
  POCAGarbageCollectorSwapFree(ArrayInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,@ArrayInstance^.ArrayRecord,NewVecRec);
 end;
end;

function POCAArrayPop(const ArrayObject:TPOCAValue):TPOCAValue;
var ArrayInstance:PPOCAArray;
    ArrayRecord:PPOCAArrayRecord;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayInstance:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject));
  ArrayRecord:=ArrayInstance^.ArrayRecord;
  if assigned(ArrayRecord) then begin
   if ArrayRecord^.Size>0 then begin
    result:=ArrayRecord^.Data[ArrayRecord^.Size-1];
    POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(ArrayInstance)),result);
    TPasMPInterlocked.Decrement(ArrayRecord^.Size);
    if ArrayRecord^.Size<(ArrayRecord^.Allocated shr 1) then begin
     POCAArrayResize(ArrayInstance);
    end;
    exit;
   end;
  end;
 end;
 result:=POCAValueNull;
end;

procedure POCAArraySort(Context:PPOCAContext;const ArrayObject:TPOCAValue);
type PPointers=^TPointers;
     TPointers=array[0..$ffff] of pointer;
     PStackItem=^TStackItem;
     TStackItem=record
      Left,Right,Depth:longint;
     end;
 function IntLog2(x:longword):longword; {$ifdef cpu386}assembler; register;
 asm
  test eax,eax
  jz @Done
  bsr eax,eax
  @Done:
 end;
{$else}
 begin
  x:=x or (x shr 1);
  x:=x or (x shr 2);
  x:=x or (x shr 4);
  x:=x or (x shr 8);
  x:=x or (x shr 16);
  x:=x shr 1;
  x:=x-((x shr 1) and $55555555);
  x:=((x shr 2) and $33333333)+(x and $33333333);
  x:=((x shr 4)+x) and $0f0f0f0f;
  x:=x+(x shr 8);
  x:=x+(x shr 16);
  result:=x and $3f;
 end;
{$endif}
var Left,Right,Depth,i,j,Middle,Size,Parent,Child:int64;
    Pivot,Temp:TPOCAValue;
    ArrayRecord:PPOCAArrayRecord;
    StackItem:PStackItem;
    Stack:array[0..31] of TStackItem;
begin
 if POCAIsValueArray(ArrayObject) then begin
  ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(ArrayObject))^.ArrayRecord;
  if assigned(ArrayRecord) and (ArrayRecord^.Size>0) then begin
   Left:=0;
   Right:=ArrayRecord^.Size-1;
   if Left<Right then begin
    StackItem:=@Stack[0];
    StackItem^.Left:=Left;
    StackItem^.Right:=Right;
    StackItem^.Depth:=IntLog2((Right-Left)+1) shl 1;
    inc(StackItem);
    while TPOCAPtrUInt(pointer(StackItem))>TPOCAPtrUInt(pointer(@Stack[0])) do begin
     dec(StackItem);
     Left:=StackItem^.Left;
     Right:=StackItem^.Right;
     Depth:=StackItem^.Depth;
     if (Right-Left)<16 then begin
      // Insertion sort
      i:=Left+1;
      while i<= Right do begin
       Temp:=POCAArrayGet(ArrayObject,i);
       j:=i-1;
       if (j>=Left) and (POCACompare(Context,POCAArrayGet(ArrayObject,j),Temp)>0) then begin
        repeat
         POCAArraySet(ArrayObject,j+1,POCAArrayGet(ArrayObject,j));
         dec(j);
        until not ((j>=Left) and (POCACompare(Context,POCAArrayGet(ArrayObject,j),Temp)>0));
        POCAArraySet(ArrayObject,j+1,Temp);
       end;
       inc(i);
      end;
     end else begin
      if (Depth=0) or (TPOCAPtrUInt(pointer(StackItem))>=TPOCAPtrUInt(pointer(@Stack[high(Stack)-1]))) then begin
       // Heap sort
       Size:=(Right-Left)+1;
       i:=Size div 2;
       Temp.CastedInt64:=0;
       repeat
        if i>Left then begin
         dec(i);
         Temp:=POCAArrayGet(ArrayObject,Left+i);
        end else begin
         if Size=0 then begin
          break;
         end else begin
          dec(Size);
          Temp:=POCAArrayGet(ArrayObject,Left+Size);
          POCAArraySet(ArrayObject,Left+Size,POCAArrayGet(ArrayObject,Left));
         end;
        end;
        Parent:=i;
        Child:=(i*2)+1;
        while Child<Size do begin
         if ((Child+1)<Size) and (POCACompare(Context,POCAArrayGet(ArrayObject,Left+Child+1),POCAArrayGet(ArrayObject,Left+Child))>0) then begin
          inc(Child);
         end;
         if POCACompare(Context,POCAArrayGet(ArrayObject,Left+Child),Temp)>0 then begin
          POCAArraySet(ArrayObject,Left+Parent,POCAArrayGet(ArrayObject,Left+Child));
          Parent:=Child;
          Child:=(Parent*2)+1;
         end else begin
          break;
         end;
        end;
        POCAArraySet(ArrayObject,Left+Parent,Temp);
       until false;
      end else begin
       // Quick sort width median-of-three optimization
       Middle:=Left+((Right-Left) shr 1);
       if (Right-Left)>3 then begin
        if POCACompare(Context,POCAArrayGet(ArrayObject,Left),POCAArrayGet(ArrayObject,Middle))>0 then begin
         Temp:=POCAArrayGet(ArrayObject,Left);
         POCAArraySet(ArrayObject,Left,POCAArrayGet(ArrayObject,Middle));
         POCAArraySet(ArrayObject,Middle,Temp);
        end;
        if POCACompare(Context,POCAArrayGet(ArrayObject,Left),POCAArrayGet(ArrayObject,Right))>0 then begin
         Temp:=POCAArrayGet(ArrayObject,Left);
         POCAArraySet(ArrayObject,Left,POCAArrayGet(ArrayObject,Right));
         POCAArraySet(ArrayObject,Right,Temp);
        end;
        if POCACompare(Context,POCAArrayGet(ArrayObject,Middle),POCAArrayGet(ArrayObject,Right))>0 then begin
         Temp:=POCAArrayGet(ArrayObject,Middle);
         POCAArraySet(ArrayObject,Middle,POCAArrayGet(ArrayObject,Right));
         POCAArraySet(ArrayObject,Right,Temp);
        end;
       end;
       Pivot:=POCAArrayGet(ArrayObject,Middle);
       i:=Left;
       j:=Right;
       repeat
        while (i<Right) and (POCACompare(Context,POCAArrayGet(ArrayObject,i),Pivot)<0) do begin
         inc(i);
        end;
        while (j>=i) and (POCACompare(Context,POCAArrayGet(ArrayObject,j),Pivot)>0) do begin
         dec(j);
        end;
        if i>j then begin
         break;
        end else begin
         if i<>j then begin
          Temp:=POCAArrayGet(ArrayObject,i);
          POCAArraySet(ArrayObject,i,POCAArrayGet(ArrayObject,j));
          POCAArraySet(ArrayObject,j,Temp);
         end;
         inc(i);
         dec(j);
        end;
       until false;
       if i<Right then begin
        StackItem^.Left:=i;
        StackItem^.Right:=Right;
        StackItem^.Depth:=Depth-1;
        inc(StackItem);
       end;
       if Left<j then begin
        StackItem^.Left:=Left;
        StackItem^.Right:=j;
        StackItem^.Depth:=Depth-1;
        inc(StackItem);
       end;
      end;
     end;
    end;
   end;
  end;
 end;
end;

function POCAHashMix(const h:longword):longword; {$ifdef caninline}inline;{$endif}
begin
 result:=h;
 result:=(not result)+(result shr 23);
 result:=result xor (result shl 22);
 result:=result xor (result shr 7);
 result:=result xor (result shl 2);
 result:=result xor (result shr 20);
 result:=result xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=result xor (result shl 2) or (result shr (32-2));
end;

function POCAHashString(const Str:TPOCARawByteString):longword;
{$ifdef cpuarm}
var b:pansichar;
    len,h,i:longword;
begin
 result:=2166136261;
 len:=length(Str);
 h:=len;
 if len>0 then begin
  b:=pansichar(Str);
  while len>3 do begin
   i:=longword(pointer(b)^);
   h:=(h xor i) xor $2e63823a;
   inc(h,(h shl 15) or (h shr (32-15)));
   dec(h,(h shl 9) or (h shr (32-9)));
   inc(h,(h shl 4) or (h shr (32-4)));
   dec(h,(h shl 1) or (h shr (32-1)));
   h:=h xor (h shl 2) or (h shr (32-2));
   result:=result xor i;
   inc(result,(result shl 1)+(result shl 4)+(result shl 7)+(result shl 8)+(result shl 24));
   inc(b,4);
   dec(len,4);
  end;
  if len>1 then begin
   i:=word(pointer(b)^);
   h:=(h xor i) xor $2e63823a;
   inc(h,(h shl 15) or (h shr (32-15)));
   dec(h,(h shl 9) or (h shr (32-9)));
   inc(h,(h shl 4) or (h shr (32-4)));
   dec(h,(h shl 1) or (h shr (32-1)));
   h:=h xor (h shl 2) or (h shr (32-2));
   result:=result xor i;
   inc(result,(result shl 1)+(result shl 4)+(result shl 7)+(result shl 8)+(result shl 24));
   inc(b,2);
   dec(len,2);
  end;
  if len>0 then begin
   i:=byte(b^);
   h:=(h xor i) xor $2e63823a;
   inc(h,(h shl 15) or (h shr (32-15)));
   dec(h,(h shl 9) or (h shr (32-9)));
   inc(h,(h shl 4) or (h shr (32-4)));
   dec(h,(h shl 1) or (h shr (32-1)));
   h:=h xor (h shl 2) or (h shr (32-2));
   result:=result xor i;
   inc(result,(result shl 1)+(result shl 4)+(result shl 7)+(result shl 8)+(result shl 24));
  end;
 end;
 result:=result xor h;
 if result=0 then begin
  result:=$ffffffff;
 end;
end;
{$else}
const m=longword($57559429);
      n=longword($5052acdb);
var b:pansichar;
    h,k,len:longword;
    p:{$ifdef fpc}UInt64{$else}int64{$endif};
begin
 len:=length(Str);
 h:=len;
 k:=h+n+1;
 if len>0 then begin
  b:=pansichar(Str);
  while len>7 do begin
   begin
    p:=longword(pointer(b)^)*UInt64(n);
    h:=h xor longword(p and $ffffffff);
    k:=k xor longword(p shr 32);
    inc(b,4);
   end;
   begin
    p:=longword(pointer(b)^)*UInt64(m);
    k:=k xor longword(p and $ffffffff);
    h:=h xor longword(p shr 32);
    inc(b,4);
   end;
   dec(len,8);
  end;
  if len>3 then begin
   p:=longword(pointer(b)^)*UInt64(n);
   h:=h xor longword(p and $ffffffff);
   k:=k xor longword(p shr 32);
   inc(b,4);
   dec(len,4);
  end;
  if len>0 then begin
   if len>1 then begin
    p:=word(pointer(b)^);
    inc(b,2);
    dec(len,2);
   end else begin
    p:=0;
   end;
   if len>0 then begin
    p:=p or (byte(b^) shl 16);
   end;
   p:=p*UInt64(m);
   k:=k xor longword(p and $ffffffff);
   h:=h xor longword(p shr 32);
  end;
 end;
 begin
  p:=(h xor (k+n))*UInt64(n);
  h:=h xor longword(p and $ffffffff);
  k:=k xor longword(p shr 32);
 end;
 result:=k xor h;
 if result=0 then begin
  result:=$ffffffff;
 end;
end;
{$endif}

function POCAHashNumber(const Num:double):longword;
begin
 result:=longword(pointer(@Num)^) xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=((result xor (result shl 2) or (result shr (32-2))) xor longword(pointer(@pansichar(pointer(@Num))[sizeof(longword)])^)) xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=result xor (result shl 2) or (result shr (32-2));
 dec(result,ord(result=0));
end;

function POCAHashObj(const Obj:pointer):longword;
begin
{$ifdef cpu64}
 result:=TPOCAUInt32(TPOCAPtrUInt(Obj) and $ffffffff) xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=((result xor (result shl 2) or (result shr (32-2))) xor (TPOCAPtrUInt(Obj) shr 32)) xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=result xor (result shl 2) or (result shr (32-2));
{$else}
 result:=longword(pointer(@Obj)^) xor $2e63823a;
 inc(result,(result shl 15) or (result shr (32-15)));
 dec(result,(result shl 9) or (result shr (32-9)));
 inc(result,(result shl 4) or (result shr (32-4)));
 dec(result,(result shl 1) or (result shr (32-1)));
 result:=result xor (result shl 2) or (result shr (32-2));
{$endif}
 dec(result,ord(result=0));
end;

function POCAValueHash(const r:TPOCAValue):longword;
var Str:PPOCAString;
begin
 case POCAGetValueType(r) of
  pvtNUMBER:begin
   result:=POCAHashNumber(r.Num);
  end;
  pvtSTRING:begin
   Str:=PPOCAString(POCAGetValueReferencePointer(R));
   result:=Str^.HashCode;
   if result=0 then begin
    result:=POCAHashString(Str^.Data);
    Str^.HashCode:=result;
   end;
  end;
  else begin
   result:=POCAHashObj(POCAGetValueReferencePointer(R));
  end;
 end;
end;

function POCAHashFindCell(HashRec:PPOCAHashRecord;const Key:TPOCAValue;HashCode:longword):longword; overload;
var Mask,Step:longword;
    Entity:longint;
begin
 Mask:=(2 shl HashRec^.LogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 if HashRec^.LogSize<>0 then begin
  result:=HashCode shr (32-HashRec^.LogSize);
 end else begin
  result:=0;
 end;
 repeat
  Entity:=HashRec^.CellToEntityIndex^[result];
  if (Entity=ENT_EMPTY) or ((Entity<>ENT_DELETED) and POCAEqual(HashRec^.Entities^[Entity].Key,Key)) then begin
   exit;
  end;
  result:=(result+Step) and Mask;
 until false;
end;

function POCAHashFindCell(HashRec:PPOCAHashRecord;const Key:TPOCARawByteString;HashCode:longword):longword; overload;
var Mask,Step:longword;
    Entity:longint;
begin
 Mask:=(2 shl HashRec^.LogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 if HashRec^.LogSize<>0 then begin
  result:=HashCode shr (32-HashRec^.LogSize);
 end else begin
  result:=0;
 end;
 repeat
  Entity:=HashRec^.CellToEntityIndex^[result];
  if (Entity=ENT_EMPTY) or ((Entity<>ENT_DELETED) and POCAEqual(HashRec^.Entities^[Entity].Key,Key)) then begin
   exit;
  end;
  result:=(result+Step) and Mask;
 until false;
end;

function POCAHashRecordSize(LogSize:longint;Events:boolean):longword;
begin
 result:=sizeof(TPOCAHashRecord)+((1 shl LogSize)*((4*sizeof(longint))+sizeof(TPOCAHashEntity)));
 if Events then begin
  inc(result,sizeof(TPOCAHashEvents));
 end;
end;

function POCAHashResize(Instance:PPOCAInstance;Hash:PPOCAHash;Events:longbool=false):PPOCAHashRecord; forward;

function POCAHashCreateEvents(Instance:PPOCAInstance;Hash:PPOCAHash):PPOCAHashRecord;
var HashRec:PPOCAHashRecord;
    EntityRec:PPOCAHashEntity;
    Size,Entity:longint;
    i,j:longword;
    Str:PPOCAString;
    Op:longint;
begin
 HashRec:=Hash^.HashRecord;
 if not assigned(HashRec) then begin
  POCAHashResize(Instance,Hash,false);
  HashRec:=Hash^.HashRecord;
 end;
 Size:=POCAHashRecordSize(HashRec^.LogSize,true);
 GetMem(result,Size);
 FillChar(result^,Size,#0);
 result^.Size:=HashRec^.Size;
 result^.RealSize:=HashRec^.RealSize;
 result^.LogSize:=HashRec^.LogSize;
 result^.CellToEntityIndex:=pointer(@pansichar(pointer(result))[sizeof(TPOCAHashRecord)]);
 result^.EntityToCellIndex:=pointer(@result^.CellToEntityIndex^[2 shl HashRec^.LogSize]);
 result^.Entities:=pointer(@result^.EntityToCellIndex^[2 shl HashRec^.LogSize]);
 result^.Events:=pointer(@result^.Entities^[1 shl HashRec^.LogSize]);
 if (assigned(HashRec) and assigned(HashRec^.Events)) then begin
  result^.Events^:=HashRec^.Events^;
 end;
 i:=0;
 j:=2 shl HashRec^.LogSize;
 while i<j do begin
  Entity:=HashRec^.CellToEntityIndex^[i];
  result^.CellToEntityIndex^[i]:=Entity;
  result^.EntityToCellIndex^[i]:=HashRec^.EntityToCellIndex^[i];
  if Entity>=0 then begin
   EntityRec:=@result^.Entities^[Entity];
   EntityRec^:=HashRec^.Entities^[Entity];
   if POCAIsValueString(EntityRec^.Key) then begin
    Str:=PPOCAString(POCAGetValueReferencePointer(EntityRec^.Key));
    if (length(Str^.Data)>2) and ((Str^.Data[1]='_') and (Str^.Data[2]='_')) then begin
     Op:=MetaOpNamesHashMap.GetValue(Str^.Data);
     if Op>=0 then begin
      result^.Events[TPOCAMetaOp(Op)]:=EntityRec^.Value;
     end;
    end;
   end;
  end;
  inc(i);
 end;
 POCAMRSWLockReadLock(@Hash^.Cache.MRSWLock);
 try
  POCAGarbageCollectorSwapFree(Hash^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,@Hash^.HashRecord,result);
  POCAHashInvalidate(Hash);
 finally
  POCAMRSWLockReadUnlock(@Hash^.Cache.MRSWLock);
 end;
end;

procedure POCAHashLockInvalidate(Hash:PPOCAHash);
var Current:PPOCAHash;
begin
 if assigned(Hash) then begin
  POCAMRSWLockReadLock(@Hash^.Cache.MRSWLock);
  try
   TPasMPInterlocked.Exchange(longint(Hash^.Cache.Ready),0);
   Current:=Hash^.Children.First;
   while assigned(Current) do begin
    POCAHashLockInvalidate(Current);
    Current:=Current^.Children.Next;
   end;
  finally
   POCAMRSWLockReadUnlock(@Hash^.Cache.MRSWLock);
  end;
 end;
end;

procedure POCAHashInvalidate(Hash:PPOCAHash);
var Current:PPOCAHash;
begin
 if assigned(Hash) then begin
  TPasMPInterlocked.Exchange(longint(Hash^.Cache.Ready),0);
  Current:=Hash^.Children.First;
  while assigned(Current) do begin
   POCAHashLockInvalidate(Current);
   Current:=Current^.Children.Next;
  end;
 end;
end;

procedure POCAHashRebuildCache(Hash:PPOCAHash);
var CountItems:longint;
    Cachable:boolean;
 procedure Process(CurrentHash:PPOCAHash);
 var Current:PPOCAHash;
     OldEntities,Entities:PPPOCAHashEntities;
     Index,i:longint;
 begin
  if assigned(CurrentHash) then begin
   if assigned(CurrentHash^.Events) or not Cachable then begin
    Cachable:=false;
    CountItems:=0;
   end else begin
    if assigned(CurrentHash^.HashRecord) then begin
     inc(CountItems,CurrentHash^.HashRecord^.Size);
    end;
   end;
   POCAMRSWLockReadLock(@CurrentHash^.Cache.MRSWLock);
   try
    Process(CurrentHash^.Prototype);
   finally
    POCAMRSWLockReadUnlock(@CurrentHash^.Cache.MRSWLock);
   end;
  end else begin
   OldEntities:=Hash^.Cache.ChainEntities;
   if Cachable then begin
    GetMem(Entities,CountItems*sizeof(PPOCAHashEntity));
    FillChar(Entities^,CountItems*sizeof(PPOCAHashEntity),#0);
    Index:=CountItems;
    Current:=Hash;
    while assigned(Current) do begin
     if assigned(Current^.HashRecord) and (Current^.HashRecord^.Size>0) then begin
      for i:=Current^.HashRecord^.Size-1 downto 0 do begin
       dec(Index);
       Entities^[Index]:=@Current^.HashRecord^.Entities[i];
      end;
     end;
     Current:=Current^.Prototype;
    end;
   end else begin
    Entities:=nil;
   end;
   TPasMPInterlocked.Exchange(pointer(Hash^.Cache.ChainEntities),pointer(Entities));
   if assigned(OldEntities) then begin
    FreeMem(OldEntities);
   end;
  end;
 end;
begin
 if assigned(Hash) and not Hash^.Cache.Ready then begin
  POCAMRSWLockWriteLock(@Hash^.Cache.MRSWLock);
  try
   if assigned(Hash^.HashRecord) then begin
    CountItems:=Hash^.HashRecord^.Size;
   end else begin
    CountItems:=0;
   end;
   Cachable:=true;
   Process(Hash^.Prototype);
   TPasMPInterlocked.Exchange(Hash^.Cache.ChainCount,CountItems);
   TPasMPInterlocked.Exchange(longint(Hash^.Cache.Ready),longint(longword($ffffffff)));
  finally
   POCAMRSWLockWriteUnlock(@Hash^.Cache.MRSWLock);
  end;
 end;
end;

procedure POCAHashClearPrototype(Hash:PPOCAHash);
var OldPrototype,Previous,Next:PPOCAHash;
begin
 if assigned(Hash) and assigned(Hash^.Prototype) then begin
  POCAMRSWLockWriteLock(@Hash^.Cache.MRSWLock);
  try
   OldPrototype:=Hash^.Prototype;
   if assigned(OldPrototype) then begin
    POCAMRSWLockWriteLock(@OldPrototype^.Cache.MRSWLock);
    try
     Previous:=Hash^.Children.Previous;
     Next:=Hash^.Children.Next;
     if assigned(Previous) then begin
      POCAMRSWLockWriteLock(@Previous^.Cache.MRSWLock);
     end;
     try
      if assigned(Next) and (Previous<>Next) then begin
       POCAMRSWLockWriteLock(@Next^.Cache.MRSWLock);
      end;
      try
       if assigned(Previous) then begin
        Previous^.Children.Next:=Next;
       end else if OldPrototype^.Children.First=Hash then begin
        OldPrototype^.Children.First:=Next;
       end;
       if assigned(Next) then begin
        Next^.Children.Previous:=Previous;
       end else if OldPrototype^.Children.Last=Hash then begin
        OldPrototype^.Children.Last:=Previous;
       end;
       Hash^.Children.Previous:=nil;
       Hash^.Children.Next:=nil;
      finally
       if assigned(Next) and (Previous<>Next) then begin
        POCAMRSWLockWriteUnlock(@Next^.Cache.MRSWLock);
       end;
      end;
     finally
      if assigned(Previous) then begin
       POCAMRSWLockWriteUnlock(@Previous^.Cache.MRSWLock);
      end;
     end;
    finally
     POCAMRSWLockWriteUnlock(@OldPrototype^.Cache.MRSWLock);
    end;
   end;
   TPasMPInterlocked.Exchange(pointer(Hash^.Prototype),nil);
   POCAHashInvalidate(Hash);
  finally
   POCAMRSWLockWriteUnlock(@Hash^.Cache.MRSWLock);
  end;
 end;
end;

function POCAHashSetPrototype(Context:PPOCAContext;const Hash:TPOCAValue;const Prototype:PPOCAHash):longbool;
var HashPtr,HashInstance,OldPrototype,Previous,Next,First,Last:PPOCAHash;
begin
 result:=POCAIsValueHash(Hash);
 if result then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if HashInstance^.Prototype<>Prototype then begin
   POCAMRSWLockWriteLock(@HashInstance^.Cache.MRSWLock);
   try
    if assigned(Prototype) then begin
     HashPtr:=HashInstance;
     while assigned(HashPtr) do begin
      if HashPtr=Prototype then begin
       POCARuntimeError(Context,'Recursive prototype chains are not allowed');
       result:=false;
       break;
      end;
      HashPtr:=HashPtr^.Prototype;
     end;
    end;
    if result then begin
     OldPrototype:=HashInstance^.Prototype;
     if assigned(OldPrototype) then begin
      POCAMRSWLockWriteLock(@OldPrototype^.Cache.MRSWLock);
      try
       Previous:=HashInstance^.Children.Previous;
       Next:=HashInstance^.Children.Next;
       if assigned(Previous) then begin
        POCAMRSWLockWriteLock(@Previous^.Cache.MRSWLock);
       end;
       try
        if assigned(Next) and (Previous<>Next) then begin
         POCAMRSWLockWriteLock(@Next^.Cache.MRSWLock);
        end;
        try
         if assigned(Previous) then begin
          Previous^.Children.Next:=Next;
         end else if OldPrototype^.Children.First=HashInstance then begin
          OldPrototype^.Children.First:=Next;
         end;
         if assigned(Next) then begin
          Next^.Children.Previous:=Previous;
         end else if OldPrototype^.Children.Last=HashInstance then begin
          OldPrototype^.Children.Last:=Previous;
         end;
         HashInstance^.Children.Previous:=nil;
         HashInstance^.Children.Next:=nil;
        finally
         if assigned(Next) and (Previous<>Next) then begin
          POCAMRSWLockWriteUnlock(@Next^.Cache.MRSWLock);
         end;
        end;
       finally
        if assigned(Previous) then begin
         POCAMRSWLockWriteUnlock(@Previous^.Cache.MRSWLock);
        end;
       end;
      finally
       POCAMRSWLockWriteUnlock(@OldPrototype^.Cache.MRSWLock);
      end;
     end;
     TPasMPInterlocked.Exchange(pointer(HashInstance^.Prototype),pointer(Prototype));
     if assigned(Prototype) then begin
      POCAMRSWLockWriteLock(@Prototype^.Cache.MRSWLock);
      try
       First:=Prototype^.Children.First;
       Last:=Prototype^.Children.Last;
       if assigned(First) then begin
        POCAMRSWLockWriteLock(@First^.Cache.MRSWLock);
       end;
       try
        if assigned(Last) and (First<>Last) then begin
         POCAMRSWLockWriteLock(@Last^.Cache.MRSWLock);
        end;
        try
         if assigned(Last) then begin
          HashInstance^.Children.Previous:=Last;
          Last^.Children.Next:=HashInstance;
         end else begin
          HashInstance^.Children.Previous:=nil;
          Prototype^.Children.First:=HashInstance;
         end;
         HashInstance^.Children.Next:=nil;
         Prototype^.Children.Last:=HashInstance;
        finally
         if assigned(Last) and (First<>Last) then begin
          POCAMRSWLockWriteUnlock(@Last^.Cache.MRSWLock);
         end;
        end;
       finally
        if assigned(First) then begin
         POCAMRSWLockWriteUnlock(@First^.Cache.MRSWLock);
        end;
       end;
      finally
       POCAMRSWLockWriteUnlock(@Prototype^.Cache.MRSWLock);
      end;
     end;
     POCAHashInvalidate(HashInstance);
    end;
   finally
    POCAMRSWLockWriteUnlock(@HashInstance^.Cache.MRSWLock);
   end;
  end;
 end;
end;

function POCAHashSetPrototypeValue(Context:PPOCAContext;const Hash,Prototype:TPOCAValue):longbool;
begin
 case POCAGetValueType(Prototype) of
  pvtHASH:begin
   result:=POCAHashSetPrototype(Context,Hash,PPOCAHash(POCAGetValueReferencePointer(Prototype)));
  end;
  pvtNULL:begin
   result:=POCAHashSetPrototype(Context,Hash,nil);
  end;
  else begin
   POCARuntimeError(Context,'Prototype must be hash or null');
   result:=false;
  end;
 end;
end;

function POCAValueSetPrototypeValue(Context:PPOCAContext;const Hash,Prototype:TPOCAValue;const Level:longint):longbool;
begin
 result:=false;
 if Level<POCA_PROTOTYPE_RECURSION_LIMIT then begin
  case POCAGetValueType(Hash) of
   pvtARRAY:begin
    result:=POCAValueSetPrototypeValue(Context,Context.Instance^.Globals.ArrayHash,Prototype,Level+1);
   end;
   pvtNUMBER:begin
    result:=POCAValueSetPrototypeValue(Context,Context.Instance^.Globals.NumberHash,Prototype,Level+1);
   end;
   pvtSTRING:begin
    result:=POCAValueSetPrototypeValue(Context,Context.Instance^.Globals.StringHash,Prototype,Level+1);
   end;
   pvtHASH:begin
    case POCAGetValueType(Prototype) of
     pvtHASH:begin
      result:=POCAHashSetPrototype(Context,Hash,PPOCAHash(POCAGetValueReferencePointer(Prototype)));
     end;
     pvtNULL:begin
      result:=POCAHashSetPrototype(Context,Hash,nil);
     end;
     else begin
      POCARuntimeError(Context,'Prototype must be hash or null');
      result:=false;
     end;
    end;
   end;
   else begin
    POCARuntimeError(Context,'Prototype must be non null');
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Prototype recursion overflow');
 end;
end;

function POCAHashGetPrototype(const Hash:TPOCAValue):PPOCAHash;
begin
 result:=nil;
 if POCAIsValueHash(Hash) then begin
  result:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Prototype;
 end;
end;

function POCAHashGetPrototypeValue(const Hash:TPOCAValue):TPOCAValue;
var p:pointer;
begin
 result:=POCAValueNull;
 if POCAIsValueHash(Hash) then begin
  p:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Prototype;
  if assigned(p) then begin
   POCASetValueReferencePointer(result,p);
  end;
 end;
end;

function POCAValueGetPrototypeValue(Context:PPOCAContext;const Hash:TPOCAValue;const Level:longint):TPOCAValue;
var p:pointer;
begin
 result:=POCAValueNull;
 if Level<POCA_PROTOTYPE_RECURSION_LIMIT then begin
  case POCAGetValueType(Hash) of
   pvtARRAY:begin
    result:=POCAValueGetPrototypeValue(Context,Context.Instance^.Globals.ArrayHash,Level+1);
   end;
   pvtNUMBER:begin
    result:=POCAValueGetPrototypeValue(Context,Context.Instance^.Globals.NumberHash,Level+1);
   end;
   pvtSTRING:begin
    result:=POCAValueGetPrototypeValue(Context,Context.Instance^.Globals.StringHash,Level+1);
   end;
   pvtHASH:begin
    p:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Prototype;
    if assigned(p) then begin
     POCASetValueReferencePointer(result,p);
    end;
   end;
   pvtGHOST:begin
    result:=POCAValueGetPrototypeValue(Context,POCAGhostGetHashValue(Hash),Level+1);
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Prototype recursion overflow');
 end;
end;

procedure POCAHashClearConstructor(Hash:PPOCAHash);
begin
 if assigned(Hash) and assigned(Hash^.Constructor_) then begin
  POCAMRSWLockWriteLock(@Hash^.Cache.MRSWLock);
  try
   TPasMPInterlocked.Exchange(pointer(Hash^.Constructor_),nil);
   POCAHashInvalidate(Hash);
  finally
   POCAMRSWLockWriteUnlock(@Hash^.Cache.MRSWLock);
  end;
 end;
end;

function POCAHashSetConstructor(Context:PPOCAContext;const Hash:TPOCAValue;const Constructor_:PPOCAObject):longbool;
var HashInstance:PPOCAHash;
begin
 result:=POCAIsValueHash(Hash);
 if result then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if HashInstance^.Constructor_<>Constructor_ then begin
   POCAMRSWLockWriteLock(@HashInstance^.Cache.MRSWLock);
   try
    TPasMPInterlocked.Exchange(pointer(HashInstance^.Constructor_),pointer(Constructor_));
    POCAHashInvalidate(HashInstance);
   finally
    POCAMRSWLockWriteUnlock(@HashInstance^.Cache.MRSWLock);
   end;
  end;
 end;
end;

function POCAHashSetConstructorValue(Context:PPOCAContext;const Hash,Constructor_:TPOCAValue):longbool;
begin
 case POCAGetValueType(Constructor_) of
  pvtHASH:begin
   result:=POCAHashSetConstructor(Context,Hash,PPOCAObject(POCAGetValueReferencePointer(Constructor_)));
  end;
  pvtNULL:begin
   result:=POCAHashSetConstructor(Context,Hash,nil);
  end;
  pvtGHOST:begin
   result:=POCAHashSetConstructorValue(Context,Hash,POCAGhostGetHashValue(Constructor_));
  end;
  else begin
   POCARuntimeError(Context,'Constructor must be hash or null');
   result:=false;
  end;
 end;
end;                                                          

function POCAValueSetConstructorValue(Context:PPOCAContext;const Hash,Constructor_:TPOCAValue;const Level:longint):longbool;
begin
 result:=false;
 if Level<POCA_CONSTRUCTOR_RECURSION_LIMIT then begin
  case POCAGetValueType(Hash) of
   pvtARRAY:begin
    result:=POCAValueSetConstructorValue(Context,Context.Instance^.Globals.ArrayHash,Constructor_,Level+1);
   end;
   pvtNUMBER:begin
    result:=POCAValueSetConstructorValue(Context,Context.Instance^.Globals.NumberHash,Constructor_,Level+1);
   end;
   pvtSTRING:begin
    result:=POCAValueSetConstructorValue(Context,Context.Instance^.Globals.StringHash,Constructor_,Level+1);
   end;
   pvtHASH:begin
    case POCAGetValueType(Constructor_) of
     pvtHASH,pVTGHOST:begin
      result:=POCAHashSetConstructor(Context,Hash,PPOCAObject(POCAGetValueReferencePointer(Constructor_)));
     end;
     pvtNULL:begin
      result:=POCAHashSetConstructor(Context,Hash,nil);
     end;
     else begin
      POCARuntimeError(Context,'Constructor must be hash, ghost or null');
      result:=false;
     end;
    end;
   end;
   pvtGHOST:begin
    result:=POCAValueSetConstructorValue(Context,POCAGhostGetHashValue(Hash),Constructor_,Level+1);
   end;
   else begin
    POCARuntimeError(Context,'Constructor must be non null');
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Constructor recursion overflow');
 end;
end;

function POCAHashGetConstructor(const Hash:TPOCAValue):PPOCAObject;
begin
 result:=nil;
 if POCAIsValueHash(Hash) then begin
  result:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Constructor_;
 end;
end;

function POCAHashGetConstructorValue(const Hash:TPOCAValue):TPOCAValue;
var p:pointer;
begin
 result:=POCAValueNull;
 if POCAIsValueHash(Hash) then begin
  p:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Constructor_;
  if assigned(p) then begin
   POCASetValueReferencePointer(result,p);
  end;
 end;
end;

function POCAValueGetConstructorValue(Context:PPOCAContext;const Hash:TPOCAValue;const Level:longint):TPOCAValue;
var p:pointer;
begin
 result:=POCAValueNull;
 if Level<POCA_CONSTRUCTOR_RECURSION_LIMIT then begin
  case POCAGetValueType(Hash) of
   pvtARRAY:begin
    result:=POCAValueGetConstructorValue(Context,Context.Instance^.Globals.ArrayHash,Level+1);
   end;
   pvtNUMBER:begin
    result:=POCAValueGetConstructorValue(Context,Context.Instance^.Globals.NumberHash,Level+1);
   end;
   pvtSTRING:begin
    result:=POCAValueGetPrototypeValue(Context,Context.Instance^.Globals.StringHash,Level+1);
   end;
   pvtHASH:begin
    p:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Constructor_;
    if assigned(p) then begin
     POCASetValueReferencePointer(result,p);
    end;     
   end;
   pvtGHOST:begin
    result:=POCAValueGetConstructorValue(Context,POCAGhostGetHashValue(Hash),Level+1);
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Constructor recursion overflow');
 end;
end;

function POCAHashSetHashEvents(Context:PPOCAContext;const ToHash,FromHash:TPOCAValue):longbool;
var Hashs:array[0..1] of PPOCAHash;
begin
 result:=false;
 if POCAIsValueHash(ToHash) then begin
  Hashs[0]:=PPOCAHash(POCAGetValueReferencePointer(ToHash));
  if POCAIsValueHash(FromHash) then begin
   Hashs[1]:=PPOCAHash(POCAGetValueReferencePointer(FromHash));
   if (not assigned(Hashs[1]^.HashRecord)) or not assigned(Hashs[1]^.HashRecord^.Events) then begin
    POCAHashCreateEvents(Context^.Instance,Hashs[1]);
   end;
   POCAHashLockInvalidate(Hashs[0]);
   TPasMPInterlocked.Exchange(pointer(Hashs[0]^.Events),pointer(Hashs[1]));
   result:=true;
  end else if POCAIsValueNull(FromHash) then begin
   POCAHashLockInvalidate(Hashs[0]);
   TPasMPInterlocked.Exchange(pointer(Hashs[0]^.Events),nil);
   result:=true;
  end;
 end;
end;

function POCAHashGetHashEventsHash(const Hash:TPOCAValue):TPOCAValue;
begin
 result:=POCAValueNull;
 if POCAIsValueHash(Hash) then begin
  POCASetValueReferencePointer(result,PPOCAHash(POCAGetValueReferencePointer(Hash))^.Events);
 end;
end;

function POCAHashGetHashEvents(const Hash:TPOCAValue):PPOCAHashEvents; overload;
var HashInstance:PPOCAHash;
begin
 result:=nil;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord) then begin
   result:=HashInstance^.Events^.HashRecord^.Events;
  end;
 end else if POCAIsValueGhost(Hash) then begin
  result:=POCAHashGetHashEvents(POCAGhostGetHashValue(Hash));
 end;
end;

function POCAHashGetHashEvents(const Hash:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;
var HashInstance:PPOCAHash;
begin
 result:=nil;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord) then begin
   result:=HashInstance^.Events^.HashRecord^.Events;
   if assigned(result) and not POCAIsValueFunctionOrNativeCode(result[Operation]) then begin
    result:=nil;
   end;
  end;
 end else if POCAIsValueGhost(Hash) then begin
  result:=POCAHashGetHashEvents(POCAGhostGetHashValue(Hash),Operation);
 end;
end;

function POCAHashGetHashEvents(const v1,v2:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;
var Hash:PPOCAHash;
begin
 result:=nil;
 if POCAIsValueHash(v1) then begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(v1));
  if assigned(Hash^.Events) and assigned(Hash^.Events^.HashRecord) then begin
   result:=Hash^.Events^.HashRecord^.Events;
   if assigned(result) and POCAIsValueFunctionOrNativeCode(result[Operation]) then begin
    exit;
   end;
  end;
 end else if POCAIsValueGhost(v1) then begin
  result:=POCAHashGetHashEvents(POCAGhostGetHashValue(v1),v2,Operation);
  exit;
 end;
 if POCAIsValueHash(v2) then begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(v2));
  if (assigned(Hash^.Events) and assigned(Hash^.Events^.HashRecord)) and assigned(Hash^.Events^.HashRecord^.Events) then begin
   result:=Hash^.Events^.HashRecord^.Events;
  end;
 end else if POCAIsValueGhost(v2) then begin
  result:=POCAHashGetHashEvents(v1,POCAGhostGetHashValue(v2),Operation);
 end;
end;

function POCAHashGetHashEvents(const v1,v2,v3:TPOCAValue;const Operation:TPOCAMetaOp):PPOCAHashEvents; overload;
var Hash:PPOCAHash;
begin
 result:=nil;
 if POCAIsValueHash(v1) then begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(v1));
  if assigned(Hash^.Events) and assigned(Hash^.Events^.HashRecord) then begin
   result:=Hash^.Events^.HashRecord^.Events;
   if assigned(result) and POCAIsValueFunctionOrNativeCode(result[Operation]) then begin
    exit;
   end;
  end;
 end else if POCAIsValueGhost(v1) then begin
  result:=POCAHashGetHashEvents(POCAGhostGetHashValue(v1),v2,v3,Operation);
  exit;
 end;
 if POCAIsValueHash(v2) then begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(v2));
  if assigned(Hash^.Events) and assigned(Hash^.Events^.HashRecord) then begin
   result:=Hash^.Events^.HashRecord^.Events;
   if assigned(result) and POCAIsValueFunctionOrNativeCode(result[Operation]) then begin
    exit;
   end;
  end;
 end else if POCAIsValueGhost(v2) then begin
  result:=POCAHashGetHashEvents(v1,POCAGhostGetHashValue(v2),v3,Operation);
  exit;
 end;
 if POCAIsValueHash(v3) then begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(v3));
  if (assigned(Hash^.Events) and assigned(Hash^.Events^.HashRecord)) and assigned(Hash^.Events^.HashRecord^.Events) then begin
   result:=Hash^.Events^.HashRecord^.Events;
  end;
 end else if POCAIsValueGhost(v3) then begin
  result:=POCAHashGetHashEvents(v1,v2,POCAGhostGetHashValue(v3),Operation);
 end;
end;

function POCAHashSetGhost(Context:PPOCAContext;const Hash:TPOCAValue;Ghost:PPOCAGhost):longbool;
var HashPtr:PPOCAHash;
begin
 result:=POCAIsValueHash(Hash);
 if result then begin
  HashPtr:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  TPasMPInterlocked.Exchange(pointer(HashPtr^.Ghost),pointer(Ghost));
  POCAHashLockInvalidate(HashPtr);
 end;
end;

function POCAHashSetGhostValue(Context:PPOCAContext;const Hash,Ghost:TPOCAValue):longbool;
begin
 case POCAGetValueType(Ghost) of
  pvtGHOST:begin
   result:=POCAHashSetGhost(Context,Hash,PPOCAGhost(POCAGetValueReferencePointer(Ghost)));
  end;
  pvtNULL:begin
   result:=POCAHashSetGhost(Context,Hash,nil);
  end;
  else begin
   POCARuntimeError(Context,'Ghost must be hash or null');
   result:=false;
  end;
 end;
end;

function POCAHashGetGhost(const Hash:TPOCAValue):PPOCAGhost;
begin
 result:=nil;
 if POCAIsValueHash(Hash) then begin
  result:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Ghost;
 end;
end;

function POCAHashGetGhostValue(const Hash:TPOCAValue):TPOCAValue;
var p:pointer;
begin
 result:=POCAValueNull;
 if POCAIsValueHash(Hash) then begin
  p:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Ghost;
  if assigned(p) then begin
   POCASetValueReferencePointer(result,p);
  end;
 end;
end;

function POCAHashSetKind(Context:PPOCAContext;const Hash:TPOCAValue;Kind:longint):longbool;
var HashPtr:PPOCAHash;
begin
 result:=POCAIsValueHash(Hash);
 if result then begin
  HashPtr:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  TPasMPInterlocked.Exchange(HashPtr^.Kind,Kind);
  POCAHashLockInvalidate(HashPtr);
 end;
end;

function POCAHashGetKind(const Hash:TPOCAValue):longint;
begin
 result:=0;
 if POCAIsValueHash(Hash) then begin
  result:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.Kind;
 end;
end;

procedure POCAHashPutHashEvents(Hash:PPOCAHash;var HashRec:PPOCAHashRecord;const Key,Value:TPOCAValue);
var Instance:PPOCAInstance;
    Str:PPOCAString;
    Op:longint;
begin
 Instance:=Hash^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance;
 if POCAIsValueString(Key) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(Key));
  if (length(Str^.Data)>2) and ((Str^.Data[1]='_') and (Str^.Data[2]='_')) then begin
   Op:=MetaOpNamesHashMap.GetValue(Str^.Data);
   if Op>=0 then begin
    if not assigned(HashRec^.Events) then begin
     HashRec:=POCAHashCreateEvents(Instance,Hash);
    end;
    if assigned(HashRec^.Events) then begin
     HashRec^.Events[TPOCAMetaOp(Op)]:=Value;
    end;
   end;
   POCAHashLockInvalidate(Hash);
  end;
 end;
end;

procedure POCAHashPut(Hash:PPOCAHash;HashRec:PPOCAHashRecord;const Key,Value:TPOCAValue);
var Entity:longint;
    Cell:longword;
begin
 Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
 Entity:=HashRec^.CellToEntityIndex^[Cell];
 if Entity>=0 then begin
  HashRec^.Entities^[Entity].Value:=Value;
  POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(Hash)),Value);
  if assigned(HashRec^.Events) then begin
   POCAHashPutHashEvents(Hash,HashRec,Key,Value);
  end;
  exit;
 end;
 Entity:=HashRec^.Size;
 TPasMPInterlocked.Increment(HashRec^.Size);
 if Entity<(2 shl HashRec^.LogSize) then begin
  TPasMPInterlocked.Exchange(HashRec^.CellToEntityIndex^[Cell],Entity);
  TPasMPInterlocked.Exchange(HashRec^.EntityToCellIndex^[Entity],Cell);
  TPasMPInterlocked.Increment(HashRec^.RealSize);
  HashRec^.Entities^[Entity].Key:=Key;
  HashRec^.Entities^[Entity].Value:=Value;
  POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(Hash)),Value);
  if assigned(HashRec^.Events) then begin
   POCAHashPutHashEvents(Hash,HashRec,Key,Value);
  end;
  POCAHashLockInvalidate(Hash);
 end;
end;

procedure POCAHashPutCache(Hash:PPOCAHash;HashRec:PPOCAHashRecord;const Key,Value:TPOCAValue;var CacheIndex:longword);
var Entity:longint;
    Cell:longword;
begin
 Entity:=CacheIndex;
 if ((longword(Entity)<longword(HashRec^.Size)) and (HashRec^.EntityToCellIndex^[Entity]>=0)) and (HashRec^.Entities^[Entity].Key.CastedInt64=Key.CastedInt64) then begin
  HashRec^.Entities^[Entity].Value:=Value;
  POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(Hash)),Value);
  if assigned(HashRec^.Events) then begin
   POCAHashPutHashEvents(Hash,HashRec,Key,Value);
  end;
  exit;
 end;
 Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
 Entity:=HashRec^.CellToEntityIndex^[Cell];
 if Entity>=0 then begin
  TPasMPInterlocked.Exchange(longint(CacheIndex),Entity);
  HashRec^.Entities^[Entity].Value:=Value;
  POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(Hash)),Value);
  if assigned(HashRec^.Events) then begin
   POCAHashPutHashEvents(Hash,HashRec,Key,Value);
  end;
  exit;
 end;
 Entity:=HashRec^.Size;
 TPasMPInterlocked.Increment(HashRec^.Size);
 if Entity<(2 shl HashRec^.LogSize) then begin
  TPasMPInterlocked.Exchange(longint(CacheIndex),Entity);
  TPasMPInterlocked.Exchange(HashRec^.CellToEntityIndex^[Cell],Entity);
  TPasMPInterlocked.Exchange(HashRec^.EntityToCellIndex^[Entity],Cell);
  TPasMPInterlocked.Increment(HashRec^.RealSize);
  HashRec^.Entities^[Entity].Key:=Key;
  HashRec^.Entities^[Entity].Value:=Value;
  POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(Hash)),Value);
  if assigned(HashRec^.Events) then begin
   POCAHashPutHashEvents(Hash,HashRec,Key,Value);
  end;
  POCAHashLockInvalidate(Hash);
 end;
end;

function POCAHashResize(Instance:PPOCAInstance;Hash:PPOCAHash;Events:longbool=false):PPOCAHashRecord;
var HashRec:PPOCAHashRecord;
    LogSize,Size,Cell,Entity:longint;
    i,j:longword;
begin
 HashRec:=Hash^.HashRecord;
 LogSize:=0;
 if assigned(HashRec) then begin
  Size:=HashRec^.RealSize;
  while Size<>0 do begin
   Size:=Size shr 1;
   inc(LogSize);
  end;
  if assigned(HashRec^.Events) then begin
   Events:=true;
  end;
 end;
 if LogSize<1 then begin
  LogSize:=1;
 end;
 Size:=POCAHashRecordSize(LogSize,Events);
 GetMem(result,Size);
 FillChar(result^,Size,#0);
 result^.Size:=0;
 result^.RealSize:=0;
 result^.LogSize:=LogSize;
 result^.CellToEntityIndex:=pointer(@pansichar(pointer(result))[sizeof(TPOCAHashRecord)]);
 result^.EntityToCellIndex:=pointer(@result^.CellToEntityIndex^[2 shl LogSize]);
 result^.Entities:=pointer(@result^.EntityToCellIndex^[2 shl LogSize]);
 if Events then begin
  result^.Events:=pointer(@result^.Entities^[1 shl LogSize]);
  if (assigned(HashRec) and assigned(HashRec^.Events)) then begin
   result^.Events^:=HashRec^.Events^;
  end;
 end else begin
  result^.Events:=nil;
 end;
 begin
  i:=0;
  j:=2 shl LogSize;
  while i<j do begin
   result^.CellToEntityIndex^[i]:=ENT_EMPTY;
   result^.EntityToCellIndex^[i]:=CELL_EMPTY;
   inc(i);
  end;
 end;
 if assigned(HashRec) then begin
  i:=0;
  j:=2 shl HashRec^.LogSize;
  while i<j do begin
   Cell:=HashRec^.EntityToCellIndex^[i];
   if Cell>=0 then begin
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity>=0 then begin
     POCAHashPut(Hash,result,HashRec^.Entities^[Entity].Key,HashRec^.Entities^[Entity].Value);
    end;
   end;
   inc(i);
  end;
 end;
 POCAMRSWLockReadLock(@Hash^.Cache.MRSWLock);
 try
  POCAGarbageCollectorSwapFree(Hash^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,@Hash^.HashRecord,result);
  POCAHashInvalidate(Hash);
 finally
  POCAMRSWLockReadUnlock(@Hash^.Cache.MRSWLock);
 end;
end;

function POCAHashRawSize(const Hash:TPOCAValue):longint;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
begin
 result:=0;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    inc(result,HashRec^.RealSize);
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashRawExist(const Hash:TPOCAValue;const Key:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:longint;
    Cell:longword;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity>=0 then begin
     result:=true;
     break;
    end;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashRawGet(const Hash:TPOCAValue;const Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:longint;
    Cell:longword;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity>=0 then begin
     OutValue:=HashRec^.Entities^[Entity].Value;
     result:=true;
     break;
    end;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashRawSet(const Hash,Key,Value:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  HashRec:=HashInstance^.HashRecord;
  while (not assigned(HashRec)) or (HashRec^.RealSize>=(1 shl HashRec^.LogSize)) do begin
   HashRec:=POCAHashResize(HashInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,HashInstance,false);
  end;
  if assigned(HashRec) then begin
   POCAHashPut(HashInstance,HashRec,Key,Value);
   result:=true;
  end;
 end;
end;

function POCAHashRawDelete(const Hash,Key:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Cell:longword;
    Entity:longint;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  HashRec:=HashInstance^.HashRecord;
  if assigned(HashRec) then begin
   Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
   Entity:=HashRec^.CellToEntityIndex^[Cell];
   if Entity>=0 then begin
    TPasMPInterlocked.Exchange(HashRec^.EntityToCellIndex^[Entity],CELL_DELETED);
    TPasMPInterlocked.Exchange(HashRec^.CellToEntityIndex^[Cell],ENT_DELETED);
    TPasMPInterlocked.Decrement(HashRec^.RealSize);
    if assigned(HashRec^.Events) then begin
     POCAHashPutHashEvents(HashInstance,HashRec,Key,POCAValueNull);
    end;
    if HashRec^.RealSize<(1 shl (HashRec^.LogSize-1)) then begin
     POCAHashResize(HashInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,HashInstance,false);
    end;
    POCAHashLockInvalidate(HashInstance);
    result:=true;
   end;
  end;
 end;
end;

procedure POCAHashRawKeys(const Dst,Hash:TPOCAValue);
var HashRec:PPOCAHashRecord;
    Index,Cell,Entity:longint;
begin
 if POCAIsValueHash(Hash) then begin
  HashRec:=PPOCAHash(POCAGetValueReferencePointer(Hash))^.HashRecord;
  if assigned(HashRec) then begin
   for Index:=0 to (2 shl HashRec^.LogSize)-1 do begin
    Cell:=HashRec^.EntityToCellIndex^[Index];
    if Cell>=0 then begin
     Entity:=HashRec^.CellToEntityIndex^[Cell];
     if Entity>=0 then begin
      POCAArrayPush(Dst,HashRec^.Entities^[Entity].Key);
     end;
    end;
   end;
  end;
 end;
end;

function POCAHashSymbol(Hash:PPOCAHash;Sym:PPOCAString;var OutValue:TPOCAValue):boolean;
var HashRec:PPOCAHashRecord;
    HashCode,Cell,Mask,Step:longword;
    Entity:longint;
    he:PPOCAHashEntity;
begin
 result:=false;
 HashCode:=Sym^.HashCode;
 if HashCode=0 then begin
  HashCode:=POCAHashString(Sym^.Data);
  TPasMPInterlocked.Exchange(longint(Sym^.HashCode),HashCode);
 end;
 while assigned(Hash) do begin
  HashRec:=Hash^.HashRecord;
  if assigned(HashRec) then begin
   Mask:=(2 shl HashRec^.LogSize)-1;
   Step:=((HashCode shl 1)+1) and Mask;
   if HashRec^.LogSize<>0 then begin
    Cell:=HashCode shr (32-HashRec^.LogSize);
   end else begin
    Cell:=0;
   end;
   repeat
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity<0 then begin
     break;
    end;
    he:=@HashRec^.Entities^[Entity];
    if POCAIsValueObject(he^.Key) and (POCAGetValueReferencePointer(he^.Key)=Sym) then begin
     OutValue:=he^.Value;
     result:=true;
     exit;
    end;
    Cell:=(Cell+Step) and Mask;
   until false;
  end;
  Hash:=Hash^.Prototype;
 end;
end;

function POCAHashSymbolCache(Hash:PPOCAHash;const Sym:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:longword):longint;
var HashRec:PPOCAHashRecord;
    HashCode,Cell,Mask,Step:longword;
    Entity:longint;
    he:PPOCAHashEntity;
    Str:PPOCAString;
begin
 result:=0;
 HashCode:=0;
 while assigned(Hash) do begin
  if assigned(Hash^.Events) then begin
   result:=2;
   break;
  end;
  HashRec:=Hash^.HashRecord;
  if assigned(HashRec) then begin
   Mask:=(2 shl HashRec^.LogSize)-1;
   Entity:=CacheIndex;
   if (longword(Entity)<longword(HashRec^.Size)) and (HashRec^.EntityToCellIndex^[Entity]>=0) then begin
    he:=@HashRec^.Entities^[Entity];
    if he^.Key.CastedInt64=Sym.CastedInt64 then begin
     OutValue:=he^.Value;
     result:=1;
     exit;
    end;
   end;
   if HashCode=0 then begin
{$ifdef cpu32}
    Str:=Sym.Reference.StringObject;
{$else}
    Str:=PPOCAString(pointer(TPOCAPtrUInt(Sym.Reference.Ptr) and POCAValueReferenceMask));
{$endif}
/// Str:=PPOCAString(POCAGetValueReferencePointer(Sym));
    HashCode:=Str^.HashCode;
    if HashCode=0 then begin
     HashCode:=POCAHashString(Str^.Data);
     TPasMPInterlocked.Exchange(longint(Str^.HashCode),HashCode);
    end;
   end;
   Step:=((HashCode shl 1)+1) and Mask;
   if HashRec^.LogSize<>0 then begin
    Cell:=HashCode shr (32-HashRec^.LogSize);
   end else begin
    Cell:=0;
   end;
   repeat
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity<0 then begin
     break;
    end;
    he:=@HashRec^.Entities^[Entity];
    if he^.Key.CastedInt64=Sym.CastedInt64 then begin
     OutValue:=he^.Value;
     TPasMPInterlocked.Exchange(longint(CacheIndex),Entity);
     result:=1;
     exit;
    end;
    Cell:=(Cell+Step) and Mask;
   until false;
  end;
  Hash:=Hash^.Prototype;
 end;
end;

function POCAHashSymbolChainCache(Hash:PPOCAHash;const Sym:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:longword):longint;
var HashRec:PPOCAHashRecord;
    HashCode,Cell,Mask,Step:longword;
    Entity,Index:longint;
    he:PPOCAHashEntity;
    Str:PPOCAString;
begin
 result:=0;
 if assigned(Hash) then begin
  if assigned(Hash^.Events) then begin
   result:=2;
  end else begin
   if Hash^.Cache.Ready then begin
    if CacheIndex<>$ffffffff then begin
     POCAMRSWLockReadLock(@Hash^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
     try
{$endif}
      if Hash^.Cache.Ready and assigned(Hash^.Cache.ChainEntities) then begin
       Entity:=CacheIndex;
       if longword(Entity)<longword(Hash^.Cache.ChainCount) then begin
        he:=Hash^.Cache.ChainEntities^[Entity];
        if he^.Key.CastedInt64=Sym.CastedInt64 then begin
         OutValue:=he^.Value;
{$ifndef POCAUseSafeMRSWLocks}
         POCAMRSWLockReadUnlock(@Hash^.Cache.MRSWLock);
{$endif}
         result:=1;
         exit;
        end;
       end;
      end;
{$ifdef POCAUseSafeMRSWLocks}
     finally
{$endif}
      POCAMRSWLockReadUnlock(@Hash^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
     end;
{$endif}
    end;
   end else begin
    POCAHashRebuildCache(Hash);
   end;
   Index:=Hash^.Cache.ChainCount;
   Str:=PPOCAString(POCAGetValueReferencePointer(Sym));
   HashCode:=Str^.HashCode;
   if HashCode=0 then begin
    HashCode:=POCAHashString(Str^.Data);
    TPasMPInterlocked.Exchange(longint(Str^.HashCode),HashCode);
   end;
   while assigned(Hash) do begin
    HashRec:=Hash^.HashRecord;
    if assigned(HashRec) then begin
     dec(Index,HashRec^.Size);
     Mask:=(2 shl HashRec^.LogSize)-1;
     Entity:=CacheIndex and Mask;
     Step:=((HashCode shl 1)+1) and Mask;
     if HashRec^.LogSize<>0 then begin
      Cell:=HashCode shr (32-HashRec^.LogSize);
     end else begin
      Cell:=0;
     end;
     repeat
      Entity:=HashRec^.CellToEntityIndex^[Cell];
      if Entity<0 then begin
       break;
      end;
      he:=@HashRec^.Entities^[Entity];
      if he^.Key.CastedInt64=Sym.CastedInt64 then begin
       OutValue:=he^.Value;
       TPasMPInterlocked.Exchange(longint(CacheIndex),Index+Entity);
       result:=1;
       exit;
      end;
      Cell:=(Cell+Step) and Mask;
     until false;
    end;
    Hash:=Hash^.Prototype;
   end;
  end;
 end;
end;

function POCAHashNewSymbol(Instance:PPOCAInstance;Hash:PPOCAHash;const Key,Value:TPOCAValue):boolean;
var HashRec:PPOCAHashRecord;
    Mask,Step,Cell:longword;
    Entity:longint;
    s:PPOCAString;
    he:PPOCAHashEntity;
begin
 result:=false;
 HashRec:=Hash^.HashRecord;
 s:=PPOCAString(POCAGetValueReferencePointer(Key));
 if s^.HashCode=0 then begin
  TPasMPInterlocked.Exchange(longint(s^.HashCode),POCAHashString(s^.Data));
 end;
 while (not assigned(HashRec)) or (HashRec^.RealSize>=(1 shl HashRec^.LogSize)) do begin
  HashRec:=POCAHashResize(Instance,Hash,false);
 end;
 Mask:=(2 shl HashRec^.LogSize)-1;
 Step:=((s^.HashCode shl 1)+1) and Mask;
 if HashRec^.LogSize<>0 then begin
  Cell:=s^.HashCode shr (32-HashRec^.LogSize);
 end else begin
  Cell:=0;
 end;
 while HashRec^.CellToEntityIndex^[Cell]<>ENT_EMPTY do begin
  Cell:=(Cell+Step) and Mask;
 end;
 Entity:=HashRec^.Size;
 TPasMPInterlocked.Increment(HashRec^.Size);
 if Entity<(2 shl HashRec^.LogSize) then begin
  TPasMPInterlocked.Exchange(HashRec^.EntityToCellIndex^[Entity],Cell);
  TPasMPInterlocked.Exchange(HashRec^.CellToEntityIndex^[Cell],Entity);
  TPasMPInterlocked.Increment(HashRec^.RealSize);
  he:=@HashRec^.Entities^[Entity];
  he^.Key:=Key;
  he^.Value:=Value;
  POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(Hash)),Value);
  if assigned(HashRec^.Events) then begin
   POCAHashPutHashEvents(Hash,HashRec,Key,Value);
  end;
  POCAHashLockInvalidate(Hash);
  result:=true;
 end;
end;

function POCAHashTrySet(Context:PPOCAContext;const Hash,Key,Value:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Cell:longword;
    Entity:longint;
    SubContext:PPOCAContext;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events[pmoSET]) then begin
   SubContext:=POCAContextSub(Context);
   try
    if POCAGetBooleanValue(SubContext,POCACall(SubContext,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],@Key,1,Hash,POCAValueNull)) then begin
     result:=POCAHashSet(SubContext,Hash,Key,Value);
    end;
   finally
    POCAContextDestroy(SubContext);
   end;
  end else begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity>=0 then begin
     HashRec^.Entities^[Entity].Value:=Value;
     POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(HashInstance)),Value);
     if assigned(HashRec^.Events) then begin
      POCAHashPutHashEvents(HashInstance,HashRec,Key,Value);
     end;
     result:=true;
    end;
   end;
  end;
 end;
end;

function POCAHashTrySetCache(Context:PPOCAContext;const Hash,Key,Value:TPOCAValue;var CacheIndex:longword):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Cell:longword;
    Entity:longint;
    SubContext:PPOCAContext;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events[pmoSET]) then begin
   SubContext:=POCAContextSub(Context);
   try
    if POCAGetBooleanValue(SubContext,POCACall(SubContext,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],@Key,1,Hash,POCAValueNull)) then begin
     result:=POCAHashSet(SubContext,Hash,Key,Value);
    end;
   finally
    POCAContextDestroy(SubContext);
   end;
  end else begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    Entity:=CacheIndex;
    if ((longword(Entity)<longword(HashRec^.Size)) and (HashRec^.EntityToCellIndex^[Entity]>=0)) and POCAEqual(HashRec^.Entities^[Entity].Key,Key) then begin
     HashRec^.Entities^[Entity].Value:=Value;
     POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(HashInstance)),Value);
     if assigned(HashRec^.Events) then begin
      POCAHashPutHashEvents(HashInstance,HashRec,Key,Value);
     end;
     result:=true;
     exit;
    end;
    Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity>=0 then begin
     TPasMPInterlocked.Exchange(longint(CacheIndex),Entity);
     HashRec^.Entities^[Entity].Value:=Value;
     POCAGarbageCollectorWriteBarrier(PPOCAObject(pointer(HashInstance)),Value);
     if assigned(HashRec^.Events) then begin
      POCAHashPutHashEvents(HashInstance,HashRec,Key,Value);
     end;
     result:=true;
    end;
   end;
  end;
 end;
end;

function POCAHashSize(Context:PPOCAContext;const Hash:TPOCAValue):longint;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    SubContext:PPOCAContext;
begin
 result:=0;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events[pmoSIZE]) then begin
    SubContext:=POCAContextSub(Context);
    try
     inc(result,trunc(POCAGetNumberValue(SubContext,POCACall(SubContext,HashInstance^.Events^.HashRecord^.Events^[pmoSIZE],nil,0,Hash,POCAValueNull))));
    finally
     POCAContextDestroy(SubContext);
    end;
   end else begin
    HashRec:=HashInstance^.HashRecord;
    if assigned(HashRec) then begin
     inc(result,HashRec^.RealSize);
    end;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashExist(Context:PPOCAContext;const Hash,Key:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:longint;
    Cell:longword;
    SubContext:PPOCAContext;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoEXIST]) then begin
    SubContext:=POCAContextSub(Context);
    try
     result:=POCAGetBooleanValue(SubContext,POCACall(SubContext,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],@Key,1,Hash,POCAValueNull));
    finally
     POCAContextDestroy(SubContext);
    end;
    if result then begin
     break;
    end;
   end else begin
    HashRec:=HashInstance^.HashRecord;
    if assigned(HashRec) then begin
     Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
     Entity:=HashRec^.CellToEntityIndex^[Cell];
     if Entity>=0 then begin
      result:=true;
      break;
     end;
    end;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashGetEvent(Context:PPOCAContext;const FuncExist,FuncGet,Hash,Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
var SubContext:PPOCAContext;
    Value:TPOCAValue;
begin
 result:=false;
 SubContext:=POCAContextSub(Context);
 try
  if POCAIsValueFunctionOrNativeCode(FuncExist) then begin
   if POCAGetBooleanValue(SubContext,POCACall(SubContext,FuncExist,@Key,1,Hash,POCAValueNull)) then begin
    OutValue:=POCACall(SubContext,FuncGet,@Key,1,Hash,POCAValueNull);
    result:=true;
   end;
  end else begin
   Value:=POCACall(SubContext,FuncGet,@Key,1,Hash,POCAValueNull);
   if POCAIsValueArray(Value) and (POCAArraySize(Value)=2) then begin
    if POCAGetBooleanValue(SubContext,POCAArrayGet(Value,0)) then begin
     OutValue:=POCAArrayGet(Value,1);
     result:=true;
    end;
   end;
  end;
 finally
  POCAContextDestroy(SubContext);
 end;
end;

function POCAHashGet(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:longint;
    Cell:longword;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  while assigned(HashInstance) do begin
   if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoGET]) then begin
    if POCAHashGetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],HashInstance^.Events^.HashRecord^.Events^[pmoGET],Hash,Key,OutValue) then begin
     result:=true;
     break;
    end;
   end else begin
    HashRec:=HashInstance^.HashRecord;
    if assigned(HashRec) then begin
     Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
     Entity:=HashRec^.CellToEntityIndex^[Cell];
     if Entity>=0 then begin
      OutValue:=HashRec^.Entities^[Entity].Value;
      result:=true;
      break;
     end;
    end;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashGetInherited(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:longint;
    Cell:longword;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if assigned(HashInstance) then begin
   HashInstance:=HashInstance^.Prototype;
   while assigned(HashInstance) do begin
    if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoGET]) then begin
     if POCAHashGetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],HashInstance^.Events^.HashRecord^.Events^[pmoGET],Hash,Key,OutValue) then begin
      result:=true;
      break;
     end;
    end else begin
     HashRec:=HashInstance^.HashRecord;
     if assigned(HashRec) then begin
      Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
      Entity:=HashRec^.CellToEntityIndex^[Cell];
      if Entity>=0 then begin
       OutValue:=HashRec^.Entities^[Entity].Value;
       result:=true;
       break;
      end;
     end;
    end;
    HashInstance:=HashInstance^.Prototype;
   end;
  end;
 end;
end;

function POCAHashGetCache(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:longword):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity,Index:longint;
    Cell:longword;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if assigned(HashInstance) then begin
   if assigned(HashInstance^.Prototype) then begin
    if HashInstance^.Cache.Ready then begin
     if CacheIndex<>$ffffffff then begin
      POCAMRSWLockReadLock(@HashInstance^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
      try
{$endif}
       if HashInstance^.Cache.Ready and assigned(HashInstance^.Cache.ChainEntities) then begin
        Entity:=CacheIndex;
        if (longword(Entity)<longword(HashInstance^.Cache.ChainCount)) and (HashInstance^.Cache.ChainEntities^[Entity]^.Key.CastedInt64=Key.CastedInt64) then begin
         OutValue:=HashInstance^.Cache.ChainEntities^[Entity]^.Value;
{$ifndef POCAUseSafeMRSWLocks}
         POCAMRSWLockReadUnlock(@HashInstance^.Cache.MRSWLock);
{$endif}
         result:=true;
         exit;
        end;
       end;
{$ifdef POCAUseSafeMRSWLocks}
      finally
{$endif}
       POCAMRSWLockReadUnlock(@HashInstance^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
      end;
{$endif}
     end;
    end else begin
     POCAHashRebuildCache(HashInstance);
    end;
    Index:=HashInstance^.Cache.ChainCount;
    repeat
     if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoGET]) then begin
      if POCAHashGetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],HashInstance^.Events^.HashRecord^.Events^[pmoGET],Hash,Key,OutValue) then begin
       result:=true;
       break;
      end;
     end else begin
      HashRec:=HashInstance^.HashRecord;
      if assigned(HashRec) then begin
       dec(Index,HashRec^.Size);
       Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
       Entity:=HashRec^.CellToEntityIndex^[Cell];
       if Entity>=0 then begin
        TPasMPInterlocked.Exchange(longint(CacheIndex),Index+Entity);
        OutValue:=HashRec^.Entities^[Entity].Value;
        result:=true;
        break;
       end;
      end;
     end;
     HashInstance:=HashInstance^.Prototype;
    until not assigned(HashInstance);
   end else begin
    if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoGET]) then begin
     if POCAHashGetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],HashInstance^.Events^.HashRecord^.Events^[pmoGET],Hash,Key,OutValue) then begin
      result:=true;
     end;
    end else begin
     HashRec:=HashInstance^.HashRecord;
     if assigned(HashRec) then begin
      if CacheIndex<>$ffffffff then begin
       Entity:=CacheIndex;
       if ((longword(Entity)<longword(HashRec^.Size)) and (HashRec^.EntityToCellIndex^[Entity]>=0)) and (HashRec^.Entities^[Entity].Key.CastedInt64=Key.CastedInt64) then begin
        OutValue:=HashRec^.Entities^[Entity].Value;
        result:=true;
        exit;
       end;
      end;
      Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
      Entity:=HashRec^.CellToEntityIndex^[Cell];
      if Entity>=0 then begin
       TPasMPInterlocked.Exchange(longint(CacheIndex),Entity);
       OutValue:=HashRec^.Entities^[Entity].Value;
       result:=true;
      end;
     end;
    end;
   end;
  end;
 end;
end;

function POCAHashGetInheritedCache(Context:PPOCAContext;const Hash,Key:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:longword):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity,Index:longint;
    Cell:longword;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if assigned(HashInstance) then begin
   if HashInstance^.Cache.Ready then begin
    if CacheIndex<>$ffffffff then begin
     POCAMRSWLockReadLock(@HashInstance^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
     try
{$endif}
      if HashInstance^.Cache.Ready and assigned(HashInstance^.Cache.ChainEntities) then begin
       Entity:=CacheIndex;
       if (longword(Entity)<longword(HashInstance^.Cache.ChainCount)) and (HashInstance^.Cache.ChainEntities^[Entity]^.Key.CastedInt64=Key.CastedInt64) then begin
        OutValue:=HashInstance^.Cache.ChainEntities^[Entity]^.Value;
{$ifndef POCAUseSafeMRSWLocks}
        POCAMRSWLockReadUnlock(@HashInstance^.Cache.MRSWLock);
{$endif}
        result:=true;
        exit;
       end;
      end;
{$ifdef POCAUseSafeMRSWLocks}
     finally
{$endif}
      POCAMRSWLockReadUnlock(@HashInstance^.Cache.MRSWLock);
{$ifdef POCAUseSafeMRSWLocks}
     end;
{$endif}
    end;
   end else begin
    POCAHashRebuildCache(HashInstance);
   end;
   Index:=HashInstance^.Cache.ChainCount;
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    dec(Index,HashRec^.Size);
   end;
   HashInstance:=HashInstance^.Prototype;
   while assigned(HashInstance) do begin
    if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoGET]) then begin
     if POCAHashGetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoEXIST],HashInstance^.Events^.HashRecord^.Events^[pmoGET],Hash,Key,OutValue) then begin
      result:=true;
      break;
     end;
    end else begin
     HashRec:=HashInstance^.HashRecord;
     if assigned(HashRec) then begin
      dec(Index,HashRec^.Size);
      Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
      Entity:=HashRec^.CellToEntityIndex^[Cell];
      if Entity>=0 then begin
       TPasMPInterlocked.Exchange(longint(CacheIndex),Index+Entity);
       OutValue:=HashRec^.Entities^[Entity].Value;
       result:=true;
       break;
      end;
     end;
    end;
    HashInstance:=HashInstance^.Prototype;
   end;
  end;
 end;
end;

function POCAHashSetEvent(Context:PPOCAContext;const FuncSet,Hash,Key,Value:TPOCAValue):boolean;
var SubContext:PPOCAContext;
    Values:array[0..1] of TPOCAValue;
begin
 SubContext:=POCAContextSub(Context);
 try
  Values[0]:=Key;
  Values[1]:=Value;
  result:=POCAGetBooleanValue(SubContext,POCACall(SubContext,FuncSet,@Values[0],2,Hash,POCAValueNull));
 finally
  POCAContextDestroy(SubContext);
 end;
end;

function POCAHashSet(Context:PPOCAContext;const Hash,Key,Value:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoSET]) then begin
   result:=POCAHashSetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoSET],Hash,Key,Value);
  end else begin
   HashRec:=HashInstance^.HashRecord;
   while (not assigned(HashRec)) or (HashRec^.RealSize>=(1 shl HashRec^.LogSize)) do begin
    HashRec:=POCAHashResize(HashInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,HashInstance,false);
   end;
   if assigned(HashRec) then begin
    POCAHashPut(HashInstance,HashRec,Key,Value);
    result:=true;
   end;
  end;
 end;
end;

function POCAHashSetCache(Context:PPOCAContext;const Hash,Key,Value:TPOCAValue;var CacheIndex:longword):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoSET]) then begin
   result:=POCAHashSetEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoSET],Hash,Key,Value);
  end else begin
   HashRec:=HashInstance^.HashRecord;
   while (not assigned(HashRec)) or (HashRec^.RealSize>=(1 shl HashRec^.LogSize)) do begin
    HashRec:=POCAHashResize(HashInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,HashInstance,false);
   end;
   if assigned(HashRec) then begin
    POCAHashPutCache(HashInstance,HashRec,Key,Value,CacheIndex);
    result:=true;
   end;
  end;
 end;
end;

function POCAHashDeleteEvent(Context:PPOCAContext;const FuncDelete,Hash,Key:TPOCAValue):boolean;
var SubContext:PPOCAContext;
begin
 SubContext:=POCAContextSub(Context);
 try
  result:=POCAGetBooleanValue(SubContext,POCACall(SubContext,FuncDelete,@Key,1,Hash,POCAValueNull));
 finally
  POCAContextDestroy(SubContext);
 end;
end;

function POCAHashDelete(Context:PPOCAContext;const Hash,Key:TPOCAValue):boolean;
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    Entity:longint;
    Cell:longword;
begin
 result:=false;
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoDELETE]) then begin
   result:=POCAHashDeleteEvent(Context,HashInstance^.Events^.HashRecord^.Events^[pmoDELETE],Hash,Key);
  end else begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    Cell:=POCAHashFindCell(HashRec,Key,POCAValueHash(Key));
    Entity:=HashRec^.CellToEntityIndex^[Cell];
    if Entity>=0 then begin             
     TPasMPInterlocked.Exchange(HashRec^.EntityToCellIndex^[Entity],CELL_DELETED);
     TPasMPInterlocked.Exchange(HashRec^.CellToEntityIndex^[Cell],ENT_DELETED);
     TPasMPInterlocked.Decrement(HashRec^.RealSize);
     if assigned(HashRec^.Events) then begin
      POCAHashPutHashEvents(HashInstance,HashRec,Key,POCAValueNull);
     end;
     if HashRec^.RealSize<(1 shl (HashRec^.LogSize-1)) then begin
      POCAHashResize(HashInstance^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance,HashInstance,false);
     end else begin
      POCAHashLockInvalidate(HashInstance);
     end;
     result:=true;
    end;
   end;
  end;
 end;
end;

procedure POCAHashOwnKeys(Context:PPOCAContext;const Dst,Hash:TPOCAValue);
var HashInstance:PPOCAHash;
    SubContext:PPOCAContext;
begin
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  if ((assigned(HashInstance^.Events) and assigned(HashInstance^.Events^.HashRecord)) and assigned(HashInstance^.Events^.HashRecord^.Events)) and POCAIsValueFunctionOrNativeCode(HashInstance^.Events^.HashRecord^.Events^[pmoKEYS]) then begin
   SubContext:=POCAContextSub(Context);
   try
    POCACall(SubContext,HashInstance^.Events^.HashRecord^.Events^[pmoKEYS],@Dst,1,Hash,POCAValueNull);
   finally
    POCAContextDestroy(SubContext);
   end;
  end else begin
   POCAHashRawKeys(Dst,Hash);
  end;
 end;
end;

procedure POCAHashKeys(Context:PPOCAContext;const Dst,Hash:TPOCAValue);
 procedure Combine(const DstHash:TPOCAValue;SrcHash:TPOCAValue);
 var i:longint;
     Keys,Key,DstValue,SrcValue:TPOCAValue;
     HashInstance:PPOCAHash;
 begin
  if POCAIsValueHash(DstHash) and POCAIsValueHash(SrcHash) then begin
   Keys:=POCANewArray(Context);
   POCAHashOwnKeys(Context,Keys,SrcHash);
   for i:=0 to POCAArraySize(Keys)-1 do begin
    Key:=POCAArrayGet(Keys,i);
    if (not POCAHashGet(Context,DstHash,Key,DstValue)) and POCAHashGet(Context,SrcHash,Key,SrcValue) then begin
     POCAHashSet(Context,DstHash,Key,SrcValue);
    end;
   end;
   HashInstance:=PPOCAHash(POCAGetValueReferencePointer(SrcHash));
   if assigned(HashInstance) then begin
    HashInstance:=HashInstance^.Prototype;
    while assigned(HashInstance) do begin
     POCASetValueReferencePointer(SrcHash,HashInstance);
     Keys:=POCANewArray(Context);
     POCAHashOwnKeys(Context,Keys,SrcHash);
     for i:=0 to POCAArraySize(Keys)-1 do begin
      Key:=POCAArrayGet(Keys,i);
      if (not POCAHashGet(Context,DstHash,Key,DstValue)) and POCAHashGet(Context,SrcHash,Key,SrcValue) then begin
       POCAHashSet(Context,DstHash,Key,SrcValue);
      end;
     end;
     HashInstance:=HashInstance^.Prototype;
    end;
   end;
  end;
 end;
var TempHash:TPOCAValue;
begin
 if POCAIsValueHash(Hash) then begin
  TempHash:=POCANewHash(Context);
  Combine(TempHash,Hash);
  POCAHashOwnKeys(Context,Dst,TempHash);
 end;
end;

function POCAHashGetString(Context:PPOCAContext;const Hash:TPOCAValue;const Key:TPOCARawByteString):TPOCAValue;
begin
 if not (POCAIsValueHash(Hash) and POCAHashGet(Context,Hash,POCANewUniqueString(Context,Key),result)) then begin
  result:=POCAValueNull;
 end;
end;

procedure POCAHashSetString(Context:PPOCAContext;const Hash:TPOCAValue;const Key:TPOCARawByteString;const Value:TPOCAValue);
begin
 if POCAIsValueHash(Hash) then begin
  POCAHashSet(Context,Hash,POCANewUniqueString(Context,Key),Value);
 end;
end;

procedure POCAHashCombine(Context:PPOCAContext;const Hash,Source:TPOCAValue);
var HashInstance:PPOCAHash;
    HashRec:PPOCAHashRecord;
    i,Entity:longint;
    Keys,Key,Value:TPOCAValue;
begin
 if POCAIsValueHash(Hash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Source));
  if assigned(HashInstance^.Events) or assigned(HashInstance^.Prototype) then begin
   Keys:=POCANewArray(Context);
   POCAHashKeys(Context,Keys,Source);
   for i:=0 to POCAArraySize(Keys)-1 do begin
    Key:=POCAArrayGet(Keys,0);
    if POCAHashGet(Context,Source,Key,Value) then begin
     POCAHashSet(Context,Hash,Key,Value);
    end;
   end;
  end else begin
   HashRec:=HashInstance^.HashRecord;
   if assigned(HashRec) then begin
    for i:=0 to (2 shl HashRec^.LogSize)-1 do begin
     Entity:=HashRec^.CellToEntityIndex^[i];
     if Entity>=0 then begin
      Key:=HashRec^.Entities^[Entity].Key;
      Value:=HashRec^.Entities^[Entity].Value;
      POCAHashSet(Context,Hash,Key,Value);
     end;
    end;
   end;
  end;
 end;
end;

function POCAHashInstanceOf(Context:PPOCAContext;const Hash,OfHash:TPOCAValue):longbool;
var HashInstance,OfHashInstance:PPOCAHash;
begin
 result:=false;
 if POCAIsValueHash(Hash) and POCAIsValueHash(OfHash) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  OfHashInstance:=PPOCAHash(POCAGetValueReferencePointer(OfHash));
  while assigned(HashInstance) do begin
   if HashInstance=OfHashInstance then begin
    result:=true;
    break;
   end;
   HashInstance:=HashInstance^.Prototype;
  end;
 end;
end;

function POCAHashIs(Context:PPOCAContext;const Hash,OfObject:TPOCAValue):longbool;
var HashInstance:PPOCAHash;
    OfObjectInstance:PPOCAObject;
begin
 result:=false;
 if POCAIsValueHash(Hash) and POCAIsValueObject(OfObject) then begin
  HashInstance:=PPOCAHash(POCAGetValueReferencePointer(Hash));
  OfObjectInstance:=PPOCAObject(POCAGetValueReferencePointer(OfObject));
  while assigned(HashInstance) do begin
   if HashInstance^.Constructor_=OfObjectInstance then begin
    result:=true;
    break;
   end;
   if assigned(HashInstance^.Constructor_) then begin
    case HashInstance^.Constructor_^.Header.ValueType of
     pvtHASH:begin
      HashInstance:=PPOCAHash(HashInstance^.Constructor_);
     end;
     pvtGHOST:begin
      HashInstance:=PPOCAGhost(HashInstance^.Constructor_)^.Hash;
     end;
     else begin
      break;
     end;
    end;
   end else begin
    break;
   end;
  end;
 end;
end;

function POCAObjectInstanceOf(Context:PPOCAContext;const Value,OfValue:TPOCAValue):longbool; {$ifdef caninline}inline;{$endif}
begin
 if POCAIsValueGhost(Value) then begin
  result:=POCAHashInstanceOf(Context,POCAGhostGetHashValue(Value),OfValue);
 end else begin
  result:=POCAHashInstanceOf(Context,Value,OfValue);
 end;
end;

function POCAObjectIs(Context:PPOCAContext;const Value,OfValue:TPOCAValue):longbool; {$ifdef caninline}inline;{$endif}
begin
 if POCAIsValueGhost(Value) then begin
  result:=POCAHashIs(Context,POCAGhostGetHashValue(Value),OfValue);
 end else begin
  result:=POCAHashIs(Context,Value,OfValue);
 end;
end;

function POCAInternSymbol(Context:PPOCAContext;Instance:PPOCAInstance;const Symbol:TPOCAValue):TPOCAValue; {$ifdef caninline}inline;{$endif}
begin
 result:=POCAValueNull;
 if not POCAHashGet(Context,Instance.Globals.Symbols,Symbol,result) then begin
  POCAHashSet(Context,Instance.Globals.Symbols,Symbol,Symbol);
  result:=Symbol;
 end;
end;

procedure POCAContextInit(Context:PPOCAContext);
begin
 Context^.Active:=true;
 Context^.FrameTop:=0;
 if assigned(Context^.TemporarySavedObjects) and (Context^.TemporarySavedObjectSize>32) then begin
  FreeMem(Context^.TemporarySavedObjects);
  Context^.TemporarySavedObjects:=nil;
 end;
 if not assigned(Context^.GrayList) then begin
  GetMemAligned(Context^.GrayList,SizeOf(TPOCAGarbageCollectorLinkedList));
 end;
 POCAGarbageCollectorLinkedListReset(Context^.GrayList);
 Context^.CallDepth:=0;
 Context^.CallParent:=nil;
 Context^.CallChild:=nil;
 Context^.CoroutineData:=nil;
 Context^.ThreadData:=nil;
 Context^.UserData:=nil;
end;

function POCAContextCreate(Instance:PPOCAInstance):PPOCAContext;
begin                     
 POCALockEnter(Instance^.Globals.Lock);
 try
  result:=Instance^.Globals.FreeContexts;
  if assigned(result) then begin
   Instance.Globals.FreeContexts:=result^.NextFree;
   result^.NextFree:=nil;
   result^.Instance:=Instance;
   dec(Instance^.Globals.FreeContextCount);
   POCALockLeave(Instance^.Globals.Lock);
   try
    POCAContextInit(result);
   finally
    POCALockEnter(Instance^.Globals.Lock);
   end;
  end else begin
   POCALockLeave(Instance^.Globals.Lock);
   try
    GetMem(result,sizeof(TPOCAContext));
    FillChar(result^,sizeof(TPOCAContext),#0);
    result^.Instance:=Instance;
    result^.GarbageCollectorLockCount:=0;
    POCAContextInit(result);
   finally
    POCALockEnter(Instance^.Globals.Lock);
   end;
   result^.Previous:=Instance^.Globals.LastContext;
   if assigned(result^.Previous) then begin
    result^.Previous^.Next:=result;
   end else begin
    Instance^.Globals.FirstContext:=result;
   end;
   result^.Next:=nil;
   Instance^.Globals.LastContext:=result;
   result^.NextFree:=nil;
  end;
 finally
  POCALockLeave(Instance^.Globals.Lock);
 end;
end;

procedure POCAContextReleaseObjectPool(Context:PPOCAContext);
var ValueType:longint;
    ContextObjectPool:PPOCAContextObjectPool;
    Pool:PPOCAPool;
begin
 if assigned(Context) then begin
  for ValueType:=0 to pvtCOUNT-1 do begin
   ContextObjectPool:=@Context^.ContextObjectPools[ValueType];
   if assigned(ContextObjectPool^.Objects) and (ContextObjectPool^.Count>0) then begin
    POCALockEnter(Context^.Instance^.Globals.Lock);
    try
     Pool:=@Context^.Instance^.Globals.Pools[ValueType];
     while ContextObjectPool^.Count>0 do begin
      dec(ContextObjectPool^.Count);
      Pool^.FreeObjects^[Pool^.FreeCount]:=ContextObjectPool^.Objects^[ContextObjectPool^.Count];
      inc(Pool^.FreeCount);
     end;
    finally
     POCALockLeave(Context^.Instance^.Globals.Lock);
    end;
   end;
  end;
 end;
end;

procedure POCAReleaseContextObjectPools(Instance:PPOCAInstance);
var Context:PPOCAContext;
begin
 Context:=Instance^.Globals.FreeContexts;
 while assigned(Context) do begin
  POCAContextReleaseObjectPool(Context);
  Context:=Context^.NextFree;
 end;
end;

procedure POCAContextFree(Context:PPOCAContext);
var i:longint;
    ContextObjectPool:PPOCAContextObjectPool;
begin
 if assigned(Context^.Previous) then begin
  Context^.Previous^.Next:=Context^.Next;
 end else if Context^.Instance^.Globals.FirstContext=Context then begin
  Context^.Instance^.Globals.FirstContext:=Context^.Next;
 end;
 if assigned(Context^.Next) then begin
  Context^.Next^.Previous:=Context^.Previous;
 end else if Context^.Instance^.Globals.FirstContext=Context then begin
  Context^.Instance^.Globals.LastContext:=Context^.Previous;
 end;
 Context^.Previous:=nil;
 Context^.Next:=nil;
 if assigned(Context^.NextFree) then begin
  Context^.Instance^.Globals.FreeContexts:=Context^.NextFree;
  Context^.NextFree:=nil;
 end;
 if assigned(Context^.TemporarySavedObjects) then begin
  FreeMem(Context^.TemporarySavedObjects);
  Context^.TemporarySavedObjects:=nil;
 end;
 if assigned(Context^.GrayList) then begin
  FreeMemAligned(Context^.GrayList);
  Context^.GrayList:=nil;
 end;
 for i:=0 to POCA_MAX_RECURSION-1 do begin
  SetLength(Context^.FrameStack[i].Registers,0);
  SetLength(Context^.FrameStack[i].Arguments,0);
 end;
 for i:=0 to pvtCOUNT-1 do begin
  ContextObjectPool:=@Context^.ContextObjectPools[i];
  if assigned(ContextObjectPool^.Objects) then begin
   FreeMem(ContextObjectPool^.Objects);
   ContextObjectPool^.Objects:=nil;
  end;
 end;
 Finalize(Context^);
 FreeMem(Context);
end;

procedure POCAContextDestroy(Context:PPOCAContext);
//var Obj:PPOCAObject;
begin
 if assigned(Context) then begin
  while Context^.GarbageCollectorLockCount>0 do begin
   POCAGarbageCollectorUnlock(Context);
  end;
  if Context^.GrayList.Next<>Context^.GrayList then begin
   POCALockEnter(Context^.Instance^.Globals.Lock);
   try
    POCAGarbageCollectorLinkedListMove(Context^.GrayList,Context^.Instance.Globals.GarbageCollector.GrayList);
   finally
    POCALockLeave(Context^.Instance^.Globals.Lock);
   end;
  end;
  Context^.TemporarySavedObjectCount:=0;
  Context^.CoroutineData:=nil;
  Context^.ThreadData:=nil;
  if assigned(Context^.CallChild) then begin
   POCAContextDestroy(Context^.CallChild);
   Context^.CallChild:=nil;
  end;
  if assigned(Context^.CallParent) then begin
   Context^.CallParent^.CallChild:=nil;
  end;
  Context^.CallDepth:=0;
  POCALockEnter(Context^.Instance^.Globals.Lock);
  try
   if Context^.Instance^.Globals.FreeContextCount<Context^.Instance^.Globals.GarbageCollector.ContextCacheSize then begin
    inc(Context^.Instance^.Globals.FreeContextCount);
    Context^.NextFree:=Context^.Instance^.Globals.FreeContexts;
    Context^.Instance^.Globals.FreeContexts:=Context;
   end else begin
    POCAContextReleaseObjectPool(Context);
    POCAContextFree(Context);
   end;
  finally
   POCALockLeave(Context^.Instance^.Globals.Lock);
  end;
 end;
end;

function POCAContextSub(Super:PPOCAContext):PPOCAContext;
begin
 if (Super^.CallDepth+1)>=POCA_MAX_RECURSION then begin
  POCARuntimeError(Super,'Call sub context overflow');
 end;
 result:=POCAContextCreate(Super^.Instance);
 if assigned(Super^.CallChild) then begin
  POCAContextDestroy(Super^.CallChild);
 end;
 result^.CallDepth:=Super^.CallDepth+1;
 result^.CallParent:=Super;
 Super^.CallChild:=result;
end;

function POCAGarbageCollectorFunctionGETSTEPFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.StepFactor;
end;

function POCAGarbageCollectorFunctionGETINTERVALFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.IntervalFactor;
end;

function POCAGarbageCollectorFunctionGETGHOSTFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.GhostFactor;
end;

function POCAGarbageCollectorFunctionGETSWEEPFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.SweepFactor;
end;

function POCAGarbageCollectorFunctionGETFLIPFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.FlipFactor;
end;

function POCAGarbageCollectorFunctionGETPERSISTENTINTERVAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.PersistentInterval;
end;

function POCAGarbageCollectorFunctionGETPERSISTENTTHRESHOLD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.PersistentThreshold;
end;

function POCAGarbageCollectorFunctionGETFULLCOLLECT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.FullCollect);
end;

function POCAGarbageCollectorFunctionGETLOCALCONTEXTPOOLSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.LocalContextPoolSize;
end;

function POCAGarbageCollectorFunctionGETCONTEXTCACHESIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.ContextCacheSize;
end;

function POCAGarbageCollectorFunctionGETMINIMUMBLOCKSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.MinimumBlockSize;
end;

function POCAGarbageCollectorFunctionSETSTEPFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setStepFactor"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.StepFactor;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.StepFactor,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETINTERVALFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setIntervalFactor"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.IntervalFactor;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.IntervalFactor,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETGHOSTFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setGhostFactor"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.GhostFactor;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.GhostFactor,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETSWEEPFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setSweepFactor"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.SweepFactor;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.SweepFactor,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETFLIPFACTOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setFlipFactor"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.FlipFactor;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.FlipFactor,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETPERSISTENTINTERVAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setPersistentInterval"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.PersistentInterval;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.PersistentInterval,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETPERSISTENTTHRESHOLD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setPersistentThreshold"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.PersistentThreshold;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.PersistentThreshold,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETFULLCOLLECT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setFullCollect"');
 end;
 result.Num:=ord(Context^.Instance^.Globals.GarbageCollector.FullCollect);
 TPasMPInterlocked.Exchange(longint(Context^.Instance^.Globals.GarbageCollector.FullCollect),longint(longbool(ord(trunc(POCAGetNumberValue(Context,Arguments^[0]))<>0))));
end;

function POCAGarbageCollectorFunctionSETLOCALCONTEXTPOOLSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setLocalContextSize"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.LocalContextPoolSize;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.LocalContextPoolSize,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETCONTEXTCACHESIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "GarbageCollector.setContextCacheSize"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.ContextCacheSize;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.ContextCacheSize,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionSETMINIMUMBLOCKSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "garbagecollector.setMinimumBlockSize"');
 end;
 result.Num:=Context^.Instance^.Globals.GarbageCollector.MinimumBlockSize;
 TPasMPInterlocked.Exchange(Context^.Instance^.Globals.GarbageCollector.MinimumBlockSize,trunc(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAGarbageCollectorFunctionCOLLECT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 Context^.Instance^.Globals.RequestGarbageCollection:=brgcFULL;
 POCAGarbageCollectorBottleneck(Context^.Instance);
 result.Num:=1;
end;

function POCAGarbageCollectorFunctionCYCLE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 Context^.Instance^.Globals.RequestGarbageCollection:=brgcCYCLE;
 POCAGarbageCollectorBottleneck(Context^.Instance);
 result.Num:=1;
end;

function POCAGarbageCollectorFunctionALLOCATED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=Context^.Instance^.Globals.GarbageCollector.Allocated;
end;

function POCAGarbageCollectorFunctionUSED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=POCAGarbageCollectorUsed(Context^.Instance);
end;

function POCAGarbageCollectorFunctionFree(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=POCAGarbageCollectorFree(Context^.Instance);
end;

function POCAInitGarbageCollectorNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'getStepFactor',POCAGarbageCollectorFunctionGETSTEPFACTOR);
 POCAAddNativeFunction(Context,result,'getIntervalFactor',POCAGarbageCollectorFunctionGETINTERVALFACTOR);
 POCAAddNativeFunction(Context,result,'getGhostFactor',POCAGarbageCollectorFunctionGETGHOSTFACTOR);
 POCAAddNativeFunction(Context,result,'getSweepFactor',POCAGarbageCollectorFunctionGETSWEEPFACTOR);
 POCAAddNativeFunction(Context,result,'getFlipFactor',POCAGarbageCollectorFunctionGETFLIPFACTOR);
 POCAAddNativeFunction(Context,result,'getPersistentInterval',POCAGarbageCollectorFunctionGETPERSISTENTINTERVAL);
 POCAAddNativeFunction(Context,result,'getPersistentThreshold',POCAGarbageCollectorFunctionGETPERSISTENTTHRESHOLD);
 POCAAddNativeFunction(Context,result,'getFullCollect',POCAGarbageCollectorFunctionGETFULLCOLLECT);
 POCAAddNativeFunction(Context,result,'getLocalContextPoolSize',POCAGarbageCollectorFunctionGETLOCALCONTEXTPOOLSIZE);
 POCAAddNativeFunction(Context,result,'getContextCacheSize',POCAGarbageCollectorFunctionGETCONTEXTCACHESIZE);
 POCAAddNativeFunction(Context,result,'getMinimumBlockSize',POCAGarbageCollectorFunctionGETMINIMUMBLOCKSIZE);
 POCAAddNativeFunction(Context,result,'setStepFactor',POCAGarbageCollectorFunctionSETSTEPFACTOR);
 POCAAddNativeFunction(Context,result,'setIntervalFactor',POCAGarbageCollectorFunctionSETINTERVALFACTOR);
 POCAAddNativeFunction(Context,result,'setGhostFactor',POCAGarbageCollectorFunctionSETGHOSTFACTOR);
 POCAAddNativeFunction(Context,result,'setSweepFactor',POCAGarbageCollectorFunctionSETSWEEPFACTOR);
 POCAAddNativeFunction(Context,result,'setFlipFactor',POCAGarbageCollectorFunctionSETFLIPFACTOR);
 POCAAddNativeFunction(Context,result,'setPersistentInterval',POCAGarbageCollectorFunctionSETPERSISTENTINTERVAL);
 POCAAddNativeFunction(Context,result,'setPersistentThreshold',POCAGarbageCollectorFunctionSETPERSISTENTTHRESHOLD);
 POCAAddNativeFunction(Context,result,'setFullCollect',POCAGarbageCollectorFunctionSETFULLCOLLECT);
 POCAAddNativeFunction(Context,result,'setLocalContextPoolSize',POCAGarbageCollectorFunctionSETLOCALCONTEXTPOOLSIZE);
 POCAAddNativeFunction(Context,result,'setContextCacheSize',POCAGarbageCollectorFunctionSETCONTEXTCACHESIZE);
 POCAAddNativeFunction(Context,result,'setMinimumBlockSize',POCAGarbageCollectorFunctionSETMINIMUMBLOCKSIZE);
 POCAAddNativeFunction(Context,result,'collect',POCAGarbageCollectorFunctionCOLLECT);
 POCAAddNativeFunction(Context,result,'cycle',POCAGarbageCollectorFunctionCYCLE);
 POCAAddNativeFunction(Context,result,'allocated',POCAGarbageCollectorFunctionALLOCATED);
 POCAAddNativeFunction(Context,result,'used',POCAGarbageCollectorFunctionUSED);
 POCAAddNativeFunction(Context,result,'free',POCAGarbageCollectorFunctionFREE);
end;

function POCAMathFunctionMIN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.min"');
 end;
 result.Num:=Min(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionMAX(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.max"');
 end;
 result.Num:=Max(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionCLAMP(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<3 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.clamp"');
 end;
 result.Num:=Min(Max(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1])),POCAGetNumberValue(Context,Arguments^[2]));
end;

function POCAMathFunctionABS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.abs"');
 end;
 result.Num:=abs(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionSIN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sin"');
 end;
 result.Num:=sin(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCOS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.cos"');
 end;
 result.Num:=cos(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionTAN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.tan"');
 end;
 result.Num:=tan(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionEXP(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.exp"');
 end;
 result.Num:=exp(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionLN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.ln"');
 end;
 result.Num:=ln(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionLOG(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.log"');
 end;
 result.Num:=ln(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionSQR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sqr"');
 end;
 result.Num:=sqr(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionSQRT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sqrt"');
 end;
 result.Num:=sqrt(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionATAN2(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.atan2"');
 end;
 result.Num:=ArcTan2(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionACOS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acos"');
 end;
 result.Num:=ArcCos(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionASIN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.asin"');
 end;
 result.Num:=ArcSin(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionATAN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.atan"');
 end;
 result.Num:=ArcTan(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCOTAN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.cotan"');
 end;
 result.Num:=Cotan(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionSECANT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.secant"');
 end;
 result.Num:=Secant(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCOSECANT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.cosecant"');
 end;
 result.Num:=Cosecant(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionHYPOT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.hypot"');
 end;
 result.Num:=Hypot(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionCEIL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.ceil"');
 end;
 result.Num:=ceil(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionFLOOR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.floor"');
 end;
 result.Num:=floor(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionLOG10(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.log10"');
 end;
 result.Num:=Log10(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionLOG2(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.log2"');
 end;
 result.Num:=Log2(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionLOGN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.logn"');
 end;
 result.Num:=LogN(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionPOW(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.pow"');
 end;
 result.Num:=Math.Power(POCAGetNumberValue(Context,Arguments^[0]),POCAGetNumberValue(Context,Arguments^[1]));
end;

function POCAMathFunctionSINH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sinh"');
 end;
 result.Num:=sinh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCOSH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.cosh"');
 end;
 result.Num:=cosh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionTANH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.tanh"');
 end;
 result.Num:=tanh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionASINH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sinh"');
 end;
 result.Num:=arcsinh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionACOSH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acosh"');
 end;
 result.Num:=arccosh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionATANH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.atanh"');
 end;
 result.Num:=arctanh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCOTH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.coth"');
 end;
 result.Num:=1.0/Math.tanh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionSECH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.sech"');
 end;
 result.Num:=1.0/Math.cosh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionCSCH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.csch"');
 end;
 result.Num:=1.0/Math.sinh(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionACOT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acot"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 if SameValue(Value,0) then begin
  result.Num:=pi*0.5;
 end else begin
  result.Num:=ArcTan(1.0/Value);
 end;
end;

function POCAMathFunctionASEC(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.asec"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 if SameValue(Value,0) then begin
  result.Num:=Infinity;
 end else begin
  result.Num:=ArcCos(1.0/Value);
 end;
end;

function POCAMathFunctionACSC(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acsc"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 if SameValue(Value,0) then begin
  result.Num:=Infinity;
 end else begin
  result.Num:=ArcSin(1.0/Value);
 end;
end;

function POCAMathFunctionACOTH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acoth"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 if SameValue(Value,1) then begin
  result.Num:=Infinity;
 end else if SameValue(Value,-1) then begin
  result.Num:=NegInfinity;
 end else begin
  result.Num:=0.5*ln((Value+1.0)/(Value-1.0));
 end;
end;

function POCAMathFunctionASECH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.asech"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 if SameValue(Value,0) then begin
  result.Num:=Infinity;
 end else if SameValue(Value,1) then begin
  result.Num:=0;
 end else begin
  result.Num:=ln((sqrt(1.0-sqr(Value))+1.0)/Value);
 end;
end;

function POCAMathFunctionACSCH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Value:double;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.acsch"');
 end;
 Value:=POCAGetNumberValue(Context,Arguments^[0]);
 result.Num:=Ln(sqrt(1.0+(1.0/sqr(Value))+(1.0/Value)));
end;

function POCAMathFunctionROUND(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.round"');
 end;
 result.Num:=System.round(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionTRUNC(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.trunc"');
 end;
 result.Num:=System.trunc(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionINT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.int"');
 end;
 double(pointer(@result)^):=System.int(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAMathFunctionRANDOM(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=random;
end;

function POCAMathFunctionISNAN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.isNaN"');
 end;
 result.Num:=ord(POCAIsNaN(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAMathFunctionISINFINITE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.isInfinite"');
 end;
 result.Num:=ord(POCAIsInfinite(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAMathFunctionISFINITE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.isFinite"');
 end;
 result.Num:=ord(POCAIsFinite(POCAGetNumberValue(Context,Arguments^[0])));
end;

function POCAMathFunctionFRAC(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "Math.frac"');
 end;
 result.Num:=frac(POCAGetNumberValue(Context,Arguments^[0]));
end;

function POCAInitMathNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAHashSetString(Context,result,'PI',POCANumber(3.14159265358979323846));
 POCAHashSetString(Context,result,'E',POCANumber(2.7182818284590452354));
 POCAHashSetString(Context,result,'LN2',POCANumber(ln(2)));
 POCAHashSetString(Context,result,'LN10',POCANumber(ln(10)));
 POCAHashSetString(Context,result,'LOG10E',POCANumber(log10(2.7182818284590452354)));
 POCAHashSetString(Context,result,'LOG2E',POCANumber(log2(2.7182818284590452354)));
 POCAHashSetString(Context,result,'SQRT1_2',POCANumber(sqrt(0.5)));
 POCAHashSetString(Context,result,'SQRT2',POCANumber(sqrt(2)));
 POCAHashSetString(Context,result,'NaN',POCANumber(NaN));
 POCAHashSetString(Context,result,'Infinity',POCANumber(Infinity));
 POCAAddNativeFunction(Context,result,'min',POCAMathFunctionMIN);
 POCAAddNativeFunction(Context,result,'max',POCAMathFunctionMAX);
 POCAAddNativeFunction(Context,result,'clamp',POCAMathFunctionCLAMP);
 POCAAddNativeFunction(Context,result,'abs',POCAMathFunctionABS);
 POCAAddNativeFunction(Context,result,'sin',POCAMathFunctionSIN);
 POCAAddNativeFunction(Context,result,'cos',POCAMathFunctionCOS);
 POCAAddNativeFunction(Context,result,'tan',POCAMathFunctionTAN);
 POCAAddNativeFunction(Context,result,'exp',POCAMathFunctionEXP);
 POCAAddNativeFunction(Context,result,'ln',POCAMathFunctionLN);
 POCAAddNativeFunction(Context,result,'log',POCAMathFunctionLOG);
 POCAAddNativeFunction(Context,result,'sqr',POCAMathFunctionSQR);
 POCAAddNativeFunction(Context,result,'sqrt',POCAMathFunctionSQRT);
 POCAAddNativeFunction(Context,result,'atan2',POCAMathFunctionATAN2);
 POCAAddNativeFunction(Context,result,'acos',POCAMathFunctionACOS);
 POCAAddNativeFunction(Context,result,'asin',POCAMathFunctionASIN);
 POCAAddNativeFunction(Context,result,'atan',POCAMathFunctionATAN);
 POCAAddNativeFunction(Context,result,'cotan',POCAMathFunctionCOTAN);
 POCAAddNativeFunction(Context,result,'secant',POCAMathFunctionSECANT);
 POCAAddNativeFunction(Context,result,'cosecant',POCAMathFunctionCOSECANT);
 POCAAddNativeFunction(Context,result,'hypot',POCAMathFunctionHYPOT);
 POCAAddNativeFunction(Context,result,'ceil',POCAMathFunctionCEIL);
 POCAAddNativeFunction(Context,result,'floor',POCAMathFunctionFLOOR);
 POCAAddNativeFunction(Context,result,'log10',POCAMathFunctionLOG10);
 POCAAddNativeFunction(Context,result,'log2',POCAMathFunctionLOG2);
 POCAAddNativeFunction(Context,result,'logn',POCAMathFunctionLOGN);
 POCAAddNativeFunction(Context,result,'pow',POCAMathFunctionPOW);
 POCAAddNativeFunction(Context,result,'sinh',POCAMathFunctionSINH);
 POCAAddNativeFunction(Context,result,'cosh',POCAMathFunctionCOSH);
 POCAAddNativeFunction(Context,result,'tanh',POCAMathFunctionTANH);
 POCAAddNativeFunction(Context,result,'asinh',POCAMathFunctionASINH);
 POCAAddNativeFunction(Context,result,'acosh',POCAMathFunctionACOSH);
 POCAAddNativeFunction(Context,result,'atanh',POCAMathFunctionATANH);
 POCAAddNativeFunction(Context,result,'coth',POCAMathFunctionCOTH);
 POCAAddNativeFunction(Context,result,'sech',POCAMathFunctionSECH);
 POCAAddNativeFunction(Context,result,'csch',POCAMathFunctionCSCH);
 POCAAddNativeFunction(Context,result,'acot',POCAMathFunctionACOT);
 POCAAddNativeFunction(Context,result,'asec',POCAMathFunctionASEC);
 POCAAddNativeFunction(Context,result,'acsc',POCAMathFunctionACSC);
 POCAAddNativeFunction(Context,result,'acoth',POCAMathFunctionACOTH);
 POCAAddNativeFunction(Context,result,'asech',POCAMathFunctionASECH);
 POCAAddNativeFunction(Context,result,'acsch',POCAMathFunctionACSCH);
 POCAAddNativeFunction(Context,result,'round',POCAMathFunctionROUND);
 POCAAddNativeFunction(Context,result,'trunc',POCAMathFunctionTRUNC);
 POCAAddNativeFunction(Context,result,'int',POCAMathFunctionINT);
 POCAAddNativeFunction(Context,result,'random',POCAMathFunctionRANDOM);
 POCAAddNativeFunction(Context,result,'isNaN',POCAMathFunctionISNAN);
 POCAAddNativeFunction(Context,result,'isInfinite',POCAMathFunctionISINFINITE);
 POCAAddNativeFunction(Context,result,'isFinite',POCAMathFunctionISFINITE);
 POCAAddNativeFunction(Context,result,'frac',POCAMathFunctionFRAC);
end;

type PPOCAIOGhostData=^TPOCAIOGhostData;
     TPOCAIOGhostData=record
      Handle:^text;
      Opened:boolean;
      SystemHandle:boolean;
     end;

procedure POCAIOGhostDestroy(Data:pointer);
var DataCasted:PPOCAIOGhostData absolute Data;
begin
 if assigned(Data) then begin
  if DataCasted^.Opened then begin
   if not DataCasted.SystemHandle then begin
    System.Close(DataCasted^.Handle^);
   end;
   DataCasted^.Opened:=false;
  end;
  if assigned(DataCasted^.Handle) and not DataCasted.SystemHandle then begin
   FreeMem(DataCasted^.Handle);
   DataCasted^.Handle:=nil;
  end;
 end;
end;

const POCAIOGhost:TPOCAGhostType=(Destroy:POCAIOGhostDestroy;CanDestroy:nil;Mark:nil;Name:'io');

function POCAIOGhostNew(var t:text;SystemHandle:boolean):PPOCAIOGhostData;
begin
 New(result);
 FillChar(result^,sizeof(TPOCAIOGhostData),#0);
 result^.Handle:=@t;
 result^.Opened:=true;
 result^.SystemHandle:=SystemHandle;
end;

function POCAIOFunctionOPEN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var OldFileMode:byte;
    fn,fm:TPOCAUTF8String;
    t:^text;
    DoCreate:boolean;
begin
 if CountArguments>0 then begin
  result:=POCAValueNull;
  New(t);
  OldFileMode:=FileMode;
  try
   try
    fn:=POCAGetStringValue(Context,Arguments^[0]);
    if CountArguments>1 then begin
     fm:=POCAGetStringValue(Context,Arguments^[1]);
    end else begin
     fm:='';
    end;
    DoCreate:=false;
    if fm='c' then begin
     FileMode:=fmOpenReadWrite;
     DoCreate:=true;
    end else if fm='r' then begin
     FileMode:=fmOpenRead;
    end else if fm='rw' then begin
     FileMode:=fmOpenReadWrite;
    end else if fm='w' then begin
     if FileExists(String(fn)) then begin
      FileMode:=fmOpenWrite;
     end else begin
      FileMode:=fmOpenReadWrite;
      DoCreate:=true;
     end;
    end else begin
     FileMode:=fmOpenRead;
    end;
    AssignFile(t^,String(fn));
    if DoCreate then begin
     {$i-}Rewrite(t^);{$i+}
    end else begin
     {$i-}Reset(t^);{$i+}
    end;
    if IOResult<>0 then begin
     result.Num:=0;
     Dispose(t);
    end else begin
     result:=POCANewGhost(Context,@POCAIOGhost,POCAIOGhostNew(t^,false));
    end;
   except
    try
     Dispose(t);
    except
    end;
    raise;
   end;
  finally
   FileMode:=OldFileMode;
  end;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCAIOFunctionCLOSE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var IOData:PPOCAIOGhostData;
begin
 if (CountArguments>0) and (POCAGhostGetType(Arguments^[0])=@POCAIOGhost) then begin
  IOData:=PPOCAIOGhostData(POCAGhostGetPointer(Arguments^[0]));
  result.Num:=ord(IOData^.Opened);
  if IOData^.Opened then begin
   if (IOData^.Handle<>@System.Input) and (IOData^.Handle<>@System.Output) and (IOData^.Handle<>@System.ErrOutput) then begin
    System.Close(IOData^.Handle^);
   end;
   IOData^.Opened:=false;
  end;
  if assigned(IOData^.Handle) and ((IOData^.Handle<>@System.Input) and (IOData^.Handle<>@System.Output) and (IOData^.Handle<>@System.ErrOutput)) then begin
   FreeMem(IOData^.Handle);
  end;
  IOData^.Handle:=nil;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCAInitIONamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
{POCAHashSetString(Context,result,'stdIn',POCANewGhost(Context,@POCAIOGhost,POCAIOGhostNew(System.Input,true)));
 POCAHashSetString(Context,result,'stdOut',POCANewGhost(Context,@POCAIOGhost,POCAIOGhostNew(System.Output,true)));
 POCAHashSetString(Context,result,'stdErr',POCANewGhost(Context,@POCAIOGhost,POCAIOGhostNew(System.ErrOutput,true)));}
 POCAAddNativeFunction(Context,result,'open',POCAIOFunctionOPEN);
 POCAAddNativeFunction(Context,result,'close',POCAIOFunctionCLOSE);
end;

procedure POCARegExpGhostDestroy(Data:pointer);
begin
 if assigned(Data) then begin
  TFLRE(Data).Free;
 end;
end;

const POCARegExpGhost:TPOCAGhostType=(Destroy:POCARegExpGhostDestroy;CanDestroy:nil;Mark:nil;Name:'RegExp');

function POCARegExpFunctionESCAPE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var a,b:TPOCARawByteString;
    i:longint;
    c:ansichar;
begin
 if CountArguments>0 then begin
  a:=POCAGetStringValue(Context,Arguments^[0]);
  b:='';
  for i:=1 to length(a) do begin
   c:=a[i];
   if c in ['(','|','.','*','?','^','$','-','[','{','}',']',')','\'] then begin
    b:=b+'\';
   end;
   b:=b+c;
  end;
  result:=POCANewString(Context,TPOCARawByteString(b));
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCARegExpFunctionCOMPILE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var s:TPOCARawByteString;
    IsUTF8:longint;
begin
 if CountArguments>0 then begin
  if POCAGhostGetType(Arguments^[0])=@POCARegExpGhost then begin
   s:=TFLRE(POCAGhostGetPointer(Arguments^[0])).RegularExpressionSource;
  end else begin
   s:=POCAGetStringValue(Context,Arguments^[0]);
  end;
  if POCAIsValueString(Arguments^[0]) then begin
   IsUTF8:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]))^.UTF8;
  end else begin
   IsUTF8:=PUCUUTF8Get(s);
  end;
  result:=POCANewGhost(Context,@POCARegExpGhost,POCARegExpCompile(Context,s,IsUTF8));
  POCAGhostSetHashValue(result,Context^.Instance.Globals.RegExpHash);
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCARegExpFunctionEXEC(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var RegExp:TFLRE;
    MultipleCaptures:TFLREMultiCaptures;
    Captures:TFLRECaptures;
    StartCodeUnit,Limit,mi,mc,i:longint;
    s:TPOCARawByteString;
    CapturesArray,v:TPOCAValue;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>0 then begin
  s:=''; 
  if CountArguments>1 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[1])));
  end else begin
   StartCodeUnit:=1;
  end;
  if CountArguments>2 then begin
   Limit:=trunc(POCAGetNumberValue(Context,Arguments^[2]));
  end else begin
   Limit:=1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  try
   result:=POCAValueNull;
   s:=POCAGetStringValue(Context,Arguments^[0]);
   MultipleCaptures:=nil;
   if RegExp.MatchAll(s,MultipleCaptures,StartCodeUnit,Limit) then begin
    mc:=length(MultipleCaptures);
   end else begin
    mc:=0;
   end;
   for mi:=0 to mc-1 do begin
    Captures:=MultipleCaptures[mi];
    if length(Captures)>0 then begin
     if POCAIsValueNull(result) then begin
      result:=POCANewArray(Context);
     end;
     if rfNAMED in RegExp.RegularExpressionFlags then begin
      CapturesArray:=POCANewHash(Context);
      for i:=0 to length(Captures)-1 do begin
       v:=POCANewArray(Context);
       POCAArraySetSize(v,3);
       POCAArraySet(v,0,POCANumber(POCAStringUTF8GetCodePoint(Context,Arguments^[0],Captures[i].Start)));
       POCAArraySet(v,1,POCANumber(PUCUUTF8Length(copy(s,Captures[i].Start,Captures[i].Length))));
       POCAArraySet(v,2,POCANewString(Context,copy(s,Captures[i].Start,Captures[i].Length)));
       POCAHashSetString(Context,CapturesArray,TPOCAUTF8String(RegExp.NamedGroups[i]),v);
      end;
     end else begin
      CapturesArray:=POCANewArray(Context);
      POCAArraySetSize(CapturesArray,length(Captures));
      for i:=0 to length(Captures)-1 do begin
       v:=POCANewArray(Context);
       POCAArraySetSize(v,4);
       POCAArraySet(v,0,POCANumber(POCAStringUTF8GetCodePoint(Context,Arguments^[0],Captures[i].Start)));
       POCAArraySet(v,1,POCANumber(PUCUUTF8Length(copy(s,Captures[i].Start,Captures[i].Length))));
       POCAArraySet(v,2,POCANewString(Context,copy(s,Captures[i].Start,Captures[i].Length)));
       POCAArraySet(v,3,POCANewString(Context,TPOCAUTF8String(RegExp.NamedGroups[i])));
       POCAArraySet(CapturesArray,i,v);
      end;
     end;
     POCAArrayPush(result,CapturesArray);
    end;
    SetLength(Captures,0);
   end;
  finally
   SetLength(MultipleCaptures,0);
   s:='';
  end;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCARegExpFunctionTEST(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var RegExp:TFLRE;
    StartCodeUnit:longint;
    s:TPOCARawByteString;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>0 then begin
  s:='';
  if CountArguments>1 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[1])));
  end else begin
   StartCodeUnit:=1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  try
   s:=POCAGetStringValue(Context,Arguments^[0]);
   result.Num:=ord(RegExp.Test(s,StartCodeUnit));
  finally
   s:='';
  end;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCARegExpFunctionFIND(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var RegExp:TFLRE;
    StartCodeUnit:longint;
    s:TPOCARawByteString;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>0 then begin
  s:='';
  if CountArguments>1 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[1])));
  end else begin
   StartCodeUnit:=1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  try
   s:=POCAGetStringValue(Context,Arguments^[0]);
   result.Num:=POCAStringUTF8GetCodePoint(Context,Arguments^[0],RegExp.Find(s,StartCodeUnit));
  finally
   s:='';
  end;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCARegExpFunctionMATCH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var RegExp:TFLRE;
    MultipleCaptures:TFLREMultiCaptures;
    Captures:TFLRECaptures;
    StartCodeUnit,Limit,mi,mc,i:longint;
    s:TPOCARawByteString;
    CapturesArray:TPOCAValue;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>0 then begin
  s:='';
  if CountArguments>1 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[1])));
  end else begin
   StartCodeUnit:=1;
  end;
  if CountArguments>2 then begin
   Limit:=trunc(POCAGetNumberValue(Context,Arguments^[2]));
  end else begin
   Limit:=1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  Captures:=nil;
  try
   s:=POCAGetStringValue(Context,Arguments^[0]);
   result:=POCAValueNull;
   MultipleCaptures:=nil;
   if RegExp.MatchAll(s,MultipleCaptures,StartCodeUnit,Limit) then begin
    mc:=length(MultipleCaptures);
   end else begin
    mc:=0;
   end;
   for mi:=0 to mc-1 do begin
    Captures:=MultipleCaptures[mi];
    if length(Captures)>0 then begin
     if POCAIsValueNull(result) then begin
      result:=POCANewArray(Context);
     end;
     if rfNAMED in RegExp.RegularExpressionFlags then begin
      CapturesArray:=POCANewHash(Context);
      for i:=0 to length(Captures)-1 do begin
       POCAHashSetString(Context,CapturesArray,TPOCAUTF8String(RegExp.NamedGroups[i]),POCANewString(Context,copy(s,Captures[i].Start,Captures[i].Length)));
      end;
     end else begin
      CapturesArray:=POCANewArray(Context);
      POCAArraySetSize(CapturesArray,length(Captures));
      for i:=0 to length(Captures)-1 do begin
       POCAArraySet(CapturesArray,i,POCANewString(Context,copy(s,Captures[i].Start,Captures[i].Length)));
      end;
     end;
     POCAArrayPush(result,CapturesArray);
    end;
    SetLength(Captures,0);
   end;
  finally
   SetLength(MultipleCaptures,0);
   s:='';
  end;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCARegExpFunctionSPLIT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var RegExp:TFLRE;
    Strings:TFLREStrings;
    StartCodeUnit,Limit,i:longint;
    s:TPOCARawByteString;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>0 then begin
  s:='';
  if CountArguments>1 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[1])));
  end else begin
   StartCodeUnit:=1;
  end;
  if CountArguments>2 then begin
   Limit:=trunc(POCAGetNumberValue(Context,Arguments^[2]));
  end else begin
   Limit:=-1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  Strings:=nil;
  try
   result:=POCAValueNull;
   s:=POCAGetStringValue(Context,Arguments^[0]);
   if RegExp.Split(s,Strings,StartCodeUnit,Limit) then begin
    for i:=0 to length(Strings)-1 do begin
     if POCAIsValueNull(result) then begin
      result:=POCANewArray(Context);
     end;
     POCAArrayPush(result,POCANewString(Context,Strings[i]));
    end;
   end;
  finally
   SetLength(Strings,0);
   s:='';
  end;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCARegExpFunctionREPLACE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var RegExp:TFLRE;
    ReplacementStringIsUTF8,ReplacementStringLen,StartCodeUnit,Limit:longint;
    s,ReplacementString,OutputString:TPOCARawByteString;
begin
 if POCAGhostGetType(This)<>@POCARegExpGhost then begin
  POCARuntimeError(Context,'Bad THIS value');
 end;
 if CountArguments>1 then begin
  s:='';
  if CountArguments>2 then begin
   StartCodeUnit:=POCAStringUTF8GetCodeUnit(Context,Arguments^[0],trunc(POCAGetNumberValue(Context,Arguments^[2])));
  end else begin
   StartCodeUnit:=1;
  end;
  if CountArguments>3 then begin
   Limit:=trunc(POCAGetNumberValue(Context,Arguments^[3]));
  end else begin
   Limit:=-1;
  end;
  RegExp:=POCAGhostGetPointer(This);
  try
   s:=POCAGetStringValue(Context,Arguments^[0]);
   ReplacementString:=POCAGetStringValue(Context,Arguments^[1]);
   if POCAIsValueString(Arguments^[1]) then begin
    ReplacementStringIsUTF8:=PPOCAString(POCAGetValueReferencePointer(Arguments^[1]))^.UTF8;
    ReplacementStringLen:=PPOCAString(POCAGetValueReferencePointer(Arguments^[1]))^.UTF8Length;
   end else begin
    ReplacementStringIsUTF8:=PUCUUTF8Get(ReplacementString);
    if ReplacementStringIsUTF8 in [suNOUTF8,suPOSSIBLEUTF8] then begin
     ReplacementStringLen:=length(ReplacementString);
    end else begin
     ReplacementStringLen:=POCAGetStringUTF8Length(Context,Arguments^[1]);
    end;
   end;
   if ReplacementStringLen>0 then begin
   end;
{$ifdef pocastrictutf8}
   if ReplacementStringIsUTF8=suNOUTF8 then begin
    ReplacementString:=PUCUUTF8Correct(ReplacementString);
    ReplacementStringIsUTF8:=PUCUUTF8Get(ReplacementString);
   end;
{$else}
   if (rfUTF8 in RegExp.RegularExpressionFlags) and (ReplacementStringIsUTF8=suNOUTF8) then begin
    ReplacementString:=PUCUUTF8Correct(ReplacementString);
    ReplacementStringIsUTF8:=PUCUUTF8Get(ReplacementString);
   end;
{$endif}
   OutputString:=RegExp.Replace(s,ReplacementString,StartCodeUnit,Limit);
   result:=POCANewString(Context,OutputString);
  finally
   s:='';
  end;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCAInitRegExpNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'escape',POCARegExpFunctionESCAPE);
 POCAAddNativeFunction(Context,result,'compile',POCARegExpFunctionCOMPILE);
 POCAAddNativeFunction(Context,result,'create',POCARegExpFunctionCOMPILE);
end;

function POCAInitRegExpHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'exec',POCARegExpFunctionEXEC);
 POCAAddNativeFunction(Context,result,'test',POCARegExpFunctionTEST);
 POCAAddNativeFunction(Context,result,'find',POCARegExpFunctionFIND);
 POCAAddNativeFunction(Context,result,'match',POCARegExpFunctionMATCH);
 POCAAddNativeFunction(Context,result,'split',POCARegExpFunctionSPLIT);
 POCAAddNativeFunction(Context,result,'replace',POCARegExpFunctionREPLACE);
end;

procedure POCACoroutineGhostDestroy(Data:pointer);
var DataCasted:PPOCACoroutineData absolute Data;
begin
 if assigned(Data) then begin
  if assigned(DataCasted^.Coroutine) then begin
   POCACoroutineDestroy(DataCasted^.Coroutine);
  end;
  if assigned(DataCasted^.Context) then begin
   DataCasted^.Context^.CoroutineData:=nil;
   POCAContextDestroy(DataCasted^.Context);
   DataCasted^.Context:=nil;
  end;
  SetLength(DataCasted^.Arguments,0);
  try
   if assigned(DataCasted^.ExceptionHolder) then begin
    try
     raise DataCasted^.ExceptionHolder;
    finally
     DataCasted^.ExceptionHolder:=nil;
    end;
   end;
  finally
   Finalize(DataCasted^);
   Dispose(DataCasted);
  end;
 end;
end;

function POCACoroutineGhostMark(Data:pointer):longbool;
var DataCasted:PPOCACoroutineData absolute Data;
    i:longint;
begin
 result:=false;
 if assigned(Data) then begin
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Data) then begin
   result:=true;
  end;
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Func) then begin
   result:=true;
  end;
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.FromValue) then begin
   result:=true;
  end;
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.ToValue) then begin
   result:=true;
  end;
  for i:=0 to length(DataCasted^.Arguments)-1 do begin
   if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Arguments[i]) then begin
    result:=true;
   end;
  end;
 end;
end;

procedure POCACoroutineGhostEntrypoint(Coroutine:PPOCACoroutine);
var CoroutineData:PPOCACoroutineData;
begin
 if assigned(Coroutine) then begin
  CoroutineData:=Coroutine^.Parameter;
  if assigned(CoroutineData) then begin
   try
    if length(CoroutineData^.Arguments)>0 then begin
     POCACall(CoroutineData^.Context,CoroutineData^.Func,@CoroutineData^.Arguments[0],length(CoroutineData^.Arguments),POCAValueNull,POCAValueNull);
    end else begin
     POCACall(CoroutineData^.Context,CoroutineData^.Func,nil,0,POCAValueNull,POCAValueNull);
    end;
   except
    CoroutineData^.ExceptionHolder:=Exception(AcquireExceptionObject);
   end;
  end;
 end;
end;

const POCACoroutineGhost:TPOCAGhostType=(Destroy:POCACoroutineGhostDestroy;CanDestroy:nil;Mark:POCACoroutineGhostMark;Name:'Coroutine');

function POCACoroutineFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
    i:longint;
begin
 result:=POCAValueNull;
 if (CountArguments<1) or not POCAIsValueFunction(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "Coroutine.create"');
 end;
 begin
  i:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Arguments^[0]))^.Code))^.CountArguments;
  if (CountArguments-1)<longint(i) then begin
   POCARuntimeError(Context,'Too few coroutine function arguments (we have '+TPOCARawByteString(IntToStr(CountArguments-1))+' but we do need '+TPOCARawByteString(IntToStr(i))+')');
  end;
 end;
 New(CoroutineData);
 try
  FillChar(CoroutineData^,sizeof(TPOCACoroutineData),#0);
  CoroutineData^.Context:=POCAContextCreate(Context^.Instance);
  CoroutineData^.Context^.CoroutineData:=CoroutineData;
  CoroutineData^.Func:=Arguments^[0];
  POCATemporarySave(Context,CoroutineData^.Func);
  CoroutineData^.Coroutine:=POCACoroutineCreate(@POCACoroutineGhostEntrypoint,65536,CoroutineData);
  CoroutineData^.Arguments:=nil;
  if CountArguments>1 then begin
   SetLength(CoroutineData^.Arguments,CountArguments-1);
   for i:=1 to CountArguments-1 do begin
    CoroutineData^.Arguments[i-1]:=Arguments^[i];
    POCATemporarySave(Context,CoroutineData^.Arguments[i-1]);
   end;
  end;
  CoroutineData^.FromValue:=POCAValueNull;
  CoroutineData^.ToValue:=POCAValueNull;
  CoroutineData^.ExceptionHolder:=nil;
  if not assigned(CoroutineData) then begin
   POCARuntimeError(Context,'Coroutine creation failed');
  end;
  result:=POCANewGhost(Context,@POCACoroutineGhost,CoroutineData);
  CoroutineData^.Data:=result;
  POCAGhostSetHashValue(result,Context^.Instance.Globals.CoroutineHash);
 except
  Dispose(CoroutineData);
  raise;
 end;
end;

function POCACoroutineFunctionRESUME(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 if POCAGhostGetType(This)=@POCACoroutineGhost then begin
  CoroutineData:=PPOCACoroutineData(POCAGhostGetPointer(This));
  if CountArguments>0 then begin
   CoroutineData^.ToValue:=Arguments^[0];
  end else begin
   CoroutineData^.ToValue:=POCAValueNull;
  end;
  POCAGarbageCollectorUnlock(Context);
  try
   POCACoroutineResume(CoroutineData^.Coroutine);
  finally
   POCAGarbageCollectorLock(Context);
  end;
  if assigned(CoroutineData^.ExceptionHolder) then begin
   try
    raise CoroutineData^.ExceptionHolder;
   finally
    CoroutineData^.ExceptionHolder:=nil;
   end;
  end;
  result:=CoroutineData^.FromValue;
  CoroutineData^.FromValue:=POCAValueNull;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCACoroutineFunctionYIELD(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 result:=POCAValueNull;
 if assigned(Context) then begin
  CoroutineData:=Context^.CoroutineData;
  while (not assigned(CoroutineData)) and assigned(Context^.CallParent) do begin
   Context:=Context^.CallParent;
   CoroutineData:=Context^.CoroutineData;
  end;
 end else begin
  CoroutineData:=nil;
 end;
 if assigned(CoroutineData) then begin
  if CountArguments>0 then begin
   CoroutineData^.FromValue:=Arguments^[0];
  end else begin
   CoroutineData^.FromValue:=POCAValueNull;
  end;
  POCAGarbageCollectorUnlock(Context);
  try
   POCACoroutineYield(CoroutineData^.Coroutine);
  finally
   POCAGarbageCollectorLock(Context);
  end;
 end;
end;

function POCACoroutineFunctionGET(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var CoroutineData:PPOCACoroutineData;
begin
 if assigned(Context) then begin
  CoroutineData:=Context^.CoroutineData;
  while (not assigned(CoroutineData)) and assigned(Context^.CallParent) do begin
   Context:=Context^.CallParent;
   CoroutineData:=Context^.CoroutineData;
  end;
 end else begin
  CoroutineData:=nil;
 end;
 if assigned(CoroutineData) then begin
  result:=CoroutineData^.ToValue;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCAInitCoroutineNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCACoroutineFunctionCREATE);
 POCAAddNativeFunction(Context,result,'yield',POCACoroutineFunctionYIELD);
 POCAAddNativeFunction(Context,result,'get',POCACoroutineFunctionGET);
end;

function POCAInitCoroutineHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'resume',POCACoroutineFunctionRESUME);
end;

procedure POCAThreadDestroy(Data:pointer);
var DataCasted:PPOCAThreadData absolute Data;
begin
 if assigned(Data) then begin
  if DataCasted^.Handle<>0 then begin
   if not DataCasted^.Terminated then begin
    try
{$ifdef fpc}
     System.KillThread(DataCasted^.Handle);
{$else}
     TerminateThread(DataCasted^.Handle,0);
{$endif}
    except
    end;
    TPasMPInterlocked.Write(DataCasted^.Terminated,true);
   end;
{$ifdef fpc}
   CloseThread(DataCasted^.Handle);
{$else}
{$ifdef win32}
   CloseHandle(DataCasted^.Handle);
{$endif}
{$endif}
   DataCasted^.Handle:=0;
  end; 
  if assigned(DataCasted^.Context) then begin
   DataCasted^.Context^.ThreadData:=nil;
   POCAContextDestroy(DataCasted^.Context);
   DataCasted^.Context:=nil;
  end;
  if assigned(DataCasted^.StartSemaphore) then begin
   POCASemaphoreDestroy(DataCasted^.StartSemaphore);
   DataCasted^.StartSemaphore:=nil;
  end;
  TPasMPInterlocked.Write(DataCasted^.Started,true);
  DataCasted^.Data.Num:=0;
  DataCasted^.Func.Num:=0;
  SetLength(DataCasted^.Arguments,0);
  DataCasted^.Arguments:=nil;
  DataCasted^.Handle:=0;
  DataCasted^.ThreadID:=0;
  DataCasted^.Context:=nil;
 end;
end;

procedure POCAThreadGhostDestroy(Data:pointer);
var DataCasted:PPOCAThreadData absolute Data;
begin
 if assigned(Data) then begin
  try
   POCAThreadDestroy(Data);
  finally
   Dispose(DataCasted);
  end;
 end;
end;

function POCAThreadGhostMark(Data:pointer):longbool;
var DataCasted:PPOCAThreadData absolute Data;
    i:longint;
begin
 result:=false;
 if assigned(Data) then begin
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Data) then begin
   result:=true;
  end;
  if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Func) then begin
   result:=true;
  end;
  for i:=0 to length(DataCasted^.Arguments)-1 do begin
   if POCAMarkValue(DataCasted^.Context^.Instance,DataCasted^.Arguments[i]) then begin
    result:=true;
   end;
  end;
 end;
end;

const POCAThreadGhost:TPOCAGhostType=(Destroy:POCAThreadGhostDestroy;CanDestroy:nil;Mark:POCAThreadGhostMark;Name:'Thread');

function POCAThreadFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
    i:longint;
begin
 result:=POCAValueNull;
 if (CountArguments<1) or not POCAIsValueFunction(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "Thread.create"');
 end;
 begin
  i:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Arguments^[0]))^.Code))^.CountArguments;
  if (CountArguments-1)<longint(i) then begin
   POCARuntimeError(Context,'Too few thread function arguments (we have '+TPOCARawByteString(IntToStr(CountArguments-1))+' but we do need '+TPOCARawByteString(IntToStr(i))+')');
  end;
 end;
 New(ThreadData);
 try
  FillChar(ThreadData^,sizeof(TPOCAThreadData),#0);
  ThreadData^.Context:=POCAContextCreate(Context^.Instance);
  ThreadData^.Context^.ThreadData:=ThreadData;
  ThreadData^.Func:=Arguments^[0];
  ThreadData^.Arguments:=nil;
  if CountArguments>1 then begin
   SetLength(ThreadData^.Arguments,CountArguments-1);
   for i:=1 to CountArguments-1 do begin
    ThreadData^.Arguments[i-1]:=Arguments^[i];
    POCATemporarySave(Context,ThreadData^.Arguments[i-1]);
   end;
  end;
  POCATemporarySave(Context,ThreadData^.Func);
  TPasMPInterlocked.Write(ThreadData^.Terminated,false);
  ThreadData^.StartSemaphore:=POCASemaphoreCreate;
  TPasMPInterlocked.Write(ThreadData^.Started,false);
{$ifdef fpc}
  ThreadData^.Handle:=BeginThread(POCAThreadProc,ThreadData,ThreadData^.ThreadID);
{$else}
  ThreadData^.Handle:=BeginThread(nil,0,pointer(@POCAThreadProc),ThreadData,{$ifdef Windows}CREATE_SUSPENDED{$else}0{$endif},ThreadData^.ThreadID);
{$endif}
  if ThreadData^.Handle=0 then begin
   POCARuntimeError(Context,'Thread creation failed');
  end;
  result:=POCANewGhost(Context,@POCAThreadGhost,ThreadData);
  ThreadData^.Data:=result;
  POCAGhostSetHashValue(result,Context^.Instance.Globals.ThreadHash);
 except
  Dispose(ThreadData);
  raise;
 end;
end;

function POCAThreadFunctionRESUME(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
begin
 if POCAGhostGetType(This)=@POCAThreadGhost then begin
  ThreadData:=PPOCAThreadData(POCAGhostGetPointer(This));
  POCAGarbageCollectorUnlock(Context);
  try
   if not TPasMPInterlocked.CompareExchange(ThreadData^.Started,true,false) then begin
    POCASemaphoreUp(ThreadData^.StartSemaphore,1);
   end;
{$ifdef Windows}
   ResumeThread(ThreadData^.Handle);
{$endif}
  finally
   POCAGarbageCollectorLock(Context);
  end;
  result:=This;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCAThreadFunctionSUSPEND(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
begin
 if POCAGhostGetType(This)=@POCAThreadGhost then begin
  ThreadData:=PPOCAThreadData(POCAGhostGetPointer(This));
  POCAGarbageCollectorUnlock(Context);
  try
{$ifdef Windows}
   SuspendThread(ThreadData^.Handle);
{$endif}
  finally
   POCAGarbageCollectorLock(Context);
  end;
  result:=This;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCAThreadFunctionKILL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
begin
 result:=POCAValueNull;
 exit;
 if POCAGhostGetType(This)=@POCAThreadGhost then begin
  ThreadData:=PPOCAThreadData(POCAGhostGetPointer(This));
  POCAGarbageCollectorUnlock(Context);
  try
   try
{$ifdef fpc}
    System.KillThread(ThreadData^.Handle);
{$else}
    TerminateThread(ThreadData^.Handle,0);
{$endif}
   except
   end;
   if assigned(ThreadData^.Context) then begin
    ThreadData^.Context^.CoroutineData:=nil;
    POCAContextDestroy(ThreadData^.Context);
    ThreadData^.Context:=nil;
   end;
   ThreadData^.Data.Num:=0;
   ThreadData^.Terminated:=true;
  finally
   POCAGarbageCollectorLock(Context);
  end;
  result:=This;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCAThreadFunctionTERMINATED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
begin
 if POCAGhostGetType(This)=@POCAThreadGhost then begin
  ThreadData:=PPOCAThreadData(POCAGhostGetPointer(This));
  if ThreadData^.Terminated then begin
   result.Num:=1;
  end else begin
   result.Num:=0;
  end;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCAThreadFunctionWAIT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var ThreadData:PPOCAThreadData;
    ms:longint;
begin
 if POCAGhostGetType(This)=@POCAThreadGhost then begin
  ThreadData:=PPOCAThreadData(POCAGhostGetPointer(This));
  if not ThreadData^.Terminated then begin
   if CountArguments<1 then begin
{$ifdef fpc}
    WaitForThreadTerminate(ThreadData^.Handle,0);
{$else}
{$ifdef win32}
    WaitForSingleObject(ThreadData^.Handle,longword(-1));
{$endif}
{$endif}
    TPasMPInterlocked.Write(ThreadData^.Terminated,true);
   end else begin
    ms:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
{$ifdef fpc}
    WaitForThreadTerminate(ThreadData^.Handle,ms);
{$else}
{$ifdef win32}
    WaitForSingleObject(ThreadData^.Handle,longword(ms));
{$endif}
{$endif}
   end;
  end;
  if ThreadData^.Terminated then begin
   result.Num:=1;
  end else begin
   result.Num:=0;
  end;
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCAInitThreadNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCAThreadFunctionCREATE);
end;

function POCAInitThreadHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'resume',POCAThreadFunctionRESUME);
 POCAAddNativeFunction(Context,result,'suspend',POCAThreadFunctionSUSPEND);
 POCAAddNativeFunction(Context,result,'kill',POCAThreadFunctionKILL);
 POCAAddNativeFunction(Context,result,'terminated',POCAThreadFunctionTERMINATED);
 POCAAddNativeFunction(Context,result,'wait',POCAThreadFunctionWAIT);
 POCAAddNativeFunction(Context,result,'start',POCAThreadFunctionRESUME);
 POCAAddNativeFunction(Context,result,'stop',POCAThreadFunctionKILL);
end;

procedure POCALockGhostDestroy(Data:pointer);
begin
 POCALockDestroy(Data);
end;

const POCALockGhost:TPOCAGhostType=(Destroy:POCALockGhostDestroy;CanDestroy:nil;Mark:nil;Name:'Lock');

function POCALockFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result:=POCANewGhost(Context,@POCALockGhost,POCALockCreate);
 POCAGhostSetHashValue(result,Context^.Instance.Globals.LockHash);
end;

function POCALockFunctionENTER(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if POCAGhostGetType(This)=@POCALockGhost then begin
  POCAGarbageCollectorUnlock(Context);
  try
   POCALockEnter(POCAGhostGetPointer(This));
  finally
   POCAGarbageCollectorLock(Context);
  end;
  result.Num:=1;
 end else begin
  result.Num:=0;
 end;
end;

function POCALockFunctionLEAVE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result:=POCAValueNull;
 if POCAGhostGetType(This)=@POCALockGhost then begin
  POCALockLeave(POCAGhostGetPointer(This));
 end;
end;

function POCAInitLockNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCALockFunctionCREATE);
end;

function POCAInitLockHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'enter',POCALockFunctionENTER);
 POCAAddNativeFunction(Context,result,'leave',POCALockFunctionLEAVE);
end;

procedure POCASemaphoreGhostDestroy(Data:pointer);
begin
 POCASemaphoreDestroy(Data);
end;

const POCASemaphoreGhost:TPOCAGhostType=(Destroy:POCASemaphoreGhostDestroy;CanDestroy:nil;Mark:nil;Name:'Semaphore');

function POCASemaphoreFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result:=POCANewGhost(Context,@POCASemaphoreGhost,POCASemaphoreCreate);
 POCAGhostSetHashValue(result,Context^.Instance.Globals.SemaphoreHash);
end;

function POCASemaphoreFunctionDOWN(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result:=POCAValueNull;
 if POCAGhostGetType(This)=@POCASemaphoreGhost then begin
  POCAGarbageCollectorUnlock(Context);
  try
   POCASemaphoreDown(POCAGhostGetPointer(This));
  finally
   POCAGarbageCollectorLock(Context);
  end;
 end;
end;

function POCASemaphoreFunctionUP(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result:=POCAValueNull;
 if POCAGhostGetType(This)=@POCASemaphoreGhost then begin
  POCASemaphoreUp(POCAGhostGetPointer(This),1);
 end;
end;

function POCAInitSemaphoreNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCASemaphoreFunctionCREATE);
end;

function POCAInitSemaphoreHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'down',POCASemaphoreFunctionDOWN);
 POCAAddNativeFunction(Context,result,'up',POCASemaphoreFunctionUP);
end;

function POCADateTimeFunctionNOW(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=SysUtils.Now;
end;

function POCADateTimeFunctionMILLISECONDS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "DateTime.milliseconds"');
 end;
 result.Num:=POCAGetNumberValue(Context,Arguments^[0])*86400000;
end;

function POCAInitDateTimeNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'now',POCADateTimeFunctionNOW);
 POCAAddNativeFunction(Context,result,'milliseconds',POCADateTimeFunctionMILLISECONDS);
end;

function POCAArrayFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var i:longint;
begin
 result:=POCANewArray(Context);
 if CountArguments>0 then begin
  POCAArraySetSize(result,trunc(POCAGetNumberValue(Context,Arguments^[0])));
  for i:=1 to CountArguments-1 do begin
   POCAArraySet(result,i-1,Arguments^[i]);
  end;       
 end;
end;

function POCAInitArrayNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCAArrayFunctionCREATE);
end;

function POCAStringFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments>0 then begin
  result:=POCAStringValue(Context,Arguments^[0]);
 end else begin
  result:=POCANewString(Context,'');
 end;
end;

function POCAStringFunctionDUMP(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var OutputString:TPOCARawByteString;
 procedure DumpValue(const Value:TPOCAValue);
 var i:longint;
     Keys,Temp:TPOCAValue;
 begin
  case POCAGetValueType(Value) of
   pvtNULL:begin
    OutputString:=OutputString+'null';
   end;
   pvtREFERENCE:begin
    OutputString:=OutputString+'reference';
   end;
   pvtNUMBER:begin
    OutputString:=OutputString+POCADoubleToString(POCAGetNumberValue(Context,Value));
   end;
   pvtSTRING:begin
    OutputString:=OutputString+'"'+POCAGetStringValue(Context,Value)+'"';
   end;
   pvtARRAY:begin
    OutputString:=OutputString+'[';
    for i:=0 to POCAArraySize(Value)-1 do begin
     if i>0 then begin
      OutputString:=OutputString+',';
     end;
     DumpValue(POCAArrayGet(Value,i));
    end;
    OutputString:=OutputString+']';
   end;
   pvtHASH:begin
    OutputString:=OutputString+'{';
    Keys:=POCANewArray(Context);
    POCAHashKeys(Context,Keys,Value);
    POCAArraySort(Context,Keys);
    if POCAIsValueArray(Keys) then begin
     for i:=0 to POCAArraySize(Keys)-1 do begin
      if i>0 then begin
       OutputString:=OutputString+',';
      end;
      Temp:=POCAArrayGet(Keys,i);
      if Temp.CastedUInt64<>Value.CastedUInt64 then begin
       DumpValue(Temp);
      end else begin
       OutputString:=OutputString+'[self]';
      end;
      OutputString:=OutputString+':';
      Temp.Num:=0;
      POCAHashGet(Context,Value,POCAArrayGet(Keys,i),Temp);
      if Temp.CastedUInt64<>Value.CastedUInt64 then begin
       DumpValue(Temp);
      end else begin
       OutputString:=OutputString+'[self]';
      end;
     end;
     OutputString:=OutputString+'}';
    end;
   end;
   pvtFUNCTION:begin
    OutputString:=OutputString+'function';
   end;
   pvtGHOST:begin
    OutputString:=OutputString+'ghost';
    if assigned(POCAGhostGetHash(Value)) then begin
     DumpValue(POCAGhostGetHashValue(Value));
    end;
   end;
   pvtCODE:begin
    OutputString:=OutputString+'code';
   end;
   pvtNATIVECODE:begin
    OutputString:=OutputString+'nativecode';
   end;
   else begin
    OutputString:=OutputString+'undefined';
   end;
  end;
 end;
begin
 OutputString:='';
 if CountArguments>0 then begin
  DumpValue(Arguments^[0]);
 end;
 result:=POCANewString(Context,OutputString);
end;

function POCAStringFunctionFROMCODEPOINTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var s:TPOCARawByteString;
    i,j:longint;
begin
 if CountArguments>0 then begin
  s:='';
  if (CountArguments=1) and POCAIsValueArray(Arguments^[0]) then begin
   j:=POCAArraySize(Arguments^[0]);
   for i:=1 to j do begin
    s:=s+PUCUUTF32CharToUTF8(trunc(POCAGetNumberValue(Context,POCAArrayGet(Arguments^[0],i-1))));
   end;
  end else begin
   for i:=0 to CountArguments-1 do begin
    s:=s+PUCUUTF32CharToUTF8(trunc(POCAGetNumberValue(Context,Arguments^[i])));
   end;
  end;
  result:=POCANewString(Context,s);
 end else begin
  result:=POCANewString(Context,'');
 end;
end;

function POCAStringFunctionFROMCODEUNITS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var s:TPOCARawByteString;
    i,j:longint;
begin
 if CountArguments>0 then begin
  s:='';
  if (CountArguments=1) and POCAIsValueArray(Arguments^[0]) then begin
   j:=POCAArraySize(Arguments^[0]);
   SetLength(s,j);
   for i:=1 to j do begin
    s[i]:=AnsiChar(byte(trunc(POCAGetNumberValue(Context,POCAArrayGet(Arguments^[0],i-1)))));
   end;
  end else begin
   SetLength(s,CountArguments);
   for i:=1 to CountArguments do begin
    s[i]:=AnsiChar(byte(trunc(POCAGetNumberValue(Context,Arguments^[i-1]))));
   end;
  end;
  result:=POCANewString(Context,s);
 end else begin
  result:=POCANewString(Context,'');
 end;
end;

function POCAInitStringNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCAStringFunctionCREATE);
 POCAAddNativeFunction(Context,result,'dump',POCAStringFunctionDUMP);
 POCAAddNativeFunction(Context,result,'fromCodePoints',POCAStringFunctionFROMCODEPOINTS);
 POCAAddNativeFunction(Context,result,'fromCodeUnits',POCAStringFunctionFROMCODEUNITS);
end;

function POCANumberFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments>0 then begin
  result:=POCANumberValue(Context,Arguments^[0]);
 end else begin
  result.Num:=0;
 end;
end;

function POCAInitNumberNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCANumberFunctionCREATE);
end;

function POCABooleanFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin                  
 if CountArguments>0 then begin
  result:=POCABooleanValue(Context,Arguments^[0]);
 end else begin
  result.Num:=0;
 end;
end;

function POCAInitBooleanNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCABooleanFunctionCREATE);
end;

function POCAConsoleFunctionLOG(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var i:longint;
    Value:TPOCAValue;
begin
 for i:=0 to CountArguments-1 do begin
  Value:=Arguments^[i];
  case POCAGetValueType(Value) of
   pvtNULL:begin
    System.Write('null');
   end;
   pvtSTRING:begin
    System.Write(PUCUUTF8ToUTF16(PPOCAString(POCAGetValueReferencePointer(Value))^.Data));
   end;
   pvtNUMBER:begin
    System.Write(POCADoubleToString(Value.Num));
   end;
   else begin
    POCARuntimeError(Context,'Bad arguments to "log"');
   end;
  end;
 end;
 System.WriteLn;
 result:=POCAValueNull;
end;

function POCAConsoleFunctionREADLINE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments>0 then begin
  result:=POCANewString(Context,ReadLine(POCAGetStringValue(Context,Arguments^[0])));
 end else begin
  result:=POCANewString(Context,ReadLine(''));
 end;
end;

function POCAInitConsoleNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'log',POCAConsoleFunctionLOG);
 POCAAddNativeFunction(Context,result,'readLine',POCAConsoleFunctionREADLINE);
end;

procedure TPOCANativeObjectDestroy(Ghost:pointer);
begin
 if assigned(Ghost) then begin
  TPOCANativeObject(Ghost).Free;
 end;
end;

function TPOCANativeObjectCanDestroy(Ghost:pointer):longbool;
begin
 result:=assigned(Ghost);
end;

function TPOCANativeObjectFunctionNativeMethodCall(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var PropertyItem:PPOCANativeObjectProperty;
begin
 PropertyItem:=UserData;
 if assigned(PropertyItem) then begin
  result:=PropertyItem^.Method(Context,This,Arguments,CountArguments);
 end else begin 
  result:=POCAValueNull;
 end;
end;

function TPOCANativeObjectMark(Ghost:pointer):longbool;
begin
 if assigned(Ghost) then begin
  result:=TPOCANativeObject(Ghost).Mark;
 end else begin
  result:=false;
 end;
end;

constructor TPOCANativeObject.Create(const pInstance:PPOCAInstance;const pContext:PPOCAContext;const pPrototype,pConstructor:PPOCAValue;const pExpandable:boolean);
{$ifdef fpc}
type PShortString=^ShortString;
{$endif}
type PMethodNameRec=^TMethodNameRec;
     TMethodNameRec=packed record
{$ifdef fpc}
      Name:PShortString;
      Address:pointer;
{$else}
      Size:word;
      Address:pointer;
      Name:ShortString;
{$endif}
     end;
     TMethodNameRecs=packed array[word] of TMethodNameRec;
     PMethodNameTable=^TMethodNameTable;
     TMethodNameTable=packed record
      Count:{$ifdef fpc}longword{$else}word{$endif};
      Methods:TMethodNameRecs;
     end;
var Index,Count:longint;
    Hash,EventsHash:PPOCAHash;
//  HashRec,EventsHashRec:PPOCAHashRecord;
    MethodTable:PMethodNameTable;
    MethodNameRec:PMethodNameRec;
    MethodName:string;
    MethodAddress:pointer;
    NativeFunction:TPOCANativeObjectMethod;
    IsEvent:boolean;
    PropertyItem:PPOCANativeObjectProperty;
begin
 inherited Create;

 fInstance:=pInstance;
 fExpandable:=pExpandable;

 fPropList:=nil;
 fPropListLen:=GetPropList(self,fPropList);

 FillChar(fGhostType,SizeOf(TPOCAGhostType),#0);
 fGhostType.Name:=TPOCAUTF8String(ClassName);
 fGhostType.Destroy:=TPOCANativeObjectDestroy;
 fGhostType.CanDestroy:=TPOCANativeObjectCanDestroy;
 fGhostType.Mark:=TPOCANativeObjectMark;

 fHashValue:=POCANewHash(pContext);
 POCAProtect(pContext,fHashValue);
 Hash:=POCAGetValueReferencePointer(fHashValue);

 fGhostValue:=POCANewGhost(pContext,@fGhostType,self,Hash,pgptOBJECT);
 POCAProtect(pContext,fGhostValue);
 POCAGhostSetHashValue(fGhostValue,fHashValue);

 if assigned(pPrototype) and not POCAIsValueNull(pPrototype^) then begin
  POCAHashSetPrototypeValue(pContext,fHashValue,pPrototype^);
 end;

 if assigned(pConstructor) and not POCAIsValueNull(pConstructor^) then begin
  POCAHashSetConstructorValue(pContext,fHashValue,pConstructor^);
 end;

 fEventsHashValue:=POCANewHash(pContext);
 POCAProtect(pContext,fEventsHashValue);
 EventsHash:=POCAGetValueReferencePointer(fEventsHashValue);

//EventsHashRec:=POCAHashCreateEvents(Instance,EventsHash);

 try

  Count:=fPropListLen;
  MethodTable:=pointer(pointer(TPOCAPtrInt(TPOCAPtrInt(pointer(self)^)+vmtMethodTable))^);
  if assigned(MethodTable) then begin
   MethodNameRec:=@MethodTable^.Methods[0];
   for Index:=0 to MethodTable^.Count-1 do begin
{$ifdef fpc}
    MethodName:=String(MethodNameRec^.Name^);
{$else}
    MethodName:=String(MethodNameRec^.Name);
{$endif}
    MethodAddress:=MethodNameRec^.Address;
    if (length(MethodName)>0) and assigned(MethodAddress) then begin
     inc(Count);
    end;
   end;
  end;

  fProperties:=nil;
  fCountProperties:=Count;
  SetLength(fProperties,fCountProperties);

  fPropHashMap:=TPOCAStringHashMap.Create(true);
  for Index:=0 to fPropListLen-1 do begin
   fPropHashMap.SetValue(fPropList^[Index].Name,Index);
   PropertyItem:=@fProperties[Index];
   PropertyItem^.Key:=POCAValueNull;
   PropertyItem^.PropInfo:=fPropList^[Index];
   PropertyItem^.Value:=POCAValueNull;
  end;

  Count:=fPropListLen;
  MethodTable:=pointer(pointer(TPOCAPtrInt(TPOCAPtrInt(pointer(self)^)+vmtMethodTable))^);
  if assigned(MethodTable) then begin
   MethodNameRec:=@MethodTable^.Methods[0];
   for Index:=0 to MethodTable^.Count-1 do begin
{$ifdef fpc}
    MethodName:=String(MethodNameRec^.Name^);
{$else}
    MethodName:=String(MethodNameRec^.Name);
{$endif}
    MethodAddress:=MethodNameRec^.Address;
    if (length(MethodName)>0) and assigned(MethodAddress) then begin
     if (length(MethodName)>1) and (MethodName[length(MethodName)]='_') then begin
      Delete(MethodName,length(MethodName),1);
     end;
     IsEvent:=(length(MethodName)>2) and (MethodName[1]='_') and (MethodName[2]='_');
     TMethod(NativeFunction).Code:=MethodAddress;
     TMethod(NativeFunction).Data:=self;
     fPropHashMap.SetValue(TPOCAUTF8String(MethodName),Count);
     PropertyItem:=@fProperties[Count];
     PropertyItem^.Key:=POCAValueNull;
     PropertyItem^.PropInfo:=nil;
     PropertyItem^.Method:=NativeFunction;
     PropertyItem^.Value:=POCANewFunction(pContext,POCANewNativeCode(pContext,TPOCANativeObjectFunctionNativeMethodCall,nil,PropertyItem));
     if IsEvent then begin
      POCAHashSet(pContext,fEventsHashValue,POCANewUniqueString(pContext,TPOCAUTF8String(MethodName)),PropertyItem^.Value);
     end;
     inc(Count);
    end;
{$ifdef fpc}
    inc(MethodNameRec);
{$else}
    inc(TPOCAPtrUInt(MethodNameRec),MethodNameRec^.Size);
{$endif}
   end;
  end;

  POCAHashLockInvalidate(EventsHash);

  POCAHashSetHashEvents(pContext,fHashValue,fEventsHashValue);

 finally

  POCAUnprotect(pContext,fGhostValue);
  POCAUnprotect(pContext,fHashValue);
  POCAUnprotect(pContext,fEventsHashValue);

  POCATemporarySave(pContext,fHashValue);

 end;

end;

destructor TPOCANativeObject.Destroy;
begin
 fPropHashMap.Free;
 SetLength(fProperties,0);
 if assigned(fPropList) then begin
  FreeMem(fPropList);
  fPropList:=nil;
  fPropListLen:=0;
 end;
 inherited Destroy;
end;

function TPOCANativeObject.Mark:boolean;
var PropertyIndex:longint;
    PropertyItem:PPOCANativeObjectProperty;
    PropInfo:PPropInfo;
    AObject:TObject;
begin
 POCAMarkValue(fInstance,fHashValue);
 for PropertyIndex:=0 to fCountProperties-1 do begin
  PropertyItem:=@fProperties[PropertyIndex];
  POCAMarkValue(fInstance,PropertyItem^.Value);
  PropInfo:=PropertyItem^.PropInfo;
  if assigned(PropInfo) then begin
   if assigned(PropInfo^.PropType) then begin
    case PropInfo^.PropType^.Kind of
     tkClass:begin
      AObject:=GetObjectProp(self,PropInfo);
      if assigned(AObject) and (AObject is TPOCANativeObject) then begin
       TPOCANativeObject(AObject).Mark;
      end;
     end;
    end;
   end;
  end;
 end;
 result:=true;
end;

function TPOCANativeObject.FindPropertyIndex(const Context:PPOCAContext;const Key:TPOCAValue;const CacheIndex:PLongword=nil):longint;
var PropertyItem:PPOCANativeObjectProperty;
begin
 if assigned(CacheIndex) and ((longint(CacheIndex^)>=0) and (longint(CacheIndex^)<fCountProperties)) then begin
  PropertyItem:=@fProperties[CacheIndex^];
  if PropertyItem^.Key.CastedInt64=Key.CastedInt64 then begin
   result:=CacheIndex^;
   exit;
  end;
 end;
 result:=fPropHashMap.GetValue(POCAGetStringValue(Context,Key));
 if assigned(CacheIndex) and (result>=0) and (result<fCountProperties) then begin
  CacheIndex^:=result;
  fProperties[result].Key.CastedInt64:=Key.CastedInt64;
 end;
end;

function TPOCANativeObject.GetPropertyValue(const Context:PPOCAContext;const PropertyIndex:longint;var Value:TPOCAValue):boolean;
var PropInfo:PPropInfo;
    AObject:TObject;
begin
 result:=(PropertyIndex>=0) and (PropertyIndex<fCountProperties);
 if result then begin
  PropInfo:=fProperties[PropertyIndex].PropInfo;
  if assigned(PropInfo) then begin
   if assigned(PropInfo^.PropType) and assigned(PropInfo^.GetProc) then begin
    case PropInfo^.PropType^.Kind of
     tkLString{$ifdef fpc},tkAString,tkSString{$endif}:begin
      Value:=POCANewString(Context,TPOCAUTF8String(GetStrProp(self,PropInfo)));
     end;
     tkWString{$ifdef fpc},tkUString{$endif}{$ifdef BESENEmbarcaderoNextGen},tkUString{$endif}:begin
      Value:=POCANewString(Context,PUCUUTF16ToUTF8({$ifdef BESENEmbarcaderoNextGen}GetStrProp{$else}GetWideStrProp{$endif}(self,PropInfo)));
     end;
     tkEnumeration:begin
      Value:=POCANewString(Context,TPOCAUTF8String(GetEnumProp(self,PropInfo)));
     end;
     tkSet:begin
      Value:=POCANewString(Context,TPOCAUTF8String(GetSetProp(self,PropInfo,false)));
     end;
     tkInteger:begin
      Value.Num:=GetOrdProp(self,PropInfo);
     end;
     tkChar:begin
      Value:=POCANewString(Context,PUCUUTF16ToUTF8(WideChar(word(GetOrdProp(self,PropInfo)))));
     end;
     tkWChar{$ifdef fpc},tkUChar{$endif}:begin
      Value:=POCANewString(Context,PUCUUTF16ToUTF8(WideChar(word(GetOrdProp(self,PropInfo)))));
     end;
     tkInt64{$ifdef fpc},tkQWORD{$endif}:begin
      Value.Num:=GetOrdProp(self,PropInfo);
     end;
     tkFloat:begin
      Value.Num:=GetFloatProp(self,PropInfo);
     end;
     tkClass:begin
      AObject:=GetObjectProp(self,PropInfo);
      if assigned(AObject) then begin
       if AObject is TPOCANativeObject then begin
        Value:=TPOCANativeObject(AObject).fGhostValue;
       end else begin
        POCARuntimeError(Context,'Unknown native property data type');
       end;
      end else begin
       POCARuntimeError(Context,'Unknown native property data type');
      end;
     end;
     tkVariant:begin
      Value:=POCANewValueFromVariant(Context,GetVariantProp(self,PropInfo));
     end;
     else begin
      POCARuntimeError(Context,'Unknown native property data type');
      exit;
     end;
    end;
   end else begin
    POCARuntimeError(Context,'Read-access from a non-readable member isn''t allowed');
   end;
  end else begin
   Value:=fProperties[PropertyIndex].Value;
  end;
 end;
end;

function TPOCANativeObject.SetPropertyValue(const Context:PPOCAContext;const PropertyIndex:longint;const Value:TPOCAValue):boolean;
var PropInfo:PPropInfo;
//  AObject:TObject;
    Ghost:PPOCAGhost;
    TypeData:PTypeData;
begin
 result:=(PropertyIndex>=0) and (PropertyIndex<fPropListLen);
 if result then begin
  PropInfo:=fProperties[PropertyIndex].PropInfo;
  if assigned(PropInfo) and assigned(PropInfo^.PropType) and assigned(PropInfo^.SetProc) then begin
   case PropInfo^.PropType^.Kind of
    tkLString{$ifdef fpc},tkAString,tkSString{$endif}:begin
     SetStrProp(self,PropInfo,String(POCAGetStringValue(Context,Value)));
    end;
    tkWString{$ifdef fpc},tkUString{$endif}{$ifdef BESENEmbarcaderoNextGen},tkUString{$endif}:begin
     {$ifdef BESENEmbarcaderoNextGen}SetStrProp{$else}SetWideStrProp{$endif}(self,PropInfo,PUCUUTF8ToUTF16(POCAGetStringValue(Context,Value)));
    end;
    tkEnumeration:begin
     SetEnumProp(self,PropInfo,String(POCAGetStringValue(Context,Value)));
    end;
    tkSet:begin
     SetSetProp(self,PropInfo,String(POCAGetStringValue(Context,Value)));
    end;
    tkInteger:begin
     SetOrdProp(self,PropInfo,trunc(POCAGetNumberValue(Context,Value)));
    end;
    tkChar,tkWChar{$ifdef fpc},tkUChar{$endif}:begin
     case POCAGetValueType(Value) of
      pvtNUMBER:begin
       SetOrdProp(self,PropInfo,trunc(POCAGetNumberValue(Context,Value)));
      end;
      else begin
       SetOrdProp(self,PropInfo,PUCUUTF8CodeUnitGetCharFallBack(POCAGetStringValue(Context,Value),0));
      end;
     end;
    end;
    tkInt64{$ifdef fpc},tkQWORD{$endif}:begin
     SetOrdProp(self,PropInfo,trunc(POCAGetNumberValue(Context,Value)));
    end;
    tkFloat:begin
     SetFloatProp(self,PropInfo,POCAGetNumberValue(Context,Value));
    end;
    tkClass:begin
     case POCAGetValueType(Value) of
      pvtGHOST:begin
       Ghost:=POCAHashGetGhost(Value);
       if assigned(Ghost) and (Ghost^.PtrType=pgptOBJECT) and assigned(Ghost^.Ptr) then begin
        TypeData:={$ifdef fpc}GetTypeData(PropInfo^.PropType){$else}GetTypeData(PropInfo^.PropType^){$endif};
        if assigned(TypeData) and (TObject(Ghost^.Ptr) is TypeData^.ClassType) then begin
         SetObjectProp(self,PropInfo,TObject(Ghost^.Ptr));
         exit;
        end;
       end;
      end;
     end;
     POCARuntimeError(Context,'Unknown native property data type');
    end;
    tkVariant:begin
     SetVariantProp(self,PropInfo,POCAGetVariantValue(Context,Value));
    end;
    else begin
     POCARuntimeError(Context,'Unknown native property data type');
     exit;
    end;
   end;
  end else begin
   POCARuntimeError(Context,'Write-access to a non-writable member isn''t allowed');
  end;
 end;
end;

function POCAGlobalFunctionSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "size"');
 end;
 case POCAGetValueType(Arguments^[0]) of
  pvtSTRING:begin
   if PPOCAString(POCAGetValueReferencePointer(Arguments^[0]))^.UTF8=suISUTF8 then begin
    result.Num:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]))^.UTF8Length;
   end else begin
    result.Num:=length(PPOCAString(POCAGetValueReferencePointer(Arguments^[0]))^.Data);
   end;
  end;
  pvtARRAY:begin
   result.Num:=POCAArraySize(Arguments^[0]);
  end;
  pvtHASH:begin
   result.Num:=POCAHashSize(Context,Arguments^[0]);
  end;
  else begin
   result.Num:=0;
  end;
 end;
end;

function POCAGlobalFunctionOWNKEYS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Hash:TPOCAValue;
begin
 if CountArguments>0 then begin
  Hash:=Arguments^[0];
 end else begin
  Hash:=POCAValueNull;
 end;
 if not POCAIsValueHash(Hash) then begin
  POCARuntimeError(Context,'Bad arguments to "ownKeys"');
 end;
 result:=POCANewArray(Context);
 POCAHashOwnKeys(Context,result,Hash);
 POCAArraySort(Context,result);
end;

function POCAGlobalFunctionKEYS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Hash:TPOCAValue;
begin
 if CountArguments>0 then begin
  Hash:=Arguments^[0];
 end else begin
  Hash:=POCAValueNull;
 end;
 if not POCAIsValueHash(Hash) then begin
  POCARuntimeError(Context,'Bad arguments to "keys"');
 end;
 result:=POCANewArray(Context);
 POCAHashKeys(Context,result,Hash);
 POCAArraySort(Context,result);
end;

function POCAGlobalFunctionPRINT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var i:longint;
    Value:TPOCAValue;
begin
 for i:=0 to CountArguments-1 do begin
  Value:=Arguments^[i];
  case POCAGetValueType(Value) of
   pvtNULL:begin
    System.Write('null');
   end;
   pvtSTRING:begin
    System.Write(TPOCAUTF16String(PUCUUTF8ToUTF16(PPOCAString(POCAGetValueReferencePointer(Value))^.Data)));
   end;
   pvtNUMBER:begin
    System.Write(POCADoubleToString(Value.Num));
   end;
   else begin
    POCARuntimeError(Context,'Bad arguments to "print"');
   end;
  end;
 end;
 result:=POCAValueNull;
end;

function POCAGlobalFunctionPUTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var i:longint;
    Value:TPOCAValue;
begin
 for i:=0 to CountArguments-1 do begin
  Value:=Arguments^[i];
  case POCAGetValueType(Value) of
   pvtNULL:begin
    System.Write('null');
   end;
   pvtSTRING:begin
    System.Write(TPOCAUTF16String(PUCUUTF8ToUTF16(PPOCAString(POCAGetValueReferencePointer(Value))^.Data)));
   end;
   pvtNUMBER:begin
    System.Write(POCADoubleToString(Value.Num));
   end;
   else begin
    POCARuntimeError(Context,'Bad arguments to "puts"');
   end;
  end;
 end;
 System.WriteLn;
 result:=POCAValueNull;
end;

function POCAGlobalFunctionREADLINE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments>0 then begin
  result:=POCANewString(Context,ReadLine(POCAGetStringValue(Context,Arguments^[0])));
 end else begin
  result:=POCANewString(Context,ReadLine(''));
 end;
end;

function POCAGlobalFunctionCHR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "chr"');
 end;
 result:=POCANewString(Context,PUCUUTF32CharToUTF8(trunc(POCAGetNumberValue(Context,Arguments^[0]))));
end;

function POCAGlobalFunctionCONTAINS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Hash,Key:TPOCAValue;
begin
 if CountArguments>0 then begin
  Hash:=Arguments^[0];
 end else begin
  Hash:=POCAValueNull;
 end;
 if CountArguments>1 then begin
  Key:=Arguments^[1];
 end else begin
  Key:=POCAValueNull;
 end;
 if (not POCAIsValueHash(Hash)) or POCAIsValueNull(Key) then begin
  POCARuntimeError(Context,'Bad arguments to "contains"');
 end;
 result.Num:=ord(POCAHashGet(Context,Hash,Key,Key));
end;

function POCAGlobalFunctionEVAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var SubContext:PPOCAContext;
    Code,CallArguments,CallThis,CallNamespace:TPOCAValue;
    ArrayRecord:PPOCAArrayRecord;
    Name:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "eval"');
 end;
 if CountArguments>1 then begin
  Name:=POCAGetStringValue(Context,Arguments^[1]);
 end else begin
  Name:='<eval>';
 end;
 if CountArguments>2 then begin
  CallArguments:=Arguments^[2];
 end else begin
  CallArguments:=POCAValueNull;
 end;
 if CountArguments>3 then begin
  CallThis:=Arguments^[3];
 end else begin
  CallThis:=POCAValueNull;
 end;
 if CountArguments>4 then begin
  CallNamespace:=Arguments^[4];
 end else begin
  CallNamespace:=POCAValueNull;
 end;
 if not (POCAIsValueHash(CallThis) or POCAIsValueGhost(CallThis)) then begin
  CallThis:=POCAValueNull;
 end;
 if not POCAIsValueHash(CallNamespace) then begin
  CallNamespace:=POCAValueNull;
 end;
 if (CountArguments=0) or (not (POCAIsValueNull(CallArguments) or POCAIsValueArray(CallArguments))) then begin
  POCARuntimeError(Context,'Bad arguments to "eval"');
 end;
 SubContext:=POCAContextSub(Context);
 try
  if POCAIsValueNull(CallNamespace) then begin
   CallNamespace:=POCANewHash(SubContext);
  end;
  Code:=POCABindToContext(Context,POCACompile(Context^.Instance,SubContext,POCAGetStringValue(Context,Arguments^[0]),Name));
  if POCAIsValueArray(CallArguments) then begin
   ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(CallArguments))^.ArrayRecord;
   if assigned(ArrayRecord) then begin
    result:=POCACall(SubContext,Code,@ArrayRecord^.Data[0],ArrayRecord^.Size,CallThis,CallNamespace);
   end else begin
    result:=POCACall(SubContext,Code,nil,0,CallThis,CallNamespace);
   end;
  end else begin
   result:=POCACall(SubContext,Code,nil,0,CallThis,CallNamespace);
  end;
 finally
  POCAContextDestroy(SubContext);
  Name:='';
 end;
end;

function POCAGlobalFunctionCOMPILE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Name:TPOCARawByteString;
    RawCode:boolean;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "compile"');
 end;
 if CountArguments>1 then begin
  Name:=POCAGetStringValue(Context,Arguments^[1]);
 end else begin
  Name:='<eval>';
 end;
 if CountArguments>2 then begin
  RawCode:=POCAGetBooleanValue(Context,Arguments^[2]);
 end else begin
  RawCode:=false;
 end;
 try
  result:=POCACompile(Context^.Instance,Context,POCAGetStringValue(Context,Arguments^[0]),Name);
  if not RawCode then begin
   result:=POCABindToContext(Context,result);
  end;
 finally
  Name:='';
 end;
end;

function POCAGlobalFunctionCALLER(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var FrameIndex:longint;
    Frame:PPOCAFrame;
    Index:TPOCAValue;
begin
 if CountArguments>0 then begin
  Index:=Arguments^[0];
 end else begin
  Index.Num:=1;
 end;
 FrameIndex:=trunc(POCAGetNumberValue(Context,Index));
 if FrameIndex>(Context^.FrameTop-1) then begin
  result:=POCAValueNull;
 end else begin
  Frame:=@Context^.FrameStack[Context^.FrameTop-(1+FrameIndex)];
  result:=POCANewArray(Context);
  POCAArrayPush(result,Frame^.Locals);
  POCAArrayPush(result,Frame^.Func);
  POCAArrayPush(result,Frame^.Obj);
  if PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code))^.SourceFile>=0 then begin
   POCAArrayPush(result,POCAArrayGet(Context^.Instance^.Globals.SourceFiles,PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code))^.SourceFile));
  end else begin
   POCAArrayPush(result,POCAValueNull);
  end;
  POCAArrayPush(result,POCANumber(POCAGetSourceFile(Context,FrameIndex)));
 end;
end;

function POCAGlobalFunctionCLOSURE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var i:longint;
    f:PPOCAFunction;
    Func,Index:TPOCAValue;
begin
 if CountArguments>0 then begin
  Func:=Arguments^[0];
 end else begin
  Func:=POCAValueNull;
 end;
 if CountArguments>0 then begin
  Index:=POCANumberValue(Context,Arguments^[1]);
 end else begin
  Index.Num:=0;
 end;
 if (not POCAIsValueFunction(Func)) or POCAIsValueNull(Index) then begin
  POCARuntimeError(Context,'Bad arguments to "closure"');
 end;
 i:=trunc(Index.Num);
 f:=PPOCAFunction(POCAGetValueReferencePointer(Func));
 while assigned(f) and (i>0) do begin
  f:=PPOCAFunction(POCAGetValueReferencePointer(f^.Next));
  dec(i);
 end;
 if assigned(f) then begin
  result:=POCANewArray(Context);
  POCAArrayPush(result,f^.Namespace);
  POCAArrayPush(result,f^.Obj);
 end else begin
  result:=POCAValueNull;
 end;
end;

function POCAGlobalFunctionBIND(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Func,Hash,Obj,Next:TPOCAValue;
begin
 if CountArguments>0 then begin
  Func:=Arguments^[0];
 end else begin
  Func:=POCAValueNull;
 end;
 if CountArguments>1 then begin
  Hash:=Arguments^[1];
 end else begin
  Hash:=POCANewHash(Context);
 end;
 if CountArguments>2 then begin
  Obj:=Arguments^[2];
 end else begin
  Obj:=POCAValueNull;
 end;
 if CountArguments>3 then begin
  Next:=Arguments^[3];
 end else begin
  Next:=POCAValueNull;
 end;
 if ((not POCAIsValueFunction(Func)) or (not POCAIsValueHash(Hash))) or ((not POCAIsValueNull(Obj)) and (not POCAIsValueFunction(Obj))) or ((not POCAIsValueNull(Next)) and (not POCAIsValueFunction(Next))) then begin
  POCARuntimeError(Context,'Bad arguments to "bind"');
 end;
 result:=POCANewFunction(Context,PPOCAFunction(POCAGetValueReferencePointer(Func))^.Code);
 PPOCAFunction(POCAGetValueReferencePointer(result))^.Namespace:=Hash;
 PPOCAFunction(POCAGetValueReferencePointer(result))^.Obj:=Obj;
 PPOCAFunction(POCAGetValueReferencePointer(result))^.Next:=Next;
end;

function POCAGlobalFunctionCALL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Func,CallArguments,CallThis,CallNamespace:TPOCAValue;
    SubContext:PPOCAContext;
    ArrayRecord:PPOCAArrayRecord;
begin
 if CountArguments>0 then begin
  Func:=Arguments^[0];
 end else begin
  Func:=POCAValueNull;
 end;
 if CountArguments>1 then begin
  CallArguments:=Arguments^[1];
 end else begin
  CallArguments:=POCAValueNull;
 end;
 if CountArguments>2 then begin
  CallThis:=Arguments^[2];
 end else begin
  CallThis:=POCAValueNull;
 end;
 if CountArguments>3 then begin
  CallNamespace:=Arguments^[3];
 end else begin
  CallNamespace:=POCAValueNull;
 end;
 if not (POCAIsValueHash(CallThis) or POCAIsValueGhost(CallThis)) then begin
  CallThis:=POCAValueNull;
 end;
 if not POCAIsValueHash(CallNamespace) then begin
  CallNamespace:=POCAValueNull;
 end;
 if (CountArguments=0) or (not POCAIsValueFunction(Func)) or (not (POCAIsValueNull(CallArguments) or POCAIsValueArray(CallArguments))) then begin
  POCARuntimeError(Context,'Bad arguments to "call"');
 end;
 SubContext:=POCAContextSub(Context);
 try
  if POCAIsValueArray(CallArguments) then begin
   ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(CallArguments))^.ArrayRecord;
   if assigned(ArrayRecord) then begin
    result:=POCACall(SubContext,Func,@ArrayRecord^.Data[0],ArrayRecord^.Size,CallThis,CallNamespace);
   end else begin
    result:=POCACall(SubContext,Func,nil,0,CallThis,CallNamespace);
   end;
  end else begin
   result:=POCACall(SubContext,Func,nil,0,CallThis,CallNamespace);
  end;
 finally
  POCAContextDestroy(SubContext);
 end;
end;

function POCAGlobalFunctionSETHASHEVENTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if (CountArguments<2) or not POCAHashSetHashEvents(Context,Arguments^[0],Arguments^[1]) then begin
  POCARuntimeError(Context,'Bad arguments to "setHashEvents"');
 end;
 result:=Arguments^[0];
end;

function POCAGlobalFunctionGETHASHEVENTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if (CountArguments<1) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "getHashEvents"');
 end;
 result:=POCAHashGetHashEventsHash(Arguments^[0]);
end;

function POCAGlobalFunctionRAWDELETE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if (CountArguments<2) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "rawDelete"');
 end;
 result.Num:=ord(POCAHashRawDelete(Arguments^[0],Arguments^[1]));
end;

function POCAGlobalFunctionRAWEXIST(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if (CountArguments<2) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "rawExist"');
 end;
 result.Num:=ord(POCAHashRawExist(Arguments^[0],Arguments^[1]));
end;

function POCAGlobalFunctionRAWGET(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if (CountArguments<2) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "rawGet"');
 end;
 POCAHashRawGet(Arguments^[0],Arguments^[1],result);
end;

function POCAGlobalFunctionRAWSET(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if (CountArguments<3) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "rawSet"');
 end;
 POCAHashRawSet(Arguments^[0],Arguments^[1],Arguments^[2]);
 result:=Arguments^[0];
end;

function POCAGlobalFunctionRAWSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if (CountArguments<1) or not POCAIsValueHash(Arguments^[0]) then begin
  POCARuntimeError(Context,'Bad arguments to "rawSize"');
 end;
 result.Num:=ord(POCAHashRawSize(Arguments^[0]));
end;

function POCAGlobalFunctionRAWKEYS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Hash:TPOCAValue;
begin
 if CountArguments>0 then begin
  Hash:=Arguments^[0];
 end else begin
  Hash:=POCAValueNull;
 end;
 if not POCAIsValueHash(Hash) then begin
  POCARuntimeError(Context,'Bad arguments to "rawKeys"');
 end;
 result:=POCANewArray(Context);
 POCAHashRawKeys(result,Hash);
 POCAArraySort(Context,result);
end;

function POCAInitGlobalNamespace(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAHashSetString(Context,result,'GarbageCollector',POCAInitGarbageCollectorNamespace(Context));
 POCAHashSetString(Context,result,'Math',POCAInitMathNamespace(Context));
 POCAHashSetString(Context,result,'IO',POCAInitIONamespace(Context));
 POCAHashSetString(Context,result,'RegExp',POCAInitRegExpNamespace(Context));
 POCAHashSetString(Context,result,'Coroutine',POCAInitCoroutineNamespace(Context));
 POCAHashSetString(Context,result,'Thread',POCAInitThreadNamespace(Context));
 POCAHashSetString(Context,result,'Lock',POCAInitLockNamespace(Context));
 POCAHashSetString(Context,result,'Semaphore',POCAInitSemaphoreNamespace(Context));
 POCAHashSetString(Context,result,'DateTime',POCAInitDateTimeNamespace(Context));
 POCAHashSetString(Context,result,'Array',POCAInitArrayNamespace(Context));
 POCAHashSetString(Context,result,'String',POCAInitStringNamespace(Context));
 POCAHashSetString(Context,result,'Number',POCAInitNumberNamespace(Context));
 POCAHashSetString(Context,result,'Boolean',POCAInitBooleanNamespace(Context));
 POCAHashSetString(Context,result,'Console',POCAInitConsoleNamespace(Context));
 POCAAddNativeFunction(Context,result,'size',POCAGlobalFunctionSIZE);
 POCAAddNativeFunction(Context,result,'ownKeys',POCAGlobalFunctionOWNKEYS);
 POCAAddNativeFunction(Context,result,'keys',POCAGlobalFunctionKEYS);
 POCAAddNativeFunction(Context,result,'print',POCAGlobalFunctionPRINT);
 POCAAddNativeFunction(Context,result,'puts',POCAGlobalFunctionPUTS);
 POCAAddNativeFunction(Context,result,'readLine',POCAGlobalFunctionREADLINE);
 POCAAddNativeFunction(Context,result,'chr',POCAGlobalFunctionCHR);
 POCAAddNativeFunction(Context,result,'contains',POCAGlobalFunctionCONTAINS);
 POCAAddNativeFunction(Context,result,'eval',POCAGlobalFunctionEVAL);
 POCAAddNativeFunction(Context,result,'compile',POCAGlobalFunctionCOMPILE);
 POCAAddNativeFunction(Context,result,'caller',POCAGlobalFunctionCALLER);
 POCAAddNativeFunction(Context,result,'closure',POCAGlobalFunctionCLOSURE);
 POCAAddNativeFunction(Context,result,'bind',POCAGlobalFunctionBIND);
 POCAAddNativeFunction(Context,result,'call',POCAGlobalFunctionCALL);
 POCAAddNativeFunction(Context,result,'setHashEvents',POCAGlobalFunctionSETHASHEVENTS);
 POCAAddNativeFunction(Context,result,'getHashEvents',POCAGlobalFunctionGETHASHEVENTS);
 POCAAddNativeFunction(Context,result,'rawDelete',POCAGlobalFunctionRAWDELETE);
 POCAAddNativeFunction(Context,result,'rawExist',POCAGlobalFunctionRAWEXIST);
 POCAAddNativeFunction(Context,result,'rawGet',POCAGlobalFunctionRAWGET);
 POCAAddNativeFunction(Context,result,'rawSet',POCAGlobalFunctionRAWSET);
 POCAAddNativeFunction(Context,result,'rawSize',POCAGlobalFunctionRAWSIZE);
 POCAAddNativeFunction(Context,result,'rawKeys',POCAGlobalFunctionRAWKEYS);
end;

function POCABaseClassFunctionCREATE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var ConstructorValue:TPOCAValue;                        
    SubContext:PPOCAContext;
begin
 result:=POCANewHash(Context);
 POCATemporarySave(Context,result);
 POCAHashSetPrototypeValue(Context,result,This);
 POCAHashSetConstructorValue(Context,result,This);
 POCAHashSetHashEvents(Context,result,This);
 if POCAHashGet(Context,result,Context^.Instance.Globals.ConstructorValueReference,ConstructorValue) then begin
  if POCAIsValueCode(ConstructorValue) or POCAIsValueFunction(ConstructorValue) or POCAIsValueNativeCode(ConstructorValue) then begin
   SubContext:=POCAContextSub(Context);
   try
    POCACall(SubContext,ConstructorValue,Arguments,CountArguments,result,POCAValueNull);
   finally
    POCAContextDestroy(SubContext);
   end;
  end;
 end;
end;

function POCAInitBaseClass(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'create',POCABaseClassFunctionCREATE);
 POCAHashSetString(Context,Context^.Instance.Globals.Namespace,'BaseClass',result);
end;

function POCAArrayFunctionEMPTY(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtARRAY:begin
   result.Num:=ord(POCAArraySize(This)=0);
  end;
  else begin
   result.Num:=0;
   POCARuntimeError(Context,'Bad this value to "empty"');
  end;
 end;
end;

function POCAArrayFunctionSIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtARRAY:begin
   result.Num:=POCAArraySize(This);
  end;
  else begin
   result.Num:=0;
   POCARuntimeError(Context,'Bad this value to "size"');
  end;
 end;
end;

function POCAArrayFunctionRESIZE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result:=This;
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "resize"');
 end;
 case POCAGetValueType(This) of
  pvtARRAY:begin
   POCAArraySetSize(This,trunc(POCAGetNumberValue(Context,Arguments^[0])));
  end;
  else begin
   POCARuntimeError(Context,'Bad this value to "resize"');
  end;
 end;
end;

function POCAArrayFunctionPUSH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var i:longint;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "push"');
 end;
 if not POCAIsValueArray(this) then begin
  POCARuntimeError(Context,'Bad this value to "push"');
 end;
 for i:=0 to CountArguments-1 do begin
  POCAArrayPush(This,Arguments^[i]);
 end;
 result:=This;
end;

function POCAArrayFunctionPOP(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "pop"');
 end;
 result:=POCAArrayPop(This);
end;

function POCAArrayFunctionSLICE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var i,Len,Start,Size:longint;
    LenValue:TPOCAValue;
begin
 if CountArguments<2 then begin
  POCARuntimeError(Context,'Bad arguments to "slice"');
 end;
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "slice"');
 end;
 Start:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
 if CountArguments>2 then begin
  LenValue:=POCANumberValue(Context,Arguments^[1]);
 end else begin
  LenValue:=POCAValueNull;
 end;
 if POCAIsValueNumber(LenValue) then begin
  Len:=trunc(LenValue.Num);
 end else begin
  Len:=0;
 end;
 Size:=POCAArraySize(This);
 if ((Start<0) or (Start>Size)) or (Len<0) then begin
  POCARuntimeError(Context,'Bad arguments to "slice"');
 end;
 if (not POCAIsValueNumber(LenValue)) or (Len>(Size-Start)) then begin
  Len:=Size-Start;
 end;
 result:=POCANewArray(Context);
 if Len>0 then begin
  for i:=0 to Len-1 do begin
   POCAArraySet(result,i,POCAArrayGet(This,Start+i));
  end;
 end;
end;

function POCAArrayFunctionSORT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if not POCAIsValueArray(This) then begin
  POCARuntimeError(Context,'Bad this value to "sort"');
 end;
 POCAArraySort(Context,This);
 result:=This;
end;

function POCAInitArrayHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'empty',POCAArrayFunctionEMPTY);
 POCAAddNativeFunction(Context,result,'size',POCAArrayFunctionSIZE);
 POCAAddNativeFunction(Context,result,'resize',POCAArrayFunctionRESIZE);
 POCAAddNativeFunction(Context,result,'push',POCAArrayFunctionPUSH);
 POCAAddNativeFunction(Context,result,'pop',POCAArrayFunctionPOP);
 POCAAddNativeFunction(Context,result,'slice',POCAArrayFunctionSLICE);
 POCAAddNativeFunction(Context,result,'sort',POCAArrayFunctionSORT);
end;

function POCANumberFunctionTOSTRING(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result:=POCAStringValue(Context,This);
end;

function POCANumberFunctionTOEXPONENTIAL(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "toExponential"');
 end;
 result:=POCANewString(Context,ConvertDoubleToString(POCAGetNumberValue(Context,This),omExponential,trunc(POCAGetNumberValue(Context,Arguments^[0]))));
end;

function POCANumberFunctionTOFIXED(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "toFixed"');
 end;
 result:=POCANewString(Context,ConvertDoubleToString(POCAGetNumberValue(Context,This),omFixed,trunc(POCAGetNumberValue(Context,Arguments^[0]))));
end;

function POCANumberFunctionTOPRECISION(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "toPrecision"');
 end;
 result:=POCANewString(Context,ConvertDoubleToString(POCAGetNumberValue(Context,This),omPrecision,trunc(POCAGetNumberValue(Context,Arguments^[0]))));
end;

function POCANumberFunctionTORADIX(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "toRadix"');
 end;
 result:=POCANewString(Context,ConvertDoubleToString(POCAGetNumberValue(Context,This),omRadix,trunc(POCAGetNumberValue(Context,Arguments^[0]))));
end;

function POCAInitNumberHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'toString',POCANumberFunctionTOSTRING);
 POCAAddNativeFunction(Context,result,'toExponential',POCANumberFunctionTOEXPONENTIAL);
 POCAAddNativeFunction(Context,result,'toFixed',POCANumberFunctionTOFIXED);
 POCAAddNativeFunction(Context,result,'toPrecision',POCANumberFunctionTOPRECISION);
 POCAAddNativeFunction(Context,result,'toRadix',POCANumberFunctionTORADIX);
end;

function POCAStringFunctionCOUNTCODEPOINTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtSTRING:begin
   if PPOCAString(POCAGetValueReferencePointer(This))^.UTF8=suISUTF8 then begin
    result.Num:=PPOCAString(POCAGetValueReferencePointer(This))^.UTF8Length;
   end else begin
    result.Num:=length(PPOCAString(POCAGetValueReferencePointer(This))^.Data);
   end;
  end;
  else begin
   result:=POCAValueNull;
   POCARuntimeError(Context,'Bad this value to "countCodePoints"');
  end;
 end;
end;

function POCAStringFunctionCOUNTCODEUNITS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtSTRING:begin
   result.Num:=length(PPOCAString(POCAGetValueReferencePointer(This))^.Data);
  end;
  else begin
   result:=POCAValueNull;
   POCARuntimeError(Context,'Bad this value to "countCodeUnits"');
  end;
 end;
end;

function POCAStringFunctionLENGTH(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 case POCAGetValueType(This) of
  pvtSTRING:begin
   if PPOCAString(POCAGetValueReferencePointer(This))^.UTF8=suISUTF8 then begin
    result.Num:=PPOCAString(POCAGetValueReferencePointer(This))^.UTF8Length;
   end else begin
    result.Num:=length(PPOCAString(POCAGetValueReferencePointer(This))^.Data);
   end;
  end;
  else begin
   result:=POCAValueNull;
   POCARuntimeError(Context,'Bad this value to "length"');
  end;
 end;
end;

function POCAStringFunctionTONUMBER(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var OK:TPasDblStrUtilsBoolean;
begin
 if CountArguments=0 then begin
  result.Num:=POCAGetNumberValue(Context,This);
 end else begin
  result:=POCAValueNull;
  OK:=false;
  if POCAGetValueType(This)=pvtSTRING then begin
   POCASetValueNumber(result,ConvertStringToDouble(PPOCAString(POCAGetValueReferencePointer(This))^.Data,rmNearest,@OK,trunc(POCAGetNumberValue(Context,Arguments^[0]))));
  end;
  if not OK then begin
   result:=POCAValueNull;
  end;
 end;
end;

function POCAStringFunctionTOSTRING(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result:=POCAStringValue(Context,This);
end;

function POCAStringFunctionINCLUDES(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var SearchString,InString:TPOCARawByteString;
    SearchStringIsUTF8,InStringIsUTF8:longint;
    p:PPOCAString;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "includes"');
 end;
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "includes"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 InString:=p^.Data;
 InStringIsUTF8:=p^.UTF8;
 if POCAIsValueString(Arguments^[0]) then begin
  p:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]));
  SearchString:=p^.Data;
  SearchStringIsUTF8:=p^.UTF8;
 end else begin
  SearchString:=POCAGetStringValue(Context,Arguments^[0]);
  SearchStringIsUTF8:=PUCUUTF8Get(SearchString);
 end;
 if (SearchStringIsUTF8=suISUTF8) and (InStringIsUTF8=suISUTF8) then begin
  if PUCUUTF8Pos(SearchString,InString)>0 then begin
   result.Num:=1;
  end else begin
   result.Num:=0;
  end;
 end else begin
  if System.Pos(SearchString,InString)>0 then begin
   result.Num:=1;
  end else begin
   result.Num:=0;
  end;
 end;
end;

function POCAStringFunctionINDEXOF(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var SearchString,InString:TPOCARawByteString;
    SearchStringIsUTF8,InStringIsUTF8:longint;
    p:PPOCAString;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "indexOf"');
 end;
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "indexOf"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 InString:=p^.Data;
 InStringIsUTF8:=p^.UTF8;
 if POCAIsValueString(Arguments^[0]) then begin
  p:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]));
  SearchString:=p^.Data;
  SearchStringIsUTF8:=p^.UTF8;
 end else begin
  SearchString:=POCAGetStringValue(Context,Arguments^[0]);
  SearchStringIsUTF8:=PUCUUTF8Get(SearchString);
 end;
 if (SearchStringIsUTF8=suISUTF8) and (InStringIsUTF8=suISUTF8) then begin
  result.Num:=PUCUUTF8Pos(SearchString,InString)-1;
 end else begin
  result.Num:=System.Pos(SearchString,InString)-1;
 end;
end;

function POCAStringFunctionLASTINDEXOF(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var SearchString,InString:TPOCARawByteString;
    SearchStringIsUTF8,InStringIsUTF8,i,j:longint;
    p:PPOCAString;
    OK:boolean;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "lastIndexOf"');
 end;
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "lastIndexOf"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 InString:=p^.Data;
 InStringIsUTF8:=p^.UTF8;
 if POCAIsValueString(Arguments^[0]) then begin
  p:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]));
  SearchString:=p^.Data;
  SearchStringIsUTF8:=p^.UTF8;
 end else begin
  SearchString:=POCAGetStringValue(Context,Arguments^[0]);
  SearchStringIsUTF8:=PUCUUTF8Get(SearchString);
 end;
 if (SearchStringIsUTF8=suISUTF8) and (InStringIsUTF8=suISUTF8) then begin
  result.Num:=PUCUUTF8LastPos(SearchString,InString)-1;
 end else begin
  result.Num:=-1;
  for i:=length(InString)-(length(SearchString)-1) downto 1 do begin
   OK:=true;
   for j:=1 to length(SearchString) do begin
    if InString[(i+j)-1]<>SearchString[j] then begin
     OK:=false;
     break;
    end;
   end;
   if OK then begin
    result.Num:=i-1;
    break;
   end;
  end;
 end;
end;

function POCAStringFunctionSPLIT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var DelimeterString,FromString:TPOCARawByteString;
    FromStringIsUTF8,i,j:longint;
    p:PPOCAString;
begin
 if CountArguments=0 then begin
  POCARuntimeError(Context,'Bad arguments to "split"');
 end;
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "split"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 FromString:=p^.Data;
 FromStringIsUTF8:=p^.UTF8;
 if POCAIsValueString(Arguments^[0]) then begin
  p:=PPOCAString(POCAGetValueReferencePointer(Arguments^[0]));
  DelimeterString:=p^.Data;
 end else begin
  DelimeterString:=POCAGetStringValue(Context,Arguments^[0]);
 end;
 result:=POCANewArray(Context);
 if length(DelimeterString)=0 then begin
  if FromStringIsUTF8=suISUTF8 then begin
   i:=1;
   while i<=length(FromString) do begin
    POCAArrayPush(result,POCANewString(Context,PUCUUTF32CharToUTF8(PUCUUTF8CodeUnitGetCharAndInc(FromString,i))));
   end;
  end else begin
   for i:=1 to length(FromString) do begin
    POCAArrayPush(result,POCANewString(Context,FromString[i]));
   end;
  end;
 end else begin
  j:=1;
  while j<=length(FromString) do begin
   i:=PosEx(DelimeterString,FromString,j);
   if i>0 then begin
    POCAArrayPush(result,POCANewString(Context,copy(FromString,j,i-j)));
    j:=i+length(DelimeterString);
   end else begin
    POCAArrayPush(result,POCANewString(Context,copy(FromString,j,(length(FromString)-j)+1)));
    break;
   end;
  end;
 end;
end;

function POCAStringFunctionTRIM(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var s:TPOCARawByteString;
    p:PPOCAString;
begin
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "trim"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 s:=p^.Data;
 if p^.UTF8=suISUTF8 then begin
  result:=POCANewString(Context,TPOCAUTF8String(PUCUUTF8Trim(TPOCAUTF8String(s))));
 end else begin
  result:=POCANewString(Context,TPOCARawByteString(Trim(String(TPOCARawByteString(s)))));
 end;
end;

function POCAStringFunctionTRIMLEFT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var s:TPOCARawByteString;
    p:PPOCAString;
begin
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "trimLeft"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 s:=p^.Data;
 if p^.UTF8=suISUTF8 then begin
  result:=POCANewString(Context,TPOCAUTF8String(PUCUUTF8TrimLeft(TPOCAUTF8String(s))));
 end else begin
  result:=POCANewString(Context,TPOCARawByteString(TrimLeft(String(TPOCARawByteString(s)))));
 end;
end;

function POCAStringFunctionTRIMRIGHT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var s:TPOCARawByteString;
    p:PPOCAString;
begin
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "trimRight"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 s:=p^.Data;
 if p^.UTF8=suISUTF8 then begin
  result:=POCANewString(Context,TPOCAUTF8String(PUCUUTF8TrimRight(TPOCAUTF8String(s))));
 end else begin
  result:=POCANewString(Context,TPOCARawByteString(TrimRight(String(TPOCARawByteString(s)))));
 end;
end;

function POCAStringFunctionTOLOWERCASE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var s:TPOCARawByteString;
    p:PPOCAString;
begin
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "toLowerCase"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 s:=p^.Data;
 if p^.UTF8=suISUTF8 then begin
  result:=POCANewString(Context,PUCUUTF8LowerCase(s));
 end else begin
  result:=POCANewString(Context,TPOCARawByteString(LowerCase(String(TPOCARawByteString(s)))));
 end;
end;

function POCAStringFunctionTOUPPERCASE(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var s:TPOCARawByteString;
    p:PPOCAString;
begin
 if not POCAIsValueString(This) then begin
  POCARuntimeError(Context,'Bad this value to "toUpperCase"');
 end;
 p:=PPOCAString(POCAGetValueReferencePointer(This));
 s:=p^.Data;
 if p^.UTF8=suISUTF8 then begin
  result:=POCANewString(Context,PUCUUTF8UpperCase(s));
 end else begin
  result:=POCANewString(Context,TPOCARawByteString(UpperCase(String(TPOCARawByteString(s)))));
 end;
end;

function POCAStringFunctionSUBSTR(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Len,Start,Size,IsUTF8:longint;
    LenValue:TPOCAValue;
    Str:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  result:=POCAValueNull;
 end else begin
  Start:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
  if CountArguments>1 then begin
   LenValue:=POCANumberValue(Context,Arguments^[1]);
  end else begin
   LenValue:=POCAValueNull;
  end;
  if POCAIsValueNumber(LenValue) then begin
   Len:=trunc(LenValue.Num);
  end else begin
   Len:=0;
  end;
  if POCAIsValueString(This) then begin
   Str:=PPOCAString(POCAGetValueReferencePointer(This))^.Data;
   IsUTF8:=PPOCAString(POCAGetValueReferencePointer(This))^.UTF8;
   if IsUTF8=suISUTF8 then begin
    Size:=PPOCAString(POCAGetValueReferencePointer(This))^.UTF8Length;
   end else begin
    Size:=length(PPOCAString(POCAGetValueReferencePointer(This))^.Data);
   end;
  end else begin
   Str:=POCAGetStringValue(Context,This);
   IsUTF8:=PUCUUTF8Get(Str);
   if IsUTF8=suISUTF8 then begin
    Size:=PUCUUTF8Length(Str);
   end else begin
    Size:=length(Str);
   end;
  end;
  if ((Start<0) or (Start>=Size)) or (Len<0) then begin
   POCARuntimeError(Context,'Bad arguments to "substr"');
  end;
  if (not POCAIsValueNumber(LenValue)) or (Len>(Size-Start)) then begin
   Len:=Size-Start;
  end;
  IF IsUTF8=suISUTF8 then begin
   if POCAIsValueString(This) then begin
    result:=POCANewString(Context,POCAStringUTF8CopyCodePointRange(Context,This,Start,(Start+Len)-1));
   end else begin
    result:=POCANewString(Context,PUCUUTF8Copy(Str,Start,Len));
   end;
  end else begin
   result:=POCANewString(Context,copy(Str,Start+1,Len));
  end;
 end;
end;

{$ifdef pocastrictutf8}
function POCAStringFunctionTOLATIN1(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 POCARuntimeError(Context,'"toLatin1" isn''t allowed in a strict-UTF8 Poca build');
end;

function POCAStringFunctionISLATIN1(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 result.Num:=0;
end;
{$else}
function POCAStringFunctionTOLATIN1(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var d,s:TPOCARawByteString;
    CodeUnit:longint;
    CharValue:longword;
begin
 if POCAIsValueString(This) then begin
  if PPOCAString(POCAGetValueReferencePointer(This))^.UTF8<>suNOUTF8 then begin
   s:=PPOCAString(POCAGetValueReferencePointer(This))^.Data;
   d:='';
   CodeUnit:=1;
   while CodeUnit<=length(s) do begin
    CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(s,CodeUnit);
    if CharValue>255 then begin
     CharValue:=128;
    end;
    d:=d+ansichar(byte(CharValue));
   end;
   result:=POCANewString(Context,d);
   PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suNOUTF8;
  end else begin
   result:=This;
  end;
 end else begin
  result:=POCANewString(Context,ansichar(byte(trunc(POCAGetNumberValue(Context,This)))));
 end;
end;

function POCAStringFunctionISLATIN1(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if POCAIsValueString(This) then begin
  result.Num:=2-PPOCAString(POCAGetValueReferencePointer(This))^.UTF8;
 end else begin
  result.Num:=2-PUCUUTF8Get(POCAGetStringValue(Context,This));
 end;
end;
{$endif}

function POCAStringFunctionTOUTF8(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if POCAIsValueString(This) then begin
  if PPOCAString(POCAGetValueReferencePointer(This))^.UTF8=suNOUTF8 then begin
   result:=POCANewString(Context,PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(This))^.Data));
  end else begin
   result:=This;
  end;
 end else begin
  result:=POCANewString(Context,PUCUUTF32CharToUTF8(trunc(POCAGetNumberValue(Context,This))));
 end;
end;

function POCAStringFunctionISUTF8(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
begin
 if POCAIsValueString(This) then begin
  result.Num:=PPOCAString(POCAGetValueReferencePointer(This))^.UTF8;
 end else begin
  result.Num:=PUCUUTF8Get(POCAGetStringValue(Context,This));
 end;
end;

function POCAStringFunctionCHARAT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Str:PPOCAString;
    CodePoint,CodeUnit,Len:longint;
    s:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "charAt"');
 end;
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  if Str^.UTF8=suISUTF8 then begin
   Len:=Str^.UTF8Length;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    CodeUnit:=POCAStringUTF8GetCodeUnit(Context,This,CodePoint);
    if (CodeUnit>0) and (CodeUnit<=length(Str^.Data)) then begin
     result:=POCANewString(Context,PUCUUTF32CharToUTF8(PUCUUTF8CodeUnitGetChar(Str^.Data,CodeUnit)));
    end else begin
     result:=POCANewString(Context,PUCUUTF32CharToUTF8(PUCUUTF8CodePointGetChar(Str^.Data,CodePoint)));
    end;
   end else begin
    result:=POCAValueNull;
   end;
  end else begin
   Len:=Str^.DataLength;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result:=POCANewString(Context,PUCUUTF32CharToUTF8(byte(ansichar(Str^.Data[CodePoint+1]))));
   end else begin
    result:=POCAValueNull;
   end;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  if PUCUIsUTF8(s) then begin
   Len:=PUCUUTF8Length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result:=POCANewString(Context,PUCUUTF32CharToUTF8(PUCUUTF8CodePointGetChar(s,CodePoint)));
   end else begin
    result:=POCAValueNull;
   end;
  end else begin
   Len:=length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result:=POCANewString(Context,PUCUUTF32CharToUTF8(byte(ansichar(s[CodePoint+1]))));
   end else begin
    result:=POCAValueNull;
   end;
  end;
 end;
end;

function POCAStringFunctionCODEPOINTAT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Str:PPOCAString;
    CodePoint,CodeUnit,Len:longint;
    s:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "codePointAt"');
 end;
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  if Str^.UTF8=suISUTF8 then begin
   Len:=Str^.UTF8Length;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    CodeUnit:=POCAStringUTF8GetCodeUnit(Context,This,CodePoint);
    if (CodeUnit>0) and (CodeUnit<=length(Str^.Data)) then begin
     result.Num:=PUCUUTF8CodeUnitGetChar(Str^.Data,CodeUnit);
    end else begin
     result.Num:=PUCUUTF8CodePointGetChar(Str^.Data,CodePoint);
    end;
   end else begin
    result:=POCAValueNull;
   end;
  end else begin
   Len:=Str^.DataLength;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=byte(ansichar(Str^.Data[CodePoint+1]));
   end else begin
    result:=POCAValueNull;
   end;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  if PUCUIsUTF8(s) then begin
   Len:=PUCUUTF8Length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=PUCUUTF8CodePointGetChar(s,CodePoint);
   end else begin
    result:=POCAValueNull;
   end;
  end else begin
   Len:=length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=byte(ansichar(s[CodePoint+1]));
   end else begin
    result:=POCAValueNull;
   end;
  end;
 end;
end;

function POCAStringFunctionCODEUNITAT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Str:PPOCAString;
    CodePoint,Len:longint;
    s:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "codeUnitAt"');
 end;
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  Len:=Str^.DataLength;
  CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
  if CodePoint<0 then begin
   inc(CodePoint,Len);
  end;
  if (CodePoint>=0) and (CodePoint<Len) then begin
   result.Num:=byte(ansichar(Str^.Data[CodePoint+1]));
  end else begin
   result:=POCAValueNull;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  Len:=length(s);
  CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
  if CodePoint<0 then begin
   inc(CodePoint,Len);
  end;
  if (CodePoint>=0) and (CodePoint<Len) then begin
   result.Num:=byte(ansichar(s[CodePoint+1]));
  end else begin
   result:=POCAValueNull;
  end;
 end;
end;

function POCAStringFunctionCODEPOINTTOCODEUNIT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Str:PPOCAString;
    CodePoint,Len:longint;
    s:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "codePointToCodeUnit"');
 end;
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  if Str^.UTF8=suISUTF8 then begin
   Len:=Str^.UTF8Length;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=POCAStringUTF8GetCodeUnit(Context,This,CodePoint)-1;
   end else begin
    result:=POCAValueNull;
   end;
  end else begin
   Len:=Str^.DataLength;
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=CodePoint;
   end else begin
    result:=POCAValueNull;
   end;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  if PUCUIsUTF8(s) then begin
   Len:=PUCUUTF8Length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=PUCUUTF8GetCodeUnit(s,CodePoint)-1;
   end else begin
    result:=POCAValueNull;
   end;
  end else begin
   Len:=length(s);
   CodePoint:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodePoint<0 then begin
    inc(CodePoint,Len);
   end;
   if (CodePoint>=0) and (CodePoint<Len) then begin
    result.Num:=CodePoint;
   end else begin
    result:=POCAValueNull;
   end;
  end;
 end;
end;

function POCAStringFunctionCODEUNITTOCODEPOINT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Str:PPOCAString;
    CodeUnit,Len:longint;
    s:TPOCARawByteString;
begin
 if CountArguments<1 then begin
  POCARuntimeError(Context,'Bad arguments to "codeUnitToCodePoint"');
 end;
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  if Str^.UTF8=suISUTF8 then begin
   Len:=Str^.DataLength;
   CodeUnit:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodeUnit<0 then begin
    inc(CodeUnit,Len);
   end;
   if (CodeUnit>=0) and (CodeUnit<Len) then begin
    result.Num:=POCAStringUTF8GetCodePoint(Context,This,CodeUnit+1);
   end else begin
    result:=POCAValueNull;
   end;
  end else begin
   Len:=Str^.DataLength;
   CodeUnit:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodeUnit<0 then begin
    inc(CodeUnit,Len);
   end;
   if (CodeUnit>=0) and (CodeUnit<Len) then begin
    result.Num:=CodeUnit;
   end else begin
    result:=POCAValueNull;
   end;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  if PUCUIsUTF8(s) then begin
   Len:=length(s);
   CodeUnit:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodeUnit<0 then begin
    inc(CodeUnit,Len);
   end;
   if (CodeUnit>=0) and (CodeUnit<Len) then begin
    result.Num:=PUCUUTF8GetCodePoint(s,CodeUnit+1);
   end else begin
    result:=POCAValueNull;
   end;
  end else begin
   Len:=length(s);
   CodeUnit:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
   if CodeUnit<0 then begin
    inc(CodeUnit,Len);
   end;
   if (CodeUnit>=0) and (CodeUnit<Len) then begin
    result.Num:=CodeUnit;
   end else begin
    result:=POCAValueNull;
   end;
  end;
 end;
end;

function POCAStringFunctionCODEPOINTS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Str:PPOCAString;
    CodePoint,CodeUnit,Len:longint;
    s:TPOCARawByteString;
begin
 result:=POCANewArray(Context);
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  if Str^.UTF8=suISUTF8 then begin
   Len:=Str^.UTF8Length;
   for CodePoint:=0 to Len-1 do begin
    CodeUnit:=POCAStringUTF8GetCodeUnit(Context,This,CodePoint);
    if (CodeUnit>0) and (CodeUnit<=length(Str^.Data)) then begin
     POCAArrayPush(result,POCANewNumber(Context,PUCUUTF8CodeUnitGetChar(Str^.Data,CodeUnit)));
    end else begin
     POCAArrayPush(result,POCANewNumber(Context,PUCUUTF8CodePointGetChar(Str^.Data,CodePoint)));
    end;
   end;
  end else begin
   Len:=Str^.DataLength;
   for CodeUnit:=1 to Len do begin
    POCAArrayPush(result,POCANewNumber(Context,byte(ansichar(Str^.Data[CodeUnit]))));
   end;
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  if PUCUIsUTF8(s) then begin
   Len:=PUCUUTF8Length(s);
   for CodePoint:=0 to Len-1 do begin
    CodeUnit:=PUCUUTF8GetCodeUnit(s,CodePoint);
    if (CodeUnit>0) and (CodeUnit<=length(s)) then begin
     POCAArrayPush(result,POCANewNumber(Context,PUCUUTF8CodeUnitGetChar(s,CodeUnit)));
    end else begin
     POCAArrayPush(result,POCANewNumber(Context,PUCUUTF8CodePointGetChar(s,CodePoint)));
    end;
   end;
  end else begin
   Len:=length(s);
   for CodeUnit:=1 to Len do begin
    POCAArrayPush(result,POCANewNumber(Context,byte(ansichar(s[CodeUnit]))));
   end;
  end;
 end;
end;

function POCAStringFunctionCODEUNITS(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var Str:PPOCAString;
    CodeUnit,Len:longint;
    s:TPOCARawByteString;
begin
 result:=POCANewArray(Context);
 if POCAIsValueString(This) then begin
  Str:=PPOCAString(POCAGetValueReferencePointer(This));
  Len:=Str^.DataLength;
  for CodeUnit:=1 to Len do begin
   POCAArrayPush(result,POCANewNumber(Context,byte(ansichar(Str^.Data[CodeUnit]))));
  end;
 end else begin
  s:=POCAGetStringValue(Context,This);
  Len:=length(s);
  for CodeUnit:=1 to Len do begin
   POCAArrayPush(result,POCANewNumber(Context,byte(ansichar(s[CodeUnit]))));
  end;
 end;
end;

function POCAStringFunctionCONCAT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var s:TPOCARawByteString;
    i,j:longint;
begin
 if POCAIsValueString(This) then begin
  s:=PPOCAString(POCAGetValueReferencePointer(This))^.Data;
 end else begin
  s:=POCAGetStringValue(Context,This);
 end;
 if CountArguments>0 then begin
  if (CountArguments=1) and POCAIsValueArray(Arguments^[0]) then begin
   j:=POCAArraySize(Arguments^[0]);
   for i:=1 to j do begin
    s:=s+POCAGetStringValue(Context,POCAArrayGet(Arguments^[0],i-1));
   end;
  end else begin
   for i:=0 to CountArguments-1 do begin
    s:=s+POCAGetStringValue(Context,Arguments^[i]);
   end;
  end;
 end;
 result:=POCANewString(Context,s);
end;

function POCAStringFunctionREPEAT(Context:PPOCAContext;const This:TPOCAValue;const Arguments:PPOCAValues;const CountArguments:longint;const UserData:pointer):TPOCAValue;
var s,Src:TPOCARawByteString;
    i,j:longint;
begin
 if POCAIsValueString(This) then begin
  Src:=PPOCAString(POCAGetValueReferencePointer(This))^.Data;
 end else begin
  Src:=POCAGetStringValue(Context,This);
 end;
 s:='';
 if CountArguments>0 then begin
  j:=trunc(POCAGetNumberValue(Context,Arguments^[0]));
  for i:=1 to j do begin
   s:=s+Src;
  end;
 end;
 result:=POCANewString(Context,s);
end;

function POCAInitStringHash(Context:PPOCAContext):TPOCAValue;
begin
 result:=POCANewHash(Context);
 POCAAddNativeFunction(Context,result,'countCodePoints',POCAStringFunctionCOUNTCODEPOINTS);
 POCAAddNativeFunction(Context,result,'countCodeUnits',POCAStringFunctionCOUNTCODEUNITS);
 POCAAddNativeFunction(Context,result,'length',POCAStringFunctionLENGTH);
 POCAAddNativeFunction(Context,result,'toNumber',POCAStringFunctionTONUMBER);
 POCAAddNativeFunction(Context,result,'toString',POCAStringFunctionTOSTRING);
 POCAAddNativeFunction(Context,result,'includes',POCAStringFunctionINCLUDES);
 POCAAddNativeFunction(Context,result,'indexOf',POCAStringFunctionINDEXOF);
 POCAAddNativeFunction(Context,result,'lastIndexOf',POCAStringFunctionLASTINDEXOF);
 POCAAddNativeFunction(Context,result,'split',POCAStringFunctionSPLIT);
 POCAAddNativeFunction(Context,result,'trim',POCAStringFunctionTRIM);
 POCAAddNativeFunction(Context,result,'trimLeft',POCAStringFunctionTRIMLEFT);
 POCAAddNativeFunction(Context,result,'trimRight',POCAStringFunctionTRIMRIGHT);
 POCAAddNativeFunction(Context,result,'toLowerCase',POCAStringFunctionTOLOWERCASE);
 POCAAddNativeFunction(Context,result,'toUpperCase',POCAStringFunctionTOUPPERCASE);
 POCAAddNativeFunction(Context,result,'substr',POCAStringFunctionSUBSTR);
 POCAAddNativeFunction(Context,result,'toLatin1',POCAStringFunctionTOLATIN1);
 POCAAddNativeFunction(Context,result,'isLatin1',POCAStringFunctionISLATIN1);
 POCAAddNativeFunction(Context,result,'toUTF8',POCAStringFunctionTOUTF8);
 POCAAddNativeFunction(Context,result,'isUTF8',POCAStringFunctionISUTF8);
 POCAAddNativeFunction(Context,result,'charAt',POCAStringFunctionCHARAT);
 POCAAddNativeFunction(Context,result,'codePointAt',POCAStringFunctionCODEPOINTAT);
 POCAAddNativeFunction(Context,result,'codeUnitAt',POCAStringFunctionCODEUNITAT);
 POCAAddNativeFunction(Context,result,'codePointToCodeUnit',POCAStringFunctionCODEPOINTTOCODEUNIT);
 POCAAddNativeFunction(Context,result,'codeUnitToCodePoint',POCAStringFunctionCODEUNITTOCODEPOINT);
 POCAAddNativeFunction(Context,result,'codePoints',POCAStringFunctionCODEPOINTS);
 POCAAddNativeFunction(Context,result,'codeUnits',POCAStringFunctionCODEUNITS);
 POCAAddNativeFunction(Context,result,'concat',POCAStringFunctionCONCAT);
 POCAAddNativeFunction(Context,result,'repeat',POCAStringFunctionREPEAT);
end;

function POCAInstanceCreate:PPOCAInstance;
var i:longint;
    Context:PPOCAContext;
    Ghost:boolean;
begin
 New(result);
 FillChar(result^,sizeof(TPOCAInstance),#0);
 result^.AutomaticSemicolonInsertion:=false;
 begin
  result^.Globals.Lock:=POCALockCreate;
  result^.Globals.Semaphore:=POCASemaphoreCreate;
 end;
{$ifdef POCAHasJIT}
 result^.Globals.NativeCodeMemoryManager:=POCANativeCodeMemoryManagerCreate(result);
{$endif}
 result^.SourceFiles:=TStringList.Create;
 result^.IncludeDirectories:=TStringList.Create;
 begin
  result^.Globals.GarbageCollector.Lock:=POCALockCreate;
  result^.Globals.GarbageCollector.ProtectList:=TPOCAPointerList.Create;
  for Ghost:=false to true do begin
   GetMemAligned(result^.Globals.GarbageCollector.WhiteLists[Ghost],SizeOf(TPOCAGarbageCollectorLinkedList));
  end;
  GetMemAligned(result^.Globals.GarbageCollector.GrayList,SizeOf(TPOCAGarbageCollectorLinkedList));
  for Ghost:=false to true do begin
   GetMemAligned(result^.Globals.GarbageCollector.BlackLists[Ghost],SizeOf(TPOCAGarbageCollectorLinkedList));
  end;
  for Ghost:=false to true do begin
   GetMemAligned(result^.Globals.GarbageCollector.PersistentLists[Ghost],SizeOf(TPOCAGarbageCollectorLinkedList));
  end;
  for Ghost:=false to true do begin
   GetMemAligned(result^.Globals.GarbageCollector.PersistentRootLists[Ghost],SizeOf(TPOCAGarbageCollectorLinkedList));
  end;
  GetMemAligned(result^.Globals.GarbageCollector.WhiteGhostList,SizeOf(TPOCAGarbageCollectorLinkedList));
  for Ghost:=false to true do begin
   GetMemAligned(result^.Globals.GarbageCollector.SweepLists[Ghost],SizeOf(TPOCAGarbageCollectorLinkedList));
  end;
  for Ghost:=false to true do begin
   POCAGarbageCollectorLinkedListReset(result^.Globals.GarbageCollector.WhiteLists[Ghost]);
   POCAGarbageCollectorLinkedListReset(result^.Globals.GarbageCollector.BlackLists[Ghost]);
   POCAGarbageCollectorLinkedListReset(result^.Globals.GarbageCollector.PersistentLists[Ghost]);
   POCAGarbageCollectorLinkedListReset(result^.Globals.GarbageCollector.PersistentRootLists[Ghost]);
   POCAGarbageCollectorLinkedListReset(result^.Globals.GarbageCollector.SweepLists[Ghost]);
  end;
  POCAGarbageCollectorLinkedListReset(result^.Globals.GarbageCollector.GrayList);
  POCAGarbageCollectorLinkedListReset(result^.Globals.GarbageCollector.WhiteGhostList);
  result^.Globals.GarbageCollector.State:=pgcsINIT;
  result^.Globals.GarbageCollector.AllocationCounter:=0;
  result^.Globals.GarbageCollector.PersistentCycleCounter:=0;
  result^.Globals.GarbageCollector.PersistentForceScan:=false;
  result^.Globals.GarbageCollector.StepFactor:=64;
  result^.Globals.GarbageCollector.IntervalFactor:=16;
  result^.Globals.GarbageCollector.GhostFactor:=64;
  result^.Globals.GarbageCollector.SweepFactor:=64;
  result^.Globals.GarbageCollector.FlipFactor:=64;
  result^.Globals.GarbageCollector.PersistentThreshold:=16;
  result^.Globals.GarbageCollector.PersistentInterval:=0;
  result^.Globals.GarbageCollector.FullCollect:=true;
  result^.Globals.GarbageCollector.LocalContextPoolSize:=256;
  result^.Globals.GarbageCollector.ContextCacheSize:=128;
  result^.Globals.GarbageCollector.MinimumBlockSize:=1024;
  result^.Globals.GarbageCollector.ScanContextGrays:=0;
  result^.Globals.GarbageCollector.ScanPoolGrays:=0;
 end;
 begin
  result^.Globals.DeadAllocationCount:=256;
  for i:=0 to pvtCOUNT-1 do begin
   POCAPoolInit(result,@result^.Globals.Pools[i],i);
  end;
  result^.Globals.DeadSize:=256;
  result^.Globals.DeadCount:=0;
  GetMem(result^.Globals.DeadBlocks,result^.Globals.DeadSize*sizeof(pointer));
  FillChar(result^.Globals.DeadBlocks^,result^.Globals.DeadSize*sizeof(pointer),#0);
 end;
 begin
  result^.Globals.FreeContexts:=nil;
  result^.Globals.FirstContext:=nil;
  result^.Globals.LastContext:=nil;
 end;
 begin
  Context:=POCAContextCreate(result);
  try
   begin
    result^.Globals.SourceFiles:=POCANewArray(Context);
   end;
   begin
    result^.Globals.UniqueStringArray:=POCANewArray(Context);
    result^.Globals.UniqueStringHashMap:=TPOCAStringHashMap.Create(true);
    result^.Globals.UniqueStringLock:=POCALockCreate;
   end;
   begin
    result^.Globals.Symbols:=POCANewHash(Context);
    result^.Globals.Save:=POCANewArray(Context);
   end;
   begin
    result^.Globals.ArgumentsValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'arguments'));
    result^.Globals.ConstructorValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,ConstructorValueSymbolString));
    begin                    
     result^.Globals.NullValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Null'));
     result^.Globals.ReferenceValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Reference'));
     result^.Globals.NumberValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Number'));
     result^.Globals.StringValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'String'));
     result^.Globals.ArrayValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Array'));
     result^.Globals.GhostClassValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'GhostClass'));
     result^.Globals.ClassValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Class'));
     result^.Globals.GhostModuleValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'GhostModule'));
     result^.Globals.ModuleValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Module'));
     result^.Globals.GhostHashValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'GhostHash'));
     result^.Globals.HashValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Hash'));
     result^.Globals.FunctionValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Function'));
     result^.Globals.ClassGhostValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'ClassGhost'));
     result^.Globals.ModuleGhostValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'ModuleGhost'));
     result^.Globals.HashGhostValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'HashGhost'));
     result^.Globals.GhostValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Ghost'));
     result^.Globals.CodeValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Code'));
     result^.Globals.NativeCodeValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'NativeCode'));
     result^.Globals.UnknownValueReference:=POCAInternSymbol(Context,result,POCANewUniqueString(Context,'Unknown'));
    end;
   end;
   result^.Globals.HiddenNamespace:=POCANewHash(Context);
   result^.Globals.Namespace:=POCAInitGlobalNamespace(Context);
   result^.Globals.BaseClass:=POCAInitBaseClass(Context);
   begin
    result^.Globals.ArrayHash:=POCAInitArrayHash(Context);
    result^.Globals.NumberHash:=POCAInitNumberHash(Context);
    result^.Globals.StringHash:=POCAInitStringHash(Context);
    result^.Globals.RegExpHash:=POCAInitRegExpHash(Context);
    result^.Globals.CoroutineHash:=POCAInitCoroutineHash(Context);
    result^.Globals.ThreadHash:=POCAInitThreadHash(Context);
    result^.Globals.LockHash:=POCAInitLockHash(Context);
    result^.Globals.SemaphoreHash:=POCAInitSemaphoreHash(Context);
    begin
     POCAHashSetString(Context,result^.Globals.Namespace,'ArrayHash',result^.Globals.ArrayHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'NumberHash',result^.Globals.NumberHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'StringHash',result^.Globals.StringHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'RegExpHash',result^.Globals.RegExpHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'CoroutineHash',result^.Globals.CoroutineHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'ThreadHash',result^.Globals.ThreadHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'LockHash',result^.Globals.LockHash);
     POCAHashSetString(Context,result^.Globals.Namespace,'SemaphoreHash',result^.Globals.SemaphoreHash);
    end;
   end;
  finally
   POCAContextDestroy(Context);
  end;
 end;
end;

procedure POCAInstanceDestroy(var Instance:PPOCAInstance);
var CurrentContext{,NextContext}:PPOCAContext;
    //i:longint;
    Ghost:boolean;
begin
 if assigned(Instance) then begin
  try
   if assigned(Instance^.Globals.FirstContext) then begin

    CurrentContext:=Instance^.Globals.FirstContext;
    while assigned(CurrentContext) do begin
     if assigned(PPOCAThreadData(CurrentContext^.ThreadData)) then begin
      POCAThreadDestroy(PPOCAThreadData(CurrentContext^.ThreadData));
      CurrentContext^.ThreadData:=nil;
     end;
     CurrentContext:=CurrentContext^.Next;
    end;

    CurrentContext:=Instance^.Globals.FirstContext;
    while assigned(CurrentContext) do begin
     if assigned(CurrentContext^.CoroutineData) then begin
      if assigned(PPOCACoroutineData(CurrentContext^.CoroutineData)^.Coroutine) then begin
       POCACoroutineDestroy(PPOCACoroutineData(CurrentContext^.CoroutineData)^.Coroutine);
       PPOCACoroutineData(CurrentContext^.CoroutineData)^.Coroutine:=nil;
      end;
      PPOCACoroutineData(CurrentContext^.CoroutineData)^.Context:=nil;
      SetLength(PPOCACoroutineData(CurrentContext^.CoroutineData)^.Arguments,0);
      if assigned(PPOCACoroutineData(CurrentContext^.CoroutineData)^.ExceptionHolder) then begin
       FreeAndNil(PPOCACoroutineData(CurrentContext^.CoroutineData)^.ExceptionHolder);
      end;
      if POCAIsValueGhost(PPOCAThreadData(CurrentContext^.CoroutineData)^.Data) then begin
       PPOCAGhost(POCAGetValueReferencePointer(PPOCAThreadData(CurrentContext^.CoroutineData)^.Data))^.Ptr:=nil;
      end;
      PPOCAThreadData(CurrentContext^.CoroutineData)^.Data.Num:=0;
      Finalize(PPOCACoroutineData(CurrentContext^.CoroutineData)^);
      FillChar(PPOCAThreadData(CurrentContext^.CoroutineData)^,SizeOf(TPOCACoroutineData),#0);
      CurrentContext^.CoroutineData:=nil;
     end;
     CurrentContext:=CurrentContext^.Next;
    end;

    while assigned(Instance^.Globals.FirstContext) do begin
     POCAContextFree(Instance^.Globals.FirstContext);
    end;

   end;

   if assigned(Instance^.Globals.DeadBlocks) then begin
    FreeMem(Instance^.Globals.DeadBlocks);
    Instance^.Globals.DeadBlocks:=nil;
   end;

   for Ghost:=false to true do begin
    FreeMemAligned(Instance^.Globals.GarbageCollector.WhiteLists[Ghost]);

    FreeMemAligned(Instance^.Globals.GarbageCollector.BlackLists[Ghost]);

    FreeMemAligned(Instance^.Globals.GarbageCollector.PersistentLists[Ghost]);

    FreeMemAligned(Instance^.Globals.GarbageCollector.PersistentRootLists[Ghost]);

    FreeMemAligned(Instance^.Globals.GarbageCollector.SweepLists[Ghost]);
   end;

   FreeMemAligned(Instance^.Globals.GarbageCollector.GrayList);

   FreeMemAligned(Instance^.Globals.GarbageCollector.WhiteGhostList);

   FreeAndNil(Instance^.Globals.GarbageCollector.ProtectList);

{$ifdef POCAHasJIT}
   POCANativeCodeMemoryManagerDestroy(Instance^.Globals.NativeCodeMemoryManager);
{$endif}

   POCALockDestroy(Instance^.Globals.GarbageCollector.Lock);

   POCALockDestroy(Instance^.Globals.Lock);

   POCALockDestroy(Instance^.Globals.UniqueStringLock);

   POCASemaphoreDestroy(Instance^.Globals.Semaphore);

   FreeAndNil(Instance^.Globals.UniqueStringHashMap);

   FreeAndNil(Instance^.IncludeDirectories);

   FreeAndNil(Instance^.SourceFiles);
  finally
   Finalize(Instance^);
   Dispose(Instance);
   Instance:=nil;
  end;
 end;
end;

{$ifdef POCAHasJIT}
function POCAGenerateNativeCode(Context:PPOCAContext;Code:PPOCACode):boolean; forward;
{$endif}

type TPOCATokenPrecedenceRule=(prNONE,prBINARY,prREVERSE,prPREFIX,prSUFFIX);
     PPOCATokenPrecedence=^TPOCATokenPrecedence;
     TPOCATokenPrecedence=record
      Tokens:TPOCATokenTypes;
      Rule:TPOCATokenPrecedenceRule;
     end;
     PPOCATokenBinaryPrefix=^TPOCATokenBinaryPrefix;
     TPOCATokenBinaryPrefix=record
      BinaryToken:TPOCATokenType;
      PrefixToken:TPOCATokenType;
     end;
     PPOCABinaryToPrefixUnaryTokenCorrectionMap=^TPOCABinaryToPrefixUnaryTokenCorrectionMap;
     TPOCABinaryToPrefixUnaryTokenCorrectionMap=array[TPOCATokenType] of TPOCATokenType;
const POCATokenPrecedences:array[0..30] of TPOCATokenPrecedence=((Tokens:[ptSEMI,ptCOMMA,ptAUTOSEMI];Rule:prREVERSE),
                                                                 (Tokens:[ptELLIPSIS];Rule:prSUFFIX),
                                                                 (Tokens:[ptREGEXP];Rule:prPREFIX),
                                                                 (Tokens:[ptRETURN,ptBREAK,ptCONTINUE,ptTHROW,ptBREAKPOINT,ptDELETE];Rule:prPREFIX),
                                                                 (Tokens:[ptASSIGN,ptPLUSEQ,ptMINUSEQ,ptMULEQ,ptDIVEQ,ptCATEQ,ptBANDEQ,ptBOREQ,ptBXOREQ,ptBSHLEQ,ptBSHREQ,ptBUSHREQ,ptMODEQ,ptPOWEQ,ptELVISEQ];Rule:prREVERSE),
                                                                 (Tokens:[ptCOLON,ptQUESTION];Rule:prREVERSE),
                                                                 (Tokens:[ptINSTANCEOF,ptIN,ptIS];Rule:prBINARY),
                                                                 (Tokens:[ptDOTDOT];Rule:prREVERSE),
                                                                 (Tokens:[ptVAR,ptREGISTER,ptCONST];Rule:prPREFIX),
                                                                 (Tokens:[ptELVIS];Rule:prBINARY),
                                                                 (Tokens:[ptOR];Rule:prBINARY),
                                                                 (Tokens:[ptAND];Rule:prBINARY),
                                                                 (Tokens:[ptBOR];Rule:prBINARY),
                                                                 (Tokens:[ptBXOR];Rule:prBINARY),
                                                                 (Tokens:[ptBAND];Rule:prBINARY),
                                                                 (Tokens:[ptSEQ,ptSNEQ];Rule:prBINARY),
                                                                 (Tokens:[ptEQ,ptNEQ];Rule:prBINARY),
                                                                 (Tokens:[ptLT,ptLTEQ,ptGT,ptGTEQ];Rule:prBINARY),
                                                                 (Tokens:[ptREGEXPEQ,ptREGEXPNEQ];Rule:prBINARY),
                                                                 (Tokens:[ptBSHL,ptbSHR,ptBUSHR];Rule:prBINARY),
                                                                 (Tokens:[ptPLUS,ptMINUS,ptCAT];Rule:prBINARY),
                                                                 (Tokens:[ptCMP];Rule:prBINARY),
                                                                 (Tokens:[ptMUL,ptDIV,ptMOD,ptPOW];Rule:prBINARY),
                                                                 (Tokens:[ptNEW];Rule:prPREFIX),
                                                                 (Tokens:[ptMINUS,ptPLUS,ptNEG,ptNUM,ptNOT,ptCAT,ptBNOT];Rule:prPREFIX),
                                                                 (Tokens:[ptPREDEC,ptPREINC];Rule:prPREFIX),
                                                                 (Tokens:[ptPOSTDEC,ptPOSTINC];Rule:prSUFFIX),
                                                                 (Tokens:[ptLPAR,ptLBRA,ptSAFELBRA];Rule:prSUFFIX),
                                                                 (Tokens:[ptDOT,ptATDOT,ptSAFEDOT];Rule:prBINARY),
                                                                 (Tokens:[ptSYMBOLNAME];Rule:prSUFFIX),
                                                                 (Tokens:[ptAT];Rule:prBINARY));
      POCATokenBinaryPrefixes:array[0..2] of TPOCATokenBinaryPrefix=((BinaryToken:ptMINUS;PrefixToken:ptNEG),
                                                                     (BinaryToken:ptPLUS;PrefixToken:ptNUM),
                                                                     (BinaryToken:ptCAT;PrefixToken:ptBNOT));
var POCABinaryTokens:TPOCATokenTypes=[];
    POCAReverseTokens:TPOCATokenTypes=[];
    POCAPrefixTokens:TPOCATokenTypes=[];
    POCASuffixTokens:TPOCATokenTypes=[];
    POCABinaryOrPrefixTokens:TPOCATokenTypes=[];
    POCABinaryToPrefixUnaryTokenCorrectionMap:TPOCABinaryToPrefixUnaryTokenCorrectionMap;

function POCACompile(Instance:PPOCAInstance;Context:PPOCAContext;const Source:TPOCARawByteString;const SourceFileName:TPOCARawByteString=''):TPOCAValue;
type PPPOCAToken=^PPOCAToken;
     PPOCAToken=^TPOCAToken;
     TPOCAToken=packed record
      Token:TPOCATokenType;
      Visited:boolean;
      SourceFile,SourceLine,SourceColumn:longint;
      Str:TPOCARawByteString;
      Rule:TPOCATokenPrecedenceRule;
      Num:double;
      TokenListNext,Parent,Next,Previous:PPOCAToken;
      case byte of
       0:(Children,LastChild:PPOCAToken;);
       1:(Left,Right:PPOCAToken;);
     end;
     //PPOCAParser=^TPOCAParser;
     TPOCAParser=packed record
      Context:PPOCAContext;
      Error:TPOCARawByteString;
      ErrorLine:longint;
      Tree:TPOCAToken;
      SrcFile:TPOCAValue;
      SourceFile:longint;
     end;
     TPOCAPreprocessorInputSourceKind=(iskNONE,iskFILE,iskMACRO);
     TPOCAPreprocessorInputSource=record
      Kind:TPOCAPreprocessorInputSourceKind;
      Name:TPOCARawByteString;
      Index:longint;
     end;
     TPOCAPreprocessorInputSources=array of TPOCAPreprocessorInputSource;
     TPOCAPreprocessorPragmaInfoItem=record
      CharPos:longint;
      Pragma:TPOCARawByteString;
     end;
     TPOCAPreprocessorPragmaInfo=array of TPOCAPreprocessorPragmaInfoItem;
     TPOCAPreprocessorOutputInfoItem=record
      FirstCharPos,LastCharPos,Source,Line:longint;
     end;
     TPOCAPreprocessorOutputInfo=array of TPOCAPreprocessorOutputInfoItem;
     TPOCAPreprocessor=record
      InputKind:TPOCAPreprocessorInputSourceKind;
      InputName:TPOCARawByteString;
      InputText:TPOCARawByteString;
      InputSources:TPOCAPreprocessorInputSources;
      InputSourcesCount:longint;
      PragmaInfo:TPOCAPreprocessorPragmaInfo;
      PragmaInfoCount:longint;
      OutputInfo:TPOCAPreprocessorOutputInfo;
      OutputInfoCount:longint;
      OutputText:TPOCARawByteString;
      OutputTextLength:longint;
     end;
     TPOCAPreprocessorInstance=record
      Preprocessor:TPOCAPreprocessor;
      Source:longint;
      Line:longint;
     end;
var TokenList:PPOCAToken;
    PreprocessorInstance:TPOCAPreprocessorInstance;
 procedure ResetTokenVisited;
 var CurrentToken:PPOCAToken;
 begin
  CurrentToken:=TokenList;
  while assigned(CurrentToken) do begin
   CurrentToken^.Visited:=false;
   CurrentToken:=CurrentToken^.TokenListNext;
  end;
 end;
 procedure SyntaxError(const AMessage:TPOCAUTF8String;SourceFile,SourceLine,SourceColumn:longint);
 begin
  raise EPOCASyntaxError.Create(SourceFile,SourceLine,SourceColumn,AMessage);
 end;
 procedure ProcessPreprocessor(var ParserInstance:TPOCAPreprocessorInstance;var Parser:TPOCAParser);
 type //TChars=set of ansichar;
      TToken=(tNONE,tCHAR,tNUMBER,tNAME,tSTRING,TSTRINGLONG);
      TInputStackItem=record
       Source:longint;
       Buffer:TPOCARawByteString;
       BufferPosition,BufferLine:longint;
      end;
      TInputStack=array of TInputStackItem;
      TMacroFunction=(mfNONE,mfFILE,mfLINE,mfTIME,mfDATE,mfPRAGMA);
      TMacroBodyItemKind=(mbikTEXT,mbikPARAMETER,mbikVAARGS,mbikSPLITTER);
      TMacroBodyItem=record
       Kind:TMacroBodyItemKind;
       Value:longint;
       Text:TPOCARawByteString;
       Quote:boolean;
      end;
      TMacroBody=array of TMacroBodyItem;
      TMacro=record
       Defined:boolean;
       Name:TPOCARawByteString;
       Body:TMacroBody;
       Parameters:longint;
       VaArgs:boolean;
       MacroFunction:TMacroFunction;
      end;
      TMacros=array of TMacro;
 const{WhiteSpace:TChars=[#9,#11..#13,#32,#255];
       WhiteSpaceEx:TChars=[#9,#10..#13,#32,#255];}
       UCS4WhiteSpace=[9,11..13,32,255];
       UCS4WhiteSpaceEx=[9,10..13,32,255];
       kwNONE=0;
       kwINCLUDE=1;
       kwINCLUDENEXT=2;
       kwINCLUDEONCE=3;
       kwINCLUDENEXTONCE=4;
       kwDEFINE=5;
       kwUNDEF=6;
       kwIF=7;
       kwIFDEF=8;
       kwIFNDEF=9;
       kwELIF=10;
       kwELSE=11;
       kwENDIF=12;
       kwLINE=13;
       kwPRAGMA=14;
       kwERROR=15;
       kwWARNING=16;
 var InputStack:TInputStack;
     CurrentToken:TToken;
     CurrentTokenChar:TPOCAUCS4Char;
     CurrentTokenString:TPOCARawByteString;
     Macros:TMacros;
     IFNestedLevel,MacroLevel:longint;
     LastSource,LastLine:longint;
     InEval:boolean;
     MacroStringTree:TPOCAStringTree;
     KeywordStringTree:TPOCAStringTree;
  procedure AddWarning(const s:TPOCAUTF8String); forward;
  function GetInputSourceIndex(Kind:TPOCAPreprocessorInputSourceKind;Name:TPOCARawByteString):longint; forward;
  function hex2byte(c:TPOCAUCS4Char):longint;
  begin
   case c of
    ord('0')..ord('9'):begin
     result:=c-byte('0');
    end;
    ord('a')..ord('f'):begin
     result:=c-byte('a')+$a;
    end;
    ord('A')..ord('F'):begin
     result:=c-byte('F')+$a;
    end;
    else begin
     result:=0;
    end;
   end;
  end;
  function ProprocessInputSourceChars(Kind:TPOCAPreprocessorInputSourceKind;const Name,Body:TPOCARawByteString):TPOCAUTF8String;
  var i,OutLen,ls,ll:longint;
      sc:ansichar;
      OutStr,s:TPOCARawByteString;
   procedure AddChar(NewChar:ansichar);
   var NewLen:longint;
   begin
    NewLen:=OutLen+1;
    if NewLen>=length(OutStr) then begin
     SetLength(OutStr,POCARoundUpToPowerOfTwo(NewLen+1));
    end;
    OutStr[NewLen]:=NewChar;
    OutLen:=NewLen;
   end;
   procedure AddString(const NewString:TPOCARawByteString);
   var i:longint;
   begin
    for i:=1 to length(NewString) do begin
     AddChar(NewString[i]);
    end;
   end;
  begin
   result:='';
   ls:=LastSource;
   ll:=LastLine;
   try
    LastSource:=GetInputSourceIndex(Kind,Name);
    LastLine:=0;
    s:=Body;
    if (length(s)>=3) and ((s[1]=#$ef) and (s[2]=#$bb) and (s[3]=#$bf)) then begin
     delete(s,1,3);
    end;
    OutStr:='';
    SetLength(OutStr,4096);
    OutLen:=0;
    i:=1;
    while i<=length(s) do begin
     sc:=s[i];
     case sc of
      #10:begin
       if ((i+1)<=length(s)) and (s[i+1]=#13) then begin
        inc(i,2);
       end else begin
        inc(i);
       end;
       inc(LastLine);
       AddChar(#10);
      end;
      #13:begin
       if ((i+1)<=length(s)) and (s[i+1]=#10) then begin
        inc(i,2);
       end else begin
        inc(i);
       end;
       inc(LastLine);
       AddChar(#10);
      end;
      '\':begin
       if ((i+1)<=length(s)) and (s[i+1]='U') then begin
        if ((i+9)<=length(s)) and
           (s[i+2] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+3] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+4] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+5] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+6] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+7] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+8] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+9] in ['0'..'9','A'..'F','a'..'f']) then begin
         AddString(PUCUUTF32CharToUTF8((hex2byte(ord(s[i+2])) shl 28) or (hex2byte(ord(s[i+3])) shl 24) or (hex2byte(ord(s[i+4])) shl 20) or (hex2byte(ord(s[i+5])) shl 16) or (hex2byte(ord(s[i+6])) shl 12) or (hex2byte(ord(s[i+7])) shl 8) or (hex2byte(ord(s[i+8])) shl 4) or (hex2byte(ord(s[i+9])) shl 0)));
         inc(i,10);
        end else begin
         AddString('\U');
         inc(i,2);
        end;
       end else if ((i+1)<=length(s)) and (s[i+1]='u') then begin
        if ((i+5)<=length(s)) and
           (s[i+2] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+3] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+4] in ['0'..'9','A'..'F','a'..'f']) and
           (s[i+5] in ['0'..'9','A'..'F','a'..'f']) then begin
         AddString(PUCUUTF32CharToUTF8((hex2byte(ord(s[i+2])) shl 12) or (hex2byte(ord(s[i+3])) shl 8) or (hex2byte(ord(s[i+4])) shl 4) or (hex2byte(ord(s[i+5])) shl 0)));
         inc(i,6);
        end else begin
         AddString('\u');
         inc(i,2);
        end;
       end else if ((i+1)<=length(s)) and (s[i+1]=#13) then begin
        AddChar('\');
        inc(i);
       end else begin
        AddChar('\');
        AddChar(s[i+1]);
        inc(i,2);
       end;
      end;
      else begin
       AddChar(sc);
       inc(i);
      end;
     end;
    end;
    result:=copy(OutStr,1,OutLen);
   finally
    OutStr:='';
    LastSource:=ls;
    LastLine:=ll;
   end;
  end;
  function LookUpKeyword(const Name:TPOCARawByteString):longint;
  var d:TPOCAStringTreeData;
  begin
   result:=kwNONE;
   d:=0;
   if KeywordStringTree.Find(Name,d) then begin
    result:=TPOCAPtrInt(d);
   end;
  end;
  function LookUpEx(const Name:TPOCARawByteString):longint;
  var d:TPOCAStringTreeData;
  begin
   result:=-1;
   d:=0;
   if MacroStringTree.Find(Name,d) then begin
    result:=TPOCAPtrInt(d);
   end;
  end;
  function LookUp(const Name:TPOCARawByteString):longint;
  begin
   result:=LookUpEx(Name);
   if result>=0 then begin
    if not Macros[result].Defined then begin
     result:=-1;
    end;
   end;
  end;
  procedure AddDefine(const Name:TPOCARawByteString;Body:TMacroBody;Parameters:longint;VaArgs:boolean;MacroFunction:TMacroFunction);
  var i:longint;
  begin
   i:=LookUpEx(Name);
   if i<0 then begin
    i:=length(Macros);
    SetLength(Macros,i+1);
   end;
   Macros[i].Defined:=true;
   Macros[i].Name:=Name;
   Macros[i].Body:=copy(Body,0,length(Body));
   Macros[i].Parameters:=Parameters;
   Macros[i].VaArgs:=VaArgs;
   Macros[i].MacroFunction:=MacroFunction;
   MacroStringTree.Add(Name,i,true);
  end;
  procedure RemoveDefine(const Name:TPOCARawByteString);
  var i:longint;
  begin
   i:=LookUpEx(Name);
   if i>=0 then begin
    Macros[i].Defined:=false;
   end;
  end;
  function GetInputSourceIndex(Kind:TPOCAPreprocessorInputSourceKind;Name:TPOCARawByteString):longint;
  var i,j:longint;
  begin
   for i:=0 to ParserInstance.Preprocessor.InputSourcesCount-1 do begin
    if (ParserInstance.Preprocessor.InputSources[i].Kind=Kind) and (ParserInstance.Preprocessor.InputSources[i].Name=Name) then begin
     result:=i;
     exit;
    end;
   end;
   result:=ParserInstance.Preprocessor.InputSourcesCount;
   inc(ParserInstance.Preprocessor.InputSourcesCount);
   if (result+1)>length(ParserInstance.Preprocessor.InputSources) then begin
    SetLength(ParserInstance.Preprocessor.InputSources,POCARoundUpToPowerOfTwo(result+2));
   end;
   ParserInstance.Preprocessor.InputSources[result].Kind:=Kind;
   ParserInstance.Preprocessor.InputSources[result].Name:=Name;
   case Kind of
    iskMACRO:begin
     Name:='MACRO('+Name+')';
    end;
   end;
   j:=Instance^.SourceFiles.IndexOf(String(Name));
   if j<0 then begin
    j:=Instance^.SourceFiles.Add(String(Name));
    if j=longint(POCAArraySize(Context^.Instance.Globals.SourceFiles)) then begin
     POCAArrayPush(Context^.Instance.Globals.SourceFiles,POCANewString(Context,Name));
    end else begin
     POCAArraySetSize(Context^.Instance.Globals.SourceFiles,Instance^.SourceFiles.Count);
     for i:=0 to Instance^.SourceFiles.Count-1 do begin
      POCAArraySet(Context^.Instance.Globals.SourceFiles,i,POCANewString(Context,TPOCARawByteString(Instance^.SourceFiles[i])));
     end;
    end;
   end;
   ParserInstance.Preprocessor.InputSources[result].Index:=j;
  end;
  procedure PushInputSource(Kind:TPOCAPreprocessorInputSourceKind;const Name,Text:TPOCARawByteString);
  var i:longint;
  begin
   i:=length(InputStack);
   SetLength(InputStack,i+1);
   InputStack[i].Source:=GetInputSourceIndex(Kind,Name);
   InputStack[i].Buffer:=Text;
   InputStack[i].BufferPosition:=1;
   InputStack[i].BufferLine:=0;
  end;
  procedure PopInputSource;
  var i:longint;
  begin
   if length(InputStack)>0 then begin
    i:=length(InputStack)-1;
    SetLength(InputStack,i);
   end;
  end;
  function NextChar:TPOCAUCS4Char;
  var i:longint;
  begin
   result:=0;
   i:=length(InputStack)-1;
   while i>=0 do begin
    if InputStack[i].BufferPosition<=length(InputStack[i].Buffer) then begin
     if (InputStack[i].Source>=0) and (ParserInstance.Preprocessor.InputSources[InputStack[i].Source].Kind=iskFILE) then begin
      LastSource:=InputStack[i].Source;
      LastLine:=InputStack[i].BufferLine;
      ParserInstance.Source:=LastSource;
      ParserInstance.Line:=LastLine;
     end;
     if ((InputStack[i].BufferPosition+2)<=length(InputStack[i].Buffer)) and
        (InputStack[i].Buffer[InputStack[i].BufferPosition+0]=#$ef) and
        (InputStack[i].Buffer[InputStack[i].BufferPosition+1]=#$bf) and
        (InputStack[i].Buffer[InputStack[i].BufferPosition+2]=#$bd) then begin
      result:=-1;
      inc(InputStack[i].BufferPosition,3);
     end else begin
      result:=PUCUUTF8CodeUnitGetCharAndIncFallback(InputStack[i].Buffer,InputStack[i].BufferPosition);
      if result=10 then begin
       inc(InputStack[i].BufferLine);
      end;
     end;
     if InputStack[i].BufferPosition>length(InputStack[i].Buffer) then begin
      PopInputSource;
     end;
     break;
    end else begin
     PopInputSource;
     i:=length(InputStack)-1;
    end;
   end;
  end;
  function GetCharAt(j:longint=0):TPOCAUCS4Char;
  var i,p:longint;
  begin
   result:=0;
   i:=length(InputStack)-1;
   while (i>=0) and (j>=0) do begin
    p:=InputStack[i].BufferPosition;
    while (p<=length(InputStack[i].Buffer)) and (j>=0) do begin
     if ((p+2)<=length(InputStack[i].Buffer)) and
         (InputStack[i].Buffer[p+0]=#$ef) and
         (InputStack[i].Buffer[p+1]=#$bf) and
         (InputStack[i].Buffer[p+2]=#$bd) then begin
      result:=-1;
      inc(p,3);
     end else begin
      result:=PUCUUTF8CodeUnitGetCharAndIncFallback(InputStack[i].Buffer,p);
     end;
     dec(j);
    end;
    dec(i);
   end;
   if j>0 then begin
    result:=0;
   end;
  end;
  function GetToken:TToken;
  var lc,c,sc:TPOCAUCS4Char;
      cc,i,j:longint;
  begin
   result:=tNONE;
   c:=NextChar;
   case c of
    ord('/'):begin
     if MacroLevel=0 then begin
      c:=GetCharAt(0);
      case c of
       ord('/'):begin
        NextChar;
        c:=NextChar;
        while not (c in [0,10]) do begin
         c:=NextChar;
        end;
        result:=tCHAR;
        CurrentToken:=tCHAR;
        CurrentTokenChar:=c;
        CurrentTokenString:=PUCUUTF32CharToUTF8(c);
       end;
       ord('*'):begin
        NextChar;
        lc:=0;
        c:=NextChar;
        cc:=1;
        repeat
         if (lc=ord('/')) and (c=ord('*')) then begin
          inc(cc);
          c:=0;
         end else if (lc=ord('*')) and (c=ord('/')) then begin
          dec(cc);
          if cc=0 then begin
           break;
          end;
         end;
         lc:=c;
         c:=NextChar;
        until false;
        c:=ord(' ');
        result:=tCHAR;
        CurrentToken:=tCHAR;
        CurrentTokenChar:=c;
        CurrentTokenString:=PUCUUTF32CharToUTF8(c);
       end;
       else begin
        c:=ord('/');
        result:=tCHAR;
        CurrentToken:=tCHAR;
        CurrentTokenChar:=c;
        CurrentTokenString:=PUCUUTF32CharToUTF8(c);
       end;
      end;
     end else begin
      c:=ord('/');
      result:=tCHAR;
      CurrentToken:=tCHAR;
      CurrentTokenChar:=c;
      CurrentTokenString:=PUCUUTF32CharToUTF8(c);
     end;
    end;
    ord('0')..ord('9'):begin
     result:=tNUMBER;
     CurrentToken:=result;
     CurrentTokenString:=PUCUUTF32CharToUTF8(c);
     i:=0;
     while GetCharAt(i) in [ord('A')..ord('Z'),ord('a')..ord('z'),ord('_'),ord('0')..ord('9')] do begin
      inc(i);
     end;
     while i>0 do begin
      CurrentTokenString:=CurrentTokenString+PUCUUTF32CharToUTF8(NextChar);
      dec(i);
     end;
    end;
    ord('"'):begin
     CurrentTokenString:='"';
     i:=0;
     repeat
      c:=GetCharAt(i);
      if (c=ord('"')) or (c=0) then begin
       inc(i);
       break;
      end else if c=ord('\') then begin
       if (GetCharAt(i+1)=ord('{')) then begin
        inc(i,2);
        j:=0;
        repeat
         c:=GetCharAt(i);
         if c=ord('{') then begin
          inc(j);
         end else if c=ord('}') then begin
          if j=0 then begin
           break;
          end else begin
           dec(j);
          end;
         end else if c=0 then begin
          break;
         end else begin
          inc(i);
         end;
        until false;
       end else begin
        inc(i,2);
       end;
      end else begin
       inc(i);
      end;
     until false;
     while i>0 do begin
      CurrentTokenString:=CurrentTokenString+PUCUUTF32CharToUTF8(NextChar);
      dec(i);
     end;
     result:=tSTRING;
     CurrentToken:=tSTRING;
    end;
    ord(''''):begin
     CurrentTokenString:='''';
     i:=0;
     repeat
      c:=GetCharAt(i);
      if (c=ord('''')) and (GetCharAt(i+1)=ord('''')) then begin
       inc(i,2);
      end else if (c=ord('''')) or (c=0) then begin
       inc(i);
       break;
      end else begin
       inc(i);
      end;
     until false;
     while i>0 do begin
      CurrentTokenString:=CurrentTokenString+PUCUUTF32CharToUTF8(NextChar);
      dec(i);
     end;
     result:=tSTRING;
     CurrentToken:=tSTRING;
    end;
    else begin
     if (c=ord('L')) and (GetCharAt(0) in [ord(''''),ord('"')]) then begin
      c:=NextChar;
      sc:=c;
      CurrentTokenString:=PUCUUTF32CharToUTF8(sc);
      i:=0;
      repeat
       c:=GetCharAt(i);
       if (c=sc) or (c=0) then begin
        inc(i);
        break;
       end else if c=10 then begin
        break;
       end else if c=ord('\') then begin
        inc(i,2);
       end else begin
        inc(i);
       end;
      until false;
      while i>0 do begin
       CurrentTokenString:=CurrentTokenString+PUCUUTF32CharToUTF8(NextChar);
       dec(i);
      end;
      result:=tSTRINGLONG;
      CurrentToken:=tSTRINGLONG;
     end else if (c in [ord('A')..ord('Z'),ord('a')..ord('z'),ord('_')]) or (c>255) then begin
      result:=tNAME;
      CurrentToken:=result;
      CurrentTokenString:=PUCUUTF32CharToUTF8(c);
      i:=0;
      c:=GetCharAt(i);
      while (c in [ord('A')..ord('Z'),ord('a')..ord('z'),ord('_'),ord('0')..ord('9')]) or (c>255) do begin
       inc(i);
       c:=GetCharAt(i);
      end;
      while i>0 do begin
       CurrentTokenString:=CurrentTokenString+PUCUUTF32CharToUTF8(NextChar);
       dec(i);
      end;
     end else begin
      result:=tCHAR;
      CurrentToken:=tCHAR;
      CurrentTokenChar:=c;
      CurrentTokenString:=PUCUUTF32CharToUTF8(c);
     end;
    end;
   end;
  end;
  procedure SkipGetToken; forward;
  procedure SkipExtGetToken; forward;
  procedure AddError(const s:TPOCAUTF8String); forward;
  procedure SkipBlankEx; forward;
  function Destringize(const s:TPOCARawByteString):TPOCARawByteString;
  var i:longint;
      c,sc,nc:TPOCAUCS4Char;
  begin
   result:='';
   i:=1;
   while i<=length(s) do begin
    sc:=PUCUUTF8CodeUnitGetCharAndIncFallback(s,i);
    case sc of
     ord('\'):begin
      if i<=length(s) then begin
       nc:=PUCUUTF8CodeUnitGetCharAndIncFallback(s,i);
       case nc of
        ord('a'):begin
         result:=result+#7;
        end;
        ord('b'):begin
         result:=result+#8;
        end;
        ord('t'):begin
         result:=result+#9;
        end;
        ord('n'):begin
         result:=result+#10;
        end;
        ord('v'):begin
         result:=result+#11;
        end;
        ord('f'):begin
         result:=result+#12;
        end;
        ord('r'):begin
         result:=result+#13;
        end;
        ord('\'):begin
         result:=result+'\';
        end;
        ord(''''):begin
         result:=result+'''';
        end;
        ord('"'):begin
         result:=result+'"';
        end;
        ord('?'):begin
         result:=result+'?';
        end;
        ord('U'):begin
         if ((i+7)<=length(s)) and
            (s[i+0] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+1] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+2] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+3] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+4] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+5] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+6] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+7] in ['0'..'9','A'..'F','a'..'f']) then begin
          c:=(hex2byte(ord(s[i+0])) shl 28) or (hex2byte(ord(s[i+1])) shl 24) or (hex2byte(ord(s[i+2])) shl 20) or (hex2byte(ord(s[i+3])) shl 16) or (hex2byte(ord(s[i+4])) shl 12) or (hex2byte(ord(s[i+5])) shl 8) or (hex2byte(ord(s[i+6])) shl 4) or (hex2byte(ord(s[i+7])) shl 0);
          inc(i,8);
          result:=result+PUCUUTF32CharToUTF8(c);
         end else begin
          result:=result+'\U';
         end;
        end;
        ord('u'):begin
         if ((i+4)<=length(s)) and
            (s[i+0] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+1] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+2] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+3] in ['0'..'9','A'..'F','a'..'f']) then begin
          c:=(hex2byte(ord(s[i+0])) shl 12) or (hex2byte(ord(s[i+1])) shl 8) or (hex2byte(ord(s[i+2])) shl 4) or (hex2byte(ord(s[i+3])) shl 0);
          inc(i,4);
          result:=result+PUCUUTF32CharToUTF8(c);
         end else begin
          result:=result+'\u';
         end;
        end;
        ord('x'),ord('X'):begin
         if ((i+2)<length(s)) and
            (s[i+0] in ['0'..'9','A'..'F','a'..'f']) and
            (s[i+1] in ['0'..'9','A'..'F','a'..'f']) then begin
          c:=(hex2byte(ord(s[i+0])) shl 4) or (hex2byte(ord(s[i+1])) shl 0);
          inc(i,2);
          result:=result+PUCUUTF32CharToUTF8(c);
         end else begin
          result:=result+('\'+PUCUUTF32CharToUTF8(nc));
         end;
        end;
        ord('0')..ord('7'):begin
         c:=nc-ord('0');
         while (i<=length(s)) and (s[i] in ['0'..'7']) do begin
          c:=(c*8)+(ord(s[i])-ord('0'));
          inc(i);
         end;
         result:=result+PUCUUTF32CharToUTF8(c);
        end;
        else begin
         result:=result+PUCUUTF32CharToUTF8(nc);
        end;
       end;
      end;
     end;
     else begin
      result:=result+PUCUUTF32CharToUTF8(sc);
     end;
    end;
   end;
  end;
  function Stringize(const s:TPOCARawByteString;q:boolean):TPOCARawByteString;
  const hexchars:array[0..$f] of ansichar='0123456789ABCDEF';
  var i:longint;
      c:TPOCAUCS4Char;
  begin
  result:='';
   if q then begin
    i:=1;
    while i<=length(s) do begin
     c:=PUCUUTF8CodeUnitGetCharAndIncFallback(s,i);
     case c of
      0:begin
       result:=result+'\0';
      end;
      7:begin
       result:=result+'\a';
      end;
      8:begin
       result:=result+'\b';
      end;
      9:begin
       result:=result+'\t';
      end;
      10:begin
       result:=result+'\n';
      end;
      11:begin
       result:=result+'\v';
      end;
      12:begin
       result:=result+'\f';
      end;
      13:begin
       result:=result+'\r';
      end;
      ord('\'):begin
       result:=result+'\\';
      end;
      ord(''''):begin
       result:=result+'\''';
      end;
      ord('"'):begin
       result:=result+'\"';
      end;
      ord('?'):begin
       result:=result+'\?';
      end;
      else begin
       if c<128 then begin
        result:=result+PUCUUTF32CharToUTF8(c);
       end else if c<=$ffff then begin
        result:=result+'\u'+hexchars[(c shr 12) and $f]+hexchars[(c shr 8) and $f]+hexchars[(c shr 4) and $f]+hexchars[c and $f];
       end else begin
        result:=result+'\U'+hexchars[(c shr 28) and $f]+hexchars[(c shr 24) and $f]+hexchars[(c shr 20) and $f]+hexchars[(c shr 16) and $f]+hexchars[(c shr 12) and $f]+hexchars[(c shr 8) and $f]+hexchars[(c shr 4) and $f]+hexchars[c and $f];
       end;
      end;
     end;
    end;
   end else begin
    result:=s;
   end;
  end;
  procedure ExtGetToken;
  var mi,i,j,k,NestedLevel,pc:longint;
      b:TPOCARawByteString;
      Parameters:array of TPOCARawByteString;
      InputStackItem:TInputStackItem;
  begin
   b:='';
   Parameters:=nil;
   repeat
    if length(InputStack)>0 then begin
     InputStackItem:=InputStack[length(InputStack)-1];
    end else begin
     InputStackItem.Source:=-1;
    end;
    if GetToken<>tNAME then begin
     break;
    end;
    mi:=LookUp(CurrentTokenString);
    if mi<0 then begin
     break;
    end;
    if Macros[mi].MacroFunction<>mfNONE then begin
     case Macros[mi].MacroFunction of
      mfFILE:begin
       if InputStackItem.Source>=0 then begin
        PushInputSource(iskMACRO,Macros[mi].Name,'"'+Stringize(ParserInstance.Preprocessor.InputSources[InputStackItem.Source].Name,true)+'"');
       end else begin
        AddError(Macros[mi].Name+': Unknown file');
        continue;
       end;
      end;
      mfLINE:begin
       if InputStackItem.Source>=0 then begin
        PushInputSource(iskMACRO,Macros[mi].Name,TPOCARawByteString(IntToStr(InputStackItem.BufferLine+1)));
       end else begin
        AddError(Macros[mi].Name+': Unknown line number');
        continue;
       end;
      end;
      mfTIME:begin
       PushInputSource(iskMACRO,Macros[mi].Name,'"'+TPOCAUTF8String(FormatDateTime('hh:nn:ss',Now))+'"');
      end;
      mfDATE:begin
       PushInputSource(iskMACRO,Macros[mi].Name,'"'+TPOCAUTF8String(FormatDateTime('mmm dd yyyy',Now))+'"');
      end;
      mfPRAGMA:begin
       SkipGetToken;
       if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('('))) then begin
        AddError(Macros[mi].Name+': missing (');
        exit;
       end;
       SkipGetToken;
       if CurrentToken<>tSTRING then begin
        AddError(Macros[mi].Name+': string was expected');
        exit;
       end;
       i:=ParserInstance.Preprocessor.PragmaInfoCount;
       inc(ParserInstance.Preprocessor.PragmaInfoCount);
       if (i+1)>length(ParserInstance.Preprocessor.PragmaInfo) then begin
        SetLength(ParserInstance.Preprocessor.PragmaInfo,POCARoundUpToPowerOfTwo(i+2));
       end;
       ParserInstance.Preprocessor.PragmaInfo[i].CharPos:=ParserInstance.Preprocessor.OutputTextLength+1;
       if length(CurrentTokenString)<2 then begin
        AddError(Macros[mi].Name+': string not closed');
        exit;
       end;
       if CurrentTokenString[1]<>CurrentTokenString[length(CurrentTokenString)] then begin
        AddError(Macros[mi].Name+': invalid string');
        exit;
       end;
       ParserInstance.Preprocessor.PragmaInfo[i].Pragma:=Destringize(copy(CurrentTokenString,2,length(CurrentTokenString)-2));
       SkipGetToken;
       if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord(')'))) then begin
        AddError(Macros[mi].Name+': missing )');
        exit;
       end;
      end;
      else begin
       AddError(Macros[mi].Name+': Unknown macro function');
       continue;
      end;
     end;
    end else if (Macros[mi].Parameters=0) and not Macros[mi].VaArgs then begin
     b:='';
     for i:=0 to length(Macros[mi].Body)-1 do begin
      case Macros[mi].Body[i].Kind of
       mbikTEXT:begin
        b:=b+Stringize(Macros[mi].Body[i].Text,Macros[mi].Body[i].Quote);
       end;
      end;
     end;
     inc(MacroLevel);
     PushInputSource(iskMACRO,Macros[mi].Name,b);
     dec(MacroLevel);
    end else if (Macros[mi].Parameters>0) or Macros[mi].VaArgs then begin
     SkipGetToken;
     if (Macros[mi].Parameters>0) and not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('('))) then begin
      AddError(Macros[mi].Name+': missing (');
      exit;
     end else if (Macros[mi].Parameters=0) and Macros[mi].VaArgs and not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('('))) then begin
 {    exit;}
     end;
     SetLength(Parameters,0);
     if (Macros[mi].Parameters>0) or ((Macros[mi].Parameters=0) and ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('(')))) then begin
      SkipGetToken;
      while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,ord(')')])) do begin
       while (CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpaceEx) do begin
        GetToken;
       end;
       SetLength(b,0);
       NestedLevel:=0;
       repeat
        if (CurrentToken=tCHAR) and (CurrentTokenChar=0) then begin
         break;
        end else if (NestedLevel=0) and ((CurrentToken=tCHAR) and (CurrentTokenChar in [ord(','),ord(')')])) then begin
         break;
        end else if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('(')) then begin
         b:=b+'(';
         inc(NestedLevel);
        end else if (CurrentToken=tCHAR) and (CurrentTokenChar=ord(')')) then begin
         b:=b+')';
         dec(NestedLevel);
        end else begin
         b:=b+CurrentTokenString;
        end;
        ExtGetToken;
       until false;
       if (CurrentToken=tCHAR) and (CurrentTokenChar=ord(',')) then begin
        SkipGetToken;
       end;
       pc:=length(Parameters);
       SetLength(Parameters,pc+1);
       Parameters[pc]:=copy(b,0,length(b));
      end;
      if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord(')'))) then begin
       AddError(Macros[mi].Name+': missing )');
       continue;
      end;
     end;
     if (length(Parameters)<Macros[mi].Parameters) or ((length(Parameters)>Macros[mi].Parameters) and not Macros[mi].VaArgs) then begin
      AddError(Macros[mi].Name+': Wrong amount of parameters');
      continue;
     end;
     k:=1;
     b:='';
     for i:=0 to length(Macros[mi].Body)-1 do begin
      if Macros[mi].Body[i].Quote then begin
       b:=b+'"';
      end;
      case Macros[mi].Body[i].Kind of
       mbikTEXT:begin
        if (i>1) and (Macros[mi].Body[i].Kind<>mbikTEXT) then begin
         k:=length(b);
        end;
        b:=b+Stringize(Macros[mi].Body[i].Text,Macros[mi].Body[i].Quote);
       end;
       mbikPARAMETER:begin
        if Macros[mi].Body[i].Value<length(Parameters) then begin
         b:=b+Stringize(Parameters[Macros[mi].Body[i].Value],Macros[mi].Body[i].Quote);
         k:=length(b)+1;
        end;
       end;
       mbikVAARGS:begin
        if length(Parameters)<=Macros[mi].Parameters then begin
         for j:=length(b) downto k+1 do begin
          if (ord(b[j]) in UCS4WhiteSpaceEx) then begin
          end else begin
           case b[j] of
            ',':begin
             b:=copy(b,1,j-1);
             break;
            end;
            else begin
             break;
            end;
           end;
          end;
         end;
        end else begin
         for j:=Macros[mi].Parameters to length(Parameters)-1 do begin
          b:=b+Stringize(Parameters[j],Macros[mi].Body[i].Quote);
          if ((j+1)<length(Parameters)) then begin
           b:=b+',';
          end;
         end;
         k:=length(b)+1;
        end;
       end;
       mbikSPLITTER:begin
        b:=b+#$ef#$bf#$bd; // UCS4AddChar(b,-1);
       end;
      end;
      if Macros[mi].Body[i].Quote then begin
       b:=b+'"';
      end;
     end;
     inc(MacroLevel);
     PushInputSource(iskMACRO,Macros[mi].Name,b);
     dec(MacroLevel);
    end;
   until false;
   SetLength(Parameters,0);
  end;
  procedure SkipGetToken;
  begin
   repeat
    GetToken;
    if (CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpace) then begin
     continue;
    end;
    break;
   until false;
  end;
  procedure SkipEOL;
  var i:longint;
  begin
   i:=0;
   while not (GetCharAt(i) in [0,10]) do begin
    inc(i);
   end;
   while i>0 do begin
    NextChar;
    dec(i);
   end;
  end;
  procedure SkipBlankEx;
  var i:longint;
  begin
   i:=0;
   while GetCharAt(i) in UCS4WhiteSpaceEx do begin
    inc(i);
   end;
   while i>0 do begin
    NextChar;
    dec(i);
   end;
  end;
  procedure SkipBlank;
  var i:longint;
  begin
   i:=0;
   while GetCharAt(i) in UCS4WhiteSpaceEx do begin
    inc(i);
   end;
   while i>0 do begin
    NextChar;
    dec(i);
   end;
  end;
  procedure SkipExtGetToken;
  begin
   repeat
    ExtGetToken;
    if (CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpace) then begin
     continue;
    end;
    break;
   until false;
  end;
  procedure AddError(const s:TPOCAUTF8String);
  begin
   SyntaxError(s,-1,-1,-1);
  end;
  procedure AddWarning(const s:TPOCAUTF8String);
  begin
  end;
  procedure AddToOutput(const s:TPOCARawByteString);
  var l,i:longint;
  begin
   l:=length(s);
   if l>0 then begin
    if (ParserInstance.Preprocessor.OutputInfoCount>0) then begin
     if ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].LastCharPos<>(ParserInstance.Preprocessor.OutputTextLength-1) then begin
      ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].LastCharPos:=(ParserInstance.Preprocessor.OutputTextLength-1);
     end;
     if (ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].Source<>LastSource) or
        (ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].Line<>LastLine) then begin
      i:=ParserInstance.Preprocessor.OutputInfoCount;
      inc(ParserInstance.Preprocessor.OutputInfoCount);
      if (i+1)>length(ParserInstance.Preprocessor.OutputInfo) then begin
       SetLength(ParserInstance.Preprocessor.OutputInfo,POCARoundUpToPowerOfTwo(i+2));
      end;
      ParserInstance.Preprocessor.OutputInfo[i].FirstCharPos:=ParserInstance.Preprocessor.OutputTextLength;
      ParserInstance.Preprocessor.OutputInfo[i].LastCharPos:=ParserInstance.Preprocessor.OutputTextLength;
      ParserInstance.Preprocessor.OutputInfo[i].Source:=LastSource;
      ParserInstance.Preprocessor.OutputInfo[i].Line:=LastLine;
     end;
    end else begin
     i:=ParserInstance.Preprocessor.OutputInfoCount;
     inc(ParserInstance.Preprocessor.OutputInfoCount);
     if (i+1)>length(ParserInstance.Preprocessor.OutputInfo) then begin
      SetLength(ParserInstance.Preprocessor.OutputInfo,POCARoundUpToPowerOfTwo(i+2));
     end;
     ParserInstance.Preprocessor.OutputInfo[i].FirstCharPos:=ParserInstance.Preprocessor.OutputTextLength;
     ParserInstance.Preprocessor.OutputInfo[i].LastCharPos:=ParserInstance.Preprocessor.OutputTextLength;
     ParserInstance.Preprocessor.OutputInfo[i].Source:=LastSource;
     ParserInstance.Preprocessor.OutputInfo[i].Line:=LastLine;
    end;
    begin
     i:=ParserInstance.Preprocessor.OutputTextLength+l;
     if length(ParserInstance.Preprocessor.OutputText)<=i then begin
      SetLength(ParserInstance.Preprocessor.OutputText,POCARoundUpToPowerOfTwo(i+1));
     end;
     Move(s[1],ParserInstance.Preprocessor.OutputText[ParserInstance.Preprocessor.OutputTextLength+1],l);
     ParserInstance.Preprocessor.OutputTextLength:=i;
    end;
   end;
  end;
  function ParseNumber(s:TPOCARawByteString):longint;
  var i:longint;
      sv:longint;
      b:boolean;
  begin
   b:=false;
   while (length(s)>0) and (s[length(s)] in ['l','L','u','U']) do begin
    Delete(s,length(s),1);
   end;
   if (length(s)>0) and (s[1]='0') then begin
    if (length(s)>1) and (s[2] in ['x','X']) then begin
     result:=0;
     for i:=3 to length(s) do begin
      if (not b) and (((result*16) div 16)<>result) then begin
       b:=true;
       AddWarning('TERM: constant too large for destination type');
      end;
      case s[i] of
       '0'..'9':begin
        sv:=ord(s[i])-ord('0');
       end;
       'a'..'f':begin
        sv:=(ord(s[i])-ord('a'))+$a;
       end;
       'A'..'F':begin
        sv:=(ord(s[i])-ord('A'))+$a;
       end;
       else begin
        sv:=0;
       end;
      end;
      result:=(result*16)+sv;
     end;
    end else begin
     result:=0;
     for i:=2 to length(s) do begin
      if (not b) and (((result*8) div 8)<>result) then begin
       b:=true;
       AddWarning('TERM: constant too large for destination type');
      end;
      result:=(result*8)+(ord(s[i])-ord('0'));
     end;
    end;
   end else begin
    result:=0;
    for i:=1 to length(s) do begin
     if (not b) and (((result*10) div 10)<>result) then begin
      b:=true;
      AddWarning('TERM: constant too large for destination type');
     end;
     result:=(result*10)+(ord(s[i])-ord('0'));
    end;
   end;
  end;
  procedure DoINCLUDE(DoIncludeNext,DoIncludeOnce:boolean);
  var cfn,fn,ffn,d,t2:TPOCARawByteString;
      c,m:TPOCAUCS4Char;
      OK:boolean;
      t:TPOCARawByteString;
      f:file;
      fm:byte;
      i:longint;
  begin
   cfn:='';
   if DoIncludeNext then begin
    AddWarning('#include_next is a GCC extension!');
    if (LastSource>=0) and (LastSource<ParserInstance.Preprocessor.InputSourcesCount) then begin
     cfn:=copy(ParserInstance.Preprocessor.InputSources[LastSource].Name,0,length(ParserInstance.Preprocessor.InputSources[LastSource].Name));
    end;
   end;
   d:='';
   t2:='';
   fn:='';
   ffn:='';
   SkipExtGetToken;
   if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('<')) then begin
    OK:=false;
    repeat
     c:=NextChar;
     if c=ord('>') then begin
      OK:=true;
      break;
     end else if c in [0,10] then begin
      break;
     end else begin
      fn:=fn+PUCUUTF32CharToUTF8(c);
     end;
    until false;
    if not OK then begin
     AddError('#include: missing >');
     exit;
    end;
    m:=ord('<');
   end else if (CurrentToken=tSTRING) and (length(CurrentTokenString)>1) and (CurrentTokenString[1]='"') then begin
    if CurrentTokenString[length(CurrentTokenString)]<>'"' then begin
     AddError('#include: missing "');
     exit;
    end;
    fn:=copy(CurrentTokenString,2,length(CurrentTokenString)-2);
    m:=ord('"');
   end else begin
    AddError('#include: missing filename');
    exit;
   end;
   ffn:='';
   if (m=ord('"')) and (ParserInstance.Preprocessor.InputSourcesCount>0) and fileexists(String(ExtractFilePath(String(ParserInstance.Preprocessor.InputSources[0].Name))+String(fn))) then begin
    ffn:=TPOCAUTF8String(ExtractFilePath(String(ParserInstance.Preprocessor.InputSources[0].Name))+String(fn));
    if ffn=cfn then begin
     ffn:='';
    end;
   end;
   if (length(ffn)=0) or not fileexists(String(ffn)) then begin
    for i:=0 to Instance^.IncludeDirectories.Count-1 do begin
     d:=TPOCAUTF8String(Instance^.IncludeDirectories[i]);
     if fileexists(String(String(d)+String(fn))) then begin
      ffn:=d+fn;
      if ffn=cfn then begin
       ffn:='';
      end else begin
       break;
      end;
     end;
    end;
   end;
   if (length(ffn)=0) or not fileexists(String(ffn)) then begin
    if fileexists(String(fn)) then begin
     ffn:=fn;
     if ffn=cfn then begin
      ffn:='';
     end;
    end;
   end;
   if (length(ffn)=0) or not fileexists(String(ffn)) then begin
    if m=ord('"') then begin
     AddError('#include: File "'+fn+'" not found');
    end else begin
     AddError('#include: File <'+fn+'> not found');
    end;
    exit;
   end;
   fm:=filemode;
   filemode:=0;
   assignfile(f,String(ffn));
   {$i-}reset(f,1);{$i+};
   if ioresult=0 then begin
    SetLength(t,filesize(f));
    if length(t)>0 then begin
     {$i-}blockread(f,t[1],length(t));{$i+}
     t2:=ProprocessInputSourceChars(iskFILE,fn,t);
     if ioresult<>0 then begin
      if m=ord('"') then begin
       AddError('#include: File "'+fn+'" I/O error');
      end else begin
       AddError('#include: File <'+fn+'> I/O error');
      end;
      {$i-}closefile(f);{$i+}
      filemode:=fm;
      exit;
     end;
    end;
    {$i-}closefile(f);{$i+}
   end else begin
    if m=ord('"') then begin
     AddError('#include: File "'+fn+'" I/O error');
    end else begin
     AddError('#include: File <'+fn+'> I/O error');
    end;
   end;
   filemode:=fm;
   if DoIncludeOnce then begin
    for i:=0 to ParserInstance.Preprocessor.InputSourcesCount-1 do begin
     if (ParserInstance.Preprocessor.InputSources[i].Kind=iskFILE) and (ParserInstance.Preprocessor.InputSources[i].Name=fn) then begin
      exit;
     end;
    end;
   end;
   PushInputSource(iskFILE,fn,t2);
  end;
  procedure DoDEFINE;
  var Name:TPOCARawByteString;
      Parameters:array of TPOCARawByteString;
      Body:TMacroBody;
      Quote:boolean;
      i,j,p,b:longint;
      VaArgs:boolean;
  begin
   Name:='';
   SkipGetToken;
   if CurrentToken<>tNAME then begin
    AddWarning('#define: missing macro name');
    SkipEOL;
    exit;
   end;
   VaArgs:=false;
   Name:=CurrentTokenString;
   GetToken;
   Parameters:=nil;
   if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('(')) then begin
    Parameters:=nil;
    repeat
     SkipGetToken;
     if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('.')) and (GetCharAt(0)=ord('.')) and (GetCharAt(1)=ord('.')) then begin
      GetToken;
      GetToken;
      GetToken;
      VaArgs:=true;
      break;
     end;
     if CurrentToken<>tNAME then begin
      break;
     end;
     p:=length(Parameters);
     SetLength(Parameters,p+1);
     Parameters[p]:=copy(CurrentTokenString,0,length(CurrentTokenString));
     GetToken;
     if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord(','))) then begin
      break;
     end;
    until false;
    if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord(')'))) then begin
     AddWarning('#define: bad macro parameter');
     SkipEOL;
     exit;
    end;
    CurrentToken:=tCHAR;
    CurrentTokenChar:=ord(' ');
   end;
   while (CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpace) do begin
    GetToken;
   end;
   Body:=nil;
   Quote:=false;
   while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,10])) do begin
    if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('\')) and (GetCharAt(0) in [0,10]) then begin
     GetToken;
     GetToken;
     b:=length(Body);
     SetLength(Body,b+1);
     Body[b].Kind:=mbikTEXT;
     Body[b].Text:=#10;
     Body[b].Quote:=false;
 {   while (CurrentToken=tCHAR) and (CurrentTokenChar in WhiteSpaceEx) do begin
      GetToken;
     end;}
     continue;
    end else if ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('#'))) or
                ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':'))) then begin
     if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':')) then begin
      NextChar;
     end;
     b:=length(Body);
     SetLength(Body,b+1);
     Body[b].Kind:=mbikSPLITTER;
     Body[b].Quote:=false;
     GetToken;
     if ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('#'))) or
        ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':'))) then begin
      if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':')) then begin
       NextChar;
      end;
      GetToken;
      if length(Body)>0 then begin
       if Body[length(Body)-1].Kind=mbikTEXT then begin
        while (length(Body[length(Body)-1].Text)>0) and (ord(Body[length(Body)-1].Text[length(Body[length(Body)-1].Text)]) in UCS4WhiteSpaceEx) do begin
         Delete(Body[length(Body)-1].Text,length(Body[length(Body)-1].Text),1);
        end;
       end else if length(Body)>1 then begin
        if Body[length(Body)-1].Kind=mbikSPLITTER then begin
         if Body[length(Body)-2].Kind=mbikTEXT then begin
          while (length(Body[length(Body)-2].Text)>0) and (ord(Body[length(Body)-2].Text[length(Body[length(Body)-2].Text)]) in UCS4WhiteSpaceEx) do begin
           Delete(Body[length(Body)-2].Text,length(Body[length(Body)-2].Text),1);
          end;
         end;
        end;
       end;
      end;
     end else begin
      Quote:=true;
     end;
     while (CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpaceEx) do begin
      GetToken;
     end;
     continue;
    end;
    if CurrentToken=tNAME then begin
     if CurrentTokenString='__VA_ARGS__' then begin
      if VaArgs then begin
       b:=length(Body);
       SetLength(Body,b+1);
       Body[b].Kind:=mbikVAARGS;
       Body[b].Quote:=Quote;
      end else begin
       AddWarning('#define: __VA_ARGS__ not allowed here');
       exit;
      end;
     end else begin
      j:=-1;
      for i:=0 to length(Parameters)-1 do begin
       if Parameters[i]=CurrentTokenString then begin
        j:=i;
        break;
       end;
      end;
      if j<0 then begin
       b:=length(Body);
       SetLength(Body,b+1);
       Body[b].Kind:=mbikTEXT;
       Body[b].Text:=CurrentTokenString;
       Body[b].Quote:=Quote;
      end else begin
       b:=length(Body);
       SetLength(Body,b+1);
       Body[b].Kind:=mbikParameter;
       Body[b].Value:=i;
       Body[b].Quote:=Quote;
      end;
     end;
    end else begin
     if CurrentToken=tCHAR then begin
      if not (CurrentTokenChar in [13,10]) then begin
       b:=length(Body);
       SetLength(Body,b+1);
       Body[b].Kind:=mbikTEXT;
       Body[b].Text:=PUCUUTF32CharToUTF8(CurrentTokenChar);
       Body[b].Quote:=Quote;
      end;
     end else begin
      b:=length(Body);
      SetLength(Body,b+1);
      Body[b].Kind:=mbikTEXT;
      Body[b].Text:=CurrentTokenString;
      Body[b].Quote:=Quote;
     end;
    end;
    Quote:=false;
    GetToken;
   end;
   AddDefine(Name,Body,length(Parameters),VaArgs,mfNONE);
  end;
  procedure DoUNDEF;
  begin
   SkipGetToken;
   if CurrentToken<>tNAME then begin
    AddWarning('#undef: missing macro name');
    SkipEOL;
    exit;
   end;
   RemoveDefine(CurrentTokenString);
   SkipEOL;
  end;
  function SearchELSEENDIF(var Keyword:longint):boolean;
  var NestedLevel:longint;
  begin
   Keyword:=kwNONE;
   CurrentToken:=tCHAR;
   CurrentTokenChar:=10;
   NestedLevel:=1;
   repeat
    while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,10])) do begin
     GetToken;
    end;
    SkipGetToken;
    if ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('#'))) or
       ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':'))) then begin
     if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':')) then begin
      NextChar;
     end;
     SkipExtGetToken;
     Keyword:=LookUpKeyword(CurrentTokenString);
     if CurrentToken=tNAME then begin
      if Keyword in [kwIF,kwIFDEF,kwIFNDEF] then begin
       inc(NestedLevel);
      end else if Keyword=kwENDIF then begin
       dec(NestedLevel);
       if NestedLevel=0 then begin
        dec(IFNestedLevel);
        result:=false;
        exit;
       end;
      end else if (NestedLevel=1) and (Keyword in [kwELSE,kwELIF]) then begin
       result:=true;
       exit;
      end;
     end;
    end else if (CurrentToken=tCHAR) and (CurrentTokenCHAR=0) then begin
     AddError('missing #endif');
     result:=true;
     exit;
    end;
   until false;
  end;
  function EvalString(s:TPOCARawByteString):boolean;
  type TEvalToken=(etNONE,etCHAR,etNAME,etNUMBER,etDIV,etMINUS,etPLUS,etLT,
                   etLEQ,etLSH,etGT,etGEQ,etRSH,etEQ,etNOT,etNEQ,etAND,etLAND,
                   etOR,etLOR,etMOD,etMUL,etXOR,etLNOT,etLPAR,etRPAR,etCOMMA,
                   etQUEST,etCOLON,etUMINUS,etUPLUS,etASSIGN);
       TEvalTokenItem=record
        Token:TEvalToken;
        s:TPOCARawByteString;
       end;
       TEvalTokenFIFO=record
        Tokens:array of TEvalTokenItem;
        Index:longint;
       end;
       TValue=record
        case Sign:boolean of
         false:(us:longword);
         true:(s:longint);
       end;
       TEvalTokenPrecLUT=array[TEvalToken] of longint;
  const TokenUnary=[etLNOT,etNOT,etUPLUS,etUMINUS];
        TokenBinary=[etMUL,etDIV,etMOD,etPLUS,etMINUS,etLSH,etRSH,etLT,etLEQ,etGT,
               etGEQ,etEQ,etNEQ,etAND,etXOR,etOR,etLAND,etLOR,etCOMMA];
        WrongToken=TokenUnary+TokenBinary+[etQUEST,etCOLON];
        OpPrecLUT:TEvalTokenPrecLUT=(666, // etNONE
                                     666, // etCHAR
                                     666, // etNAME
                                     666, // etNUMBER
                                     12,  // etDIV
                                     11,  // etMINUS
                                     11,  // etPLUS
                                     9,   // etLT
                                     9,   // etLEQ
                                     10,  // etLSH
                                     9,   // etGT
                                     9,   // etGEQ
                                     10,  // etRSH
                                     8,   // etEQ
                                     13,  // etNOT
                                     8,   // etNEQ
                                     7,   // etAND,
                                     4,   // etLAND
                                     5,   // etOR
                                     3,   // etLOR
                                     12,  // etMOD
                                     12,  // etMUL
                                     6,   // etXOR
                                     13,  // etLNOT
                                     666, // etLPAR
                                     666, // etRPAR
                                     1,   // etCOMMA
                                     2,   // etQUEST
                                     666, // etCOLON
                                     13,  // etUMINUS
                                     13,  // etUPLUS
                                     666  // etASSIGN
                                    );
  var FIFO:TEvalTokenFIFO;
   procedure AddToken(Token:TEvalToken;const s:TPOCARawByteString);
   var i:longint;
   begin
    i:=length(FIFO.Tokens);
    SetLength(FIFO.Tokens,i+1);
    FIFO.Tokens[i].Token:=Token;
    FIFO.Tokens[i].s:=s;
   end;
   procedure Tokenize(s:TPOCARawByteString);
   var i:longint;
       c:TPOCAUCS4Char;
       ns:TPOCARawByteString;
   begin
    i:=1;
    while i<=length(s) do begin
     c:=PUCUUTF8CodeUnitGetCharAndIncFallback(s,i);
     case c of
      ord('/'):begin
       AddToken(etDIV,'/');
      end;
      ord('-'):begin
       AddToken(etMINUS,'-');
      end;
      ord('+'):begin
       AddToken(etPLUS,'+');
      end;
      ord('<'):begin
       if (i<=length(s)) and (s[i]='=') then begin
        AddToken(etLEQ,'<=');
        inc(i);
       end else if (i<=length(s)) and (s[i]='<') then begin
        AddToken(etLSH,'<<');
        inc(i);
       end else begin
        AddToken(etLT,'<');
       end;
      end;
      ord('>'):begin
       if (i<=length(s)) and (s[i]='=') then begin
        AddToken(etGEQ,'>=');
        inc(i);
       end else if (i<=length(s)) and (s[i]='>') then begin
        AddToken(etRSH,'>>');
        inc(i);
       end else begin
        AddToken(etGT,'>');
       end;
      end;
      ord('='):begin
       if (i<=length(s)) and (s[i]='=') then begin
        AddToken(etEQ,'==');
        inc(i);
       end else begin
        AddToken(etASSIGN,'=');
       end;
      end;
      ord('~'):begin
       AddToken(etNOT,'~');
      end;
      ord('!'):begin
       if (i<=length(s)) and (s[i]='=') then begin
        AddToken(etNEQ,'!=');
        inc(i);
       end else begin
        AddToken(etLNOT,'!');
       end;
      end;
      ord('&'):begin
       if (i<=length(s)) and (s[i]='&') then begin
        AddToken(etLAND,'&&');
        inc(i);
       end else begin
        AddToken(etAND,'&');
       end;
      end;
      ord('|'):begin
       if (i<=length(s)) and (s[i]='|') then begin
        AddToken(etLOR,'||');
        inc(i);
       end else begin
        AddToken(etOR,'|');
       end;
      end;
      ord('%'):begin
       AddToken(etMOD,'%');
      end;
      ord('*'):begin
       AddToken(etMUL,'*');
      end;
      ord('^'):begin
       AddToken(etXOR,'^');
      end;
      ord('('):begin
       AddToken(etLPAR,'(');
      end;
      ord(')'):begin
       AddToken(etRPAR,')');
      end;
      ord(','):begin
       AddToken(etCOMMA,',');
      end;
      ord('?'):begin
       AddToken(etQUEST,'?');
      end;
      ord(':'):begin
       AddToken(etCOLON,':');
      end;
      ord('0')..ord('9'):begin
       ns:=PUCUUTF32CharToUTF8(c);
       while (i<=length(s)) and (s[i] in ['0'..'9','a'..'z','A'..'Z']) do begin
        ns:=ns+TPOCARawByteString(s[i]);
        inc(i);
       end;
       AddToken(etNUMBER,ns);
      end;
      else begin
       AddToken(etCHAR,PUCUUTF32CharToUTF8(c));
      end;
     end;
    end;
   end;
   procedure PreprocessTokens;
   var i:longint;
   begin
    i:=0;
    while i<length(FIFO.Tokens) do begin
     if FIFO.Tokens[i].Token=etPLUS then begin
      if (i>0) and not (FIFO.Tokens[i-1].Token in [etNUMBER,etNAME,etCHAR,etRPAR]) then begin
       FIFO.Tokens[i].Token:=etUPLUS;
      end;
     end else if FIFO.Tokens[i].Token=etMINUS then begin
      if (i>0) and not (FIFO.Tokens[i-1].Token in [etNUMBER,etNAME,etCHAR,etRPAR]) then begin
       FIFO.Tokens[i].Token:=etUMINUS;
      end;
     end;
     inc(i);
    end;
   end;
   function OpPrec(Token:TEvalToken):longint;
   begin
    result:=OpPrecLUT[Token];
 {  case Token of
     etLNOT,etNOT,etUPLUS,etUMINUS:begin
      result:=13;
     end;
     etMUL,etDIV,etMOD:begin
      result:=12;
     end;
     etPLUS,etMINUS:begin
      result:=11;
     end;
     etLSH,etRSH:begin
      result:=10;
     end;
     etLT,etLEQ,etGT,etGEQ:begin
      result:=9;
     end;
     etEQ,etLNEQ:begin
      result:=8;
     end;
     etAND:begin
      result:=7;
     end;
     etXOR:begin
      result:=6;
     end;
     etOR:begin
      result:=5;
     end;
     etLAND:begin
      result:=4;
     end;
     etLOR:begin
      result:=3;
     end;
     etQUEST:begin
      result:=2;
     end;
     etCOMMA:begin
      result:=1;
     end;
     else begin
      result:=666;
     end;
    end;}
   end;
   function BoolVal(v:TValue):boolean;
   begin
    if v.Sign then begin
     result:=v.s<>0;
    end else begin
     result:=v.us<>0;
    end;
   end;
   function ParseNumber(s:TPOCARawByteString):TValue;
   var i:longint;
       sv:longint;
       usv:longword;
       b:boolean;
   begin
    b:=false;
    fillchar(result,sizeof(TValue),#0);
    result.Sign:=true;
    while (length(s)>0) and (s[length(s)] in ['l','L','u','U']) do begin
     if (length(s)>0) and (s[length(s)] in ['u','U']) then begin
      result.Sign:=false;
     end;
     Delete(s,length(s),1);
    end;
    if result.Sign then begin
     if (length(s)>0) and (s[1]='0') then begin
      if (length(s)>1) and (s[2] in ['x','X']) then begin
       result.s:=0;
       for i:=3 to length(s) do begin
        if (not b) and (((result.s*16) div 16)<>result.s) then begin
         b:=true;
         AddWarning('TERM: constant too large for destination type');
        end;
        case s[i] of
         '0'..'9':begin
          sv:=ord(s[i])-ord('0');
         end;
         'a'..'f':begin
          sv:=(ord(s[i])-ord('a'))+$a;
         end;
         'A'..'F':begin
          sv:=(ord(s[i])-ord('A'))+$a;
         end;
         else begin
          sv:=0;
         end;
        end;
        result.s:=(result.s*16)+sv;
       end;
      end else begin
       result.s:=0;
       for i:=2 to length(s) do begin
        if (not b) and (((result.s*8) div 8)<>result.s) then begin
         b:=true;
         AddWarning('TERM: constant too large for destination type');
        end;
        result.s:=(result.s*8)+(ord(s[i])-ord('0'));
       end;
      end;
     end else begin
      result.s:=0;
      for i:=1 to length(s) do begin
       if (not b) and (((result.s*10) div 10)<>result.s) then begin
        b:=true;
        AddWarning('TERM: constant too large for destination type');
       end;
       result.s:=(result.s*10)+(ord(s[i])-ord('0'));
      end;
     end;
    end else begin
     if (length(s)>0) and (s[1]='0') then begin
      if (length(s)>1) and (s[2] in ['x','X']) then begin
       result.us:=0;
       for i:=3 to length(s) do begin
        if (not b) and (((result.us*16) div 16)<>result.us) then begin
         b:=true;
         AddWarning('TERM: constant too large for destination type');
        end;
        case s[i] of
         '0'..'9':begin
          usv:=ord(s[i])-ord('0');
         end;
         'a'..'f':begin
          usv:=(ord(s[i])-ord('a'))+$a;
         end;
         'A'..'F':begin
          usv:=(ord(s[i])-ord('A'))+$a;
         end;
         else begin
          usv:=0;
         end;
        end;
        result.us:=(result.us*16)+usv;
       end;
      end else begin
       result.us:=0;
       for i:=2 to length(s) do begin
        if (not b) and (((result.us*8) div 8)<>result.us) then begin
         b:=true;
         AddWarning('TERM: constant too large for destination type');
        end;
        result.us:=(result.us*8)+longword(ord(s[i])-ord('0'));
       end;
      end;
     end else begin
      result.us:=0;
      for i:=1 to length(s) do begin
       if (not b) and (((result.us*10) div 10)<>result.us) then begin
        b:=true;
        AddWarning('TERM: constant too large for destination type');
       end;
       result.us:=(result.us*10)+longword(ord(s[i])-ord('0'));
      end;
     end;
    end;
   end;
   function DoTokenUnary(Token:TEvalToken;v:TValue):TValue;
   begin
    case Token of
     etLNOT:begin
      result.sign:=true;
      result.s:=ord(v.s=0);
     end;
     etNOT:begin
      result.sign:=v.sign;
      if result.sign then begin
       result.s:=not v.s;
      end else begin
       result.us:=not v.us;
      end;
     end;
     etPLUS:begin
      result:=v;
     end;
     etMINUS:begin
      result.sign:=v.sign;
      if result.sign then begin
       result.s:=-v.s;
      end else begin
       result.us:=-v.us;
      end;
     end;
     else begin
      result:=v;
     end;
    end;
   end;
   {$hints off}
   function DoTokenBinary(Token:TEvalToken;v1,v2:TValue):TValue;
   var iv2:longint;
   begin
    fillchar(result,sizeof(TValue),#0);
    iv2:=0;
    case Token of
     etMUL,etDIV,etMOD,etPLUS,etMINUS,etAND,etXOR,etOR:begin
      if (not v1.Sign) or (not v2.Sign) then begin
       if v1.Sign then begin
        v1.Sign:=false;
        v1.us:=v1.s;
       end else if v2.Sign then begin
        v2.Sign:=false;
        v2.us:=v2.s;
       end;
       result.Sign:=false;
      end else begin
       result.Sign:=true;
      end;
     end;
     etLT,etLEQ,etGT,etGEQ,etEQ,etNEQ:begin
      if (not v1.Sign) or (not v2.Sign) then begin
       if v1.Sign then begin
        v1.Sign:=false;
        v1.us:=v1.s;
       end else if v2.Sign then begin
        v2.Sign:=false;
        v2.us:=v2.s;
       end
      end;
      result.Sign:=true;
     end;
     etLAND,etLOR:begin
      result.Sign:=true;
     end;
     etLSH,etRSH:begin
      result.Sign:=v1.Sign;
      if v2.Sign then begin
       iv2:=v2.s;
      end else begin
       iv2:=v2.us;
      end;
     end;
     etCOMMA:begin
      result.Sign:=v2.Sign;
     end;
    end;
    case Token of
     etMUL:begin
      if result.Sign then begin
       result.s:=v1.s*v2.s;
      end else begin
       result.us:=v1.us*v2.us;
      end;
     end;
     etDIV:begin
      if result.Sign then begin
       if v2.s=0 then begin
        AddError('TERM: divide by zero');
        result.s:=0;
       end else begin
        result.s:=v1.s div v2.s;
       end;
      end else begin
       if v2.s=0 then begin
        AddError('TERM: divide by zero');
        result.us:=0;
       end else begin
        result.us:=v1.us div v2.us;
       end;
      end;
     end;
     etMOD:begin
      if result.Sign then begin
       if v2.s=0 then begin
        AddError('TERM: divide by zero');
        result.s:=0;
       end else begin
        result.s:=v1.s mod v2.s;
       end;
      end else begin
       if v2.s=0 then begin
        AddError('TERM: divide by zero');
        result.us:=0;
       end else begin
        result.us:=v1.us mod v2.us;
       end;
      end;
     end;
     etPLUS:begin
      if result.Sign then begin
       result.s:=v1.s+v2.s;
      end else begin
       result.us:=v1.us+v2.us;
      end;
     end;
     etMINUS:begin
      if result.Sign then begin
       result.s:=v1.s-v2.s;
      end else begin
       result.us:=v1.us-v2.us;
      end;
     end;
     etLSH:begin
      if result.Sign then begin
       result.s:=v1.s*(1 shl iv2);
      end else begin
       result.us:=v1.us shl iv2;
      end;
     end;
     etRSH:begin
      if result.Sign then begin
       result.s:=v1.s div (1 shl iv2);
      end else begin
       result.us:=v1.us shr iv2;
      end;
     end;
     etLT:begin
      if v1.Sign then begin
       if v1.s<v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us<v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etLEQ:begin
      if v1.Sign then begin
       if v1.s<=v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us<=v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etGT:begin
      if v1.Sign then begin
       if v1.s>v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us>v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etGEQ:begin
      if v1.Sign then begin
       if v1.s>=v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us>=v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etEQ:begin
      if v1.Sign then begin
       if v1.s=v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us=v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etNEQ:begin
      if v1.Sign then begin
       if v1.s<>v2.s then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if v1.us<>v2.us then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etAND:begin
      if result.Sign then begin
       result.s:=v1.s and v2.s;
      end else begin
       result.us:=v1.us and v2.us;
      end;
     end;
     etXOR:begin
      if result.Sign then begin
       result.s:=v1.s xor v2.s;
      end else begin
       result.us:=v1.us xor v2.us;
      end;
     end;
     etOR:begin
      if result.Sign then begin
       result.s:=v1.s or v2.s;
      end else begin
       result.us:=v1.us or v2.us;
      end;
     end;
     etLAND:begin
      if v1.Sign then begin
       if (v1.s<>0) and (v2.s<>0) then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if (v1.us<>0) and (v2.us<>0) then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etLOR:begin
      if v1.Sign then begin
       if (v1.s<>0) or (v2.s<>0) then begin
        result.s:=1;
       end else begin
        result.s:=0;
       end;
      end else begin
       if (v1.us<>0) or (v2.us<>0) then begin
        result.us:=1;
       end else begin
        result.us:=0;
       end;
      end;
     end;
     etCOMMA:begin
      result:=v2;
     end;
    end;
   end;
   function DoLevel(MinPrec:longint;DoEval:boolean):TValue;
   var at:TEvalTokenItem;
       bp:longint;
       r1,r2,tr:TValue;
       qb:boolean;
   begin
    fillchar(result,sizeof(TValue),#0);
    result.Sign:=true;
    if FIFO.Index>=length(FIFO.Tokens) then begin
     AddError('TERM: truncated constant integral expression');
     exit;
    end;
    at:=FIFO.Tokens[FIFO.Index];
    inc(FIFO.Index);
    case at.Token of
     etLPAR:begin
      result:=DoLevel(0,DoEval);
      if FIFO.Index>=length(FIFO.Tokens) then begin
       AddError('TERM: truncated constant integral expression');
       exit;
      end;
      at:=FIFO.Tokens[FIFO.Index];
      inc(FIFO.Index);
      if at.Token<>etRPAR then begin
       AddError('TERM: a right parenthesis was expected');
       exit;
      end;
     end;
     etNUMBER:begin
      result:=ParseNumber(at.s);
     end;
     else begin
      if at.Token in TokenUnary then begin
       result:=DoTokenUnary(at.Token,DoLevel(OpPrec(at.Token),DoEval));
      end else if at.Token in WrongToken then begin
       AddError('TERM: rogue operator '''+at.s+''' in constant integral');
       exit;
      end else begin
       AddError('TERM: invalid token in constant integral expression');
       exit;
      end;
     end;
    end;
    repeat
     if FIFO.Index>=length(FIFO.Tokens) then begin
      exit;
     end;
     at:=FIFO.Tokens[FIFO.Index];
     inc(FIFO.Index);
     if at.Token in TokenBinary then begin
      bp:=OpPrec(at.Token);
      if bp>MinPrec then begin
       if ((at.Token=etLOR) and BoolVal(result)) or ((at.Token=etLAND) and not BoolVal(result)) then begin
        tr:=DoLevel(bp,false);
        if DoEval then begin
         result.Sign:=true;
         case at.Token of
          etLOR:result.s:=1;
          etLAND:result.s:=0;
         end;
        end;
       end else begin
        tr:=DoLevel(bp,DoEval);
        result:=DoTokenBinary(at.Token,result,tr);
       end;
       continue;
      end;
     end else if at.Token=etQUEST then begin
      bp:=OpPrec(etQUEST);
      if bp>=MinPrec then begin
       qb:=BoolVal(result);
       r1:=DoLevel(bp,DoEval and qb);
       if FIFO.Index>=length(FIFO.Tokens) then begin
        AddError('TERM: truncated constant integral expression');
        exit;
       end;
       at:=FIFO.Tokens[FIFO.Index];
       inc(FIFO.Index);
       if at.Token<>etCOLON then begin
        AddError('TERM: a colon was expected');
        exit;
       end;
       r2:=DoLevel(bp,DoEval and not qb);
       if DoEval then begin
        if qb then begin
         result:=r1;
        end else begin
         result:=r2;
        end;
       end;
       continue;
      end;
     end;
     dec(FIFO.Index);
     break;
    until false;
   end;
  var v:TValue;
  begin
   fillchar(FIFO,sizeof(TEvalTokenFIFO),#0);
   Tokenize(s);
   PreprocessTokens;
   v:=DoLevel(0,true);
   result:=v.us<>0;
   SetLength(FIFO.Tokens,0);
  end;
  function Eval:boolean;
  var s,mn:TPOCARawByteString;
      i,j,l:longint;
      OldInEval:boolean;
  begin
   s:='';
   mn:='';
   OldInEval:=InEval;
   InEval:=true;
   result:=false;
   l:=length(InputStack);
   while (length(InputStack)>l) or not (GetCharAt(0) in [0,10]) do begin
    ExtGetToken;
    if CurrentToken=tNAME then begin
     if CurrentTokenString='defined' then begin
      SkipGetToken;
      if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('(')) then begin
       SkipGetToken;
       if CurrentToken<>tNAME then begin
        AddError('TERM: missing macro name');
        SkipEOL;
        exit;
       end;
       mn:=copy(CurrentTokenString,0,length(CurrentTokenString));
       SkipExtGetToken;
       if not ((CurrentToken=tCHAR) and (CurrentTokenChar=ord(')'))) then begin
        AddError('TERM: missing )');
        SkipEOL;
        exit;
       end;
      end else begin
       if CurrentToken<>tNAME then begin
        AddError('TERM: missing macro name');
        SkipEOL;
        exit;
       end;
       mn:=copy(CurrentTokenString,0,length(CurrentTokenString));
      end;
      if LookUp(mn)>=0 then begin
       s:=s+'1L';
      end else begin
       s:=s+'0L';
      end;
     end else begin
      s:=s+'0';
     end;
    end else if CurrentToken in [tSTRING,tSTRINGLONG] then begin
     j:=0;
     for i:=length(CurrentTokenString) downto 1 do begin
      j:=(j*256)+ord(CurrentTokenString[1]);
     end;
     s:=s+TPOCARawByteString(IntToStr(j));
     if CurrentToken=tSTRINGLONG then begin
      s:=s+'L';
     end;
    end else if CurrentToken=tNUMBER then begin
     s:=s+CurrentTokenString;
    end else begin
     if not ((CurrentToken=tCHAR) and (CurrentTokenChar in UCS4WhiteSpaceEx)) then begin
      s:=s+CurrentTokenString;
     end;
    end;
   end;
   result:=EvalString(s);
   InEval:=OldInEval;
  end;
  procedure DoIF;
  var Keyword:longint;
  begin
   inc(IFNestedLevel);
   if not Eval then begin
    repeat
     Keyword:=kwNONE;
     SearchELSEENDIF(Keyword);
     if not ((CurrentToken=tNAME) and (Keyword=kwELIF)) then begin
      SkipEOL;
      exit;
     end;
    until Eval;
   end;
  end;
  procedure DoIFDEF(ShouldResultValue:boolean);
  var Keyword:longint;
  begin
   SkipGetToken;
   if CurrentToken<>tNAME then begin
    if ShouldResultValue then begin
     AddWarning('#ifdef: missing identifier');
    end else begin
     AddWarning('#ifndef: missing identifier');
    end;
    SkipEOL;
    exit;
   end;
   inc(IFNestedLevel);
   if (LookUp(CurrentTokenString)>=0)<>ShouldResultValue then begin
    repeat
     Keyword:=kwNONE;
     SearchELSEENDIF(Keyword);
     if not ((CurrentToken=tNAME) and (Keyword=kwELIF)) then begin
      SkipEOL;
      exit;
     end;
    until Eval;
   end;
  end;
  procedure DoELSEELIF;
  var Keyword:longint;
  begin
   if IFNestedLevel=0 then begin
    AddError('missing #if');
   end else begin
    Keyword:=kwNONE;
    while SearchELSEENDIF(Keyword) do begin
     Keyword:=kwNONE;
    end;
   end;
   SkipEOL;
  end;
  procedure DoENDIF;
  begin
   if IFNestedLevel=0 then begin
    AddError('missing #if');
   end else begin
    dec(IFNestedLevel);
   end;
   SkipEOL;
  end;
  procedure DoLINE;
  var l,s:longint;
  begin
   SkipExtGetToken;
   if CurrentToken<>tNUMBER then begin
    AddWarning('#line: missing number');
    SkipEOL;
    exit;
   end;
 //l:=LastLine;
   s:=LastSource;
   l:=ParseNumber(CurrentTokenString);
   SkipExtGetToken;
   if (CurrentToken=tCHAR) and (CurrentTokenChar in [0,10]) then begin
    LastLine:=l;
    if length(InputStack)>0 then begin
     InputStack[length(InputStack)-1].BufferLine:=LastLine-1;
    end;
    PushInputSource(iskNONE,'',#10);
    exit;
   end else if CurrentToken=tSTRING then begin
    if length(CurrentTokenString)<2 then begin
     AddError('#line: string not closed');
     exit;
    end;
    if CurrentTokenString[1]<>CurrentTokenString[length(CurrentTokenString)] then begin
     AddError('#line: invalid string');
     exit;
    end;
    s:=GetInputSourceIndex(iskFILE,Destringize(copy(CurrentTokenString,2,length(CurrentTokenString)-2)));
   end else if CurrentToken=tNAME then begin
    s:=GetInputSourceIndex(iskFILE,CurrentTokenString);
   end;
   while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,10])) do begin
    GetToken;
   end;
   if length(InputStack)>0 then begin
    LastSource:=s;
    LastLine:=l;
    InputStack[length(InputStack)-1].BufferLine:=LastLine-1;
    InputStack[length(InputStack)-1].Source:=LastSource;
   end;
   PushInputSource(iskNONE,'',#10);
  end;
  procedure DoPRAGMA;
  var s:TPOCARawByteString;
      i:longint;
  begin
   s:='';
   repeat
    i:=NextChar;
    if (CurrentTokenChar<0) or (i in [0,10]) then begin
     break;
    end;
    s:=s+PUCUUTF32CharToUTF8(i);
   until false;
   i:=ParserInstance.Preprocessor.PragmaInfoCount;
   inc(ParserInstance.Preprocessor.PragmaInfoCount);
   if (i+1)>length(ParserInstance.Preprocessor.PragmaInfo) then begin
    SetLength(ParserInstance.Preprocessor.PragmaInfo,POCARoundUpToPowerOfTwo(i+2));
   end;
   ParserInstance.Preprocessor.PragmaInfo[i].CharPos:=ParserInstance.Preprocessor.OutputTextLength+1;
   ParserInstance.Preprocessor.PragmaInfo[i].Pragma:=s;
  end;
  procedure DoERROR;
  var s:TPOCARawByteString;
  begin
   s:='';
   CurrentTokenString:='';
   SkipBlank;
   while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,10])) do begin
    s:=s+CurrentTokenString;
    GetToken;
   end;
   AddError(s);
  end;
  procedure DoWARNING;
  var s:TPOCARawByteString;
  begin
   s:='';
   CurrentTokenString:='';
   SkipBlank;
   while not ((CurrentToken=tCHAR) and (CurrentTokenChar in [0,10])) do begin
    s:=s+CurrentTokenString;
    GetToken;
   end;
   AddError(s);
  end;
 var NewLine:boolean;
     MacroBody:TMacroBody;
 begin
  MacroStringTree:=TPOCAStringTree.Create;
  try
   MacroStringTree.Hashing:=true;
   KeywordStringTree:=TPOCAStringTree.Create;
   try
    InputStack:=nil;
    Macros:=nil;
    MacroBody:=nil;
    try
     KeywordStringTree.Hashing:=true;
     KeywordStringTree.Add('include',kwINCLUDE);
     KeywordStringTree.Add('include_next',kwINCLUDENEXT);
     KeywordStringTree.Add('include_once',kwINCLUDEONCE);
     KeywordStringTree.Add('includeonce',kwINCLUDEONCE);
     KeywordStringTree.Add('import',kwINCLUDEONCE);
     KeywordStringTree.Add('include_next_once',kwINCLUDENEXTONCE);
     KeywordStringTree.Add('import_next',kwINCLUDENEXTONCE);
     KeywordStringTree.Add('define',kwDEFINE);
     KeywordStringTree.Add('undef',kwUNDEF);
     KeywordStringTree.Add('if',kwIF);
     KeywordStringTree.Add('ifdef',kwIFDEF);
     KeywordStringTree.Add('ifndef',kwIFNDEF);
     KeywordStringTree.Add('elif',kwELIF);
     KeywordStringTree.Add('else',kwELSE);
     KeywordStringTree.Add('endif',kwENDIF);
     KeywordStringTree.Add('line',kwLINE);
     KeywordStringTree.Add('pragma',kwPRAGMA);
     KeywordStringTree.Add('error',kwERROR);
     KeywordStringTree.Add('warning',kwWARNING);
     LastSource:=-1;
     LastLine:=-1;
     InEval:=false;
     SetLength(MacroBody,0);
     AddDefine('__FILE__',MacroBody,0,false,mfFILE);
     AddDefine('__LINE__',MacroBody,0,false,mfLINE);
     AddDefine('__TIME__',MacroBody,0,false,mfTIME);
     AddDefine('__DATE__',MacroBody,0,false,mfDATE);
     AddDefine('_Pragma',MacroBody,0,false,mfPRAGMA);
     SetLength(MacroBody,1);
     MacroBody[0].Kind:=mbikTEXT;
     MacroBody[0].Text:='1';
     MacroBody[0].Quote:=false;
     AddDefine('__POCA__',MacroBody,0,false,mfNONE);
     SetLength(MacroBody,1);
     MacroBody[0].Kind:=mbikTEXT;
     MacroBody[0].Text:='"'+POCAVersion+'"';
     MacroBody[0].Quote:=false;
     AddDefine('__POCA_VERSION__',MacroBody,0,false,mfNONE);
     SetLength(MacroBody,0);
     SetLength(ParserInstance.Preprocessor.InputSources,16);
     SetLength(ParserInstance.Preprocessor.PragmaInfo,16);
     SetLength(ParserInstance.Preprocessor.OutputInfo,16);
     SetLength(ParserInstance.Preprocessor.OutputText,4096);
     ParserInstance.Preprocessor.InputSourcesCount:=0;
     ParserInstance.Preprocessor.PragmaInfoCount:=0;
     ParserInstance.Preprocessor.OutputInfoCount:=0;
     ParserInstance.Preprocessor.OutputTextLength:=0;
     PushInputSource(ParserInstance.Preprocessor.InputKind,ParserInstance.Preprocessor.InputName,ProprocessInputSourceChars(ParserInstance.Preprocessor.InputKind,ParserInstance.Preprocessor.InputName,ParserInstance.Preprocessor.InputText));
     NewLine:=true;
     IFNestedLevel:=0;
     MacroLevel:=0;
     while length(InputStack)>0 do begin
      ExtGetToken;
      if (((CurrentToken=tCHAR) and (CurrentTokenChar=ord('#'))) or
          ((CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':')))) and NewLine then begin
       if (CurrentToken=tCHAR) and (CurrentTokenChar=ord('%')) and (GetCharAt(0)=ord(':')) then begin
        NextChar;
       end;
       SkipGetToken;
       case LookUpKeyword(CurrentTokenString) of
        kwINCLUDE:begin
         DoINCLUDE(false,false);
        end;
        kwINCLUDENEXT:begin
         DoINCLUDE(true,false);
        end;
        kwINCLUDEONCE:begin
         DoINCLUDE(false,true);
        end;
        kwINCLUDENEXTONCE:begin
         DoINCLUDE(true,true);
        end;
        kwDEFINE:begin
         DoDEFINE;
        end;
        kwUNDEF:begin
         DoUNDEF;
        end;
        kwIF:begin
         DoIF;
        end;
        kwIFDEF:begin
         DoIFDEF(true);
        end;
        kwIFNDEF:begin
         DoIFDEF(false);
        end;
        kwELIF:begin
         DoELSEELIF;
        end;
        kwELSE:begin
         DoELSEELIF;
        end;
        kwENDIF:begin
         DoENDIF;
        end;
        kwLINE:begin
         DoLINE;
        end;
        kwPRAGMA:begin
         DoPRAGMA;
        end;
        kwERROR:begin
         DoERROR;
        end;
        kwWARNING:begin
         DoWARNING;
        end;
        else begin
         AddWarning('undefined statement: '+CurrentTokenString);
         SkipEOL;
        end;
       end;
      end else begin
       if CurrentToken=tSTRINGLONG then begin
        AddToOutput('L');
        AddToOutput(CurrentTokenString);
        NewLine:=false;
       end else if CurrentToken=tCHAR then begin
        if CurrentTokenChar in [0..255] then begin
         case CurrentTokenChar of
          0:begin
           AddToOutput(CurrentTokenString);
          end;
          10:begin
           NewLine:=true;
          end;
          9,11,12,13,32:begin
          end;
          else begin
           NewLine:=false;
          end;
         end;
        end else if CurrentTokenChar<0 then begin
         continue;
        end;
       end else begin
        NewLine:=false;
       end;
       AddToOutput(CurrentTokenString);
      end;
     end;
     if (ParserInstance.Preprocessor.OutputInfoCount>0) then begin
      if ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].LastCharPos<>(ParserInstance.Preprocessor.OutputTextLength-1) then begin
       ParserInstance.Preprocessor.OutputInfo[ParserInstance.Preprocessor.OutputInfoCount-1].LastCharPos:=(ParserInstance.Preprocessor.OutputTextLength-1);
      end;
     end;
     SetLength(ParserInstance.Preprocessor.InputSources,ParserInstance.Preprocessor.InputSourcesCount);
     SetLength(ParserInstance.Preprocessor.PragmaInfo,ParserInstance.Preprocessor.PragmaInfoCount);
     SetLength(ParserInstance.Preprocessor.OutputInfo,ParserInstance.Preprocessor.OutputInfoCount);
     SetLength(ParserInstance.Preprocessor.OutputText,ParserInstance.Preprocessor.OutputTextLength);
    finally
     SetLength(InputStack,0);
     SetLength(Macros,0);
     SetLength(MacroBody,0);
    end;
   finally
    KeywordStringTree.Destroy;
   end;
  finally
   MacroStringTree.Destroy;
  end;
 end;
 procedure Dump(Token:PPOCAToken);
  procedure DumpIt(const s:TPOCARawByteString);
  begin
   write(s);
  end;
 begin
  while assigned(Token) do begin
   case Token^.Token of
    ptNONE:begin
    end;
    ptTOP:begin
    end;
    ptAND:begin
     DumpIt(' && ');
    end;
    ptOR:begin
     DumpIt(' || ');
    end;
    ptNOT:begin
     DumpIt(' ! ');
    end;
    ptLPAR:begin
     DumpIt(' ( ');
    end;
    ptRPAR:begin
     DumpIt(' ) ');
    end;
    ptLBRA:begin
     DumpIt(' [ ');
    end;
    ptRBRA:begin
     DumpIt(' ] ');
    end;
    ptLCURL:begin
     DumpIt(' { ');
    end;
    ptRCURL:begin
     DumpIt(' } ');
    end;
    ptMUL:begin
     DumpIt(' * ');
    end;
    ptPLUS:begin
     DumpIt(' + ');
    end;
    ptMINUS:begin
     DumpIt(' - ');
    end;
    ptNEG:begin
     DumpIt(' -');
    end;
    ptDIV:begin
     DumpIt(' / ');
    end;
    ptNUM:begin
     DumpIt(' +');
    end;
    ptCOLON:begin
     DumpIt(' : ');
    end;
    ptDOT:begin
     DumpIt(' . ');
    end;
    ptCOMMA:begin
     DumpIt(' , ');
    end;
    ptSEMI:begin
     DumpIt(' ;'#13#10);
    end;
    ptASSIGN:begin
     DumpIt(' = ');
    end;
    ptLT:begin
     DumpIt(' < ');
    end;
    ptLTEQ:begin
     DumpIt(' <= ');
    end;
    ptEQ:begin
     DumpIt(' == ');
    end;
    ptNEQ:begin
     DumpIt(' != ');
    end;
    ptGT:begin
     DumpIt(' > ');
    end;
    ptGTEQ:begin
     DumpIt(' >= ');
    end;
    ptCMP:begin
     DumpIt(' <=> ');
    end;
    ptIF:begin
     DumpIt(' if ');
    end;
    ptELSEIF:begin
     DumpIt(' elseif ');
    end;
    ptELSE:begin
     DumpIt(' else ');
    end;
    ptFOR:begin
     DumpIt(' for ');
    end;
    ptFOREACH:begin
     DumpIt(' foreach ');
    end;
    ptWHILE:begin
     DumpIt(' while ');
    end;
    ptRETURN:begin
     DumpIt(' return ');
    end;
    ptBREAK:begin
     DumpIt(' break ');
    end;
    ptCONTINUE:begin
     DumpIt(' continue ');
    end;
    ptFUNCTION:begin
     DumpIt(' function ');
    end;
    ptSYMBOL:begin
     DumpIt(' '+Token^.Str+' ');
    end;
    ptLITERALNUM:begin
     DumpIt(' '+POCADoubleToString(Token^.Num)+' ');
    end;
    ptLITERALSTR:begin
     DumpIt(' "'+Token^.Str+'" ');
    end;
    ptEMPTY:begin
     DumpIt(' empty ');
    end;
    ptNULL:begin
     DumpIt(' null ');
    end;
    ptELLIPSIS:begin
     DumpIt(' ... ');
    end;
    ptQUESTION:begin
     DumpIt(' ? ');
    end;
    ptVAR:begin
     DumpIt(' var ');
    end;
    ptPLUSEQ:begin
     DumpIt(' += ');
    end;
    ptMINUSEQ:begin
     DumpIt(' -= ');
    end;
    ptMULEQ:begin
     DumpIt(' *= ');
    end;
    ptDIVEQ:begin
     DumpIt(' /= ');
    end;
    ptCATEQ:begin
     DumpIt(' ~= ');
    end;
    ptFORINDEX:begin
     DumpIt(' forindex ');
    end;
    ptLAND:begin
     DumpIt(' && ');
    end;
    ptLOR:begin
     DumpIt(' || ');
    end;
    ptTRY:begin
     DumpIt(' try ');
    end;
    ptCATCH:begin
     DumpIt(' catch ');
    end;
    ptFINALLY:begin
     DumpIt(' finally ');
    end;
    ptTHROW:begin
     DumpIt(' throw ');
    end;
    ptDO:begin
     DumpIt(' do ');
    end;
    ptWHEN:begin
     DumpIt(' when ');
    end;
    ptSWITCH:begin
     DumpIt(' switch ');
    end;
    ptCASE:begin
     DumpIt(' case ');
    end;
    ptDEFAULT:begin
     DumpIt(' default ');
    end;
    ptFALLTHROUGH:begin
     DumpIt(' fallthrough ');
    end;
    ptRETRY:begin
     DumpIt(' retry ');
    end;
    ptPOSTDEC:begin
     DumpIt('-- ');
    end;
    ptPOSTINC:begin
     DumpIt('++ ');
    end;
    ptPREDEC:begin
     DumpIt(' --');
    end;
    ptPREINC:begin
     DumpIt(' ++');
    end;
    ptBAND:begin
     DumpIt(' & ');
    end;
    ptBOR:begin
     DumpIt(' | ');
    end;
    ptBXOR:begin
     DumpIt(' ^ ');
    end;
    ptBNOT:begin
     DumpIt(' ~');
    end;
    ptBSHL:begin
     DumpIt(' << ');
    end;
    ptBSHR:begin
     DumpIt(' >> ');
    end;
    ptBUSHR:begin
     DumpIt(' >>> ');
    end;
    ptBANDEQ:begin
     DumpIt(' &= ');
    end;
    ptBOREQ:begin
     DumpIt(' |= ');
    end;
    ptBXOREQ:begin
     DumpIt(' ^= ');
    end;
    ptBSHLEQ:begin
     DumpIt(' <<= ');
    end;
    ptBSHREQ:begin
     DumpIt(' >>= ');
    end;
    ptBUSHREQ:begin
     DumpIt(' >>>= ');
    end;
    ptMOD:begin
     DumpIt(' % ');
    end;
    ptMODEQ:begin
     DumpIt(' %= ');
    end;
    ptPOW:begin
     DumpIt(' *= ');
    end;
    ptPOWEQ:begin
     DumpIt(' **= ');
    end;
    ptREGISTER:begin
     DumpIt(' register ');
    end;
    ptBLOCK:begin
     DumpIt(' block ');
    end;
    ptINLINEBLOCK:begin
     DumpIt(' inlineblock ');
    end;
    ptSUPERTHAT:begin
     DumpIt(' superthat ');
    end;
    ptTHAT:begin
     DumpIt(' that ');
    end;
    ptTHIS:begin
     DumpIt(' this ');
    end;
    ptSELF:begin
     DumpIt(' self ');
    end;
    ptLOCAL:begin
     DumpIt(' local ');
    end;
    ptDEFINED:begin
     DumpIt(' defined ');
    end;
    ptNEW:begin
     DumpIt(' new ');
    end;
    ptTRUE:begin
     DumpIt(' true ');
    end;
    ptFALSE:begin
     DumpIt(' false ');
    end;
    ptFASTFUNCTION:begin
     DumpIt(' fastfunction ');
    end;
    ptAT:begin
     DumpIt(' @ ');
    end;
    ptATDOT:begin
     DumpIt(' @. ');
    end;
    ptDOTDOT:begin
     DumpIt(' .. ');
    end;
    ptSAFEDOT:begin
     DumpIt(' ?. ');
    end;
    ptSAFELBRA:begin
     DumpIt(' [? ');
    end;
    ptSAFERBRA:begin
     DumpIt(' ?] ');
    end;
    ptFORKEY:begin
     DumpIt(' forkey ');
    end;
    ptINSTANCEOF:begin
     DumpIt(' instanceof ');
    end;
    ptSEQ:begin
     DumpIt(' === ');
    end;
    ptSNEQ:begin
     DumpIt(' !== ');
    end;
    ptIN:begin
     DumpIt(' in ');
    end;
    ptIS:begin
     DumpIt(' is ');
    end;
    ptSUPER:begin
     DumpIt(' super ');
    end;
    ptCAT:begin
     DumpIt(' ~ ');
    end;
    ptREGEXP:begin
     DumpIt(' "'+Token^.Str+'" ');
    end;
    ptREGEXPEQ:begin
     DumpIt(' =~= ');
    end;
    ptREGEXPNEQ:begin
     DumpIt(' !~= ');
    end;
    ptPROTOTYPE:begin
     DumpIt(' prototype ');
    end;
    ptDELETE:begin
     DumpIt(' delete ');
    end;
    ptCLASS:begin
     DumpIt(' class ');
    end;
    ptMODULE:begin
     DumpIt(' module ');
    end;
    ptEXTENDS:begin
     DumpIt(' extends ');
    end;
    ptLAMBDA:begin
     DumpIt(' -> ');
    end;
    ptFASTLAMBDA:begin
     DumpIt(' ==> ');
    end;
    ptCLASSFUNCTION:begin
     DumpIt(' classfunction ');
    end;
    ptMODULEFUNCTION:begin
     DumpIt(' modulefunction ');
    end;
    ptGLOBAL:begin
     DumpIt(' global ');
    end;
    ptBASECLASS:begin
     DumpIt(' baseclass ');
    end;
    ptLET:begin
     DumpIt(' let ');
    end;
    ptREG:begin
     DumpIt(' reg ');
    end;
    ptCONST:begin
     DumpIt(' const ');
    end;
    ptFUNC:begin
     DumpIt(' func ');
    end;
    ptFASTFUNC:begin
     DumpIt(' fastfunc ');
    end;
    ptHASHKIND:begin
     DumpIt(' hashkind ');
    end;
    ptTYPEOF:begin
     DumpIt(' typeof ');
    end;
    ptIDOF:begin
     DumpIt(' idof ');
    end;
    ptGHOSTTYPEOF:begin
     DumpIt(' ghosttypeof ');
    end;
    ptCOLONCOLON:begin
     DumpIt(' :: ');
    end;
    ptCONSTRUCTOR:begin
     DumpIt(' constructor ');
    end;
    ptBREAKPOINT:begin
     DumpIt(' breakpoint ');
    end;
    ptIMPORT:begin
     DumpIt(' import ');
    end;
    ptEXPORT:begin
     DumpIt(' export ');
    end;
    ptAUTOSEMI:begin
     DumpIt(' ;'#13#10);
    end;
    ptELVIS:begin
     DumpIt(' ?: ');
    end;
    ptELVISEQ:begin
     DumpIt(' ?= ');
    end;
    ptSYMBOLNAME:begin
     DumpIt(' _'+Token^.Str+'_ ');
    end;
    ptSUPERCODESYMBOL:begin
     DumpIt(' __'+Token^.Str+'__ ');
    end;
   end;
   if assigned(Token^.Children) then begin
    Dump(Token^.Children);
   end;
   Token:=Token^.Next;
  end;
 end;
 procedure ProcessLexer(var Parser:TPOCAParser;const Source:TPOCARawByteString);
 var SourcePosition,SourceLength,SourceLine,SourceColumn,LastPragma,LastOutputInfo:longint;
     AutomaticSemicolonInsertion:boolean;
  procedure AddToken(Token:TPOCATokenType;const Str:TPOCARawByteString;const Num:double);
  var NewToken:PPOCAToken;
      i,j:longint;
  begin
   case Token of
    ptLITERALSTR:begin
     if assigned(Parser.Tree.LastChild) and (Parser.Tree.LastChild^.Token=ptLITERALSTR) then begin
      Parser.Tree.LastChild^.Str:=Parser.Tree.LastChild^.Str+Str;
      exit;
     end;
    end;
    ptIF:begin
     if assigned(Parser.Tree.LastChild) and (Parser.Tree.LastChild^.Token=ptELSE) then begin
      Parser.Tree.LastChild^.Token:=ptELSEIF;
      exit;
     end;
    end;
    ptSYMBOL:begin
     if assigned(Parser.Tree.LastChild) then begin
      case Parser.Tree.LastChild^.Token of
       ptPOSTDEC:begin
        Parser.Tree.LastChild^.Token:=ptPREDEC;
       end;
       ptPOSTINC:begin
        Parser.Tree.LastChild^.Token:=ptPREINC;
       end;
      end;
     end;
    end;
    ptLAND:begin
     Token:=ptAND;
    end;
    ptLOR:begin
     Token:=ptOR;
    end;
    ptLET,ptREG:begin
     Token:=ptREGISTER;
    end;
    ptFUNC:begin
     Token:=ptFUNCTION;
    end;
    ptFASTFUNC:begin
     Token:=ptFASTFUNCTION;
    end;
   end;     
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=Token;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=Parser.SourceFile;
   NewToken^.SourceLine:=SourceLine;
   NewToken^.SourceColumn:=SourceColumn;
   for i:=LastOutputInfo to PreprocessorInstance.Preprocessor.OutputInfoCount-1 do begin
    if (SourcePosition>=PreprocessorInstance.Preprocessor.OutputInfo[i].FirstCharPos) and
       (SourcePosition<=PreprocessorInstance.Preprocessor.OutputInfo[i].LastCharPos) then begin
     j:=PreprocessorInstance.Preprocessor.OutputInfo[i].Source;
     if (j>=0) and (j<PreprocessorInstance.Preprocessor.InputSourcesCount) then begin
      NewToken^.SourceFile:=PreprocessorInstance.Preprocessor.InputSources[j].Index;
     end;
     NewToken^.SourceLine:=PreprocessorInstance.Preprocessor.OutputInfo[i].Line+1;
     LastOutputInfo:=i;
     break;
    end;
   end;
   NewToken^.Str:=Str;
   NewToken^.Num:=Num;
   NewToken^.Next:=nil;
   NewToken^.Previous:=Parser.Tree.LastChild;
   NewToken^.Children:=nil;
   NewToken^.LastChild:=nil;
   NewToken^.Parent:=nil;
   NewToken^.Rule:=prNONE;
   if (Token in POCAPrefixTokens) and
      (assigned(NewToken^.Previous) and (NewToken^.Previous.Token in POCABinaryOrPrefixTokens)) then begin
    NewToken^.Token:=POCABinaryToPrefixUnaryTokenCorrectionMap[Token];
   end;
   if not assigned(Parser.Tree.Children) then begin
    Parser.Tree.Children:=NewToken;
   end;
   if assigned(Parser.Tree.LastChild) then begin
    Parser.Tree.LastChild^.Next:=NewToken;
   end;
   Parser.Tree.LastChild:=NewToken;
  end;
  function FindKeywordToken(const Source:TPOCARawByteString;SourcePosition,SourceLength:longint):TPOCATokenType;
  var Node:PPOCALexerKeywordTokenCharTreeNode;
      Index:longint;
      CurrentChar:ansichar;
  begin
   result:=ptNONE;
   Node:=LexerKeywordTokenCharTreeRootNode;
   for Index:=SourcePosition to SourceLength do begin
    CurrentChar:=Source[Index];
    if (CurrentChar in POCAKeywordChars) and assigned(Node^.Children[CurrentChar]) then begin
     Node:=Node^.Children[CurrentChar];
     result:=Node^.Token;
     if not Node^.HasChildren then begin
      break;
     end;
    end else begin
     break;
    end;
   end;
   if result<>ptNONE then begin
    inc(SourcePosition,length(LexerKeywordTokens[result]));
    if (SourcePosition<=SourceLength) and PUCUUnicodeIsIDPart(PUCUUTF8CodeUnitGetCharFallback(Source,SourcePosition)) then begin
     result:=ptNONE;
    end;
   end;
  end;
  procedure FixPrevious;
  var t,p:PPOCAToken;
  begin
   t:=Parser.Tree.Children;
   p:=nil;
   while assigned(t) do begin
    t^.Previous:=p;
    p:=t;
    t:=t^.Next;
   end;
  end;
  procedure ProcessPragma;
  var i:longint;
      s:TPOCARawByteString;
  begin
   for i:=LastPragma to PreprocessorInstance.Preprocessor.PragmaInfoCount-1 do begin
    if SourcePosition>=PreprocessorInstance.Preprocessor.PragmaInfo[i].CharPos then begin
     s:=TPOCARawByteString(lowercase(trim(String(PreprocessorInstance.Preprocessor.PragmaInfo[i].Pragma))));
     if (length(s)>3) and (((s[1]='a') and (s[2]='s') and (s[3]='i')) and not (s[4] in ['a'..'z','0'..'9','_'])) then begin
      s:=TPOCARawByteString(trim(String(copy(s,4,length(s)-3))));
      AutomaticSemicolonInsertion:=(s='on') or (s='1') or (s='true');
     end;
     LastPragma:=i+1;
    end;
   end;
  end;
  procedure DoAutomaticSemicolonInsertion;
  begin
   if AutomaticSemicolonInsertion and (assigned(Parser.Tree.LastChild) and not (Parser.Tree.LastChild^.Token in
     [ptAND,ptOR,ptNOT,ptLPAR,ptRPAR,ptLBRA,ptRBRA,ptLCURL,ptMUL,ptPLUS,ptMINUS,ptNEG,ptDIV,ptNUM,ptCOLON,ptDOT,ptCOMMA,ptSEMI,
      ptASSIGN,ptLT,ptLTEQ,ptEQ,ptNEQ,ptGT,ptGTEQ,ptCMP,ptIF,ptELSEIF,ptELSE,ptFOR,ptFOREACH,ptWHILE,ptFUNCTION,ptEMPTY,
      ptNULL,ptELLIPSIS,ptQUESTION,ptVAR,ptPLUSEQ,ptMINUSEQ,ptMULEQ,ptDIVEQ,ptCATEQ,ptFORINDEX,ptLAND,ptLOR,ptTRY,ptCATCH,ptFINALLY,
      ptTHROW,ptDO,ptWHEN,ptSWITCH,ptCASE,ptDEFAULT,ptPOSTDEC,ptPOSTINC,ptPREDEC,ptPREINC,ptBAND,ptBOR,ptBXOR,ptBNOT,ptBSHL,ptBSHR,
      ptBUSHR,ptBANDEQ,ptBOREQ,ptBXOREQ,ptBSHLEQ,ptBSHREQ,ptBUSHREQ,ptMOD,ptMODEQ,ptPOW,ptPOWEQ,ptREGISTER,ptBLOCK,ptINLINEBLOCK,
      ptLOCAL,ptDEFINED,ptNEW,ptFASTFUNCTION,ptAT,ptATDOT,ptDOTDOT,ptSAFEDOT,ptSAFELBRA,ptSAFERBRA,ptFORKEY,ptINSTANCEOF,ptSEQ,
      ptSNEQ,ptIN,ptIS,ptCAT,ptREGEXP,ptREGEXPEQ,ptREGEXPNEQ,ptDELETE,ptCLASS,ptMODULE,ptEXTENDS,ptLAMBDA,ptFASTLAMBDA,
      ptCLASSFUNCTION,ptMODULEFUNCTION,ptLET,ptREG,ptCONST,ptFUNC,ptFASTFUNC,ptHASHKIND,ptTYPEOF,ptIDOF,ptGHOSTTYPEOF,
      ptCOLONCOLON,ptCONSTRUCTOR,ptBREAKPOINT,ptIMPORT,ptEXPORT,ptAUTOSEMI,ptSUPER,ptELVIS,ptELVISEQ,ptSYMBOLNAME])) then begin
    AddToken(ptAUTOSEMI,'',0);
   end;
  end;
  procedure ScanUntil(IncludingHere:longint);
  var SourceToken:TPOCATokenType;
      Counter,SourceLookaheadPosition,LastSourcePosition,Last,OldSourcePosition,OldSourceColumn,OldSourceLine,OldLastPragma,OldLastOutputInfo,CharValue,Level:longint;
      SourceChar,EndChar,OldSourceChar:ansichar;
      StringContent:TPOCARawByteString;
      Value:int64;
      DoParseExp,InClass:boolean;
      OK:boolean;
      RegExp:TFLRE;
   procedure StringInterpolation;
   begin
    AddToken(ptLITERALSTR,{$ifdef pocastrictutf8}PUCUUTF8Correct(StringContent){$else}StringContent{$endif},0);
    StringContent:='';
    AddToken(ptCAT,'',0);
    Last:=SourcePosition;
    SourceLookaheadPosition:=SourcePosition;
    Level:=0;
    while SourceLookaheadPosition<=SourceLength do begin
     case Source[SourceLookaheadPosition] of
      '{':begin
       inc(SourceLookaheadPosition);
       inc(Level);
      end;
      '}':begin
       if Level=0 then begin
        AddToken(ptLPAR,'',0);
        ScanUntil(SourceLookaheadPosition-1);
        AddToken(ptRPAR,'',0);
        AddToken(ptCAT,'',0);
        if SourcePosition=SourceLookaheadPosition then begin
         PUCUUTF8SafeInc(Source,SourcePosition);
         inc(SourceColumn);
        end else begin
         SourcePosition:=Last;
         while SourcePosition<=SourceLookaheadPosition do begin
          CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
          case CharValue of
           $0000:begin
            break;
           end;
           $000a:begin
            if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
             inc(SourcePosition);
            end;
            inc(SourceLine);
            SourceColumn:=0;
           end;
           $000d:begin
            if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
             inc(SourcePosition);
            end;
            inc(SourceLine);
            SourceColumn:=0;
           end;
           $2028,$2029:begin
            inc(SourceLine);
            SourceColumn:=0;
           end;
           else begin
            inc(SourceColumn);
           end;
          end;
         end;
        end;
        break;
       end else begin
        dec(Level);
       end;
      end;
      else begin
       inc(SourceLookaheadPosition);
      end;
     end;
    end;
    StringContent:='';
   end;
  begin
   StringContent:='';
   try
    while SourcePosition<=IncludingHere do begin
     if (LastPragma<PreprocessorInstance.Preprocessor.PragmaInfoCount) and (SourcePosition>=PreprocessorInstance.Preprocessor.PragmaInfo[LastPragma].CharPos) then begin
      ProcessPragma;
     end;
     SourceChar:=Source[SourcePosition];
     case SourceChar of
      #0:begin
       break;
      end;
      #1..#9,#11..#12,#14..#32:begin
       inc(SourcePosition);
       inc(SourceColumn);
      end;
      #10,#13:begin
       DoAutomaticSemicolonInsertion;
       if ((SourcePosition+1)<=SourceLength) and ((Source[SourcePosition+1] in [#10,#13]) and (Source[SourcePosition]<>Source[SourcePosition+1])) then begin
        inc(SourcePosition,2);
       end else begin
        inc(SourcePosition);
       end;
       inc(SourceLine);
       SourceColumn:=0;
      end;
      '(':begin
       inc(SourcePosition);
       AddToken(ptLPAR,'',0);
      end;
      ')':begin
       inc(SourcePosition);
       AddToken(ptRPAR,'',0);
      end;
      '[':begin
       inc(SourcePosition);
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]='?') then begin
        inc(SourcePosition);
        AddToken(ptSAFELBRA,'',0);
       end else begin
        AddToken(ptLBRA,'',0);
       end;
      end;
      ']':begin
       inc(SourcePosition);
       AddToken(ptRBRA,'',0);
      end;
      '{':begin
       inc(SourcePosition);
       AddToken(ptLCURL,'',0);
      end;
      '}':begin
       inc(SourcePosition);
       AddToken(ptRCURL,'',0);
      end;
      '?':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         ':':begin
          inc(SourcePosition);
          AddToken(ptELVIS,'',0);
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptELVISEQ,'',0);
         end;
         '.':begin
          inc(SourcePosition);
          AddToken(ptSAFEDOT,'',0);
         end;
         ']':begin
          inc(SourcePosition);
          AddToken(ptSAFERBRA,'',0);
         end;
         else begin
          AddToken(ptQUESTION,'',0);
         end;
        end;
       end else begin
        AddToken(ptQUESTION,'',0);
       end;
      end;
      '^':begin
       inc(SourcePosition);
       AddToken(ptBXOR,'',0);
      end;
      ':':begin
       inc(SourcePosition);
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]=':') then begin
        inc(SourcePosition);
        AddToken(ptCOLONCOLON,'',0);
       end else begin
        AddToken(ptCOLON,'',0);
       end;
      end;
      ';':begin
       inc(SourcePosition);
       AddToken(ptSEMI,'',0);
      end;
      ',':begin
       inc(SourcePosition);
       AddToken(ptCOMMA,'',0);
      end;
      '.':begin
       inc(SourcePosition);
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]='.') then begin
        inc(SourcePosition);
        if (SourcePosition<=SourceLength) and (Source[SourcePosition]='.') then begin
         inc(SourcePosition);
         AddToken(ptELLIPSIS,'',0);
        end else begin
         AddToken(ptDOTDOT,'',0);
        end;
       end else begin
        AddToken(ptDOT,'',0);
       end;
      end;
      '@':begin
       inc(SourcePosition);
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]='.') then begin
        inc(SourcePosition);
        AddToken(ptATDOT,'',0);
       end else begin
        AddToken(ptAT,'',0);
       end;
      end;
      '%':begin
       inc(SourcePosition);
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]='=') then begin
        inc(SourcePosition);
        AddToken(ptMODEQ,'',0);
       end else begin
        AddToken(ptMOD,'',0);
       end;
      end;
      '&':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '&':begin
          inc(SourcePosition);
          AddToken(ptAND,'',0);
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptBANDEQ,'',0);
         end;
         else begin
          AddToken(ptBAND,'',0);
         end;
        end;
       end else begin
        AddToken(ptBAND,'',0);
       end;
      end;
      '|':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '|':begin
          inc(SourcePosition);
          AddToken(ptOR,'',0);
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptBOREQ,'',0);
         end;
         else begin
          AddToken(ptBOR,'',0);
         end;
        end;
       end else begin
        AddToken(ptBOR,'',0);
       end;
      end;
      '+':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '+':begin
          inc(SourcePosition);
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]='+') then begin
           inc(SourcePosition);
           AddToken(ptPREINC,'',0);
          end else begin
           AddToken(ptPOSTINC,'',0);
          end;
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptPLUSEQ,'',0);
         end;
         else begin
          AddToken(ptPLUS,'',0);
         end;
        end;
       end else begin
        AddToken(ptPLUS,'',0);
       end;
      end;
      '-':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '-':begin
          inc(SourcePosition);
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]='-') then begin
           inc(SourcePosition);
           AddToken(ptPREDEC,'',0);
          end else begin
           AddToken(ptPOSTDEC,'',0);
          end;
         end;
         '>':begin
          inc(SourcePosition);
          AddToken(ptLAMBDA,'',0);
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptMINUSEQ,'',0);
         end;
         else begin
          AddToken(ptMINUS,'',0);
         end;
        end;
       end else begin
        AddToken(ptMINUS,'',0);
       end;
      end;
      '*':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '*':begin
          inc(SourcePosition);
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]='=') then begin
           inc(SourcePosition);
           AddToken(ptPOWEQ,'',0);
          end else begin
           AddToken(ptPOW,'',0);
          end;
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptMULEQ,'',0);
         end;
         else begin
          AddToken(ptMUL,'',0);
         end;
        end;
       end else begin
        AddToken(ptMUL,'',0);
       end;
      end;
      '/':begin
       OK:=false;
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '*':begin
          inc(SourcePosition);
          while SourcePosition<=SourceLength do begin
           CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
           case CharValue of
            $0000:begin
             break;
            end;
            $000a:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
              inc(SourcePosition);
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            $000d:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
              inc(SourcePosition);
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            $2028,$2029:begin
             inc(SourceLine);
             SourceColumn:=0;
            end;
            ord('*'):begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]='/') then begin
              inc(SourcePosition);
              inc(SourceColumn);
              break;
             end;
            end;
            else begin
             inc(SourceColumn);
            end;
           end;
          end;
         end;
         '/':begin
          while SourcePosition<=SourceLength do begin
           CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
           case CharValue of
            $0000:begin
             break;
            end;
            $000a:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
              inc(SourcePosition);
             end;
             break;
            end;
            $000d:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
              inc(SourcePosition);
             end;
             break;
            end;
            $2028,$2029:begin
             break;
            end;
            else begin
            end;
           end;
          end;
          inc(SourceLine);
          SourceColumn:=0;
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptDIVEQ,'',0);
         end;
         else begin
          OK:=true;
         end;
        end;
       end else begin
        OK:=true;
       end;
       if OK then begin
        if not (assigned(Parser.Tree.LastChild) and (Parser.Tree.LastChild^.Token in [ptLITERALSTR,ptLITERALNUM,ptSYMBOL,ptRPAR,ptRBRA,ptRCURL,ptNULL,ptSUPERTHAT,ptTHAT,ptTHIS,ptSELF,ptLOCAL,ptGLOBAL,ptBASECLASS,ptTRUE,ptFALSE])) then begin
         OldSourcePosition:=SourcePosition;
         OldSourceColumn:=SourceColumn;
         OldSourceLine:=SourceLine;
         OldSourceChar:=SourceChar;
         OldLastPragma:=LastPragma;
         OldLastOutputInfo:=LastOutputInfo;
         dec(SourcePosition);
         OK:=false;
         if OK then begin
         end;
         InClass:=false;
         begin
          LastSourcePosition:=SourcePosition;
          inc(SourcePosition);
          inc(SourceColumn);
          while SourcePosition<=SourceLength do begin
           SourceChar:=Source[SourcePosition];
           case SourceChar of
            #10,#13:begin
             if ((SourcePosition+1)<=SourceLength) and ((Source[SourcePosition+1] in [#10,#13]) and (Source[SourcePosition]<>Source[SourcePosition+1])) then begin
              inc(SourcePosition,2);
             end else begin
              inc(SourcePosition);
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            '/':begin
             if not InClass then begin
              inc(SourcePosition);
              inc(SourceColumn);
              while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['a'..'z']) do begin
               inc(SourcePosition);
               inc(SourceColumn);
              end;
              break;
             end;
            end;
            '\':begin
             inc(SourcePosition);
             inc(SourceColumn);
             if SourcePosition<=SourceLength then begin
              PUCUUTF8SafeInc(Source,SourcePosition);
              inc(SourceColumn);
             end;
            end;
            '#':begin
             inc(SourcePosition);
             while SourcePosition<=SourceLength do begin
              CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
              case CharValue of
               $0000:begin
                break;
               end;
               $000a:begin
                if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
                 inc(SourcePosition);
                end;
                break;
               end;
               $000d:begin
                if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
                 inc(SourcePosition);
                end;
                break;
               end;
               $2028,$2029:begin
                break;
               end;
               else begin
               end;
              end;
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            '[':begin
             inc(SourcePosition);
             inc(SourceColumn);
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=':') then begin
              inc(SourcePosition);
              inc(SourceColumn);
              while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['a'..'z']) do begin
               inc(SourcePosition);
               inc(SourceColumn);
              end;
              if (SourcePosition<=SourceLength) and (Source[SourcePosition]=':') then begin
               inc(SourcePosition);
               inc(SourceColumn);
               if (SourcePosition<=SourceLength) and (Source[SourcePosition]=']') then begin
                inc(SourcePosition);
                inc(SourceColumn);
               end;
              end;
             end else begin
              InClass:=true;
             end;
            end;
            ']':begin
             InClass:=false;
             inc(SourcePosition);
             inc(SourceColumn);
            end;
            '(':begin
             inc(SourcePosition);
             inc(SourceColumn);
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]='?') then begin
              inc(SourcePosition);
              inc(SourceColumn);
              if (SourcePosition<=SourceLength) and (Source[SourcePosition]='#') then begin
               inc(SourcePosition);
               inc(SourceColumn);
               while (SourcePosition<=SourceLength) and (Source[SourcePosition]<>')') do begin
                CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
                case CharValue of
                 $0000:begin
                  break;
                 end;
                 $000a:begin
                  if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
                   inc(SourcePosition);
                  end;
                  inc(SourceLine);
                  SourceColumn:=0;
                 end;
                 $000d:begin
                  if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
                   inc(SourcePosition);
                  end;
                  inc(SourceLine);
                  SourceColumn:=0;
                 end;
                 $2028,$2029:begin
                  inc(SourceLine);
                  SourceColumn:=0;
                 end;
                 else begin
                  inc(SourceColumn);
                 end;
                end;
               end;
               if (SourcePosition<=SourceLength) and (Source[SourcePosition]=')') then begin
                inc(SourcePosition);
                inc(SourceColumn);
               end;
              end;
             end;
            end;
            else begin
             CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
             case CharValue of
              $000a:begin
               if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
                inc(SourcePosition);
               end;
               inc(SourceLine);
               SourceColumn:=0;
              end;
              $000d:begin
               if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
                inc(SourcePosition);
               end;
               inc(SourceLine);
               SourceColumn:=0;
              end;
              $2028,$2029:begin
               inc(SourceLine);
               SourceColumn:=0;
              end;
              else begin
               inc(SourceColumn);
              end;
             end;
            end;
           end;
          end;
          if LastSourcePosition<SourcePosition then begin
           StringContent:=copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition);
           RegExp:=nil;
           try
            try
             RegExp:=POCARegExpCompile(Parser.Context,StringContent,PUCUUTF8Get(StringContent));
             OK:=true;
            except
             on e:Exception do begin
              SyntaxError(TPUCUUTF8String(e.Message),Parser.SourceFile,SourceLine,SourceColumn);
              OK:=false;
             end;
            end;
           finally
            if assigned(RegExp) then begin
             RegExp.Free;
            end;
           end;
          end else begin
           OK:=false;
          end;
         end;
         if OK then begin
          AddToken(ptLPAR,'',0);
          AddToken(ptREGEXP,'',0);
          AddToken(ptLITERALSTR,{$ifdef pocastrictutf8}PUCUUTF8Correct(StringContent){$else}StringContent{$endif},0);
          AddToken(ptRPAR,'',0);
          continue;
         end else begin
          SourcePosition:=OldSourcePosition;
          SourceColumn:=OldSourceColumn;
          SourceLine:=OldSourceLine;
          SourceChar:=OldSourceChar;
          LastPragma:=OldLastPragma;
          LastOutputInfo:=OldLastOutputInfo;
          if SourceChar<>#0 then begin
          end;
         end;
        end;
        AddToken(ptDIV,'',0);
       end;
      end;
      '~':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '=':begin
          inc(SourcePosition);
          AddToken(ptCATEQ,'',0);
         end;
         else begin
          AddToken(ptCAT,'',0);
         end;
        end;
       end else begin
        AddToken(ptCAT,'',0);
       end;
      end;
      '!':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '=':begin
          inc(SourcePosition);
          if SourcePosition<=SourceLength then begin
           case Source[SourcePosition] of
            '=':begin
             inc(SourcePosition);
             AddToken(ptSNEQ,'',0);
            end;
            else begin
             AddToken(ptNEQ,'',0);
            end;
           end;
          end else begin
           AddToken(ptNEQ,'',0);
          end;
         end;
         '~':begin
          if ((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='=') then begin
           inc(SourcePosition,2);
           AddToken(ptREGEXPNEQ,'',0);
          end else begin
           AddToken(ptNOT,'',0);
          end;
         end;
         else begin
          AddToken(ptNOT,'',0);
         end;
        end;
       end else begin
        AddToken(ptNOT,'',0);
       end;
      end;
      '=':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '=':begin
          inc(SourcePosition);
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]='=') then begin
           inc(SourcePosition);
           AddToken(ptSEQ,'',0);
          end else begin
           AddToken(ptEQ,'',0);
          end;
         end;
         '~':begin
          if ((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='=') then begin
           inc(SourcePosition,2);
           AddToken(ptREGEXPEQ,'',0);
          end else begin
           AddToken(ptASSIGN,'',0);
          end;
         end;
         '>':begin
          inc(SourcePosition);
          AddToken(ptFASTLAMBDA,'',0);
         end;
         else begin
          AddToken(ptASSIGN,'',0);
         end;
        end;
       end else begin
        AddToken(ptASSIGN,'',0);
       end;
      end;
      '<':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '<':begin
          inc(SourcePosition);
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]='=') then begin
           inc(SourcePosition);
           AddToken(ptBSHLEQ,'',0);
          end else begin
           AddToken(ptBSHL,'',0);
          end;
         end;
         '=':begin
          inc(SourcePosition);
          case Source[SourcePosition] of
           '>':begin
            inc(SourcePosition);
            AddToken(ptCMP,'',0);
           end;
           else begin
            AddToken(ptLTEQ,'',0);
           end;
          end;
         end;
         else begin
          AddToken(ptLT,'',0);
         end;
        end;
       end else begin
        AddToken(ptLT,'',0);
       end;
      end;
      '>':begin
       inc(SourcePosition);
       if SourcePosition<=SourceLength then begin
        case Source[SourcePosition] of
         '>':begin
          inc(SourcePosition);
          if SourcePosition<=SourceLength then begin
           case Source[SourcePosition] of
            '>':begin
             inc(SourcePosition);
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]='=') then begin
              inc(SourcePosition);
              AddToken(ptBUSHREQ,'',0);
             end else begin
              AddToken(ptBUSHR,'',0);
             end;
            end;
            '=':begin
             inc(SourcePosition);
             AddToken(ptBSHREQ,'',0);
            end;
            else begin
             AddToken(ptBSHR,'',0);
            end;
           end;
          end else begin
           AddToken(ptBSHR,'',0);
          end;
         end;
         '=':begin
          inc(SourcePosition);
          AddToken(ptGTEQ,'',0);
         end;
         else begin
          AddToken(ptGT,'',0);
         end;
        end;
       end else begin
        AddToken(ptGT,'',0);
       end;
      end;
      '#':begin
       inc(SourcePosition);
       while SourcePosition<=SourceLength do begin
        CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
        case CharValue of
         $0000:begin
          break;
         end;
         $000a:begin
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
           inc(SourcePosition);
          end;
          break;
         end;
         $000d:begin
          if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
           inc(SourcePosition);
          end;
          break;
         end;
         $2028,$2029:begin
          break;
         end;
         else begin
         end;
        end;
       end;
       inc(SourceLine);
       SourceColumn:=0;
      end;
      '''','"','`':begin
       EndChar:=SourceChar;
       inc(SourcePosition);
       inc(SourceColumn);
       LastSourcePosition:=SourcePosition;
       StringContent:='';
       while SourcePosition<=SourceLength do begin
        SourceChar:=Source[SourcePosition];
        if SourceChar=EndChar then begin
         if (EndChar='''') and (((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='''')) then begin
          if LastSourcePosition<SourcePosition then begin
           StringContent:=StringContent+copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition);
          end;
          StringContent:=StringContent+'''';
          inc(SourcePosition,2);
          LastSourcePosition:=SourcePosition;
         end else begin
          break;
         end;
        end else begin
         case SourceChar of
          #0:begin
           SyntaxError('Unterminated string',Parser.SourceFile,SourceLine,SourceColumn);
           break;
          end;
          #10,#13:begin
           if ((SourcePosition+1)<=SourceLength) and ((Source[SourcePosition+1] in [#10,#13]) and (Source[SourcePosition]<>Source[SourcePosition+1])) then begin
            inc(SourcePosition,2);
           end else begin
            inc(SourcePosition);
           end;
           inc(SourceLine);
           SourceColumn:=0;
          end;
          '$':begin
           if (EndChar='`') and (((SourcePosition+1)<=SourceLength) and ((Source[SourcePosition+1]='{'))) then begin
            if LastSourcePosition<SourcePosition then begin
             StringContent:=StringContent+copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition);
            end;
            inc(SourcePosition,2);
            inc(SourceColumn,2);
            LastSourcePosition:=SourcePosition;
            StringInterpolation;
            LastSourcePosition:=SourcePosition;
           end else begin
            inc(SourcePosition);
            inc(SourceColumn);
           end;
          end;
          '\':begin
           if LastSourcePosition<SourcePosition then begin
            StringContent:=StringContent+copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition);
           end;
           inc(SourcePosition);
           inc(SourceColumn);
           if (EndChar='''') or (EndChar='`') then begin
            StringContent:=StringContent+'\';
           end else begin
            if SourcePosition<=SourceLength then begin
             SourceChar:=Source[SourcePosition];
             PUCUUTF8SafeInc(Source,SourcePosition);
             inc(SourceColumn);
             case SourceChar of
              'a':begin
               StringContent:=StringContent+#7;
              end;
              'b':begin
               StringContent:=StringContent+#8;
              end;
              't':begin
               StringContent:=StringContent+#9;
              end;
              'n':begin
               StringContent:=StringContent+#10;
              end;
              'v':begin
               StringContent:=StringContent+#11;
              end;
              'f':begin
               StringContent:=StringContent+#12;
              end;
              'r':begin
               StringContent:=StringContent+#13;
              end;
              'x':begin
               Value:=0;
               Counter:=0;
               while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9','A'..'F','a'..'f']) do begin
                Value:=(Value shl 4) or Hex2Byte(Source[SourcePosition]);
                inc(Counter);
                if Counter>1 then begin
                 StringContent:=StringContent+{$ifdef pocastrictutf8}PUCUUTF32CharToUTF8(Value){$else}ansichar(byte(Value)){$endif};
                 Value:=0;
                 Counter:=0;
                end;
                inc(SourcePosition);
                inc(SourceColumn);
               end;
               if Counter<>0 then begin
                StringContent:=StringContent+{$ifdef pocastrictutf8}PUCUUTF32CharToUTF8(Value){$else}ansichar(byte(Value)){$endif};
               end;
              end;
              'u':begin
               Value:=0;
               while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9','A'..'F','a'..'f']) do begin
                Value:=(Value shl 4) or Hex2Byte(Source[SourcePosition]);
                inc(SourcePosition);
                inc(SourceColumn);
               end;
               StringContent:=StringContent+PUCUUTF32CharToUTF8(Value);
              end;
              '0'..'7':begin
               Value:=longword(longword(ord(SourceChar))-longword(ord('0')));
               while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'7']) do begin
                Value:=(Value shl 3) or longword(ord(Source[SourcePosition])-ord('0'));
                inc(SourcePosition);
                inc(SourceColumn);
               end;
               StringContent:=StringContent+PUCUUTF32CharToUTF8(Value);
              end;
              '{':begin
               StringInterpolation;
              end;
              '\':begin
               StringContent:=StringContent+'\';
              end;
              else begin
               StringContent:=StringContent+SourceChar;
              end;
             end;
            end else begin
             SyntaxError('Unterminated string',Parser.SourceFile,SourceLine,SourceColumn);
             break;
            end;
           end;
           LastSourcePosition:=SourcePosition;
          end;
          else begin
           CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
           case CharValue of
            $000a:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
              inc(SourcePosition);
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            $000d:begin
             if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
              inc(SourcePosition);
             end;
             inc(SourceLine);
             SourceColumn:=0;
            end;
            $2028,$2029:begin
             inc(SourceLine);
             SourceColumn:=0;
            end;
            else begin
             inc(SourceColumn);
            end;
           end;
          end;
         end;
        end;
       end;
       if LastSourcePosition<SourcePosition then begin
        StringContent:=StringContent+copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition);
        LastSourcePosition:=SourcePosition+2;
        if LastSourcePosition=0 then begin
        end;
       end;
       if (SourcePosition<=SourceLength) and (Source[SourcePosition]=EndChar) then begin
        inc(SourcePosition);
        inc(SourceColumn);
        AddToken(ptLITERALSTR,{$ifdef pocastrictutf8}PUCUUTF8Correct(StringContent){$else}StringContent{$endif},0);
       end else begin
        SyntaxError('Unterminated string',Parser.SourceFile,SourceLine,SourceColumn);
       end;
      end;
      '0'..'9':begin
       LastSourcePosition:=SourcePosition;
       if (SourceChar='0') and (((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='x')) then begin
        inc(SourcePosition,2);
        inc(SourceColumn,2);
        while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9','A'..'F','a'..'f']) do begin
         inc(SourcePosition);
         inc(SourceColumn);
        end;
        if (LastSourcePosition+2)=SourcePosition then begin
         SyntaxError('Invalid number literal',Parser.SourceFile,SourceLine,SourceColumn);
        end else begin
         AddToken(ptLITERALNUM,'',ConvertStringToDouble(copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition)));
        end;
       end else if (SourceChar='0') and (((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='o')) then begin
        inc(SourcePosition,2);
        inc(SourceColumn,2);
        while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'7']) do begin
         inc(SourcePosition);
         inc(SourceColumn);
        end;
        if (LastSourcePosition+2)=SourcePosition then begin
         SyntaxError('Invalid number literal',Parser.SourceFile,SourceLine,SourceColumn);
        end else begin
         AddToken(ptLITERALNUM,'',ConvertStringToDouble(copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition)));
        end;
       end else if (SourceChar='0') and (((SourcePosition+1)<=SourceLength) and (Source[SourcePosition+1]='b')) then begin
        inc(SourcePosition,2);
        inc(SourceColumn,2);
        while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'1']) do begin
         inc(SourcePosition);
         inc(SourceColumn);
        end;
        if (LastSourcePosition+2)=SourcePosition then begin
         SyntaxError('Invalid number literal',Parser.SourceFile,SourceLine,SourceColumn);
        end else begin
         AddToken(ptLITERALNUM,'',ConvertStringToDouble(copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition)));
        end;
       end else begin
        inc(SourcePosition);
        inc(SourceColumn);
        while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9']) do begin
         inc(SourcePosition);
         inc(SourceColumn);
        end;
        DoParseExp:=true;
        if (SourcePosition<=SourceLength) and (Source[SourcePosition]='.') then begin
         if ((SourcePosition+1)<=SourceLength) and not (Source[SourcePosition+1] in (['.','a'..'z','A'..'Z',#$80..#$ff]-['e','E'])) then begin
          inc(SourcePosition);
          inc(SourceColumn);
          while (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9']) do begin
           inc(SourcePosition);
           inc(SourceColumn);
          end;
         end else begin
          DoParseExp:=false;
         end;
        end;
        if DoParseExp and ((SourcePosition<=SourceLength) and (Source[SourcePosition] in ['e','E'])) then begin
         inc(SourcePosition);
         inc(SourceColumn);
         if (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['-','+']) then begin
          inc(SourcePosition);
          inc(SourceColumn);
         end;
         if (SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9']) then begin
          repeat
           inc(SourcePosition);
           inc(SourceColumn);
          until not ((SourcePosition<=SourceLength) and (Source[SourcePosition] in ['0'..'9']));
         end else begin
          SyntaxError('Invalid number literal',Parser.SourceFile,SourceLine,SourceColumn);
         end;
        end;
        AddToken(ptLITERALNUM,'',ConvertStringToDouble(copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition)));
       end;
      end;
      else begin
       if SourceChar in POCAKeywordChars then begin
        SourceToken:=FindKeywordToken(Source,SourcePosition,SourceLength);
       end else begin
        SourceToken:=ptNONE;
       end;
       if SourceToken<>ptNONE then begin
        Value:=length(LexerKeywordTokens[SourceToken]);
        inc(SourcePosition,Value);
        inc(SourceColumn,Value);
        AddToken(SourceToken,'',0);
       end else begin
        CharValue:=PUCUUTF8CodeUnitGetCharFallBack(Source,SourcePosition);
        case CharValue of
         $03bb:begin
          AddToken(ptFUNCTION,'',0);
          inc(SourceColumn);
         end;
         else begin
          if PUCUUnicodeIsIDBegin(CharValue) then begin
           LastSourcePosition:=SourcePosition;
           while SourcePosition<=SourceLength do begin
            Last:=SourcePosition;
            if PUCUUnicodeIsIDPart(PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition)) then begin
             inc(SourceColumn);
            end else begin
             SourcePosition:=Last;
             break;
            end;
           end;
           AddToken(ptSYMBOL,PUCUUTF8Correct(copy(Source,LastSourcePosition,SourcePosition-LastSourcePosition)),0);
          end else if PUCUUnicodeIsWhiteSpace(CharValue) then begin
           while SourcePosition<=SourceLength do begin
            Last:=SourcePosition;
            CharValue:=PUCUUTF8CodeUnitGetCharAndIncFallback(Source,SourcePosition);
            case CharValue of
             $000a:begin
              if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#13) then begin
               inc(SourcePosition);
              end;
              inc(SourceLine);
              SourceColumn:=0;
             end;
             $000d:begin
              if (SourcePosition<=SourceLength) and (Source[SourcePosition]=#10) then begin
               inc(SourcePosition);
              end;
              inc(SourceLine);
              SourceColumn:=0;
             end;
             $2028,$2029:begin
              inc(SourceLine);
              SourceColumn:=0;
             end;
             else begin
              if PUCUUnicodeIsWhiteSpace(CharValue) then begin
               inc(SourceColumn);
              end else begin
               SourcePosition:=Last;
               break;
              end;
             end;
            end;
           end;
          end else begin
           SyntaxError('Invalid token',Parser.SourceFile,SourceLine,SourceColumn);
           break;
          end;
         end;
        end;
       end;
      end;
     end;
    end;
   finally
    StringContent:='';
   end;
  end;
 begin
  AutomaticSemicolonInsertion:=Instance.AutomaticSemicolonInsertion;
  try
   LastPragma:=0;
   LastOutputInfo:=0;
   SourcePosition:=1;
   SourceLength:=length(Source);
   SourceLine:=1;
   SourceColumn:=0;
   if (SourceLength>2) and ((Source[1]=#$ef) and (Source[2]=#$bb) and (Source[3]=#$bf)) then begin
    inc(SourcePosition,3);
   end;
   ScanUntil(SourceLength);
   FixPrevious;
  finally
   Instance.AutomaticSemicolonInsertion:=AutomaticSemicolonInsertion;
  end;
 end;
 function ScanBlockForwards(Token:PPOCAToken):PPOCAToken;
 var BeginToken,EndToken:TPOCATokenType;
     NestedLevel:longint;
 begin
  if assigned(Token) and (Token^.Token in [ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA]) then begin
   BeginToken:=Token^.Token;
   case BeginToken of
    ptLPAR:begin
     EndToken:=ptRPAR;
    end;
    ptLBRA:begin
     EndToken:=ptRBRA;
    end;
    ptLCURL:begin
     EndToken:=ptRCURL;
    end;
    else {ptSAFELBRA:}begin
     EndToken:=ptSAFERBRA;
    end;
   end;
   result:=Token^.Next;
   NestedLevel:=1;
   while assigned(result) do begin
    if result^.Token=BeginToken then begin
     inc(NestedLevel);
    end else if result^.Token=EndToken then begin
     dec(NestedLevel);
     if NestedLevel<=0 then begin
      break;
     end;
    end else if result^.Token in [ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA] then begin
     result:=ScanBlockForwards(result);
     if not assigned(result) then begin
      exit;
     end;
    end;
    result:=result^.Next;
   end;
   if assigned(result) and (result^.Token<>EndToken) then begin
    result:=nil;
   end;
  end else begin
   result:=nil;
  end;
 end;
 function ScanBlockBackwards(Token:PPOCAToken):PPOCAToken;
 var BeginToken,EndToken:TPOCATokenType;
     NestedLevel:longint;
 begin
  if assigned(Token) and (Token^.Token in [ptRPAR,ptRBRA,ptRCURL,ptSAFERBRA]) then begin
   BeginToken:=Token^.Token;
   case BeginToken of
    ptRPAR:begin
     EndToken:=ptLPAR;
    end;
    ptRBRA:begin
     EndToken:=ptLBRA;
    end;
    ptRCURL:begin
     EndToken:=ptLCURL;
    end;
    else {ptSAFERBRA:}begin
     EndToken:=ptSAFELBRA;
    end;
   end;
   result:=Token^.Previous;
   NestedLevel:=1;
   while assigned(result) do begin
    if result^.Token=BeginToken then begin
     inc(NestedLevel);
    end else if result^.Token=EndToken then begin
     dec(NestedLevel);
     if NestedLevel<=0 then begin
      break;
     end;
    end else if result^.Token in [ptRPAR,ptRBRA,ptRCURL] then begin
     result:=ScanBlockBackwards(result);
     if not assigned(result) then begin
      exit;
     end;
    end;
    result:=result^.Previous;
   end;
   if assigned(result) and (result^.Token<>EndToken) then begin
    result:=nil;
   end;
  end else begin
   result:=nil;
  end;
 end;
 procedure ProcessTransformer(var Parser:TPOCAParser);
  function NewToken(WhereToken:PPOCAToken;Token:TPOCATokenType):PPOCAToken;
  begin
   New(result);
   FillChar(result^,sizeof(TPOCAToken),#0);
   result^.TokenListNext:=TokenList;
   TokenList:=result;
   result^.Token:=Token;
   result^.Visited:=false;
   result^.Rule:=prNONE;
   result^.SourceFile:=WhereToken^.SourceFile;
   result^.SourceLine:=WhereToken^.SourceLine;
   result^.SourceColumn:=WhereToken^.SourceColumn;
  end;
  function InsertAfter(WhereToken:PPOCAToken;Token:TPOCATokenType):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=Token;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken;
   NewToken^.Next:=WhereToken^.Next;
   WhereToken^.Next:=NewToken;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertNumAfter(WhereToken:PPOCAToken;Value:double):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;     
   NewToken^.Token:=ptLITERALNUM;
   NewToken^.Num:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken;
   NewToken^.Next:=WhereToken^.Next;
   WhereToken^.Next:=NewToken;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertSymbolAfter(WhereToken:PPOCAToken;const Value:TPOCARawByteString):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptSYMBOL;
   NewToken^.Str:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken;
   NewToken^.Next:=WhereToken^.Next;
   WhereToken^.Next:=NewToken;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertStringAfter(WhereToken:PPOCAToken;const Value:TPOCARawByteString):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptLITERALSTR;
   NewToken^.Str:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken;
   NewToken^.Next:=WhereToken^.Next;
   WhereToken^.Next:=NewToken;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertSymbolNameAfter(WhereToken:PPOCAToken;const Value:TPOCARawByteString):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptSYMBOLNAME;
   NewToken^.Str:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken;
   NewToken^.Next:=WhereToken^.Next;
   WhereToken^.Next:=NewToken;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertBefore(WhereToken:PPOCAToken;Token:TPOCATokenType):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=Token;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken^.Previous;
   NewToken^.Next:=WhereToken;
   if assigned(NewToken^.Previous) then begin
    NewToken^.Previous^.Next:=NewToken;
   end;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.Children=WhereToken then begin
    Parser.Tree.Children:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertNumBefore(WhereToken:PPOCAToken;Value:double):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptLITERALNUM;
   NewToken^.Num:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken^.Previous;
   NewToken^.Next:=WhereToken;
   if assigned(NewToken^.Previous) then begin
    NewToken^.Previous^.Next:=NewToken;
   end;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.Children=WhereToken then begin
    Parser.Tree.Children:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertSymbolBefore(WhereToken:PPOCAToken;const Value:TPOCARawByteString):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptSYMBOL;
   NewToken^.Str:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken^.Previous;
   NewToken^.Next:=WhereToken;
   if assigned(NewToken^.Previous) then begin
    NewToken^.Previous^.Next:=NewToken;
   end;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.Children=WhereToken then begin
    Parser.Tree.Children:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  function InsertSymbolNameBefore(WhereToken:PPOCAToken;const Value:TPOCARawByteString):PPOCAToken;
  var NewToken:PPOCAToken;
  begin
   New(NewToken);
   FillChar(NewToken^,sizeof(TPOCAToken),#0);
   NewToken^.TokenListNext:=TokenList;
   TokenList:=NewToken;
   NewToken^.Token:=ptSYMBOLNAME;
   NewToken^.Str:=Value;
   NewToken^.Visited:=false;
   NewToken^.SourceFile:=WhereToken^.SourceFile;
   NewToken^.SourceLine:=WhereToken^.SourceLine;
   NewToken^.SourceColumn:=WhereToken^.SourceColumn;
   NewToken^.Previous:=WhereToken^.Previous;
   NewToken^.Next:=WhereToken;
   if assigned(NewToken^.Previous) then begin
    NewToken^.Previous^.Next:=NewToken;
   end;
   if assigned(NewToken^.Next) then begin
    NewToken^.Next^.Previous:=NewToken;
   end;
   if Parser.Tree.Children=WhereToken then begin
    Parser.Tree.Children:=NewToken;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=NewToken;
   end;
   result:=NewToken;
  end;
  procedure RemoveToken(Token:PPOCAToken);
  begin
   if assigned(Token^.Previous) then begin
    Token^.Previous^.Next:=Token^.Next;
   end else if Parser.Tree.Children=Token then begin
    Parser.Tree.Children:=Token^.Next;
   end;
   if assigned(Token^.Next) then begin
    Token^.Next^.Previous:=Token^.Previous;
   end else if Parser.Tree.LastChild=Token then begin
    Parser.Tree.LastChild:=Token^.Previous;
   end;
  end;
  function MoveToAfter(WhereToken,Token:PPOCAToken):PPOCAToken;
  begin
   RemoveToken(Token);
   Token^.Previous:=WhereToken;
   Token^.Next:=WhereToken^.Next;
   WhereToken^.Next:=Token;
   if assigned(Token^.Next) then begin
    Token^.Next^.Previous:=Token;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=Token;
   end;
   result:=Token;
  end;
  function MoveToBefore(WhereToken,Token:PPOCAToken):PPOCAToken;
  begin
   RemoveToken(Token);
   Token^.Previous:=WhereToken^.Previous;
   Token^.Next:=WhereToken;
   if assigned(Token^.Previous) then begin
    Token^.Previous^.Next:=Token;
   end;
   if assigned(Token^.Next) then begin
    Token^.Next^.Previous:=Token;
   end;
   if Parser.Tree.Children=WhereToken then begin
    Parser.Tree.Children:=Token;
   end;
   if Parser.Tree.LastChild=WhereToken then begin
    Parser.Tree.LastChild:=Token;
   end;
   result:=Token;
  end;
  procedure TransformAtThis;
  var CurrentToken:PPOCAToken;
  begin
   CurrentToken:=Parser.Tree.Children;
   while assigned(CurrentToken) do begin
    case CurrentToken^.Token of
     ptAT:begin
      if not (assigned(CurrentToken^.Previous) and
              (CurrentToken^.Previous.Token in [ptSYMBOL,
                                                ptSUPERCODESYMBOL,
                                                ptSUPERTHAT,
                                                ptTHAT,
                                                ptTHIS,
                                                ptSELF,
                                                ptLOCAL,
                                                ptGLOBAL,
                                                ptBASECLASS,
                                                ptPROTOTYPE,
                                                ptCONSTRUCTOR,
                                                ptHASHKIND,
                                                ptRPAR,
                                                ptRBRA,
                                                ptRCURL,
                                                ptLITERALSTR,
                                                ptLITERALNUM])) then begin
       CurrentToken^.Token:=ptTHIS;
       InsertAfter(CurrentToken,ptDOT);
      end else begin
       CurrentToken:=CurrentToken^.Next;
      end;
     end;
     else begin
      CurrentToken:=CurrentToken^.Next;
     end;
    end;
   end;
  end;
  procedure TransformLambdaFunction;
  var CurrentToken,NextToken,Token:PPOCAToken;
  begin
   CurrentToken:=Parser.Tree.Children;
   while assigned(CurrentToken) do begin
    case CurrentToken^.Token of
     ptLAMBDA,ptFASTLAMBDA:begin
      NextToken:=CurrentToken^.Next;
      if assigned(NextToken) and (NextToken^.Token=ptSYMBOLNAME) then begin
       NextToken:=NextToken^.Next;
      end;
      if not (assigned(CurrentToken^.Previous) and (CurrentToken^.Previous^.Token=ptRPAR)) then begin
       SyntaxError('Missed closed parenthesis brace',CurrentToken^.SourceFile,CurrentToken^.SourceLine,CurrentToken^.SourceColumn);
      end;
      Token:=ScanBlockBackwards(CurrentToken^.Previous);
      if not (assigned(Token) and (Token^.Token=ptLPAR)) then begin
       SyntaxError('Missed open parenthesis brace',CurrentToken^.SourceFile,CurrentToken^.SourceLine,CurrentToken^.SourceColumn);
      end;
      MoveToBefore(Token,CurrentToken);
      if CurrentToken^.Token=ptFASTLAMBDA then begin
       CurrentToken^.Token:=ptFASTFUNCTION;
      end else begin
       CurrentToken^.Token:=ptFUNCTION;
      end;
      if (assigned(CurrentToken^.Previous) and
         (CurrentToken^.Previous^.Token in [ptSYMBOL,
                                            ptSUPERTHAT,
                                            ptTHAT,
                                            ptTHIS,
                                            ptSELF,
                                            ptLOCAL,
                                            ptGLOBAL,
                                            ptBASECLASS,
                                            ptPROTOTYPE,
                                            ptCONSTRUCTOR,
                                            ptHASHKIND,
                                            ptRBRA])) then begin
       InsertBefore(CurrentToken,ptASSIGN);
       if assigned(CurrentToken) and
          assigned(CurrentToken^.Previous) and
          (CurrentToken^.Previous^.Token=ptASSIGN) and
          assigned(CurrentToken^.Previous^.Previous) and
          (CurrentToken^.Previous^.Previous^.Token=ptSYMBOL) then begin
        if (assigned(CurrentToken^.Previous^.Next) and (CurrentToken^.Previous^.Next^.Token in [ptFASTFUNCTION,ptFUNCTION])) and not
           (assigned(CurrentToken^.Previous^.Next^.Next) and (CurrentToken^.Previous^.Next^.Next^.Token in [ptSYMBOLNAME])) then begin
         InsertSymbolNameAfter(CurrentToken^.Previous^.Next,CurrentToken^.Previous^.Previous^.Str);
        end;
       end;
      end;
      CurrentToken:=NextToken;
     end;
     else begin
      CurrentToken:=CurrentToken^.Next;
     end;
    end;
   end;
  end;
  type TByteSet=set of byte;
  function TransformBlock(StartToken:PPOCAToken;EndToken:TPOCATokenTypes;IgnoreVarLocal:boolean):PPOCAToken;
   procedure SkipBraces(var CurrentToken:PPOCAToken);
   var LastToken:PPOCAToken;
   begin
    LastToken:=CurrentToken;
    case CurrentToken^.Token of
     ptLPAR:begin
      CurrentToken:=TransformBlock(CurrentToken^.Next,[ptRPAR],false);
      if assigned(CurrentToken) and (CurrentToken^.Token=ptRPAR) then begin
       CurrentToken:=CurrentToken^.Next;
      end else begin
       SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptLCURL:begin
      CurrentToken:=TransformBlock(CurrentToken^.Next,[ptRCURL],false);
      if assigned(CurrentToken) and (CurrentToken^.Token=ptRCURL) then begin
       CurrentToken:=CurrentToken^.Next;
      end else begin
       SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptLBRA:begin
      CurrentToken:=TransformBlock(CurrentToken^.Next,[ptRBRA],false);
      if assigned(CurrentToken) and (CurrentToken^.Token=ptRBRA) then begin
       CurrentToken:=CurrentToken^.Next;
      end else begin
       SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptSAFELBRA:begin
      CurrentToken:=TransformBlock(CurrentToken^.Next,[ptSAFERBRA],false);
      if assigned(CurrentToken) and (CurrentToken^.Token=ptSAFERBRA) then begin
       CurrentToken:=CurrentToken^.Next;
      end else begin
       SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
    end;
   end;
  var LastToken,NextToken,IdentifierTokenList,LastEndToken,SymbolNameToken,AnchorToken,TempToken,TokenA,TokenB,TokenC:PPOCAToken;
      WhichToken:TPOCATokenType;
      Meta:longint;
      CountStatements:TPOCAInt32;
  begin
   result:=StartToken;
   while assigned(result) and not (result^.Token in EndToken) do begin
    LastToken:=result;
    case result^.Token of
     ptLPAR:begin
      result:=TransformBlock(result^.Next,[ptRPAR],false);
      if assigned(result) and (result^.Token=ptRPAR) then begin
       result:=result^.Next;
      end else begin
       SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptLCURL:begin
      result:=TransformBlock(result^.Next,[ptRCURL],false);
      if assigned(result) and (result^.Token=ptRCURL) then begin
       result:=result^.Next;
      end else begin
       SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptLBRA:begin
      result:=TransformBlock(result^.Next,[ptRBRA],false);
      if assigned(result) and (result^.Token=ptRBRA) then begin
       result:=result^.Next;
      end else begin
       SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptSAFELBRA:begin
      result:=TransformBlock(result^.Next,[ptSAFERBRA],false);
      if assigned(result) and (result^.Token=ptSAFERBRA) then begin
       result:=result^.Next;
      end else begin
       SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptSUPER:begin
      if assigned(result^.Next) and
         (result^.Next^.Token in [ptDOT,ptATDOT]) and
         assigned(result^.Next^.Next) and
         (result^.Next^.Next^.Token=ptSYMBOL) then begin
       result^.Token:=ptSUPERTHAT;
       result^.Next^.Token:=ptATDOT;
      end else begin
       result^.Token:=ptSUPERTHAT;
       InsertAfter(result,ptSUPERCODESYMBOL);
       InsertAfter(result,ptATDOT);
      end;
     end;
     ptCONSTRUCTOR:begin
      if assigned(result^.Previous) and (result^.Previous^.Token in [ptDOT,ptSAFEDOT,ptATDOT]) then begin
       result:=result^.Next;
      end else begin
       result^.Token:=ptFUNCTION;
       InsertSymbolAfter(result,ConstructorValueSymbolString);
      end;
     end;
     ptIMPORT:begin
      TokenA:=nil;
      TokenB:=nil;
      result^.Token:=ptSEMI;
      result:=result^.Next;
      TempToken:=result;
      while assigned(result) and not ((result^.Token in [ptSEMI,ptAUTOSEMI]) or
                                      ((result^.Token=ptSYMBOL) and (result^.Str='from'))) do begin
       if assigned(result) and (result^.Token=ptSYMBOL) then begin
        result:=result^.Next;
        if assigned(result) then begin
         case result^.Token of
          ptSEMI,ptAUTOSEMI:begin
           break;
          end;
          ptCOMMA:begin
           result:=result^.Next;
          end;
          else begin
           if (result^.Token=ptSYMBOL) and (result^.Str='from') then begin
            break;
           end else begin
            SyntaxError('Invalid import statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
            break;
           end;
          end;
         end;
        end;
       end else begin
        result:=result^.Next;
       end;
      end;
      if (result^.Token=ptSYMBOL) and (result^.Str='from') then begin
       result:=result^.Next;
      end else begin
       SyntaxError('Invalid import statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       break;
      end;
      if assigned(result) and (result^.Token=ptSYMBOL) then begin
       TokenA:=result;
       TokenB:=result;
       result:=result^.Next;
       repeat
        if assigned(result) and (result^.Token=ptDOT) then begin
         result:=result^.Next;
         if assigned(result) and (result^.Token=ptSYMBOL) then begin
          TokenB:=result;
          result:=result^.Next;
         end else begin
          SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
         end;
        end else begin
         break;
        end;
       until false;
      end else begin
       SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
      if not (assigned(result) and (result^.Token in [ptSEMI,ptAUTOSEMI])) then begin
       SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
      result:=TempToken;
      while assigned(result) and not ((result^.Token in [ptSEMI,ptAUTOSEMI]) or
                                      ((result^.Token=ptSYMBOL) and (result^.Str='from'))) do begin
       if assigned(result) and (result^.Token=ptSYMBOL) then begin
        NextToken:=result^.Next;
        TempToken:=InsertBefore(result,ptVAR);
        TempToken:=InsertAfter(result,ptASSIGN);
        TokenC:=TokenA;
        while assigned(TokenC) do begin
         TempToken:=InsertAfter(TempToken,TokenC^.Token);
         if TokenC^.Token=ptSYMBOL then begin
          TempToken^.Str:=TokenC^.Str;
         end;
         if TokenC=TokenB then begin
          break;
         end;
         TokenC:=TokenC^.Next;
        end;
        TempToken:=InsertAfter(TempToken,ptDOT);
        TempToken:=InsertSymbolAfter(TempToken,'exports');
        TempToken:=InsertAfter(TempToken,ptDOT);
        TempToken:=InsertAfter(TempToken,result^.Token);
        if result^.Token=ptSYMBOL then begin
         TempToken^.Str:=result^.Str;
        end;
        TempToken:=InsertAfter(TempToken,ptSEMI);
        result:=NextToken;
        if assigned(result) then begin
         case result^.Token of
          ptSEMI,ptAUTOSEMI:begin
           break;
          end;
          ptCOMMA:begin
           result^.Token:=ptSEMI;
           result:=result^.Next;
          end;
          else begin
           if (result^.Token=ptSYMBOL) and (result^.Str='from') then begin
            break;
           end else begin
            SyntaxError('Invalid import statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
            break;
           end;
          end;
         end;
        end;
       end else begin
        result:=result^.Next;
       end;
      end;
      if (result^.Token=ptSYMBOL) and (result^.Str='from') then begin
       result^.Token:=ptSEMI;
       result:=result^.Next;
      end else begin
       SyntaxError('Invalid import statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       break;
      end;
      if assigned(result) and (result^.Token=ptSYMBOL) then begin
       result^.Token:=ptSEMI;
       result:=result^.Next;
       repeat
        if assigned(result) and (result^.Token=ptDOT) then begin
         result^.Token:=ptSEMI;
         result:=result^.Next;
         if assigned(result) and (result^.Token=ptSYMBOL) then begin
          result^.Token:=ptSEMI;
          result:=result^.Next;
         end else begin
          SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
         end;
        end else begin
         break;
        end;
       until false;
      end else begin
       SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
      if not (assigned(result) and (result^.Token in [ptSEMI,ptAUTOSEMI])) then begin
       SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptEXPORT:begin
      result^.Token:=ptSEMI;
      result:=result^.Next;
      while assigned(result) and not (result^.Token in [ptSEMI,ptAUTOSEMI]) do begin
       if assigned(result) and (result^.Token=ptSYMBOL) then begin
        NextToken:=result^.Next;
        TempToken:=InsertBefore(result,ptDOT);
        InsertSymbolBefore(TempToken,'exports');
        TempToken:=InsertAfter(result,ptASSIGN);
        TempToken:=InsertSymbolAfter(TempToken,result^.Str);
        TempToken:=InsertAfter(TempToken,ptSEMI);
        result:=NextToken;
        if assigned(result) then begin
         case result^.Token of
          ptSEMI,ptAUTOSEMI:begin
           break;
          end;
          ptCOMMA:begin
           result^.Token:=ptSEMI;
           result:=result^.Next;
          end;
          else begin
           SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
           break;
          end;
         end;
        end else begin
         break;
        end;
       end else begin
        SyntaxError('Symbol to export expected',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
        break;
       end;
      end;
      if not (assigned(result) and (result^.Token in [ptSEMI,ptAUTOSEMI])) then begin
       SyntaxError('Invalid export statement',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptFOREACH,ptFORKEY,ptFORINDEX:begin
      // transform foreach(a in b) into foreach(a;b) (also for forkey and forindex)
      Meta:=1;
      result:=result^.Next;
      if assigned(result) and (result^.Token=ptLPAR) then begin
       AnchorToken:=result;
       result:=result^.Next;
       while assigned(result) and not (result^.Token=ptRPAR) do begin
        case result^.Token of
         ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA:begin
          result:=ScanBlockForwards(result);
         end;
         ptSEMI:begin
          Meta:=0;
          result:=result^.Next;
         end;
         ptIN:begin
          if Meta>0 then begin
           dec(Meta);
           result^.Token:=ptSEMI;
           result:=result^.Next;
          end else begin
           SyntaxError('Invalid IN syntax usage',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end;
         else begin
          result:=result^.Next;
         end;
        end;
       end;
       if assigned(result) and (result^.Token=ptRPAR) then begin
        result:=AnchorToken;
       end else begin
        SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end else begin
       result:=result^.Next;
      end;
     end;
     ptFASTFUNCTION,ptFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin
      if assigned(result^.Next) and (result^.Next^.Token in [ptSYMBOL,
                                                             ptSUPERTHAT,
                                                             ptTHAT,
                                                             ptTHIS,
                                                             ptSELF,
                                                             ptLOCAL,
                                                             ptGLOBAL,
                                                             ptBASECLASS,
                                                             ptPROTOTYPE,
                                                             ptCONSTRUCTOR,
                                                             ptHASHKIND]) then begin
       if assigned(result^.Next^.Next) and (result^.Next^.Next^.Token<>ptLPAR) then begin
        LastToken:=result;
        NextToken:=result^.Next;
        while assigned(NextToken) do begin
         LastToken:=NextToken;
         case NextToken^.Token of
          ptLPAR:begin
           break;
          end;
          ptLCURL:begin
           NextToken:=TransformBlock(NextToken^.Next,[ptRCURL],false);
           if assigned(NextToken) and (NextToken^.Token=ptRCURL) then begin
            NextToken:=NextToken^.Next;
           end else begin
            SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
           end;
           break;
          end;
          ptLBRA:begin
           NextToken:=TransformBlock(NextToken^.Next,[ptRBRA],false);
           if assigned(NextToken) and (NextToken^.Token=ptRBRA) then begin
            NextToken:=NextToken^.Next;
           end else begin
            SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
           end;
          end;
          ptSAFELBRA:begin
           NextToken:=TransformBlock(NextToken^.Next,[ptSAFERBRA],false);
           if assigned(NextToken) and (NextToken^.Token=ptSAFERBRA) then begin
            NextToken:=NextToken^.Next;
           end else begin
            SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
           end;
          end;
          else begin
           NextToken:=NextToken^.Next;
          end;
         end;
        end;
        SymbolNameToken:=nil;
        if assigned(NextToken) and (NextToken^.Token=ptLPAR) then begin
         if assigned(NextToken^.Previous) and (NextToken^.Previous^.Token=ptSYMBOL) then begin
          SymbolNameToken:=NextToken^.Previous;
         end;
        end else begin
         SyntaxError('Missed open parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
        end;
        while assigned(result^.Next) and (result^.Next<>NextToken) do begin
         case result^.Next^.Token of
          ptCOLONCOLON:begin
           result^.Next^.Token:=ptDOT;
          end;
         end;
         MoveToBefore(result,result^.Next);
        end;
        InsertBefore(result,ptASSIGN);
        LastToken:=result;
        if assigned(SymbolNameToken) and
           (SymbolNameToken^.Token=ptSYMBOL) and
           assigned(result) and
           (result^.Token in [ptFASTFUNCTION,ptFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION]) then begin
         InsertSymbolNameAfter(result,SymbolNameToken^.Str);
         result:=result^.Next;
        end;
        result:=result^.Next;
       end else begin
        if (result^.Next^.Token=ptSYMBOL) and ((not assigned(result^.Previous)) or not (result^.Previous^.Token in [ptVAR,ptREGISTER,ptCONST])) then begin
         InsertBefore(result,ptVAR);
        end;
        if (result^.Next^.Token=ptSYMBOL) and not (assigned(result^.Next^.Next) and (result^.Next^.Next^.Token=ptSYMBOLNAME)) then begin
         InsertSymbolNameAfter(result^.Next,result^.Next^.Str);
        end;
        MoveToBefore(result,result^.Next);
        InsertBefore(result,ptASSIGN);
        LastToken:=result;
        result:=result^.Next;
       end;
      end else begin
       LastToken:=result;
       result:=result^.Next;
      end;
      if assigned(result) then begin
       LastToken:=result;
      end;
      if assigned(result) and (result^.Token=ptSYMBOLNAME) then begin
       result:=result^.Next;
      end;
      if assigned(result) and (result^.Token=ptLPAR) then begin
       result:=TransformBlock(result^.Next,[ptRPAR],true);
       if assigned(result) and (result^.Token=ptRPAR) then begin
        result:=result^.Next;
       end else begin
        SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end;
      if assigned(result) and (result^.Token=ptLCURL) then begin
       result:=TransformBlock(result^.Next,[ptRCURL],false);
       if assigned(result) and (result^.Token=ptRCURL) then begin
        result:=result^.Next;
       end else begin
        SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end;
     end;
     ptCLASS,ptMODULE:begin
      WhichToken:=result^.Token;
      if assigned(result^.Next) and (result^.Next^.Token=ptSYMBOL) then begin
       SymbolNameToken:=result^.Next;
      end else begin
       if WhichToken=ptCLASS then begin
        SymbolNameToken:=InsertSymbolAfter(result,'');
       end else begin
        SymbolNameToken:=nil;
       end;
      end;
      if assigned(result^.Next) and (result^.Next^.Token in [ptSYMBOL,
                                                             ptSUPERTHAT,
                                                             ptTHAT,
                                                             ptTHIS,
                                                             ptSELF,
                                                             ptLOCAL,
                                                             ptGLOBAL,
                                                             ptBASECLASS,
                                                             ptPROTOTYPE,
                                                             ptCONSTRUCTOR,
                                                             ptHASHKIND]) then begin
       if (not assigned(result^.Previous)) or not (result^.Previous^.Token in [ptVAR,ptREGISTER,ptCONST]) then begin
        result^.Token:=ptVAR;
        result:=result^.Next^.Next;
       end else begin
        NextToken:=result^.Next^.Next;
        RemoveToken(result);
        result:=NextToken;
       end;
       while assigned(result) do begin
        case result^.Token of
         ptLPAR:begin
          result:=TransformBlock(result^.Next,[ptRPAR],false);
          if assigned(result) and (result^.Token=ptRPAR) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end;
         ptLCURL:begin
          break;
         end;
         ptLBRA:begin
          result:=TransformBlock(result^.Next,[ptRBRA],false);
          if assigned(result) and (result^.Token=ptRBRA) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end;
         ptSAFELBRA:begin
          result:=TransformBlock(result^.Next,[ptSAFERBRA],false);
          if assigned(result) and (result^.Token=ptSAFERBRA) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end;
         ptEXTENDS:begin
          break;
         end;
         else begin
          result:=result^.Next;
         end;
        end;
       end;
       if assigned(result) then begin
        LastToken:=result;
        InsertBefore(result,ptASSIGN);
        InsertBefore(result,ptLPAR);
        if WhichToken=ptCLASS then begin
         InsertBefore(result,ptCLASSFUNCTION);
        end else begin
         InsertBefore(result,ptMODULEFUNCTION);
        end;
        IdentifierTokenList:=nil;
        if assigned(result) and (result^.Token=ptEXTENDS) then begin
         LastToken:=result;
         NextToken:=result^.Next;
         RemoveToken(result);
         result:=NextToken;
         if assigned(result) and (result^.Token=ptLCURL) then begin
          SyntaxError('Missed symbol',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
         end else begin
          NextToken:=result;
          while assigned(NextToken) do begin
           case NextToken^.Token of
            ptLPAR:begin
             NextToken:=TransformBlock(NextToken^.Next,[ptRPAR],false);
             if assigned(NextToken) and (NextToken^.Token=ptRPAR) then begin
              NextToken:=NextToken^.Next;
             end else begin
              SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
             end;
            end;
            ptLCURL:begin
             break;
            end;
            ptLBRA:begin
             NextToken:=TransformBlock(NextToken^.Next,[ptRBRA],false);
             if assigned(NextToken) and (NextToken^.Token=ptRBRA) then begin
              NextToken:=NextToken^.Next;
             end else begin
              SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
             end;
            end;
            ptSAFELBRA:begin
             NextToken:=TransformBlock(NextToken^.Next,[ptSAFERBRA],false);
             if assigned(NextToken) and (NextToken^.Token=ptSAFERBRA) then begin
              NextToken:=NextToken^.Next;
             end else begin
              SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
             end;
            end;
            else begin
             NextToken:=NextToken^.Next;
            end;
           end;
          end;
          if assigned(NextToken) and (NextToken^.Token=ptLCURL) then begin
           LastEndToken:=NextToken;
           while assigned(result) and (result<>LastEndToken) do begin
            LastToken:=result;
            NextToken:=result^.Next;
            RemoveToken(result);
            result^.Previous:=nil;
            result^.Next:=nil;
            if assigned(IdentifierTokenList) then begin
             IdentifierTokenList^.Next:=result;
             result^.Previous:=IdentifierTokenList;
            end;
            IdentifierTokenList:=result;
            result:=NextToken;
           end;
          end else begin
           SyntaxError('Missed open curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
         end;
        end;
        InsertBefore(result,ptLPAR);
        if assigned(IdentifierTokenList) then begin
         InsertBefore(result,ptREGISTER);
         InsertSymbolBefore(result,#1'PROTO'#1);
        end;
        InsertBefore(result,ptRPAR);
        if assigned(result) and (result^.Token=ptLCURL) then begin
         if (WhichToken in [ptCLASS]) and assigned(SymbolNameToken) then begin
          result:=InsertAfter(result,ptLOCAL);
          result:=InsertAfter(result,ptDOT);
          result:=InsertSymbolAfter(result,'className');
          result:=InsertAfter(result,ptASSIGN);
          result:=InsertStringAfter(result,SymbolNameToken^.Str);
          result:=InsertAfter(result,ptSEMI);
         end;
         if (WhichToken in [ptCLASS]) and assigned(SymbolNameToken) then begin
          result:=InsertAfter(result,ptLOCAL);
          result:=InsertAfter(result,ptDOT);
          result:=InsertSymbolAfter(result,'classType');
          result:=InsertAfter(result,ptASSIGN);
          result:=InsertAfter(result,ptLOCAL);
          result:=InsertAfter(result,ptSEMI);
         end;
         if WhichToken in [ptCLASS,ptMODULE] then begin
          result:=InsertAfter(result,ptLOCAL);
          result:=InsertAfter(result,ptDOT);
          result:=InsertAfter(result,ptHASHKIND);
          result:=InsertAfter(result,ptASSIGN);
          if WhichToken=ptCLASS then begin
           result:=InsertNumAfter(result,phkCLASS);
          end else begin
           result:=InsertNumAfter(result,phkMODULE);
          end;
          result:=InsertAfter(result,ptSEMI);
         end;
         if WhichToken=ptMODULE then begin
          result:=InsertAfter(result,ptLOCAL);
          result:=InsertAfter(result,ptDOT);
          result:=InsertSymbolAfter(result,'exports');
          result:=InsertAfter(result,ptASSIGN);
          result:=InsertAfter(result,ptLCURL);
          result:=InsertAfter(result,ptRCURL);
          result:=InsertAfter(result,ptSEMI);
         end;
         if assigned(IdentifierTokenList) or (WhichToken=ptCLASS) then begin
          begin
           result:=InsertAfter(result,ptLOCAL);
           result:=InsertAfter(result,ptDOT);
           result:=InsertAfter(result,ptPROTOTYPE);
           result:=InsertAfter(result,ptASSIGN);
           if assigned(IdentifierTokenList) then begin
            result:=InsertSymbolAfter(result,#1'PROTO'#1);
           end else begin
            if WhichToken=ptCLASS then begin
             result:=InsertAfter(result,ptBASECLASS);
            end else begin
             result:=InsertAfter(result,ptNULL);
            end;
           end;
           result:=InsertAfter(result,ptSEMI);
          end;
          begin
           result:=InsertAfter(result,ptLOCAL);
           result:=InsertAfter(result,ptDOT);
           result:=InsertAfter(result,ptCONSTRUCTOR);
           result:=InsertAfter(result,ptASSIGN);
           if assigned(IdentifierTokenList) then begin
            result:=InsertSymbolAfter(result,#1'PROTO'#1);
           end else begin
            if WhichToken=ptCLASS then begin
             result:=InsertAfter(result,ptBASECLASS);
            end else begin
             result:=InsertAfter(result,ptNULL);
            end;
           end;
           result:=InsertAfter(result,ptSEMI);
          end;
         end;
         result:=TransformBlock(result^.Next,[ptRCURL],false);
         if assigned(result) and (result^.Token=ptRCURL) then begin
          LastToken:=result;
          result:=InsertAfter(result,ptRPAR);
          result:=InsertAfter(result,ptLPAR);
          if assigned(IdentifierTokenList) then begin
           while assigned(IdentifierTokenList) do begin
            NextToken:=IdentifierTokenList^.Next;
            IdentifierTokenList^.Previous:=nil;
            IdentifierTokenList^.Next:=nil;
            MoveToAfter(result,IdentifierTokenList);
            result:=IdentifierTokenList;
            IdentifierTokenList:=NextToken;
           end;
          end else begin
           if WhichToken=ptCLASS then begin
            result:=InsertAfter(result,ptBASECLASS);
           end else begin
            result:=InsertAfter(result,ptNULL);
           end;
          end;
          result:=InsertAfter(result,ptRPAR);
          if not (assigned(result^.Next) and (result^.Next^.Token in [ptSEMI,ptAUTOSEMI])) then begin
           result:=InsertAfter(result,ptSEMI);
          end;
          result:=result^.Next;
         end else begin
          SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
         end;
        end else begin
         SyntaxError('Missed open curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
        end;
       end else begin
        SyntaxError('Corrupt class definition',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end else begin
       SyntaxError('Missed symbol',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
      end;
     end;
     ptVAR,ptREGISTER,ptCONST:begin
      if IgnoreVarLocal or (assigned(result^.Next) and (result^.Next^.Token in [ptFASTFUNCTION,ptFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION])) then begin
       result:=result^.Next;
      end else begin
       CountStatements:=0;
       AnchorToken:=result;
       WhichToken:=result^.Token;
       result:=result^.Next;
       while assigned(result) and not (result^.Token in [ptCOMMA,ptSEMI,ptAUTOSEMI]) do begin
        LastToken:=result;
        case result^.Token of
         ptLPAR:begin
          result:=TransformBlock(result^.Next,[ptRPAR],false);
          if assigned(result) and (result^.Token=ptRPAR) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed closed parenthesis brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
          if assigned(result) and (result^.Token=ptASSIGN) then begin
           result:=TransformBlock(result^.Next,[ptCOMMA,ptSEMI,ptAUTOSEMI],false);
          end;
         end;
         ptLCURL:begin
          result:=TransformBlock(result^.Next,[ptRCURL],false);
          if assigned(result) and (result^.Token=ptRCURL) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed closed curly brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
          if assigned(result) and (result^.Token=ptASSIGN) then begin
           result:=TransformBlock(result^.Next,[ptCOMMA,ptSEMI,ptAUTOSEMI],false);
          end;
         end;
         ptLBRA:begin
          result:=TransformBlock(result^.Next,[ptRBRA],false);
          if assigned(result) and (result^.Token=ptRBRA) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
          if assigned(result) and (result^.Token=ptASSIGN) then begin
           result:=TransformBlock(result^.Next,[ptCOMMA,ptSEMI,ptAUTOSEMI],false);
          end;
         end;
         ptSAFELBRA:begin
          result:=TransformBlock(result^.Next,[ptSAFERBRA],false);
          if assigned(result) and (result^.Token=ptSAFERBRA) then begin
           result:=result^.Next;
          end else begin
           SyntaxError('Missed safe closed brace',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
          end;
          if assigned(result) and (result^.Token=ptASSIGN) then begin
           result:=TransformBlock(result^.Next,[ptCOMMA,ptSEMI,ptAUTOSEMI],false);
          end;
         end;
         ptSYMBOL:begin
          if assigned(result^.Next) and (result^.Next^.Token in [ptASSIGN]) then begin
           result:=TransformBlock(result^.Next,[ptCOMMA,ptSEMI,ptAUTOSEMI],false);
          end else begin
           result:=InsertAfter(result,ptASSIGN);
           result:=InsertAfter(result,ptNULL);
           result:=result^.Next;
          end;
         end;
         else begin
          result:=result^.Next;
         end;
        end;
        if assigned(result) and (result^.Token=ptCOMMA) then begin
         result^.Token:=ptSEMI;
         result:=InsertAfter(result,WhichToken);
         result:=result^.Next;
        end;
        inc(CountStatements);
       end;
       if assigned(result) and (result^.Token in [ptSEMI,ptAUTOSEMI]) then begin
        if CountStatements>1 then begin
         InsertBefore(AnchorToken,ptINLINEBLOCK);
         InsertBefore(AnchorToken,ptLCURL);
         InsertBefore(result,ptSEMI);
         InsertBefore(result,ptRCURL);
        end;
        result:=result^.Next;
       end else begin
        SyntaxError('Missed semicolon',LastToken^.SourceFile,LastToken^.SourceLine,LastToken^.SourceColumn);
       end;
      end;
     end;
     else begin
      result:=result^.Next;
     end;
    end;
   end;
  end;
 begin
  ResetTokenVisited;
  TransformAtThis;
  TransformLambdaFunction;
  TransformBlock(Parser.Tree.Children,[],false);
// Dump(Parser.Tree.Children);
 end;
 procedure ProcessParser(var Parser:TPOCAParser);
  function NewToken(const t:PPOCAToken;const Token:TPOCATokenType):PPOCAToken;
  begin
   New(result);
   FillChar(result^,sizeof(TPOCAToken),#0);
   result^.TokenListNext:=TokenList;
   TokenList:=result;
   result^.Token:=Token;
   result^.Visited:=false;
   result^.Rule:=prNONE;
   result^.SourceFile:=t^.SourceFile;
   result^.SourceLine:=t^.SourceLine;
   result^.SourceColumn:=t^.SourceColumn;
  end;
  procedure AddNewChild(p,c:PPOCAToken);
  begin
   c^.Parent:=p;
   if assigned(p^.LastChild) then begin
    c^.Previous:=p^.LastChild;
    p^.LastChild^.Next:=c;
   end else begin
    p^.Children:=c;
   end;
   p^.LastChild:=c;
   c^.Rule:=prNONE;
  end;
  procedure ParseBlock(Top:PPOCAToken;EndToken:TPOCATokenType;List:PPPOCAToken;UntilIncludingToken:PPOCAToken);
   function ParseToken(Parent:PPOCAToken;List:PPPOCAToken;ParentToken:TPOCATokenType=ptNONE):PPOCAToken;
   var t,Block,CaseBlock,UntilToIncludeToken:PPOCAToken;
    function Pop:PPOCAToken;
    begin
     result:=List^;
     List^:=result^.Next;
     if assigned(result^.Next) then begin
      result^.Next^.Previous:=result^.Previous;
     end;
     if assigned(result^.Previous) then begin
      result^.Previous^.Next:=result^.Next;
     end;
     result^.Next:=nil;
     result^.Previous:=nil;
    end;
    procedure ParseBraceBlock(IgnoreAutomaticInsertedSemicolon:boolean);
    begin
     if IgnoreAutomaticInsertedSemicolon and (assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptLBRA)))) then begin
      Pop;
     end;
     if (not assigned(List^)) or (List^^.Token<>ptLBRA) then begin
      SyntaxError('Missed open brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
     AddNewChild(t,ParseToken(t,List));
    end;
    procedure ParseParenthesisBraceBlock(IgnoreAutomaticInsertedSemicolon:boolean);
    begin
     if IgnoreAutomaticInsertedSemicolon and (assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptLPAR)))) then begin
      Pop;
     end;
     if (not assigned(List^)) or (List^^.Token<>ptLPAR) then begin
      SyntaxError('Missed open parenthesis brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
     AddNewChild(t,ParseToken(t,List));
    end;
    procedure ParseCurlyBraceBlock(AddCurlyBraceIfNotExist,IgnoreAutomaticInsertedSemicolon:boolean);
    begin
     if IgnoreAutomaticInsertedSemicolon and (assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptLCURL)))) then begin
      Pop;
     end;
     if AddCurlyBraceIfNotExist then begin
      if not assigned(List^) then begin
       SyntaxError('Missed curly brace, expression or statement',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end else begin
      if (not assigned(List^)) or (List^^.Token<>ptLCURL) then begin
       SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
     if List^^.Token=ptLCURL then begin
      AddNewChild(t,ParseToken(t,List));
     end else begin
      if AddCurlyBraceIfNotExist then begin
       Block:=NewToken(t,ptLCURL);
       if List^^.Token in [ptIF,ptELSEIF,ptELSE,ptFOR,ptFOREACH,ptWHILE,ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION,ptFORINDEX,ptFORKEY,ptTRY,ptCATCH,ptFINALLY,ptDO,ptWHEN,ptSWITCH,ptCASE,ptDEFAULT,ptBLOCK,ptINLINEBLOCK] then begin
        AddNewChild(Block,ParseToken(t,List));
       end else begin
        ParseBlock(Block,ptSEMI,List,UntilIncludingToken);
       end;
       AddNewChild(t,Block);
      end else begin
       SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
    end;
    function ScanUntil(const UntilTokens:TPOCATokenTypes):PPOCAToken;
    var Current:PPOCAToken;
    begin
     result:=nil;
     Current:=List^;
     while assigned(Current) and not (Current^.Token in UntilTokens) do begin
      result:=Current;
      case Current^.Token of
       ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA:begin
        Current:=ScanBlockForwards(Current);
       end;
       else begin
        Current:=Current^.Next;
       end;
      end;
     end;
    end;
    procedure ParseUntil(const Dest:PPOCAToken;const UntilTokens:TPOCATokenTypes);
    begin
     while assigned(List^) and not (List^^.Token in UntilTokens) do begin
      AddNewChild(Dest,ParseToken(Dest,List));
     end;
    end;
   var i:longint;
   begin
    t:=List^;
    if assigned(t) then begin
     List^:=t^.Next;
     if assigned(t^.Next) then begin
      t^.Next^.Previous:=nil;
     end;
     if assigned(t^.Previous) then begin
      t^.Previous^.Next:=nil;
     end;
     t^.Next:=nil;
     t^.Previous:=nil;
     t^.Parent:=Parent;
     case t^.Token of
      ptLPAR:begin
       ParseBlock(t,ptRPAR,List,UntilIncludingToken);
      end;
      ptLBRA:begin
       ParseBlock(t,ptRBRA,List,UntilIncludingToken);
      end;
      ptLCURL:begin
       ParseBlock(t,ptRCURL,List,UntilIncludingToken);
      end;
      ptSAFELBRA:begin
       ParseBlock(t,ptSAFERBRA,List,UntilIncludingToken);
      end;
      ptBLOCK:begin
       ParseCurlyBraceBlock(false,true);
      end;
      ptINLINEBLOCK:begin
       ParseCurlyBraceBlock(false,true);
      end;
      ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin // function(...){...} / function SymbolName (...){...}
       begin
        if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptSYMBOLNAME))) then begin
         Pop;
        end;
        if assigned(List^) and (List^^.Token=ptSYMBOLNAME) then begin
         AddNewChild(t,Pop);
        end;
       end;
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptIF:begin // if(...){...} / if(...)... + elseif's + else
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptELSEIF,ptELSE]))) then begin
        Pop;
       end;
       while assigned(List^) and (List^^.Token=ptELSEIF) do begin
        AddNewChild(t,ParseToken(t,List));
        if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptELSEIF,ptELSE]))) then begin
         Pop;
        end;
       end;
       if assigned(List^) and (List^^.Token=ptELSE) then begin
        AddNewChild(t,ParseToken(t,List));
        if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptELSEIF,ptELSE]))) then begin
         Pop;
        end;
       end;
      end;
      ptELSEIF:begin // elseif(...){...} / elseif(...)...
       if (not assigned(Parent)) or (Parent^.Token<>ptIF) then begin
        SyntaxError('Missed owner IF-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        ParseParenthesisBraceBlock(true);
        ParseCurlyBraceBlock(true,true);
        if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptELSEIF,ptELSE]))) then begin
         Pop;
        end;
       end;
      end;
      ptELSE:begin // else{...} / else...
       if (not assigned(Parent)) or (Parent^.Token<>ptIF) then begin
        SyntaxError('Missed owner IF-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        ParseCurlyBraceBlock(true,true);
        if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptELSEIF,ptELSE]))) then begin
         Pop;
        end;
       end;
      end;
      ptFOR:begin // for(...){...} / for(...)...
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptFOREACH:begin // foreach(...){...} / foreach(...)...
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptWHILE:begin // while(...){...} / while(...)...
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptFORINDEX:begin // forindex(...){...} / forindex(...)...
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptFORKEY:begin // forkey(...){...} / forkkey(...)...
       ParseParenthesisBraceBlock(true);
       ParseCurlyBraceBlock(true,true);
      end;
      ptDO:begin // do{...}while(...)
       ParseCurlyBraceBlock(false,true);
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptWHILE))) then begin
        Pop;
       end;
       if assigned(List^) and (List^^.Token=ptWHILE) then begin
        AddNewChild(t,Pop);
        ParseParenthesisBraceBlock(true);
       end else begin
        SyntaxError('Bad do{}while() block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptTRY:begin // try{...}
       ParseCurlyBraceBlock(false,true);
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptFINALLY,ptCATCH]))) then begin
        Pop;
       end;
       if assigned(List^) and (List^^.Token=ptFINALLY) then begin
        AddNewChild(t,ParseToken(t,List));
       end else begin
        if assigned(List^) and (List^^.Token=ptCATCH) then begin
         AddNewChild(t,ParseToken(t,List));
         if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptFINALLY))) then begin
          Pop;
         end;
         if assigned(List^) and (List^^.Token=ptFINALLY) then begin
          AddNewChild(t,ParseToken(t,List));
         end;
        end else begin
         SyntaxError('Missed try catch or finally block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
       end;
      end;
      ptCATCH:begin // catch(...){...}
       if (not assigned(Parent)) or (Parent^.Token<>ptTRY) then begin
        SyntaxError('Missed owner TRY-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        ParseParenthesisBraceBlock(true);
        ParseCurlyBraceBlock(false,true);
       end;
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptFINALLY,ptCATCH]))) then begin
        Pop;
       end;
      end;
      ptFINALLY:begin // finally{...}
       if (not assigned(Parent)) or (Parent^.Token<>ptTRY) then begin
        SyntaxError('Missed owner TRY-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        ParseCurlyBraceBlock(false,true);
       end;
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token in [ptFINALLY,ptCATCH]))) then begin
        Pop;
       end;
      end;
      ptWHEN:begin
       ParseParenthesisBraceBlock(true);
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptLCURL))) then begin
        Pop;
       end;
       if assigned(List^) and (List^^.Token=ptLCURL) then begin
        Block:=Pop;
        i:=0;
        while assigned(List^) and not (List^^.Token in [ptRCURL]) do begin
         case List^^.Token of
          ptCASE,ptDEFAULT,ptELSE:begin
           case List^^.Token of
            ptDEFAULT,ptELSE:begin
             List^^.Token:=ptDEFAULT;
            end;
            else begin
             List^^.Token:=ptCASE;
            end;
           end;
           AddNewChild(Block,ParseToken(Block,List,ptWHEN));
           if assigned(List^) and (List^^.Token in [ptSEMI,ptAUTOSEMI]) then begin
            Pop;
           end;
           inc(i);
          end;
          else begin
           SyntaxError('case/default expected',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
          end;
         end;
        end;
        if assigned(List^) and (List^^.Token in [ptRCURL]) then begin
         Pop;
        end;
        if i=0 then begin
         SyntaxError('No empty when blocks allowed',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        AddNewChild(t,Block);
       end else begin
        SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptSWITCH:begin
       ParseParenthesisBraceBlock(true);
       if assigned(List^) and ((List^^.Token=ptAUTOSEMI) and (assigned(List^^.Next) and (List^^.Next^.Token=ptLCURL))) then begin
        Pop;
       end;
       if assigned(List^) and (List^^.Token=ptLCURL) then begin
        Block:=Pop;
        CaseBlock:=nil;
        i:=0;
        while assigned(List^) and not (List^^.Token in [ptRCURL]) do begin
         case List^^.Token of
          ptCASE,ptDEFAULT:begin
           case List^^.Token of
            ptDEFAULT:begin
             List^^.Token:=ptDEFAULT;
            end;
            else begin
             List^^.Token:=ptCASE;
            end;
           end;
           CaseBlock:=ParseToken(Block,List,ptSWITCH);
           AddNewChild(Block,CaseBlock);
           if assigned(List^) and (List^^.Token in [ptSEMI,ptAUTOSEMI]) then begin
            Pop;
           end;
           if assigned(List^) and (List^^.Token in [ptCASE,ptDEFAULT]) then begin
            AddNewChild(CaseBlock^.Right,NewToken(CaseBlock^.Right,ptFALLTHROUGH));
            AddNewChild(CaseBlock^.Right,NewToken(CaseBlock^.Right,ptSEMI));
           end;
           inc(i);
          end;
          else begin
           if assigned(CaseBlock) and assigned(CaseBlock^.Right) and (CaseBlock^.Right^.Token=ptLCURL) then begin
            UntilToIncludeToken:=ScanUntil([ptCASE,ptDEFAULT,ptRCURL]);
            ParseBlock(CaseBlock^.Right,ptNONE,List,UntilToIncludeToken);
            if assigned(List^) and (List^^.Token in [ptSEMI,ptAUTOSEMI]) then begin
             Pop;
            end;
            if assigned(CaseBlock^.Right^.LastChild) and not (CaseBlock^.Right^.LastChild^.Token in [ptSEMI]) then begin
             AddNewChild(CaseBlock^.Right,NewToken(CaseBlock^.Right,ptSEMI));
            end;
            AddNewChild(CaseBlock^.Right,NewToken(CaseBlock^.Right,ptFALLTHROUGH));
            AddNewChild(CaseBlock^.Right,NewToken(CaseBlock^.Right,ptSEMI));
           end else begin
            SyntaxError('Invalid switch block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
           end;
          end;
         end;
        end;
        if assigned(List^) and (List^^.Token in [ptRCURL]) then begin
         Pop;
        end;
        if i=0 then begin
         SyntaxError('No empty switch blocks allowed',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        AddNewChild(t,Block);
       end else begin
        SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptCASE:begin
       if assigned(Parent) and (Parent^.Token=ptLCURL) and (ParentToken in [ptWHEN,ptSWITCH]) then begin
        if ParentToken=ptWHEN then begin
         ParseParenthesisBraceBlock(true);
         ParseCurlyBraceBlock(false,true);
        end else begin
         Block:=NewToken(t,ptLPAR);
         UntilToIncludeToken:=ScanUntil([ptCOLON]);
         if assigned(UntilToIncludeToken) and assigned(UntilToIncludeToken^.Next) and (UntilToIncludeToken^.Next.Token=ptCOLON) then begin
          ParseBlock(Block,ptNONE,List,UntilToIncludeToken);
          AddNewChild(t,Block);
          if assigned(List^) and (List^^.Token=ptCOLON) then begin
           Pop;
           AddNewChild(t,NewToken(t,ptLCURL));
          end else begin
           SyntaxError('Invalid SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
          end;
         end else begin
          SyntaxError('Invalid SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end;
{        ParseUntil(Block,[ptCOLON]);
         AddNewChild(t,Block);
         if assigned(List^) and (List^^.Token=ptCOLON) then begin
          Pop;
          AddNewChild(t,NewToken(t,ptLCURL));
         end else begin
          SyntaxError('Invalid SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end;}
        end;
       end else begin
        SyntaxError('Missed owner WHEN-block or SWITCH-BLOCK',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptDEFAULT:begin
       if assigned(Parent) and (Parent^.Token=ptLCURL) and (ParentToken in [ptWHEN,ptSWITCH]) then begin
        if ParentToken=ptWHEN then begin
         ParseCurlyBraceBlock(false,true);
        end else begin
         if assigned(List^) and (List^^.Token=ptCOLON) then begin
          Pop;
          AddNewChild(t,NewToken(t,ptLCURL));
         end else begin
          SyntaxError('Invalid SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end;
        end;
       end else begin
        SyntaxError('Missed owner WHEN-block or SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
     end;
     result:=t;
    end else begin
     result:=nil;
    end;
   end;
   function DoNeedSemicolon(t,n:PPOCAToken):boolean;
   begin
    if (not assigned(n)) or (n^.Token in [ptSEMI,ptAUTOSEMI,ptRPAR,ptRBRA,ptRCURL,ptELSEIF,ptELSE,ptCATCH,ptFINALLY]) then begin
     result:=false;
    end else begin
     case t^.Token of
      ptIF:begin
       result:=(not assigned(t^.Previous)) or (t^.Previous^.Token in [ptSEMI,ptAUTOSEMI]);
      end;
      ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin
       result:=assigned(t^.Previous) and (t^.Previous^.Token=ptASSIGN);
      end;
      ptFOR,ptFOREACH,ptWHILE,ptFORINDEX,ptFORKEY,ptDO,ptWHEN,ptSWITCH,ptBLOCK,ptINLINEBLOCK:begin
       result:=true;
      end;
      ptTRY:begin
       result:=(not assigned(t^.Previous)) or (t^.Previous^.Token in [ptSEMI,ptAUTOSEMI]);
      end;
      else begin
       result:=false;
      end;
     end;
    end;
   end;
  var t:PPOCAToken;
  begin
   t:=Top;
   while assigned(List^) do begin
    if ((List^^.Token in [ptRPAR,ptRBRA,ptRCURL,ptELSEIF,ptELSE,ptCASE,ptDEFAULT,ptCATCH,ptFINALLY]) and (List^^.Token<>EndToken)) or ((EndToken in [ptSEMI,ptAUTOSEMI]) and (List^^.Token=ptCOMMA)) then begin
     break;
    end;
    t:=ParseToken(t,List);
    if (t^.Token=EndToken) then begin
     exit;
    end;
    AddNewChild(Top,t);
    if DoNeedSemicolon(t,List^) then begin
     AddNewChild(Top,NewToken(t,ptSEMI));
    end;
    if assigned(UntilIncludingToken) and (t=UntilIncludingToken) then begin
     exit;
    end;
   end;
   if ((EndToken<>ptSEMI) and (EndToken<>ptAUTOSEMI)) and (EndToken<>ptNONE) then begin
    if assigned(List^) then begin
     if List^^.Token<>EndToken then begin
      case List^^.Token of
       ptRPAR:begin
        SyntaxError('Missed matching open parenthesis',List^^.SourceFile,List^^.SourceLine,List^^.SourceColumn);
       end;
       ptRBRA:begin
        SyntaxError('Missed matching open brace',List^^.SourceFile,List^^.SourceLine,List^^.SourceColumn);
       end;
       ptRCURL:begin
        SyntaxError('Missed matching open curly brace',List^^.SourceFile,List^^.SourceLine,List^^.SourceColumn);
       end;
       ptELSEIF,ptELSE:begin
        SyntaxError('Missed owner IF-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       ptCATCH,ptFINALLY:begin
        SyntaxError('Missed owner TRY-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       ptCASE,ptDEFAULT:begin
        SyntaxError('Missed owner WHEN-block or SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
     end;
    end;
    case EndToken of
     ptRPAR:begin
      SyntaxError('Missed closed parenthesis',Top^.SourceFile,Top^.SourceLine,Top^.SourceColumn);
     end;
     ptRBRA:begin
      SyntaxError('Missed closed brace',Top^.SourceFile,Top^.SourceLine,Top^.SourceColumn);
     end;
     ptRCURL:begin
      SyntaxError('Missed closed curly brace',Top^.SourceFile,Top^.SourceLine,Top^.SourceColumn);
     end;
     else begin
      SyntaxError('Unterminated block',Top^.SourceFile,Top^.SourceLine,Top^.SourceColumn);
     end;
    end;
   end;
  end;
  function ParsePrecedences(StartToken,EndToken:PPOCAToken;Level:longint):PPOCAToken;
   function EmptyToken:PPOCAToken;
   begin
    New(result);
    FillChar(result^,sizeof(TPOCAToken),#0);
    result^.TokenListNext:=TokenList;
    TokenList:=result;
    result^.Token:=ptEMPTY;
    result^.Visited:=false;
    result^.SourceFile:=Parser.SourceFile;
    result^.SourceLine:=-1;
    result^.SourceColumn:=-1;
   end;
   procedure PrecedenceChildren(t:PPOCAToken);
   var Top:PPOCAToken;
   begin
    Top:=ParsePrecedences(t^.Children,t^.LastChild,0);
    t^.Children:=Top;
    t^.LastChild:=Top;
   end;
   procedure PrecedenceBlock(Block:PPOCAToken);
   var t:PPOCAToken;
   begin
    t:=Block^.Children;
    while assigned(t) do begin
     case t^.Token of
      ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA:begin
       PrecedenceChildren(t);
      end;
      ptIF,ptELSEIF,ptELSE,ptFOR,ptFOREACH,ptWHILE,ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION,ptFORINDEX,ptFORKEY,ptTRY,ptCATCH,ptFINALLY,ptDO,ptWHEN,ptSWITCH,ptCASE,ptDEFAULT,ptBLOCK,ptINLINEBLOCK:begin
       PrecedenceBlock(t);
      end;
     end;
     t:=t^.Next;
    end;
   end;
   procedure PrecedenceWhen(Block:PPOCAToken);
   var t:PPOCAToken;
   begin
    t:=Block^.Children;
    PrecedenceChildren(t);
    PrecedenceBlock(t^.Next);
   end;
   procedure PrecedenceSwitch(Block:PPOCAToken);
   var t:PPOCAToken;
   begin
    t:=Block^.Children;
    PrecedenceChildren(t);
    PrecedenceBlock(t^.Next);
   end;
  var Rule:TPOCATokenPrecedenceRule;
      Precedence:PPOCATokenPrecedence;
      t,Top,Left,Right,a,b,c,d:PPOCAToken;
  begin
   result:=nil;
   if (Level>=length(POCATokenPrecedences)) and (StartToken<>EndToken) then begin
    if assigned(StartToken) then begin
     SyntaxError('Precedence level overflow',StartToken^.SourceFile,StartToken^.SourceLine,StartToken^.SourceColumn);
    end else begin
     SyntaxError('Precedence level overflow',Parser.SourceFile,-1,-1);
    end;
   end;
   if not (assigned(StartToken) or assigned(EndToken)) then begin
    result:=EmptyToken;
   end else begin
{   if longint(StartToken^.Token)=39 then begin
     writeln(longint(StartToken^.Token));
    end;}
    begin
     if not assigned(EndToken) then begin
      EndToken:=StartToken;
     end;
     if not assigned(StartToken) then begin
      StartToken:=EndToken;
     end;
    end;
    begin
     if assigned(StartToken^.Previous) then begin
      StartToken^.Previous^.Next:=nil;
     end;
     if assigned(EndToken^.Next) then begin
      EndToken^.Next^.Previous:=nil;
     end;
     StartToken^.Previous:=nil;
     EndToken^.Next:=nil;
    end;
    if StartToken=EndToken then begin
     case StartToken^.Token of
      ptLPAR,ptLBRA,ptLCURL,ptSAFELBRA:begin
       PrecedenceChildren(StartToken);
      end;
      ptIF,ptELSEIF,ptELSE,ptFOR,ptFOREACH,ptWHILE,ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION,ptFORINDEX,ptFORKEY,ptTRY,ptCATCH,ptFINALLY,ptDO,ptCASE,ptDEFAULT,ptBLOCK,ptINLINEBLOCK:begin
       PrecedenceBlock(StartToken);
      end;
      ptWHEN:begin
       PrecedenceWhen(StartToken);
      end;
      ptSWITCH:begin
       PrecedenceSwitch(StartToken);
      end;
     end;
     result:=StartToken;
    end else begin
     begin
      if StartToken^.Token in [ptSEMI,ptCOMMA,ptCOLON,ptDOTDOT,ptAUTOSEMI] then begin
       t:=EmptyToken;
       StartToken^.Previous:=t;
       t^.Next:=StartToken;
       StartToken:=t;
      end;
      if EndToken^.Token in [ptSEMI,ptCOMMA,ptCOLON,ptDOTDOT,ptAUTOSEMI] then begin
       t:=EmptyToken;
       EndToken^.Next:=t;
       t^.Previous:=EndToken;
       EndToken:=t;
      end;
     end;
     Precedence:=@POCATokenPrecedences[Level];
     if (ptDOT in Precedence^.Tokens) or
        (ptATDOT in Precedence^.Tokens) or
        (ptSAFEDOT in Precedence^.Tokens) then begin
      case EndToken^.Token of
       ptLPAR,ptLBRA,ptSAFELBRA:begin
        dec(Level);
       end;
      end;
     end;
     begin
      Top:=nil;
      Left:=nil;
      Right:=nil;
      Rule:=POCATokenPrecedences[Level].Rule;
      case Rule of
       prBINARY:begin
        t:=EndToken^.Previous;
        while assigned(t^.Previous) do begin
         if t^.Token in POCATokenPrecedences[Level].Tokens then begin
          if assigned(t^.Previous) then begin
           a:=StartToken;
          end else begin
           a:=nil;
          end;
          b:=t^.Previous;
          c:=t^.Next;
          if assigned(t^.Next) then begin
           d:=EndToken;
          end else begin
           d:=nil;
          end;
          Top:=t;
          Left:=ParsePrecedences(a,b,Level);
          Right:=ParsePrecedences(c,d,Level+1);
          break;
         end;
         t:=t^.Previous;
        end;
       end;
       prREVERSE:begin
        t:=StartToken^.Next;
        while assigned(t^.Next) do begin
         if t^.Token in POCATokenPrecedences[Level].Tokens then begin
          if assigned(t^.Previous) then begin
           a:=StartToken;
          end else begin
           a:=nil;
          end;
          b:=t^.Previous;
          c:=t^.Next;
          if assigned(t^.Next) then begin
           d:=EndToken;
          end else begin
           d:=nil;
          end;
          Top:=t;
          Left:=ParsePrecedences(a,b,Level+1);
          Right:=ParsePrecedences(c,d,Level);
          break;
         end;
         t:=t^.Next;
        end;
       end;
       prPREFIX:begin
        if (StartToken^.Token in POCATokenPrecedences[Level].Tokens) and assigned(StartToken^.Next) then begin
         a:=StartToken^.Children;
         b:=StartToken^.LastChild;
         c:=StartToken^.Next;
         d:=EndToken;
         Top:=StartToken;
         if assigned(a) then begin
          Left:=ParsePrecedences(a,b,0);
         end;
         Right:=ParsePrecedences(c,d,Level);
        end;
       end;
       prSUFFIX:begin
        if (EndToken^.Token in POCATokenPrecedences[Level].Tokens) and assigned(EndToken^.Previous) then begin
         a:=StartToken;
         b:=EndToken^.Previous;
         c:=EndToken^.Children;
         d:=EndToken^.LastChild;
         Top:=EndToken;
         Left:=ParsePrecedences(a,b,Level);
         if assigned(c) then begin
          Right:=ParsePrecedences(c,d,0);
         end;
        end;
       end;
      end;
      if assigned(Top) then begin
       Top^.Rule:=Rule;
       if assigned(Left) then begin
        Left^.Next:=Right;
        Left^.Previous:=nil;
       end;
       Top^.Children:=Left;
       if assigned(Right) then begin
        Right^.Next:=nil;
        Right^.Previous:=Left;
       end;
       Top^.LastChild:=Right;
       Top^.Next:=nil;
       Top^.Previous:=nil;
       result:=Top;
      end else begin
       result:=ParsePrecedences(StartToken,EndToken,Level+1);
      end;
     end;
    end;
   end;
  end;
 var t:PPOCAToken;
 begin
  if assigned(Parser.Tree.Children) then begin
   begin
    t:=Parser.Tree.Children;
    while assigned(t) do begin
     t^.Previous:=nil;
     t:=t^.Next;
    end;
   end;
   begin
    t:=Parser.Tree.Children;
    Parser.Tree.Children:=nil;
    Parser.Tree.LastChild:=nil;
    ParseBlock(@Parser.Tree,ptNONE,@t,nil);
    if assigned(t) then begin
     case t^.Token of
      ptRPAR:begin
       SyntaxError('Missed matching open parenthesis',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptRBRA:begin
       SyntaxError('Missed matching open brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptRCURL:begin
       SyntaxError('Missed matching open curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptELSEIF,ptELSE:begin
       SyntaxError('Missed owner IF-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptCATCH,ptFINALLY:begin
       SyntaxError('Missed owner TRY-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptCASE,ptDEFAULT:begin
       SyntaxError('Missed owner WHEN-block or SWITCH-block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      else begin
       SyntaxError('Invalid source',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
    end;
   end;
   begin
    t:=ParsePrecedences(Parser.Tree.Children,Parser.Tree.LastChild,0);
    t^.Next:=nil;
    t^.Previous:=nil;
    Parser.Tree.Children:=t;
    Parser.Tree.LastChild:=t;
   end;
  end;
 end;
 function ProcessCodeGenerator(var Parser:TPOCAParser):TPOCAValue;
 type PPOCACodeGeneratorRegister=^TPOCACodeGeneratorRegister;
      TPOCACodeGeneratorRegister=packed record
       InUse,Freeable,IsNumber,IsConst:bytebool;
      end;
      TPOCACodeGeneratorRegisters=array of TPOCACodeGeneratorRegister;
      PPOCACodeGeneratorSwitch=^TPOCACodeGeneratorSwitch;
      TPOCACodeGeneratorSwitch=record
       BreakJumps:array of longword;
       CountBreakJumps:longint;
       BreakRegisters:array of TPOCACodeGeneratorRegisters;
      end;
      TPOCACodeGeneratorSwitchs=array of TPOCACodeGeneratorSwitch;
      PPOCACodeGeneratorLoop=^TPOCACodeGeneratorLoop;
      TPOCACodeGeneratorLoop=record
       LabelToken:PPOCAToken;
       BreakJumps,ContinueJumps:array of longword;
       CountBreakJumps,CountContinueJumps:longint;
       BreakRegisters,ContinueRegisters:array of TPOCACodeGeneratorRegisters;
      end;
      TPOCACodeGeneratorLoops=array of TPOCACodeGeneratorLoop;
      TPOCACodeGeneratorScope=record
       SymbolRegisterHashMap:TPOCAStringHashMap;
      end;
      TPOCACodeGeneratorScopes=array of TPOCACodeGeneratorScope;
      PPOCACodeGeneratorWhenSwitchCaseBlock=^TPOCACodeGeneratorWhenSwitchCaseBlock;
      TPOCACodeGeneratorWhenSwitchCaseBlock=record
       RetryRegisters:TPOCACodeGeneratorRegisters;
       FallthroughRegisters:TPOCACodeGeneratorRegisters;
       Fallthroughs:array of longword;
       CountFallthroughs:longint;
       JumpRetryPos:longword;
       HasRetry:boolean;
       HasFallthrough:boolean;
      end;
      TPOCACodeGeneratorWhenSwitchCaseBlocks=array of TPOCACodeGeneratorWhenSwitchCaseBlock;
      PPOCACodeGeneratorBreakContinueScopeKind=^TPOCACodeGeneratorBreakContinueScopeKind;
      TPOCACodeGeneratorBreakContinueScopeKind=(bcskLOOP,bcskSWITCH);
      PPOCACodeGeneratorBreakContinueScope=^TPOCACodeGeneratorBreakContinueScope;
      TPOCACodeGeneratorBreakContinueScope=record
       Kind:TPOCACodeGeneratorBreakContinueScopeKind;
       Index:longint;
      end;
      TPOCACodeGeneratorBreakContinueScopes=array of TPOCACodeGeneratorBreakContinueScope;
      PPOCACodeGenerator=^TPOCACodeGenerator;
      TPOCACodeGenerator=record
       LastLine:longint;
       ByteCode:PLongwords;
       ByteCodeSize:longint;
       ByteCodeAllocated:longint;
       Lines:TPOCACodeLines;
       LineCount:longint;
       NextLineIP:longint;
       ArgumentSymbols:PLongints;
       ArgumentLocals:PLongints;
       ArgAllocated:longword;
       OptionalArgumentSymbols:PLongints;
       OptionalArgumentLocals:PLongints;
       OptionalArgumentValues:PLongints;
       OptionalArgumentAllocated:longword;
       RestArgSym:TPOCAValue;
       SwitchTop:longint;
       SwitchAllocated:longint;
       Switchs:TPOCACodeGeneratorSwitchs;
       LoopTop:longint;
       LoopAllocated:longint;
       Loops:TPOCACodeGeneratorLoops;
       Consts:TPOCAValue;
       Scopes:TPOCACodeGeneratorScopes;
       CountScopes:longint;
       Registers:TPOCACodeGeneratorRegisters;
       CountRegisters:longword;
       LocalArguments:array of longint;
       CountLocalArguments:longint;
       LocalArgumentIndex:longint;
       WhenSwitchCaseBlocks:TPOCACodeGeneratorWhenSwitchCaseBlocks;
       CountWhenSwitchCaseBlocks:longint;
       BreakContinueScopes:TPOCACodeGeneratorBreakContinueScopes;
       CountBreakContinueScopes:longint;
       Opcodes:array of longint;
       CountOpcodes:longint;
       HasLocals:longbool;
       FastFunction:longbool;
       Constants:array of PPOCAToken;
       ConstantRegisters:array of longint;
       CountConstants:longint;
       CountRegExps:longint;
      end;
  function GenerateCode(var Parser:TPOCAParser;Block:PPOCAToken;ArgumentList:PPOCAToken;CodeToken:TPOCATokenType;const CodeName:TPOCARawByteString):TPOCAValue;
  var CodeGenerator:PPOCACodeGenerator;
   function GetRegisters:TPOCACodeGeneratorRegisters;
   begin
    result:=copy(CodeGenerator^.Registers,0,CodeGenerator^.CountRegisters);
   end;
   procedure ClearRegisters;
   var i:longint;
   begin
    for i:=0 to CodeGenerator^.CountRegisters-1 do begin
     CodeGenerator^.Registers[i].IsNumber:=false;
    end;
    for i:=0 to CodeGenerator^.CountConstants-1 do begin
     CodeGenerator^.Registers[CodeGenerator^.ConstantRegisters[i]].IsNumber:=assigned(CodeGenerator^.Constants[i]) and (CodeGenerator^.Constants[i]^.Token=ptLITERALNUM);
    end;
   end;
   procedure SetRegisters(const Src:TPOCACodeGeneratorRegisters);
   var i:longint;
   begin
    for i:=0 to CodeGenerator^.CountRegisters-1 do begin
     if i<length(Src) then begin
      CodeGenerator^.Registers[i].IsNumber:=Src[i].IsNumber;
     end;
    end;
   end;
   function AreRegistersEqual(const r1,r2:TPOCACodeGeneratorRegisters;Exact:boolean;Safe:boolean=true):boolean;
   var i:longint;
   begin
    if (Exact and (length(r1)=length(r2))) or ((not Exact) and (length(r1)<=length(r2))) then begin
     result:=true;
     for i:=0 to length(r1)-1 do begin
      if (r1[i].IsNumber<>r2[i].IsNumber) and (Safe or (r1[i].InUse or r2[i].InUse)) then begin
       result:=false;
       break;
      end;
     end;
    end else begin
     result:=false;
    end;
   end;
   procedure CombineRegisters(var Dst:TPOCACodeGeneratorRegisters;const Src:TPOCACodeGeneratorRegisters;Safe:boolean=false);
   var i:longint;
   begin
    for i:=0 to length(Dst)-1 do begin
     if i<length(Src) then begin
      Dst[i].IsNumber:=Dst[i].IsNumber and Src[i].IsNumber;
     end else begin
      if Safe then begin
       Dst[i].IsNumber:=false;
      end else begin
       break;
      end;
     end;
    end;
   end;
   procedure CombineCurrentRegisters(const Src:TPOCACodeGeneratorRegisters;Safe:boolean=false);
   var i:longint;
   begin
    for i:=0 to CodeGenerator^.CountRegisters-1 do begin
     if i<length(Src) then begin
      CodeGenerator^.Registers[i].IsNumber:=CodeGenerator^.Registers[i].IsNumber and Src[i].IsNumber;
     end else begin
      if Safe then begin
       CodeGenerator^.Registers[i].IsNumber:=false;
      end else begin
       break;
      end;
     end;
    end;
   end;
   function GetRegisterNumber(RegNr:longint):boolean;
   begin
    if (RegNr>=0) and (RegNr<longint(CodeGenerator^.CountRegisters)) then begin
     result:=CodeGenerator^.Registers[RegNr].IsNumber;
    end else begin
     result:=false;
    end;
   end;
   function GetRegisterConstant(RegNr:longint):boolean;
   begin
    if (RegNr>=0) and (RegNr<longint(CodeGenerator^.CountRegisters)) then begin
     result:=CodeGenerator^.Registers[RegNr].InUse and CodeGenerator^.Registers[RegNr].IsConst;
    end else begin
     result:=false;
    end;
   end;
   procedure SetRegisterNumber(RegNr:longint;IsNumber:boolean);
   begin
    if (RegNr>=0) and (RegNr<longint(CodeGenerator^.CountRegisters)) then begin
     CodeGenerator^.Registers[RegNr].IsNumber:=IsNumber;
    end;
   end;
   function Unary(t:PPOCAToken):boolean; {$ifdef caninline}inline;{$endif}
   begin
    result:=assigned(t^.Children) and (t^.Children=t^.LastChild);
   end;
   function Binary(t:PPOCAToken):boolean; {$ifdef caninline}inline;{$endif}
   begin
    result:=(assigned(t^.Children) and assigned(t^.LastChild)) and (t^.Children^.Next=t^.LastChild);
   end;
   function GetRegister(Freeable,IsConst:boolean):longint;
   var i:longint;
   begin
    for i:=0 to CodeGenerator^.CountRegisters-1 do begin
     if not CodeGenerator^.Registers[i].InUse then begin
      CodeGenerator^.Registers[i].InUse:=true;
      CodeGenerator^.Registers[i].Freeable:=Freeable;
      CodeGenerator^.Registers[i].IsNumber:=false;
      CodeGenerator^.Registers[i].IsConst:=IsConst;
      result:=i;
      exit;
     end;
    end;
    if longint(CodeGenerator^.CountRegisters)>=length(CodeGenerator^.Registers) then begin
     if CodeGenerator^.CountRegisters=0 then begin
      SetLength(CodeGenerator^.Registers,16);
     end else begin
      SetLength(CodeGenerator^.Registers,CodeGenerator^.CountRegisters shl 1);
     end;
    end;
    result:=CodeGenerator^.CountRegisters;
    CodeGenerator^.Registers[result].InUse:=true;
    CodeGenerator^.Registers[result].Freeable:=Freeable;
    CodeGenerator^.Registers[result].IsNumber:=false;
    CodeGenerator^.Registers[result].IsConst:=IsConst;
    inc(CodeGenerator^.CountRegisters);
   end;
   procedure FreeRegister(var RegNr:longint;Force:boolean=false);
   begin
    if ((RegNr>=0) and (RegNr<longint(CodeGenerator^.CountRegisters))) and (Force or CodeGenerator^.Registers[RegNr].Freeable) then begin
     CodeGenerator^.Registers[RegNr].InUse:=false;
     CodeGenerator^.Registers[RegNr].IsNumber:=false;
     CodeGenerator^.Registers[RegNr].IsConst:=false;
     RegNr:=-1;
    end;
   end;
   procedure Emit(Value:longword);
   var NewSize:longint;
       NewByteCode:pointer;
   begin
    if CodeGenerator^.ByteCodeSize>=CodeGenerator^.ByteCodeAllocated then begin
     NewSize:=CodeGenerator^.ByteCodeAllocated;
     while CodeGenerator^.ByteCodeSize>=NewSize do begin
      inc(NewSize,NewSize);
     end;
     GetMem(NewByteCode,NewSize*sizeof(longword));
     FillChar(NewByteCode^,NewSize*sizeof(longword),#0);
     if assigned(CodeGenerator^.ByteCode) then begin
      Move(CodeGenerator^.ByteCode^,NewByteCode^,CodeGenerator^.ByteCodeSize*sizeof(longword));
      FreeMem(CodeGenerator^.ByteCode);
     end;
     CodeGenerator^.ByteCode:=NewByteCode;
     CodeGenerator^.ByteCodeAllocated:=NewSize;
    end;
    CodeGenerator^.ByteCode^[CodeGenerator^.ByteCodeSize]:=Value;
    inc(CodeGenerator^.ByteCodeSize);
   end;
   procedure PeepholeOptimize;
   var Opcode:longword;
   begin
    while (CodeGenerator^.ByteCodeSize>0) and (CodeGenerator^.CountOpcodes>0) do begin
     Opcode:=CodeGenerator^.ByteCode^[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-1]];
     case Opcode and $ff of
      popLOADNULL:begin
      end;
     end;
{    case Opcode and $ff of
      popPOP:begin
       if CodeGenerator^.CountOpcodes>1 then begin
        case CodeGenerator^.ByteCode^[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-2]] and $ff of
         popPUSHREG,popGETLOCAL,popPUSHZERO,popPUSHONE,popPUSHCONST,popPUSHEND,popGETMEMBER:begin
          dec(CodeGenerator^.CountOpcodes,2);
          CodeGenerator^.ByteCodeSize:=CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes];
          continue;
         end;
         popINCREG,popDECREG:begin
          if CodeGenerator^.CountOpcodes>2 then begin
           case CodeGenerator^.ByteCode^[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-3]] and $ff of
            popPUSHREG:begin
             CodeGenerator^.ByteCode^[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-3]]:=CodeGenerator^.ByteCode^[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-2]];
             dec(CodeGenerator^.CountOpcodes,2);
             CodeGenerator^.ByteCodeSize:=CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes];
             continue;
            end;
           end;
          end;
         end;
        end;
       end;
      end;
     end;}
     break;
    end;
   end;
   procedure EmitOpcode(Opcode:longword); overload;
   begin
    PeepholeOptimize;
    if CodeGenerator^.CountOpcodes>=length(CodeGenerator^.Opcodes) then begin
     if CodeGenerator^.CountOpcodes=0 then begin
      SetLength(CodeGenerator^.Opcodes,1024);
     end else begin
      SetLength(CodeGenerator^.Opcodes,CodeGenerator^.CountOpcodes shl 1);
     end;
    end;
    CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes]:=CodeGenerator^.ByteCodeSize;
    inc(CodeGenerator^.CountOpcodes);
    Emit(Opcode);
   end;
   procedure EmitImmediate(Opcode,Immediate:longword);
   begin
    EmitOpcode((Opcode and $ff) or ((Immediate and $ffffff) shl 8));
   end;
   procedure EmitOpcode(Opcode,Operand:longword); overload;
   begin
    EmitImmediate(Opcode,1);
    Emit(Operand);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB:longword); overload;
   begin
    EmitImmediate(Opcode,2);
    Emit(OperandA);
    Emit(OperandB);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC:longword); overload;
   begin
    EmitImmediate(Opcode,3);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC,OperandD:longword); overload;
   begin
    EmitImmediate(Opcode,4);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
    Emit(OperandD);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC,OperandD,OperandE:longword); overload;
   begin
    EmitImmediate(Opcode,5);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
    Emit(OperandD);
    Emit(OperandE);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC,OperandD,OperandE,OperandF:longword); overload;
   begin
    EmitImmediate(Opcode,6);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
    Emit(OperandD);
    Emit(OperandE);
    Emit(OperandF);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC,OperandD,OperandE,OperandF,OperandG:longword); overload;
   begin
    EmitImmediate(Opcode,7);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
    Emit(OperandD);
    Emit(OperandE);
    Emit(OperandF);
    Emit(OperandG);
   end;
   procedure EmitOpcode(Opcode,OperandA,OperandB,OperandC,OperandD,OperandE,OperandF,OperandG,OperandH:longword); overload;
   begin
    EmitImmediate(Opcode,8);
    Emit(OperandA);
    Emit(OperandB);
    Emit(OperandC);
    Emit(OperandD);
    Emit(OperandE);
    Emit(OperandF);
    Emit(OperandG);
    Emit(OperandH);
   end;
   function NewConstant(c:TPOCAValue):longint;
   begin
    POCAArrayPush(CodeGenerator^.Consts,c);
    result:=POCAArraySize(CodeGenerator^.Consts)-1;
    if result>=$10000 then begin
     SyntaxError('Too many constants in code block',Parser.SourceFile,-1,-1);
    end;
   end;
   function InternConstant(c:TPOCAValue):longint;
   var i,n:longint;
       b:TPOCAValue;
   begin
    n:=POCAArraySize(CodeGenerator^.Consts);
    if not POCAIsValueCode(c) then begin
     for i:=0 to n-1 do begin
      b:=POCAArrayGet(CodeGenerator^.Consts,i);
      if ((POCAIsValueNumber(b) and POCAIsValueNumber(c)) and (b.Num=c.Num)) or
         (POCAIsValueNull(b) and POCAIsValueNull(c)) or
         ((POCAIsValueString(b) and POCAIsValueString(c)) and (PPOCAString(POCAGetValueReferencePointer(b))^.Data=PPOCAString(POCAGetValueReferencePointer(c))^.Data)) then begin
       result:=i;
       exit;
      end;
     end;
    end;
    result:=NewConstant(c);
   end;
   function NewLambda(t:PPOCAToken):TPOCAValue;
   var ArgList:PPOCAToken;
       Name:TPOCARawByteString;
   begin
    if not (assigned(t^.Right) and (t^.Right^.Token=ptLCURL)) then begin
     SyntaxError('Bad function definition',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
    end;
    Name:='';
    ArgList:=nil;
    if assigned(t^.Left) then begin
     if t^.Left^.Token=ptSYMBOLNAME then begin
      Name:=t^.Left^.Str;
      if t^.Left^.Next^.Token=ptLPAR then begin
       if assigned(t^.Left^.Next^.Left) then begin
        ArgList:=t^.Left^.Next^.Left;
       end;
      end else begin
       SyntaxError('Bad function definition',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end else if (t^.Left^.Token=ptLPAR) and assigned(t^.Left^.Left) then begin
      ArgList:=t^.Left^.Left;
     end;
    end;
    result:=GenerateCode(Parser,t^.Right^.Left,ArgList,t^.Token,Name);
   end;
   function FindConstantIndex(t:PPOCAToken):longint;
   var c:TPOCAValue;
   begin
    case t^.Token of
     ptNULL:begin
      c:=POCAValueNull;
     end;
     ptLITERALSTR:begin
      c:=POCANewUniqueString(Parser.Context,t^.Str);
     end;
     ptSYMBOL:begin
      c:=POCAInternSymbol(Parser.Context,Instance,POCANewUniqueString(Parser.Context,t^.Str));
     end;
     ptSUPERCODESYMBOL:begin
      if length(CodeName)>0 then begin
       c:=POCAInternSymbol(Parser.Context,Instance,POCANewUniqueString(Parser.Context,CodeName));
      end else begin
       c:=POCAValueNull;
       SyntaxError('Invalid super syntax usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
     ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin
      c:=NewLambda(t);
     end;
     ptLITERALNUM:begin
      c:=POCANumber(t^.Num);
     end;
     else begin
      c:=POCAValueNull;
      SyntaxError('Invalid constant',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
    end;
    result:=InternConstant(c);
   end;
   function DefineArgument(t:PPOCAToken):longint;
   begin
    if t^.Token=ptLPAR then begin
     if t^.Rule=prSUFFIX then begin
      SyntaxError('Function calls can''t be default arguments',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
     result:=DefineArgument(t^.Right);
    end else begin
     if (t^.Token in [ptMINUS,ptNEG]) and (assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM)) then begin
      t^.Right^.Num:=-t^.Right^.Num;
      result:=DefineArgument(t^.Right);
     end else if (t^.Token in [ptCAT,ptBNOT]) and (assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM)) then begin
      t^.Right^.Num:=not int64(trunc(t^.Right^.Num));
      result:=DefineArgument(t^.Right);
     end else if (t^.Token in [ptPLUS,ptNUM]) and (assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM)) then begin
      result:=DefineArgument(t^.Right);
     end else begin
      result:=FindConstantIndex(t);
     end;
    end;
   end;
   procedure ScopeStart;
   var OldCount,NewCount,i:longint;
   begin
    OldCount:=length(CodeGenerator^.Scopes);
    if CodeGenerator^.CountScopes>=OldCount then begin
     if CodeGenerator^.CountScopes=0 then begin
      NewCount:=8;
     end else begin
      NewCount:=CodeGenerator^.CountScopes*2;
     end;
     SetLength(CodeGenerator^.Scopes,NewCount);
     for i:=OldCount to NewCount-1 do begin
      CodeGenerator^.Scopes[i].SymbolRegisterHashMap:=nil;
     end;
    end;
    CodeGenerator^.Scopes[CodeGenerator^.CountScopes].SymbolRegisterHashMap:=TPOCAStringHashMap.Create(true);
    inc(CodeGenerator^.CountScopes);
   end;
   procedure ScopeEnd;
   var HashMap:TPOCAStringHashMap;
       Item:PPOCAStringHashMapItem;
       Reg:longint;
   begin
    dec(CodeGenerator^.CountScopes);
    HashMap:=CodeGenerator^.Scopes[CodeGenerator^.CountScopes].SymbolRegisterHashMap;
    CodeGenerator^.Scopes[CodeGenerator^.CountScopes].SymbolRegisterHashMap:=nil;
    if assigned(HashMap) then begin
     try
      Item:=HashMap.First;
      while assigned(Item) do begin
       Reg:=Item^.Value;
       FreeRegister(Reg,true);
       Item:=Item^.Next;
      end;
     finally
      FreeAndNil(HashMap);
     end;
    end;
   end;
   function GenerateScalarConstant(t:PPOCAToken;OutReg:longint):longint;
   var v:longint;
   begin
    if OutReg<0 then begin
     OutReg:=GetRegister(true,false);
    end;
    result:=OutReg;
    case t^.Token of
     ptLITERALNUM:begin
      if t^.Num=0 then begin
       EmitOpcode(popLOADZERO,result);
       SetRegisterNumber(result,true);
       exit;
      end else if t^.Num=1 then begin
       EmitOpcode(popLOADONE,result);
       SetRegisterNumber(result,true);
       exit;
      end else if POCAIsFinite(t^.Num) then begin
       v:=trunc(t^.Num);
       if v=t^.Num then begin
        EmitOpcode(popLOADINT32,result,longword(v));
        SetRegisterNumber(result,true);
        exit;
       end;
      end;
     end;
    end;
    EmitOpcode(popLOADCONST,result,FindConstantIndex(t));
    SetRegisterNumber(result,t^.Token=ptLITERALNUM);
   end;
   function IsSymbolRegister(t:PPOCAToken):boolean;
   var i:longint;
       HashMap:TPOCAStringHashMap;
   begin
    result:=false;
    if assigned(t) and (t^.Token=ptSYMBOL) then begin
     for i:=CodeGenerator^.CountScopes-1 downto 0 do begin
      HashMap:=CodeGenerator^.Scopes[i].SymbolRegisterHashMap;
      if assigned(HashMap) and assigned(HashMap.GetKey(t^.Str)) then begin
       result:=true;
       break;
      end;
     end;
    end;
   end;
   function IsSymbolRegisterConstant(t:PPOCAToken):boolean;
   var i:longint;
       HashMap:TPOCAStringHashMap;
       Item:PPOCAStringHashMapItem;
   begin
    result:=false;
    if assigned(t) and (t^.Token=ptSYMBOL) then begin
     for i:=CodeGenerator^.CountScopes-1 downto 0 do begin
      HashMap:=CodeGenerator^.Scopes[i].SymbolRegisterHashMap;
      if assigned(HashMap) then begin
       Item:=HashMap.GetKey(t^.Str);
       if assigned(Item) then begin
        result:=((Item^.Value>=0) and (Item^.Value<CodeGenerator^.CountRegisters)) and CodeGenerator^.Registers[Item^.Value].IsConst;
        break;
       end;
      end;
     end;
    end;
   end;
   function GetSymbolRegister(t:PPOCAToken;CreateIfNotFound,IsConst:boolean):longword;
   var HashMap:TPOCAStringHashMap;
       Item:PPOCAStringHashMapItem;
       i:longint;
   begin
    result:=0;
    if assigned(t) and (t^.Token=ptSYMBOL) then begin
     for i:=CodeGenerator^.CountScopes-1 downto 0 do begin
      HashMap:=CodeGenerator^.Scopes[i].SymbolRegisterHashMap;
      if assigned(HashMap) then begin
       Item:=HashMap.GetKey(t^.Str);
       if assigned(Item) then begin
        if (((Item^.Value>=0) and (Item^.Value<CodeGenerator^.CountRegisters)) and CodeGenerator^.Registers[Item^.Value].IsConst) and CreateIfNotFound then begin
         SyntaxError('Constants are read-only',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        result:=Item^.Value;
        break;
       end else begin
        if CreateIfNotFound then begin
         Item:=HashMap.NewKey(t^.Str,true);
         Item^.Value:=GetRegister(false,IsConst);
         result:=Item^.Value;
         break;
        end;
       end;
      end;
     end;
    end;
   end;
   function DeleteSymbolRegister(t:PPOCAToken;Depth:longint):boolean;
   var HashMap:TPOCAStringHashMap;
       Item:PPOCAStringHashMapItem;
       i,r:longint;
   begin
    result:=false;
    if t^.Token=ptSYMBOL then begin
     for i:=CodeGenerator^.CountScopes-1 downto 0 do begin
      if Depth<1 then begin
       break;
      end;
      dec(Depth);
      HashMap:=CodeGenerator^.Scopes[i].SymbolRegisterHashMap;
      if assigned(HashMap) then begin
       Item:=HashMap.GetKey(t^.Str);
       if assigned(Item) then begin
        HashMap.DeleteKey(Item);
        r:=Item^.Value;
        FreeRegister(r,true);
        result:=true;
        break;
       end;
      end;
     end;
    end;
   end;
   procedure CollectConstant(t:PPOCAToken);
   var i,r:longint;
       c:PPOCAToken;
   begin
    for i:=0 to CodeGenerator^.CountConstants-1 do begin
     c:=CodeGenerator^.Constants[i];
     if c=t then begin
      exit;
     end else if c^.Token=t^.Token then begin
      case c^.Token of
       ptLITERALNUM:begin
        if c^.Num=t^.Num then begin
         exit;
        end;
       end;
       ptLITERALSTR:begin
        if c^.Str=t^.Str then begin
         exit;
        end;
       end;
      end;
     end;
    end;
    if CodeGenerator^.CountConstants>=length(CodeGenerator^.Constants) then begin
     if CodeGenerator^.CountConstants=0 then begin
      SetLength(CodeGenerator^.Constants,1024);
      SetLength(CodeGenerator^.ConstantRegisters,1024);
     end else begin
      SetLength(CodeGenerator^.Constants,CodeGenerator^.CountConstants shl 1);
      SetLength(CodeGenerator^.ConstantRegisters,CodeGenerator^.CountConstants shl 1);
     end;
    end;
    r:=GenerateScalarConstant(t,GetRegister(false,false));
    CodeGenerator^.Constants[CodeGenerator^.CountConstants]:=t;
    CodeGenerator^.ConstantRegisters[CodeGenerator^.CountConstants]:=r;
    SetRegisterNumber(r,t^.Token=ptLITERALNUM);
    if (r>=0) and (r<longint(CodeGenerator^.CountRegisters)) then begin
     CodeGenerator^.Registers[r].InUse:=true;
     CodeGenerator^.Registers[r].Freeable:=false;
     CodeGenerator^.Registers[r].IsConst:=true;
    end;
    inc(CodeGenerator^.CountConstants);
   end;
   procedure CollectConstants(t:PPOCAToken);
    procedure ScanToken(t,p:PPOCAToken);
    begin
     if assigned(t) and not t^.Visited then begin
      t^.Visited:=true;
      case t^.Token of
       ptLITERALNUM,ptLITERALSTR:begin
        if (not assigned(p)) or (p^.Token<>ptASSIGN) then begin
         CollectConstant(t);
        end;
       end;
      end;
      if not (t^.Token in [ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION]) then begin
       if assigned(t^.Children) and (t^.Children<>t^.LastChild) and (t^.Children<>t^.Next) then begin
        ScanToken(t^.Children,t);
       end;
       if assigned(t^.LastChild) and (t^.LastChild<>t^.Next) then begin
        ScanToken(t^.LastChild,t);
       end;
       if assigned(t^.Next) then begin
        ScanToken(t^.Next,t);
       end;
      end;
     end;
    end;
   begin
    if assigned(t) then begin
     ResetTokenVisited;
     ScanToken(t,nil);
    end;
   end;
   function FindConstantRegister(t:PPOCAToken):longint;
   var i:longint;
       c:PPOCAToken;
   begin
    result:=-1;
    for i:=0 to CodeGenerator^.CountConstants-1 do begin
     c:=CodeGenerator^.Constants[i];
     if c=t then begin
      result:=CodeGenerator^.ConstantRegisters[i];
      exit;
     end else if c^.Token=t^.Token then begin
      case c^.Token of
       ptLITERALNUM:begin
        if c^.Num=t^.Num then begin     
         result:=CodeGenerator^.ConstantRegisters[i];
         exit;
        end;
       end;
       ptLITERALSTR:begin
        if c^.Str=t^.Str then begin
         result:=CodeGenerator^.ConstantRegisters[i];
         exit;
        end;
       end;
      end;
     end;
    end;
   end;
   procedure ProcessConstantFolding(t:PPOCAToken);
    procedure ScanToken(t,p:PPOCAToken;IsExpression:boolean);
     function ToNum(l:PPOCAToken):double;
     var OK:TPasDblStrUtilsBoolean;
     begin
      case l^.Token of
       ptLITERALNUM:begin
        result:=l^.Num;
       end;
       ptLITERALSTR:begin
        OK:=false;
        result:=ConvertStringToDouble(l^.Str,rmNearest,@OK);
        if not OK then begin
         result:=NAN;
        end;
       end;
       else begin
        result:=NAN;
       end;
      end;
     end;
     function ToStr(l:PPOCAToken):TPOCARawByteString;
     begin
      case l^.Token of
       ptLITERALNUM:begin
        result:=POCADoubleToString(l^.Num);
       end;
       ptLITERALSTR:begin
        result:=l^.Str;
       end;
       else begin
        result:='';
       end;
      end;
     end;
    var n:double;
    begin
     if assigned(t) and not t^.Visited then begin
      t^.Visited:=true;
      if assigned(p) then begin
      end;
      case t^.Token of
       ptASSIGN,ptPLUSEQ,ptMINUSEQ,ptMULEQ,ptDIVEQ,ptCATEQ,ptBANDEQ,ptBOREQ,ptBXOREQ,ptBSHLEQ,ptBSHREQ,ptBUSHREQ,ptMODEQ,ptPOWEQ:begin
        case t^.Rule of
         prREVERSE:begin
          ScanToken(t^.Right,t,true);
          ScanToken(t^.Left,t,false);
         end;
         else begin
          ScanToken(t^.Children,t,false);
          ScanToken(t^.LastChild,t,false);
          ScanToken(t^.Next,t,false);
         end;
        end;
       end;
       ptLPAR:begin
        if IsExpression and not (Binary(t) or not assigned(t^.Right)) then begin
         ScanToken(t^.Left,t,true);
         ScanToken(t^.Right,t,true);
         if assigned(t^.Right) and (t^.Right^.Token<>ptREGEXP) then begin
          if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=t^.Left^.Num;
           t^.Left^.Token:=ptEMPTY;
          end else if assigned(t^.Right) and (t^.Right^.Token=ptLITERALSTR) then begin
           t^.Token:=ptLITERALSTR;
           t^.Str:=t^.Left^.Str;
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
        end else begin
         ScanToken(t^.Left,t,false);
         ScanToken(t^.Right,t,false);
        end;
       end;
       ptPLUS:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ToNum(t^.Left);
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ToNum(t^.Left)+ToNum(t^.Right);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptMINUS:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=-ToNum(t^.Left);
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ToNum(t^.Left)-ToNum(t^.Right);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptMUL:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ToNum(t^.Left)*ToNum(t^.Right);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptDIV:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           n:=ToNum(t^.Right);
           if n<>0 then begin
            t^.Token:=ptLITERALNUM;
            t^.Num:=ToNum(t^.Left)/n;
            t^.Left^.Token:=ptEMPTY;
            t^.Right^.Token:=ptEMPTY;
           end;
          end;
         end;
        end;
       end;
       ptMOD:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           n:=ToNum(t^.Right);
           if n<>0 then begin
            t^.Token:=ptLITERALNUM;
            t^.Num:=Modulo(ToNum(t^.Left),n);
            t^.Left^.Token:=ptEMPTY;
            t^.Right^.Token:=ptEMPTY;
           end;
          end;
         end;
        end;
       end;
       ptPOW:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=Math.Power(ToNum(t^.Left),ToNum(t^.Right));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptCAT:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=int64(not int64(trunc(ToNum(t^.Left))));
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALSTR;
           t^.Str:=ToStr(t^.Left)+ToStr(t^.Right);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptNOT:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(ToNum(t^.Left)=0);
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptNEG:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=-ToNum(t^.Left);
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptBNOT:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=int64(not int64(trunc(ToNum(t^.Left))));
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptNUM:begin
        case t^.Rule of
         prPREFIX:begin
          ScanToken(t^.Left,t,true);
          if assigned(t^.Left) and (t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ToNum(t^.Left);
           t^.Left^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptLT:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num<t^.Right^.Num);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str<t^.Right^.Str);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptLTEQ:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num<=t^.Right^.Num);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str<=t^.Right^.Str);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptGT:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num>t^.Right^.Num);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str>t^.Right^.Str);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptGTEQ:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num>=t^.Right^.Num);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str>=t^.Right^.Str);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptEQ:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num=t^.Right^.Num);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str=t^.Right^.Str);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptNEQ:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Num<>t^.Right^.Num);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=ord(t^.Left^.Str<>t^.Right^.Str);
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptCMP:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALNUM) and (t^.Right^.Token=ptLITERALNUM)) then begin
           t^.Token:=ptLITERALNUM;
           if t^.Left^.Num<t^.Right^.Num then begin
            t^.Num:=-1;
           end else if t^.Left^.Num>t^.Right^.Num then begin
            t^.Num:=1;
           end else begin
            t^.Num:=0;
           end;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end else if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token=ptLITERALSTR) and (t^.Right^.Token=ptLITERALSTR)) then begin
           t^.Token:=ptLITERALNUM;
           if t^.Left^.Str=t^.Right^.Str then begin
            t^.Num:=0;
           end else if t^.Left^.Str<t^.Right^.Str then begin
            t^.Num:=-1;
           end else begin
            t^.Num:=1;
           end;
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptBAND:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=int64(System.trunc(ToNum(t^.Left))) and int64(System.trunc(ToNum(t^.Right)));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptBXOR:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=int64(System.trunc(ToNum(t^.Left))) xor int64(System.trunc(ToNum(t^.Right)));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptBOR:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=int64(System.trunc(ToNum(t^.Left))) or int64(System.trunc(ToNum(t^.Right)));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptBSHL:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=int64(System.trunc(ToNum(t^.Left))) shl longint(System.trunc(ToNum(t^.Right)));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptBSHR:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=sar64(int64(System.trunc(ToNum(t^.Left))),longint(System.trunc(ToNum(t^.Right))));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       ptBUSHR:begin
        case t^.Rule of
         prBINARY:begin
          ScanToken(t^.Left,t,true);
          ScanToken(t^.Right,t,true);
          if (assigned(t^.Left) and assigned(t^.Right)) and ((t^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) and (t^.Right^.Token in [ptLITERALNUM,ptLITERALSTR])) then begin
           t^.Token:=ptLITERALNUM;
           t^.Num:=int64(System.trunc(ToNum(t^.Left))) shr longint(System.trunc(ToNum(t^.Right)));
           t^.Left^.Token:=ptEMPTY;
           t^.Right^.Token:=ptEMPTY;
          end;
         end;
        end;
       end;
       else begin
        if not (t^.Token in [ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION]) then begin
         ScanToken(t^.Children,t,false);
         ScanToken(t^.LastChild,t,false);
         ScanToken(t^.Next,t,false);
        end;
       end;
      end;
     end;
    end;
   begin
    ResetTokenVisited;
    ScanToken(t,nil,false);
   end;
   procedure FixTargetImmediate(Position:longint);
   begin
    CodeGenerator^.ByteCode[Position]:=CodeGenerator^.ByteCodeSize;
   end;
   function GenerateExpression(t:PPOCAToken;OutReg:longint=-1;DoNeedResult:boolean=false):longint; forward;
   function GenerateBlock(t:PPOCAToken;OutReg:longint=-1;DoNeedResult:boolean=false;NewScope:boolean=true):longint;
   var Expression:PPOCAToken;
       Reg:longint;
   begin
    result:=-1;
    if NewScope then begin
     ScopeStart;
    end;
    try
     while assigned(t) do begin
      if t^.Token in [ptSEMI,ptAUTOSEMI] then begin
       Expression:=t^.Left;
       if assigned(Expression) and ((DoNeedResult and (result<0)) or (Expression^.Token<>ptEMPTY)) then begin
        Reg:=GenerateExpression(Expression,OutReg,DoNeedResult);
        if Reg>=0 then begin
         result:=Reg;
        end;
       end;
       if assigned(Expression) and (Expression^.Token in [ptCONTINUE,ptBREAK,ptTHROW,ptRETURN,ptFALLTHROUGH,ptRETRY]) then begin
        break;
       end else begin
        t:=t^.Right;
       end;
      end else begin
       if (DoNeedResult and (result<0)) or (t^.Token<>ptEMPTY) then begin
        Reg:=GenerateExpression(t,OutReg,DoNeedResult);
        if Reg>=0 then begin
         result:=Reg;
        end;
       end;
       break;
      end;
     end;
    finally
     if NewScope then begin
      ScopeEnd;
     end;
    end;
   end;
   function GenerateCommaBlock(t:PPOCAToken;OutReg:longint=-1;DoNeedResult:boolean=false;NewScope:boolean=true):longint;
   var Expression:PPOCAToken;
       Reg:longint;
   begin
    result:=-1;
    if NewScope then begin
     ScopeStart;
    end;
    try
     while assigned(t) do begin
      if t^.Token=ptCOMMA then begin
       Expression:=t^.Left;
       if assigned(Expression) and ((DoNeedResult and (result<0)) or (Expression^.Token<>ptEMPTY)) then begin
        Reg:=GenerateExpression(Expression,OutReg,DoNeedResult);
        if Reg>=0 then begin
         result:=Reg;
        end;
       end;
       if assigned(Expression) and (Expression^.Token in [ptCONTINUE,ptBREAK,ptTHROW,ptRETURN,ptFALLTHROUGH,ptRETRY]) then begin
        break;
       end else begin
        t:=t^.Right;
       end;
      end else begin
       if (DoNeedResult and (result<0)) or (t^.Token<>ptEMPTY) then begin
        Reg:=GenerateExpression(t,OutReg,DoNeedResult);
        if Reg>=0 then begin
         result:=Reg;
        end;
       end;
       break;
      end;
     end;
    finally
     if NewScope then begin
      ScopeEnd;
     end;
    end;
   end;
   function GenerateExpression(t:PPOCAToken;OutReg:longint=-1;DoNeedResult:boolean=false):longint;
    procedure NewLine(Line:longint);
    begin
     if (CodeGenerator^.LineCount+1)>=length(CodeGenerator^.Lines) then begin
      SetLength(CodeGenerator^.Lines,(CodeGenerator^.LineCount+1)*2);
     end;
     CodeGenerator^.Lines[CodeGenerator^.LineCount].InstructionPointer:=CodeGenerator^.ByteCodeSize;
     CodeGenerator^.Lines[CodeGenerator^.LineCount].Line:=Line;
     inc(CodeGenerator^.LineCount);
    end;
    function GetNumberOp(Op:longword):longword;
    begin
     case Op and $ff of
      popNOT:begin
       result:=popN_NOT or (Op and $ffffff00);
      end;
      popMUL:begin
       result:=popN_MUL or (Op and $ffffff00);
      end;
      popADD:begin
       result:=popN_ADD or (Op and $ffffff00);
      end;
      popSUB:begin
       result:=popN_SUB or (Op and $ffffff00);
      end;
      popDIV:begin
       result:=popN_DIV or (Op and $ffffff00);
      end;
      popNEG:begin
       result:=popN_NEG or (Op and $ffffff00);
      end;
      popLT:begin
       result:=popN_LT or (Op and $ffffff00);
      end;
      popLTEQ:begin
       result:=popN_LTEQ or (Op and $ffffff00);
      end;
      popGT:begin
       result:=popN_GT or (Op and $ffffff00);
      end;
      popGTEQ:begin
       result:=popN_GTEQ or (Op and $ffffff00);
      end;
      popEQ:begin
       result:=popN_EQ or (Op and $ffffff00);
      end;
      popNEQ:begin
       result:=popN_NEQ or (Op and $ffffff00);
      end;
      popCMP:begin
       result:=popN_CMP or (Op and $ffffff00);
      end;
      popDEC:begin
       result:=popN_DEC or (Op and $ffffff00);
      end;
      popINC:begin
       result:=popN_INC or (Op and $ffffff00);
      end;
      popBAND:begin
       result:=popN_BAND or (Op and $ffffff00);
      end;
      popBXOR:begin
       result:=popN_BXOR or (Op and $ffffff00);
      end;
      popBOR:begin
       result:=popN_BOR or (Op and $ffffff00);
      end;
      popBNOT:begin
       result:=popN_NOT or (Op and $ffffff00);
      end;
      popBSHL:begin
       result:=popN_BSHL or (Op and $ffffff00);
      end;
      popBSHR:begin
       result:=popN_BSHR or (Op and $ffffff00);
      end;
      popBUSHR:begin
       result:=popN_BUSHR or (Op and $ffffff00);
      end;
      popMOD:begin
       result:=popN_MOD or (Op and $ffffff00);
      end;
      popPOW:begin
       result:=popN_POW or (Op and $ffffff00);
      end;
      popINRANGE:begin
       result:=popN_INRANGE or (Op and $ffffff00);
      end;
      popJIFTRUE:begin
       result:=popN_JIFTRUE or (Op and $ffffff00);
      end;
      popJIFFALSE:begin
       result:=popN_JIFFALSE or (Op and $ffffff00);
      end;
      popJIFTRUELOOP:begin
       result:=popN_JIFTRUELOOP or (Op and $ffffff00);
      end;
      popJIFFALSELOOP:begin
       result:=popN_JIFFALSELOOP or (Op and $ffffff00);
      end;
      else begin
       result:=Op;
      end;
     end;
    end;
    function GenerateBinaryOperation(Op:longword;t:PPOCAToken;OutReg:longint):longint;
    var r1,r2:longint;
    begin
     if not (assigned(t^.Left) and assigned(t^.Right)) then begin
      SyntaxError('Empty subexpression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     r1:=GenerateExpression(t^.Left,-1,true);
     r2:=GenerateExpression(t^.Right,-1,true);
     if GetRegisterNumber(r1) and GetRegisterNumber(r2) then begin
      EmitOpcode(GetNumberOp(Op),result,r1,r2);
      SetRegisterNumber(result,true);
     end else begin
      EmitOpcode(Op,result,r1,r2);
      SetRegisterNumber(result,false);
     end;
     FreeRegister(r1);
     FreeRegister(r2);
    end;
    function GenerateInOperation(t:PPOCAToken;OutReg:longint):longint;
    var rt:PPOCAToken;
        Reg1,Reg2,Reg3:longint;
    begin
     rt:=t^.Right;
     while assigned(rt) and ((rt^.Token=ptLPAR) and (assigned(rt^.Left) and ((rt^.Left=rt^.Right) or not assigned(rt^.Right)))) do begin
      rt:=rt^.Left;
     end;
     if assigned(rt) and ((rt^.Token=ptDOTDOT) and Binary(rt)) then begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      Reg1:=GenerateExpression(t^.Left,-1,true);
      Reg2:=GenerateExpression(rt^.Left,-1,true);
      Reg3:=GenerateExpression(rt^.Right,-1,true);
      EmitOpcode(popINRANGE,result,Reg1,Reg2,Reg3);
      SetRegisterNumber(result,false);
      FreeRegister(Reg3);
      FreeRegister(Reg2);
      FreeRegister(Reg1);
     end else begin
      result:=GenerateBinaryOperation(popIN,t,OutReg);
     end;
    end;
    function GetLeftValueLocalRegister(t:PPOCAToken):longint;
    var Token:TPOCATokenType;
    begin
     result:=-1;
     if not assigned(t) then begin
      SyntaxError('Bad left value',Parser.SourceFile,-1,-1);
     end;
     Token:=t^.Token;
     case Token of
      ptLPAR:begin
       if t^.Rule<>prSUFFIX then begin
        result:=GetLeftValueLocalRegister(t^.Left);
       end;
      end;
      ptSYMBOL:begin
       if IsSymbolRegister(t) then begin
        if IsSymbolRegisterConstant(t) then begin
         SyntaxError('Constants are read-only',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        result:=GetSymbolRegister(t,false,false);
       end;
      end;
      ptSUPERCODESYMBOL:begin
       SyntaxError('Invalid super syntax usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptREGISTER,ptCONST:begin
       t:=t^.Right;
       while assigned(t) and ((t^.Token=ptLPAR) and (t^.Rule<>prSUFFIX)) do begin
        t:=t^.Left;
       end;
       if assigned(t) and (t^.Token=ptSYMBOL) then begin
        result:=GetSymbolRegister(t,true,Token=ptCONST);
       end;
      end;
      ptVAR:begin
       if IsSymbolRegisterConstant(t) then begin
        SyntaxError('Constants are read-only',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
     end;
    end;
    function ProcessLeftValue(t:PPOCAToken;var ConstantIndex,Reg1,Reg2:longint):longword;
    var Token:TPOCATokenType;
    begin
     result:=0;
     if not assigned(t) then begin
      SyntaxError('Bad left value',Parser.SourceFile,-1,-1);
     end;
     Token:=t^.Token;
     case Token of
      ptLPAR:begin
       if t^.Rule<>prSUFFIX then begin
        result:=ProcessLeftValue(t^.Left,ConstantIndex,Reg1,Reg2);
        exit;
       end;
      end;
      ptSYMBOL:begin
       if IsSymbolRegister(t) then begin
        if IsSymbolRegisterConstant(t) then begin
         SyntaxError('Constants are read-only',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        Reg1:=GetSymbolRegister(t,false,false);
        result:=popCOPY;
       end else begin
        ConstantIndex:=FindConstantIndex(t);
        result:=popSETSYM;
       end;
       exit;
      end;
      ptSUPERCODESYMBOL:begin
       SyntaxError('Invalid super syntax usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptDOT:begin
       Reg1:=GenerateExpression(t^.Left,-1,true);
       if assigned(t^.Right) and (t^.Right^.Token=ptPROTOTYPE) then begin
        result:=popSETPROTOTYPE;
       end else if assigned(t^.Right) and (t^.Right^.Token=ptCONSTRUCTOR) then begin
        result:=popSETCONSTRUCTOR;
       end else if assigned(t^.Right) and (t^.Right^.Token=ptHASHKIND) then begin
        result:=popSETHASHKIND;
       end else begin
        ConstantIndex:=FindConstantIndex(t^.Right);
        result:=popSETMEMBER;
       end;
       exit;
      end;
      ptSAFEDOT:begin
       SyntaxError('??. is not allowed as lvalue',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptLBRA:begin
       Reg1:=GenerateExpression(t^.Left,-1,true);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       result:=popINSERT;
       exit;
      end;
      ptSAFELBRA:begin
       SyntaxError('??[ is not allowed as lvalue',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
      ptVAR:begin
       if CodeToken=ptFASTFUNCTION then begin
        SyntaxError('VAR is not allowed in fastfunctions',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       CodeGenerator^.HasLocals:=true;
       t:=t^.Right;
       while assigned(t) and ((t^.Token=ptLPAR) and (t^.Rule<>prSUFFIX)) do begin
        t:=t^.Left;
       end;
       if assigned(t) and (t^.Token=ptSYMBOL) then begin
        if IsSymbolRegisterConstant(t) then begin
         SyntaxError('Constants are read-only',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        ConstantIndex:=FindConstantIndex(t);
        result:=popSETLOCAL;
        exit;
       end;
      end;
      ptREGISTER,ptCONST:begin
       t:=t^.Right;
       while assigned(t) and ((t^.Token=ptLPAR) and (t^.Rule<>prSUFFIX)) do begin
        t:=t^.Left;
       end;
       if assigned(t) and (t^.Token=ptSYMBOL) then begin
        Reg1:=GetSymbolRegister(t,true,Token=ptCONST);
        result:=popCOPY;
        exit;
       end;
      end;
     end;
     SyntaxError('Bad left value',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
    end;
    procedure GenerateLeftValue(t:PPOCAToken;Reg:longint);
    var AssignOp,ConstantIndex,Reg1,Reg2:longint;
    begin
     ConstantIndex:=0;
     Reg1:=0;
     Reg2:=0;
     AssignOp:=ProcessLeftValue(t,ConstantIndex,Reg1,Reg2);
     case AssignOp and $ff of
      popSETMEMBER:begin
       EmitOpcode(popSETMEMBER,Reg1,ConstantIndex,Reg,$ffffffff);
      end;
      popSETPROTOTYPE:begin
       EmitOpcode(popSETPROTOTYPE,Reg1,Reg);
      end;
      popSETHASHKIND:begin
       EmitOpcode(popSETHASHKIND,Reg1,Reg);
      end;
      popINSERT:begin
       EmitOpcode(popINSERT,Reg1,Reg2,Reg);
      end;
      popCOPY:begin
       EmitOpcode(popCOPY,Reg1,Reg);
       SetRegisterNumber(Reg1,GetRegisterNumber(Reg));
      end;
      popSETLOCAL:begin
       EmitOpcode(popSETLOCAL,ConstantIndex,Reg,$ffffffff);
      end;
      popSETSYM:begin
       EmitOpcode(popSETSYM,ConstantIndex,Reg,$ffffffff);
      end;
      else begin
       EmitOpcode(AssignOp and $ff,ConstantIndex,Reg);
      end;
     end;
    end;
    function GenerateAssignOp(Op:longint;t:PPOCAToken;OutReg:longint):longint;
    var ConstantIndex,Reg1,Reg2,Reg3:longint;
        SetOp:longword;
    begin
     ConstantIndex:=0;
     Reg1:=-1;
     Reg2:=-1;
     Reg3:=-1;
     SetOp:=ProcessLeftValue(t^.Left,ConstantIndex,Reg1,Reg2);
     case SetOp and $ff of
      popSETMEMBER:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETMEMBER,result,Reg1,ConstantIndex,$ffffffff);
       Reg3:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg3);
       FreeRegister(Reg3);
       EmitOpcode(popSETMEMBER,Reg1,ConstantIndex,result,$ffffffff);
      end;
      popSETPROTOTYPE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETPROTOTYPE,result,Reg1);
       Reg3:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg3);
       FreeRegister(Reg3);
       EmitOpcode(popSETPROTOTYPE,Reg1,result);
      end;
      popSETHASHKIND:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETHASHKIND,result,Reg1);
       Reg3:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg3);
       FreeRegister(Reg3);
       EmitOpcode(popSETHASHKIND,Reg1,result);
      end;
      popINSERT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popEXTRACT,result,Reg1,Reg2);
       Reg3:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg3);
       FreeRegister(Reg3);
       EmitOpcode(popINSERT,Reg1,Reg2,result);
      end;
      popCOPY:begin
       Reg2:=GenerateExpression(t^.Right,-1,true);
       if GetRegisterNumber(Reg1) and GetRegisterNumber(Reg2) then begin
        EmitOpcode(GetNumberOp(Op),Reg1,Reg1,Reg2);
        SetRegisterNumber(Reg1,true);
       end else begin
        EmitOpcode(Op,Reg1,Reg1,Reg2);
        SetRegisterNumber(Reg1,false);
       end;
       FreeRegister(Reg2);
       if OutReg<0 then begin
        result:=Reg1;
       end else begin
        EmitOpcode(popCOPY,OutReg,Reg1);
        SetRegisterNumber(OutReg,GetRegisterNumber(Reg1));
        result:=OutReg;
       end;
      end;
      popSETLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg2);
       FreeRegister(Reg2);
       EmitOpcode(popSETLOCAL,ConstantIndex,result,$ffffffff);
      end;
      popSETSYM:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg2);
       FreeRegister(Reg2);
       EmitOpcode(popSETSYM,ConstantIndex,result,$ffffffff);
      end;
      else begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(Op,result,result,Reg2);
       FreeRegister(Reg2);
       EmitOpcode(SetOp and $ff,ConstantIndex,result);
      end;
     end;
    end;
    function GenerateElvisAssignOp(t:PPOCAToken;OutReg:longint):longint;
    var ConstantIndex,Reg1,Reg2,Reg3,JumpTrue:longint;
        SetOp:longword;
        Registers:TPOCACodeGeneratorRegisters;
    begin
     ConstantIndex:=0;
     Reg1:=-1;
     Reg2:=-1;
     Reg3:=-1;
     SetOp:=ProcessLeftValue(t^.Left,ConstantIndex,Reg1,Reg2);
     case SetOp and $ff of
      popSETMEMBER:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETMEMBER,result,Reg1,ConstantIndex,$ffffffff);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       if GetRegisterNumber(result) then begin
        EmitOpcode(popN_JIFTRUE,0,result);
       end else begin
        EmitOpcode(popJIFTRUE,0,result);
       end;
       Registers:=GetRegisters;
       Reg3:=GenerateExpression(t^.Right,result,true);
       if result<>Reg3 then begin
        EmitOpcode(popCOPY,result,Reg3);
        FreeRegister(Reg3);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETMEMBER,Reg1,ConstantIndex,result,$ffffffff);
      end;
      popSETPROTOTYPE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETPROTOTYPE,result,Reg1);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       if GetRegisterNumber(result) then begin
        EmitOpcode(popN_JIFTRUE,0,result);
       end else begin
        EmitOpcode(popJIFTRUE,0,result);
       end;
       Registers:=GetRegisters;
       Reg3:=GenerateExpression(t^.Right,result,true);
       if result<>Reg3 then begin
        EmitOpcode(popCOPY,result,Reg3);
        FreeRegister(Reg3);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETPROTOTYPE,Reg1,result);
      end;
      popSETHASHKIND:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETHASHKIND,result,Reg1);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       if GetRegisterNumber(result) then begin
        EmitOpcode(popN_JIFTRUE,0,result);
       end else begin
        EmitOpcode(popJIFTRUE,0,result);
       end;
       Registers:=GetRegisters;
       Reg3:=GenerateExpression(t^.Right,result,true);
       if result<>Reg3 then begin
        EmitOpcode(popCOPY,result,Reg3);
        FreeRegister(Reg3);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETHASHKIND,Reg1,result);
      end;
      popINSERT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popEXTRACT,result,Reg1,Reg2);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       if GetRegisterNumber(result) then begin
        EmitOpcode(popN_JIFTRUE,0,result);
       end else begin
        EmitOpcode(popJIFTRUE,0,result);
       end;
       Registers:=GetRegisters;
       Reg3:=GenerateExpression(t^.Right,result,true);
       if result<>Reg3 then begin
        EmitOpcode(popCOPY,result,Reg3);
        FreeRegister(Reg3);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popINSERT,Reg1,Reg2,result);
      end;
      popCOPY:begin
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       if GetRegisterNumber(Reg1) then begin
        EmitOpcode(popN_JIFTRUE,0,Reg1);
       end else begin
        EmitOpcode(popJIFTRUE,0,Reg1);
       end;
       Registers:=GetRegisters;
       Reg2:=GenerateExpression(t^.Right,Reg1,true);
       if Reg1<>Reg2 then begin
        EmitOpcode(popCOPY,Reg1,Reg2);
        FreeRegister(Reg2);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       if OutReg<0 then begin
        result:=Reg1;
       end else begin
        EmitOpcode(popCOPY,OutReg,Reg1);
        SetRegisterNumber(OutReg,GetRegisterNumber(Reg1));
        result:=OutReg;
       end;
      end;
      popSETLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       if GetRegisterNumber(result) then begin
        EmitOpcode(popN_JIFTRUE,0,result);
       end else begin
        EmitOpcode(popJIFTRUE,0,result);
       end;
       Registers:=GetRegisters;
       Reg2:=GenerateExpression(t^.Right,result,true);
       if result<>Reg2 then begin
        EmitOpcode(popCOPY,result,Reg2);
        FreeRegister(Reg2);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETLOCAL,ConstantIndex,result,$ffffffff);
      end;
      popSETSYM:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       if GetRegisterNumber(result) then begin
        EmitOpcode(popN_JIFTRUE,0,result);
       end else begin
        EmitOpcode(popJIFTRUE,0,result);
       end;
       Registers:=GetRegisters;
       Reg2:=GenerateExpression(t^.Right,result,true);
       if result<>Reg2 then begin
        EmitOpcode(popCOPY,result,Reg2);
        FreeRegister(Reg2);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(popSETSYM,ConstantIndex,result,$ffffffff);
      end;
      else begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       JumpTrue:=CodeGenerator^.ByteCodeSize+1;
       if GetRegisterNumber(result) then begin
        EmitOpcode(popN_JIFTRUE,0,result);
       end else begin
        EmitOpcode(popJIFTRUE,0,result);
       end;
       Registers:=GetRegisters;
       Reg2:=GenerateExpression(t^.Right,result,true);
       if result<>Reg2 then begin
        EmitOpcode(popCOPY,result,Reg2);
        FreeRegister(Reg2);
       end;
       FixTargetImmediate(JumpTrue);
       CombineCurrentRegisters(Registers);
       EmitOpcode(SetOp and $ff,ConstantIndex,result);
      end;
     end;
    end;
    function GeneratePostfixDecIncOp(Op:longint;t:PPOCAToken;OutReg:longint):longint;
    var ConstantIndex,Reg1,Reg2,Reg3:longint;
        SetOp:longword;
    begin
     ConstantIndex:=0;
     Reg1:=-1;
     Reg2:=-1;
     Reg3:=-1;
     SetOp:=ProcessLeftValue(t^.Left,ConstantIndex,Reg1,Reg2);
     case SetOp and $ff of
      popSETMEMBER:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitOpcode(popGETMEMBER,result,Reg1,ConstantIndex,$ffffffff);
       EmitOpcode(Op,Reg2,result);
       EmitOpcode(popSETMEMBER,Reg1,ConstantIndex,Reg2,$ffffffff);
       FreeRegister(Reg2);
      end;
      popSETPROTOTYPE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitOpcode(popGETPROTOTYPE,result,Reg1);
       EmitOpcode(Op,Reg2,result);
       EmitOpcode(popSETPROTOTYPE,Reg1,Reg2);
       FreeRegister(Reg2);
      end;
      popSETHASHKIND:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitOpcode(popGETHASHKIND,result,Reg1);
       EmitOpcode(Op,Reg2,result);
       EmitOpcode(popSETHASHKIND,Reg1,Reg2);
       FreeRegister(Reg2);
      end;
      popINSERT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg3:=GetRegister(true,false);
       EmitOpcode(popEXTRACT,result,Reg1,Reg2);
       EmitOpcode(Op,Reg3,result);
       EmitOpcode(popINSERT,Reg1,Reg2,Reg3);
       FreeRegister(Reg3);
      end;
      popCOPY:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popCOPY,result,Reg1);
       SetRegisterNumber(result,GetRegisterNumber(Reg1));
       if GetRegisterNumber(Reg1) then begin
        EmitOpcode(GetNumberOp(Op),Reg1,Reg1);
       end else begin
        EmitOpcode(Op,Reg1,Reg1);
       end;
      end;
      popSETLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg1:=GetRegister(true,false);
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       EmitOpcode(Op,Reg1,result);
       EmitOpcode(popSETLOCAL,ConstantIndex,Reg1,$ffffffff);
       FreeRegister(Reg1);
      end;
      popSETSYM:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg1:=GetRegister(true,false);
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       EmitOpcode(Op,Reg1,result);
       EmitOpcode(popSETSYM,ConstantIndex,Reg1,$ffffffff);
       FreeRegister(Reg1);
      end;
      else begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg1:=GetRegister(true,false);
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       EmitOpcode(Op,Reg1,result);
       EmitOpcode(SetOp and $ff,ConstantIndex,Reg1);
       FreeRegister(Reg1);
      end;
     end;
    end;
    function GeneratePrefixDecIncOp(Op:longint;t:PPOCAToken;OutReg:longint):longint;
    var ConstantIndex,Reg1,Reg2,Reg3:longint;
        SetOp:longword;
    begin
     ConstantIndex:=0;
     Reg1:=-1;
     Reg2:=-1;
     Reg3:=-1;
     SetOp:=ProcessLeftValue(t^.Right,ConstantIndex,Reg1,Reg2);
     case SetOp and $ff of
      popSETMEMBER:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitOpcode(popGETMEMBER,result,Reg1,ConstantIndex,$ffffffff);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETMEMBER,Reg1,ConstantIndex,result,$ffffffff);
      end;
      popSETPROTOTYPE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitOpcode(popGETPROTOTYPE,result,Reg1);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETPROTOTYPE,Reg1,result);
      end;
      popSETHASHKIND:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg2:=GetRegister(true,false);
       EmitOpcode(popGETHASHKIND,result,Reg1);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETHASHKIND,Reg1,result);
      end;
      popINSERT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       Reg3:=GetRegister(true,false);
       EmitOpcode(popEXTRACT,result,Reg1,Reg2);
       EmitOpcode(Op,result,result);
       EmitOpcode(popINSERT,Reg1,Reg2,result);
      end;
      popCOPY:begin
       if OutReg<0 then begin
        if GetRegisterNumber(Reg1) then begin
         EmitOpcode(GetNumberOp(Op),Reg1,Reg1);
        end else begin
         EmitOpcode(Op,Reg1,Reg1);
        end;
        result:=Reg1;
       end else begin
        result:=OutReg;
        if GetRegisterNumber(Reg1) then begin
         EmitOpcode(GetNumberOp(Op),result,Reg1);
         SetRegisterNumber(result,true);
        end else begin
         EmitOpcode(Op,result,Reg1);
         SetRegisterNumber(result,false);
        end;
       end;
      end;
      popSETLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETLOCAL,ConstantIndex,result,$ffffffff);
      end;
      popSETSYM:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       EmitOpcode(Op,result,result);
       EmitOpcode(popSETSYM,ConstantIndex,result,$ffffffff);
      end;
      else begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popGETLOCAL,result,ConstantIndex,$ffffffff);
       EmitOpcode(Op,result,result);
       EmitOpcode(SetOp and $ff,ConstantIndex,result);
      end;
     end;
     FreeRegister(Reg3);
     FreeRegister(Reg2);
     FreeRegister(Reg1);
    end;
    function GenerateLambda(t:PPOCAToken;OutReg:longint):longint;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     EmitOpcode(popLOADCONST,result,NewConstant(NewLambda(t)));
    end;
    procedure GenerateArrayItem(t:PPOCAToken;ArrayReg:longint);
    var Reg1,Reg2:longint;
    begin
     if assigned(t) then begin
      if Binary(t) and (t^.Token=ptDOTDOT) then begin
       Reg1:=GenerateExpression(t^.Left,-1,true);
       Reg2:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(popARRAYRANGEPUSH,ArrayReg,Reg1,Reg2);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
      end else begin
       Reg1:=GenerateExpression(t,-1,true);
       EmitOpcode(popARRAYPUSH,ArrayReg,Reg1);
       FreeRegister(Reg1);
      end;
     end;
    end;
    procedure GenerateArray(t:PPOCAToken;ArrayReg:longint);
    begin
     while assigned(t) do begin
      if t^.Token=ptCOMMA then begin
       GenerateArrayItem(t^.Left,ArrayReg);
       t:=t^.Right;
      end else begin
       if t^.Token<>ptEMPTY then begin
        GenerateArrayItem(t,ArrayReg);
       end;
       break;
      end;
     end;
    end;
    procedure GenerateHashElement(t:PPOCAToken;HashReg:longint);
    var Reg1,Reg2:longint;
    begin
     if (not assigned(t)) or (t^.Token=ptEMPTY) then begin
      exit;
     end;
     if (t^.Token<>ptCOLON) or not assigned(t^.Left) then begin
      SyntaxError('Bad hash initializer',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      case t^.Left^.Token of
       ptSYMBOL:begin      
        Reg1:=GenerateScalarConstant(t^.Left,-1);
       end;
       ptLITERALSTR,ptLITERALNUM:begin
        Reg1:=GenerateExpression(t^.Left,-1,true);
       end;
       ptPROTOTYPE:begin
        Reg2:=GenerateExpression(t^.Right,-1,true);
        EmitOpcode(popSETPROTOTYPE,HashReg,Reg2);
        FreeRegister(Reg2);
        exit;
       end;
       ptCONSTRUCTOR:begin
        Reg2:=GenerateExpression(t^.Right,-1,true);
        EmitOpcode(popSETCONSTRUCTOR,HashReg,Reg2);
        FreeRegister(Reg2);
        exit;
       end;
       ptHASHKIND:begin
        Reg2:=GenerateExpression(t^.Right,-1,true);
        EmitOpcode(popSETHASHKIND,HashReg,Reg2);
        FreeRegister(Reg2);
        exit;
       end;
       else begin
        Reg1:=-1;
        SyntaxError('Bad hash initializer',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      Reg2:=GenerateExpression(t^.Right,-1,true);
      EmitOpcode(popHASHAPPEND,HashReg,Reg1,Reg2);
      FreeRegister(Reg1);
      FreeRegister(Reg2);
     end;
    end;
    procedure GenerateHash(t:PPOCAToken;HashReg:longint);
    begin
     while assigned(t) do begin
      if t^.Token=ptCOMMA then begin
       GenerateHashElement(t^.Left,HashReg);
       t:=t^.Right;
      end else begin
       if t^.Token<>ptEMPTY then begin
        GenerateHashElement(t,HashReg);
       end;
       break;
      end;
     end;
    end;
    function IsHashCall(t:PPOCAToken):boolean;
    begin
     if assigned(t) then begin
      if assigned(t^.Left) and (t^.Token=ptCOMMA) then begin
       result:=t^.Left^.Token=ptCOLON;
      end else begin
       result:=t^.Token=ptCOLON;
      end;
     end else begin
      result:=false;
     end;
    end;
    function CountList(t:PPOCAToken;Token:TPOCATokenType):longint; overload;
    begin
     result:=1;
     while assigned(t) and (t^.Token=Token) do begin
      inc(result);
      t:=t^.Right;
     end;
    end;
    function CountList(t:PPOCAToken;Tokens:TPOCATokenTypes):longint; overload;
    begin
     result:=1;
     while assigned(t) and (t^.Token in Tokens) do begin
      inc(result);
      t:=t^.Right;
     end;
    end;
    function GenerateFunctionCall(t:PPOCAToken;OutReg:longint;const InjectedMember:TPOCARawByteString=''):longint;
    var IsMethod,IsSafeMethod:boolean;
        Count,Reg1,Reg2,Reg3,i,JumpNull,JumpEnd,ConstantIndex:longint;
        Registers:TPOCACodeGeneratorRegisters;
        Regs:array of longint;
     function CollectList(t:PPOCAToken):longint;
     begin
      result:=0;
      while assigned(t) do begin
       if t^.Token=ptCOMMA then begin
        inc(result);
        t:=t^.Right;
       end else begin
        inc(result);
        break;
       end;
      end;
     end;
     procedure EmitList(t:PPOCAToken);
     var Count,r:longint;  
     begin
      Count:=0;
      while assigned(t) do begin
       if t^.Token=ptCOMMA then begin
        r:=GenerateExpression(t^.Left,-1,true);
        Regs[Count]:=r;
        inc(Count);
        t:=t^.Right;
       end else begin
        r:=GenerateExpression(t,-1,true);
        Regs[Count]:=r;
        break;
       end;
      end;
     end;
    begin
     Regs:=nil;
     try
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      if assigned(t^.Left) and (t^.Left^.Token in [ptDOT,ptSAFEDOT]) then begin
       IsSafeMethod:=t^.Left^.Token=ptSAFEDOT;
       IsMethod:=true;
       if assigned(t^.Left^.Left) and (t^.Left^.Left^.Token=ptAT) then begin
        Reg1:=GenerateExpression(t^.Left^.Left^.Left,-1,true);
        Reg3:=GenerateExpression(t^.Left^.Left^.Right,-1,true);
        Reg2:=GetRegister(true,false);
        if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptPROTOTYPE) then begin
         EmitOpcode(popGETPROTOTYPE,Reg2,Reg3);
        end else if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptCONSTRUCTOR) then begin
         EmitOpcode(popGETCONSTRUCTOR,Reg2,Reg3);
        end else if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptHASHKIND) then begin
         EmitOpcode(popGETHASHKIND,Reg2,Reg3);
        end else begin
         EmitOpcode(popGETMEMBER,Reg2,Reg3,FindConstantIndex(t^.Left^.Right),$ffffffff);
        end;
        FreeRegister(Reg3);
       end else begin
        Reg1:=GenerateExpression(t^.Left^.Left,-1,true);
        Reg2:=GetRegister(true,false);
        if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptPROTOTYPE) then begin
         EmitOpcode(popGETPROTOTYPE,Reg2,Reg1);
        end else if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptCONSTRUCTOR) then begin
         EmitOpcode(popGETCONSTRUCTOR,Reg2,Reg1);
        end else if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptHASHKIND) then begin
         EmitOpcode(popGETHASHKIND,Reg2,Reg1);
        end else begin
         EmitOpcode(popGETMEMBER,Reg2,Reg1,FindConstantIndex(t^.Left^.Right),$ffffffff);
        end;
       end;
      end else if assigned(t^.Left) and (t^.Left^.Token=ptATDOT) and assigned(t^.Left^.Left) and (t^.Left^.Left^.Token=ptSUPERTHAT) then begin
       IsSafeMethod:=false;
       IsMethod:=true;
       Reg1:=GetRegister(true,false);
       EmitOpcode(popLOADTHAT,Reg1);
       SetRegisterNumber(Reg1,false);
       Reg2:=GetRegister(true,false);
       EmitOpcode(popINHERITEDMETHOD,Reg2,Reg1,FindConstantIndex(t^.Left^.Right),$ffffffff);
       EmitOpcode(popLOADTHIS,Reg1);
      end else if assigned(t^.Left) and (t^.Left^.Token=ptATDOT) then begin
       IsSafeMethod:=false;
       IsMethod:=true;
       Reg1:=GenerateExpression(t^.Left^.Left,-1,true);
       Reg2:=GetRegister(true,false);
       EmitOpcode(popINHERITEDMETHOD,Reg2,Reg1,FindConstantIndex(t^.Left^.Right),$ffffffff);
      end else begin
       IsSafeMethod:=false;
       IsMethod:=false;
       Reg1:=-1;
       Reg2:=GenerateExpression(t^.Left,-1,true);
      end;
      if IsSafeMethod then begin
       Registers:=GetRegisters;
       JumpNull:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJIFFALSE,0,Reg1);
      end else begin
       JumpNull:=0;
      end;
      if length(InjectedMember)>0 then begin
       IsMethod:=true;
       ConstantIndex:=InternConstant(POCAInternSymbol(Parser.Context,Instance,POCANewUniqueString(Parser.Context,InjectedMember)));
       Reg1:=Reg2;
       Reg2:=GetRegister(true,false);
       EmitOpcode(popGETMEMBER,Reg2,Reg1,ConstantIndex,$ffffffff);
      end;
      if IsHashCall(t^.Right) then begin
       Reg3:=GetRegister(true,false);
       EmitOpcode(popNEWHASH,Reg3);
       GenerateHash(t^.Right,Reg3);
       if IsMethod then begin
        EmitOpcode(popMCALLH,result,Reg1,Reg2,Reg3);
       end else begin
        EmitOpcode(popFCALLH,result,Reg2,Reg3);
       end;
       FreeRegister(Reg3);
      end else begin
       Count:=CollectList(t^.Right);
       SetLength(Regs,Count);
       EmitList(t^.Right);
       if IsMethod then begin
        EmitOpcode(popMCALL or ((3+Count) shl 8));
        Emit(result);
        Emit(Reg1);
        Emit(Reg2);
       end else begin
        EmitOpcode(popFCALL or ((2+Count) shl 8));
        Emit(result);
        Emit(Reg2);
       end;
       for i:=0 to Count-1 do begin
        Emit(Regs[i]);
        FreeRegister(Regs[i]);
       end;
      end;
      if IsSafeMethod then begin
       JumpEnd:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJMP,0);
       FixTargetImmediate(JumpNull);
       EmitOpcode(popLOADNULL,result);
       SetRegisterNumber(result,false);
       CombineCurrentRegisters(Registers);
       FixTargetImmediate(JumpEnd);
      end;     
      FreeRegister(Reg2);
      FreeRegister(Reg1);
     finally
      SetLength(Regs,0);
     end;
    end;
    function StartBreakContinueScope(const Kind:TPOCACodeGeneratorBreakContinueScopeKind;const Index:longint):longint;
    var bcs:PPOCACodeGeneratorBreakContinueScope;
    begin
     if (CodeGenerator^.CountBreakContinueScopes+1)>length(CodeGenerator^.BreakContinueScopes) then begin
      SetLength(CodeGenerator^.BreakContinueScopes,(CodeGenerator^.CountBreakContinueScopes+1)*2);
     end;
     bcs:=@CodeGenerator^.BreakContinueScopes[CodeGenerator^.CountBreakContinueScopes];
     result:=CodeGenerator^.CountBreakContinueScopes;
     inc(CodeGenerator^.CountBreakContinueScopes);
     bcs^.Kind:=Kind;
     bcs^.Index:=Index;
    end;
    procedure EndBreakContinueScope;
    begin
     dec(CodeGenerator^.CountBreakContinueScopes);
    end;
    function StartSwitch:longint;
    var s:PPOCACodeGeneratorSwitch;
    begin
     if CodeGenerator^.SwitchTop>=CodeGenerator^.SwitchAllocated then begin
      CodeGenerator^.SwitchAllocated:=(CodeGenerator^.SwitchTop+1)*2;
      SetLength(CodeGenerator^.Switchs,CodeGenerator^.SwitchAllocated);
     end;
     s:=@CodeGenerator^.Switchs[CodeGenerator^.SwitchTop];
     s^.CountBreakJumps:=0;
     s^.BreakRegisters:=nil;
     StartBreakContinueScope(bcskSWITCH,CodeGenerator^.SwitchTop);
     inc(CodeGenerator^.SwitchTop);
     result:=CodeGenerator^.ByteCodeSize;
    end;
    procedure EndSwitch(BreakPos:longint;var BreakRegisters:TPOCACodeGeneratorRegisters;var HasBreak:boolean);
    var s:PPOCACodeGeneratorSwitch;
        i:longint;
    begin
     EndBreakContinueScope;
     dec(CodeGenerator^.SwitchTop);
     s:=@CodeGenerator^.Switchs[CodeGenerator^.SwitchTop];
     HasBreak:=HasBreak or (s^.CountBreakJumps>0);
     for i:=0 to s^.CountBreakJumps-1 do begin
      CodeGenerator^.ByteCode[s^.BreakJumps[i]]:=BreakPos;
     end;
     s^.CountBreakJumps:=0;
     for i:=0 to length(s^.BreakRegisters)-1 do begin
      CombineRegisters(BreakRegisters,s^.BreakRegisters[i]);
      SetLength(s^.BreakRegisters[i],0);
     end;
     SetLength(s^.BreakRegisters,0);
     SetLength(s^.BreakJumps,0);
    end;
    function StartLoop(LabelToken:PPOCAToken;IsSwitch:boolean):longint;
    var l:PPOCACodeGeneratorLoop;
    begin
     if CodeGenerator^.LoopTop>=CodeGenerator^.LoopAllocated then begin
      CodeGenerator^.LoopAllocated:=(CodeGenerator^.LoopTop+1)*2;
      SetLength(CodeGenerator^.Loops,CodeGenerator^.LoopAllocated);
     end;
     l:=@CodeGenerator^.Loops[CodeGenerator^.LoopTop];
     l^.LabelToken:=LabelToken;
     l^.CountBreakJumps:=0;
     l^.CountContinueJumps:=0;
     l^.BreakRegisters:=nil;
     l^.ContinueRegisters:=nil;
     StartBreakContinueScope(bcskLOOP,CodeGenerator^.LoopTop);
     inc(CodeGenerator^.LoopTop);
     result:=CodeGenerator^.ByteCodeSize;
    end;
    procedure EndLoop(BreakPos,ContinuePos:longint;var BreakRegisters,ContinueRegisters:TPOCACodeGeneratorRegisters);
    var l:PPOCACodeGeneratorLoop;
        i:longint;
    begin
     EndBreakContinueScope;
     dec(CodeGenerator^.LoopTop);
     l:=@CodeGenerator^.Loops[CodeGenerator^.LoopTop];
     for i:=0 to l^.CountBreakJumps-1 do begin
      CodeGenerator^.ByteCode[l^.BreakJumps[i]]:=BreakPos;
     end;
     for i:=0 to l^.CountContinueJumps-1 do begin
      CodeGenerator^.ByteCode[l^.ContinueJumps[i]]:=ContinuePos;
     end;
     l^.CountBreakJumps:=0;
     l^.CountContinueJumps:=0;
     for i:=0 to length(l^.BreakRegisters)-1 do begin
      CombineRegisters(BreakRegisters,l^.BreakRegisters[i]);
      SetLength(l^.BreakRegisters[i],0);
     end;
     for i:=0 to length(l^.ContinueRegisters)-1 do begin
      CombineRegisters(ContinueRegisters,l^.ContinueRegisters[i]);
      SetLength(l^.ContinueRegisters[i],0);
     end;
     SetLength(l^.BreakRegisters,0);
     SetLength(l^.ContinueRegisters,0);
     SetLength(l^.BreakJumps,0);
     SetLength(l^.ContinueJumps,0);
    end;
    function GenerateShortCircuit(t:PPOCAToken;OutReg:longint):longint;
    var e,r:longint;
        Registers:TPOCACodeGeneratorRegisters;
    begin
     Registers:=nil;
     try
     {if OutReg<0 then begin
       result:=GenerateExpression(t^.Left,-1,true);
       if GetRegisterNumber(result) then begin
        if t^.Token=ptAND then begin
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popN_JIFFALSE,0,result);
        end else begin // ptOR or ptELVIS
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popN_JIFTRUE,0,result);
        end;
       end else begin
        if t^.Token=ptAND then begin
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popJIFFALSE,0,result);
        end else begin // ptOR or ptELVIS
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       r:=GenerateExpression(t^.Right,result,true);
       if result<>r then begin
        EmitOpcode(popCOPY,result,r);
        SetRegisterNumber(result,GetRegisterNumber(r));
       end;
       FixTargetImmediate(e);
       CombineCurrentRegisters(Registers);
      end else}begin
       if OutReg<0 then begin
        OutReg:=GetRegister(true,false);
       end;
       result:=OutReg;
       r:=GenerateExpression(t^.Left,result,true);
       if result<>r then begin
        EmitOpcode(popCOPY,result,r);
        SetRegisterNumber(result,GetRegisterNumber(r));
       end;
       if GetRegisterNumber(result) then begin
        if t^.Token=ptAND then begin
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popN_JIFFALSE,0,result);
        end else begin // ptOR or ptELVIS
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popN_JIFTRUE,0,result);
        end;
       end else begin
        if t^.Token=ptAND then begin
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popJIFFALSE,0,result);
        end else begin // ptOR or ptELVIS
         e:=CodeGenerator^.ByteCodeSize+1;
         EmitOpcode(popJIFTRUE,0,result);
        end;
       end;
       Registers:=GetRegisters;
       r:=GenerateExpression(t^.Right,result,true);
       if result<>r then begin
        EmitOpcode(popCOPY,result,r);
        SetRegisterNumber(result,GetRegisterNumber(r));
       end;
       CombineCurrentRegisters(Registers);
       FixTargetImmediate(e);
      end;
     finally
      SetLength(Registers,0);
     end;
    end;
    function GenerateTest(Test:PPOCAToken;IsLoop,DoNegative:boolean;JumpNext:longint):longint;
    var Back,RegLeft,RegRight,RegExpression:longint;
        Optimized:boolean;
    begin
     result:=0;
     Optimized:=false;
     Back:=CodeGenerator^.ByteCodeSize;
     if assigned(Test) and (Test^.Token in [ptLT,ptLTEQ,ptGT,ptGTEQ,ptEQ,ptNEQ,ptCMP]) and Binary(Test) then begin
      RegLeft:=GenerateExpression(Test^.Left);
      RegRight:=GenerateExpression(Test^.Right);
      if GetRegisterNumber(RegLeft) and GetRegisterNumber(RegRight) then begin
       case Test^.Token of
        ptLT:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if IsLoop then begin
           EmitOpcode(popN_JIFGTEQLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFGTEQ,JumpNext,RegLeft,RegRight);
          end;
         end else begin
          if IsLoop then begin
           EmitOpcode(popN_JIFLTLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFLT,JumpNext,RegLeft,RegRight);
          end;
         end;
         Optimized:=true;
        end;
        ptLTEQ:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if IsLoop then begin
           EmitOpcode(popN_JIFGTLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFGT,JumpNext,RegLeft,RegRight);
          end;
         end else begin
          if IsLoop then begin
           EmitOpcode(popN_JIFLTEQLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFLTEQ,JumpNext,RegLeft,RegRight);
          end;
         end;
         Optimized:=true;
        end;
        ptGT:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if IsLoop then begin
           EmitOpcode(popN_JIFLTEQLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFLTEQ,JumpNext,RegLeft,RegRight);
          end;
         end else begin
          if IsLoop then begin
           EmitOpcode(popN_JIFGTLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFGT,JumpNext,RegLeft,RegRight);
          end;
         end;
         Optimized:=true;
        end;
        ptGTEQ:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if IsLoop then begin
           EmitOpcode(popN_JIFLTLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFLT,JumpNext,RegLeft,RegRight);
          end;
         end else begin
          if IsLoop then begin
           EmitOpcode(popN_JIFGTEQLOOP,JumpNext,RegLeft,RegRight);
          end else begin
           EmitOpcode(popN_JIFGTEQ,JumpNext,RegLeft,RegRight);
          end;
         end;
         Optimized:=true;
        end;
        ptEQ:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if (Test^.Right^.Token=ptLITERALNUM) and (Test^.Right^.Num=0) then begin
           if IsLoop then begin
            EmitOpcode(popN_JIFTRUELOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFTRUE,JumpNext,RegLeft,RegRight);
           end;
          end else begin
           if IsLoop then begin
            EmitOpcode(popN_JIFNEQLOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFNEQ,JumpNext,RegLeft,RegRight);
           end;
          end;
         end else begin
          if (Test^.Right^.Token=ptLITERALNUM) and (Test^.Right^.Num=0) then begin
           if IsLoop then begin
            EmitOpcode(popN_JIFFALSELOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFFALSE,JumpNext,RegLeft,RegRight);
           end;
          end else begin
           if IsLoop then begin
            EmitOpcode(popN_JIFEQLOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFEQ,JumpNext,RegLeft,RegRight);
           end;
          end;
         end;
         Optimized:=true;
        end;
        ptNEQ,ptCMP:begin
         result:=CodeGenerator^.ByteCodeSize+1;
         if DoNegative then begin
          if (Test^.Right^.Token=ptLITERALNUM) and (Test^.Right^.Num=0) then begin
           if IsLoop then begin
            EmitOpcode(popN_JIFFALSELOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFFALSE,JumpNext,RegLeft,RegRight);
           end;
          end else begin
           if IsLoop then begin
            EmitOpcode(popN_JIFEQLOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFEQ,JumpNext,RegLeft,RegRight);
           end;
          end;
         end else begin
          if (Test^.Right^.Token=ptLITERALNUM) and (Test^.Right^.Num=0) then begin
           if IsLoop then begin
            EmitOpcode(popN_JIFTRUELOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFTRUE,JumpNext,RegLeft,RegRight);
           end;
          end else begin
           if IsLoop then begin
            EmitOpcode(popN_JIFNEQLOOP,JumpNext,RegLeft,RegRight);
           end else begin
            EmitOpcode(popN_JIFNEQ,JumpNext,RegLeft,RegRight);
           end;
          end;
         end;
         Optimized:=true;
        end;   
       end;
      end;
      FreeRegister(RegLeft);
      FreeRegister(RegRight);
     end;
     if not Optimized then begin
      CodeGenerator^.ByteCodeSize:=Back;
      RegExpression:=GenerateExpression(Test,-1,true);
      result:=CodeGenerator^.ByteCodeSize+1;
      if GetRegisterNumber(RegExpression) then begin
       if DoNegative then begin
        if IsLoop then begin
         EmitOpcode(popN_JIFFALSELOOP,JumpNext,RegExpression);
        end else begin
         EmitOpcode(popN_JIFFALSE,JumpNext,RegExpression);
        end;
       end else begin
        if IsLoop then begin
         EmitOpcode(popN_JIFTRUELOOP,JumpNext,RegExpression);
        end else begin
         EmitOpcode(popN_JIFTRUE,JumpNext,RegExpression);
        end;
       end;
      end else begin
       if DoNegative then begin
        if IsLoop then begin
         EmitOpcode(popJIFFALSELOOP,JumpNext,RegExpression);
        end else begin
         EmitOpcode(popJIFFALSE,JumpNext,RegExpression);
        end;
       end else begin
        if IsLoop then begin
         EmitOpcode(popJIFTRUELOOP,JumpNext,RegExpression);
        end else begin
         EmitOpcode(popJIFTRUE,JumpNext,RegExpression);
        end;
       end;
      end;
      FreeRegister(RegExpression);
     end;
    end;
    function GenerateIF(tIF,tELSE:PPOCAToken;OutReg:longint):longint;
    var JumpNext,JumpEnd:longint;
        Registers:array[0..1] of TPOCACodeGeneratorRegisters;
    begin
     Registers[0]:=nil;
     Registers[1]:=nil;
     try
      if tIF^.Children^.Token=ptLPAR then begin
       JumpNext:=GenerateTest(tIF^.Children^.Left,false,true,0);
      end else begin
       JumpNext:=GenerateTest(tIF^.Children,false,true,0);
      end;
      if OutReg<0 then begin
       OutReg:=GetRegister(true,false);
       if not (assigned(tELSE) and (tELSE^.Token<>ptEMPTY)) then begin
        if DoNeedResult then begin
         EmitOpcode(popLOADNULL,OutReg);
        end;
       end;
      end;
      Registers[0]:=GetRegisters;
      result:=GenerateBlock(tIF^.Children^.Next^.Children,OutReg,DoNeedResult,true);
      if result<>OutReg then begin
       EmitOpcode(popCOPY,OutReg,result);
       SetRegisterNumber(OutReg,GetRegisterNumber(result));
       result:=OutReg;
      end;
      if (not (assigned(tELSE) and (tELSE^.Token<>ptEMPTY))) and not DoNeedResult then begin
       CombineCurrentRegisters(Registers[0]);
       FixTargetImmediate(JumpNext);
      end else begin
       begin
        JumpEnd:=CodeGenerator^.ByteCodeSize+1;
        EmitOpcode(popJMP,0);
       end;
       FixTargetImmediate(JumpNext);
       Registers[1]:=GetRegisters;
       SetRegisters(Registers[0]);
       if assigned(tELSE) and (tELSE^.Token<>ptEMPTY) then begin
        if tELSE^.Token=ptELSEIF then begin
         result:=GenerateIF(tELSE,tELSE^.Next,OutReg);
        end else begin
         result:=GenerateBlock(tELSE^.Children^.Children,OutReg,DoNeedResult,true);
        end;
        if result<>OutReg then begin
         EmitOpcode(popCOPY,OutReg,result);
         SetRegisterNumber(OutReg,GetRegisterNumber(result));
         result:=OutReg;
        end;
       end else begin
        if DoNeedResult then begin
         EmitOpcode(popLOADNULL,result);
        end;
       end;
       FixTargetImmediate(JumpEnd);
       CombineCurrentRegisters(Registers[1]);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
     end;
    end;
    function GenerateIFELSE(t:PPOCAToken;OutReg:longint):longint;
    begin
     result:=GenerateIF(t,t^.Left^.Next.Next,OutReg);
    end;
    function GenerateTry(t:PPOCAToken;OutReg:longint):longint;
    var TryBlock,CatchBlock,FinallyBlock,CatchIdentifier:PPOCAToken;
        CatchIdentifierRegister,TryBlockPos,CatchBlockPos,FinallyBlockPos,EndPos,Reg:longint;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
      EmitOpcode(popLOADNULL,result);
     end else begin
      result:=OutReg;
     end;
     TryBlock:=t^.Children;
     CatchBlock:=nil;
     FinallyBlock:=nil;
     if assigned(TryBlock) then begin
      if assigned(TryBlock^.Next) then begin
       case TryBlock^.Next^.Token of
        ptCATCH:begin
         CatchBlock:=TryBlock^.Next;
         if assigned(CatchBlock^.Next) and (CatchBlock^.Next^.Token=ptFINALLY) then begin
          FinallyBlock:=CatchBlock^.Next;
         end;
        end;
        ptFINALLY:begin
         FinallyBlock:=TryBlock^.Next;
        end;
       end;
      end;
     end;
     if assigned(TryBlock) and (assigned(CatchBlock) or assigned(FinallyBlock)) then begin
      CatchIdentifierRegister:=GetRegister(true,false);
      EmitImmediate(popTRY,6);
      Emit(result);
      Emit(CatchIdentifierRegister);
      TryBlockPos:=CodeGenerator^.ByteCodeSize;
      Emit($ffffffff);
      CatchBlockPos:=CodeGenerator^.ByteCodeSize;
      Emit($ffffffff);
      FinallyBlockPos:=CodeGenerator^.ByteCodeSize;
      Emit($ffffffff);
      EndPos:=CodeGenerator^.ByteCodeSize;
      Emit($ffffffff);
      if assigned(CatchBlock) then begin
       CatchIdentifier:=CatchBlock^.Children;
       if assigned(CatchIdentifier) and (CatchIdentifier^.Token=ptLPAR) then begin
        if assigned(CatchIdentifier^.Children) and (CatchIdentifier^.Children^.Token=ptSYMBOL) then begin
         if (not assigned(CatchIdentifier^.Children^.Next)) or (CatchIdentifier^.Children^.Next^.Token=ptEMPTY) then begin
          CatchBlock:=CatchIdentifier^.Next;
          CatchIdentifier:=CatchIdentifier^.Children;
          if CatchBlock^.Token=ptLCURL then begin
           if assigned(FinallyBlock) then begin
            if assigned(FinallyBlock^.Children) and (FinallyBlock^.Children^.Token=ptLCURL) then begin
             FinallyBlock:=FinallyBlock^.Children;
             begin
              FixTargetImmediate(TryBlockPos);
              Reg:=GenerateBlock(TryBlock^.Children,result,DoNeedResult,true);
              if result<>Reg then begin
               EmitOpcode(popCOPY,result,Reg);
               SetRegisterNumber(result,GetRegisterNumber(Reg));
               FreeRegister(Reg);
              end;
              EmitOpcode(popTRYBLOCKEND,result);
             end;
             begin
              ClearRegisters;
              FixTargetImmediate(CatchBlockPos);
              GenerateLeftValue(CatchIdentifier,CatchIdentifierRegister);
              Reg:=GenerateBlock(CatchBlock^.Children,result,DoNeedResult,true);
              if result<>Reg then begin
               EmitOpcode(popCOPY,result,Reg);
               SetRegisterNumber(result,GetRegisterNumber(Reg));
               FreeRegister(Reg);
              end;
              EmitOpcode(popTRYBLOCKEND,result);
             end;
             begin
              ClearRegisters;
              FixTargetImmediate(FinallyBlockPos);
              Reg:=GenerateBlock(FinallyBlock^.Children,result,DoNeedResult,true);
              if result<>Reg then begin
               EmitOpcode(popCOPY,result,Reg);
               SetRegisterNumber(result,GetRegisterNumber(Reg));
               FreeRegister(Reg);
              end;
              EmitOpcode(popTRYBLOCKEND,result);
             end;
             FixTargetImmediate(EndPos);
             ClearRegisters;
            end else begin
             SyntaxError('Bad finally block',FinallyBlock^.SourceFile,FinallyBlock^.SourceLine,FinallyBlock^.SourceColumn);
            end;
           end else begin
            begin
             FixTargetImmediate(TryBlockPos);
             Reg:=GenerateBlock(TryBlock^.Children,result,DoNeedResult,true);
             if result<>Reg then begin
              EmitOpcode(popCOPY,result,Reg);
              SetRegisterNumber(result,GetRegisterNumber(Reg));
              FreeRegister(Reg);
             end;
             EmitOpcode(popTRYBLOCKEND,result);
            end;
            begin
             ClearRegisters;
             FixTargetImmediate(CatchBlockPos);
             GenerateLeftValue(CatchIdentifier,CatchIdentifierRegister);
             Reg:=GenerateBlock(CatchBlock^.Children,result,DoNeedResult,true);
             if result<>Reg then begin
              EmitOpcode(popCOPY,result,Reg);
              SetRegisterNumber(result,GetRegisterNumber(Reg));
              FreeRegister(Reg);
             end;
             EmitOpcode(popTRYBLOCKEND,result);
            end;
            FixTargetImmediate(EndPos);
            ClearRegisters;
           end;
          end else begin
           SyntaxError('Bad catch block',CatchBlock^.SourceFile,CatchBlock^.SourceLine,CatchBlock^.SourceColumn);
          end;
         end else begin
          SyntaxError('Bad catch identifier',CatchIdentifier^.SourceFile,CatchIdentifier^.SourceLine,CatchIdentifier^.SourceColumn);
         end;
        end else begin
         SyntaxError('Missed catch identifier',CatchIdentifier^.SourceFile,CatchIdentifier^.SourceLine,CatchIdentifier^.SourceColumn);
        end;
       end else begin
        SyntaxError('Bad CATCH-block expression',CatchBlock^.SourceFile,CatchBlock^.SourceLine,CatchBlock^.SourceColumn);
       end;
      end else if assigned(FinallyBlock) then begin
       if assigned(FinallyBlock^.Children) and (FinallyBlock^.Children^.Token=ptLCURL) then begin
        FinallyBlock:=FinallyBlock^.Children;
        begin
         FixTargetImmediate(TryBlockPos);
         Reg:=GenerateBlock(TryBlock^.Children,result,DoNeedResult,true);
         if result<>Reg then begin
          EmitOpcode(popCOPY,result,Reg);
          SetRegisterNumber(result,GetRegisterNumber(Reg));
          FreeRegister(Reg);
         end;
         EmitOpcode(popTRYBLOCKEND,result);
        end;
        begin
         ClearRegisters;
         FixTargetImmediate(FinallyBlockPos);
         Reg:=GenerateBlock(FinallyBlock^.Children,result,DoNeedResult,true);
         if result<>Reg then begin
          EmitOpcode(popCOPY,result,Reg);
          SetRegisterNumber(result,GetRegisterNumber(Reg));
          FreeRegister(Reg);
         end;
         EmitOpcode(popTRYBLOCKEND,result);
        end;
        FixTargetImmediate(EndPos);
        ClearRegisters;
       end else begin
        SyntaxError('Bad finally block',FinallyBlock^.SourceFile,FinallyBlock^.SourceLine,FinallyBlock^.SourceColumn);
       end;
      end;
      FreeRegister(CatchIdentifierRegister);
     end else begin
      SyntaxError('Bad TRY-block expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
     SetRegisterNumber(result,false);
    end;
    function GenerateQuestion(t:PPOCAToken;OutReg:longint):longint;
    var JumpNext,JumpEnd:longint;
        Registers:array[0..1] of TPOCACodeGeneratorRegisters;
    begin
     Registers[0]:=nil;
     Registers[1]:=nil;
     try
      if (assigned(t^.Right)) and (t^.Right^.Token<>ptCOLON) then begin
       result:=-1;
       SyntaxError('Bad short circuit IF ?: expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end else begin
       if OutReg<0 then begin
        OutReg:=GetRegister(true,false);
       end;
       if t^.Left^.Token=ptLPAR then begin
        JumpNext:=GenerateTest(t^.Left^.Left,false,true,0);
       end else begin
        JumpNext:=GenerateTest(t^.Left,false,true,0);
       end;
       Registers[0]:=GetRegisters;
       begin
        result:=GenerateExpression(t^.Right^.Left,OutReg,true);
        if result<>OutReg then begin
         EmitOpcode(popCOPY,OutReg,result);
         SetRegisterNumber(OutReg,GetRegisterNumber(result));
         result:=OutReg;
        end;
       end;
       begin
        JumpEnd:=CodeGenerator^.ByteCodeSize+1;
        EmitOpcode(popJMP,0);
       end;
       FixTargetImmediate(JumpNext);
       Registers[1]:=GetRegisters;
       SetRegisters(Registers[0]);
       begin
        result:=GenerateExpression(t^.Right^.Right,OutReg,true);
        if result<>OutReg then begin
         EmitOpcode(popCOPY,OutReg,result);
         SetRegisterNumber(OutReg,GetRegisterNumber(result));
         result:=OutReg;
        end;
       end;
       FixTargetImmediate(JumpEnd);
       CombineCurrentRegisters(Registers[1]);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
     end;
    end;
    function GenerateWhile(t:PPOCAToken;OutReg:longint):longint;
    var Test,Body,LabelToken:PPOCAToken;
        Len,JumpNext,JumpOver,BreakPos,ContinuePos,Start:longint;
        Registers:array[0..4] of TPOCACodeGeneratorRegisters;
    begin
     Registers[0]:=nil;
     Registers[1]:=nil;
     Registers[2]:=nil;
     Registers[3]:=nil;
     Registers[4]:=nil;
     try
      begin
       Test:=t^.Left^.Children;
       LabelToken:=nil;
       Len:=CountList(Test,[ptSEMI,ptAUTOSEMI]);
       if Len=2 then begin
        LabelToken:=Test^.Right;
        if (not assigned(LabelToken)) or (LabelToken^.Token<>ptSYMBOL) then begin
         SyntaxError('Bad loop label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        Test:=Test^.Left;
       end else if Len<>1 then begin
        SyntaxError('Too many semicolons in list',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       Body:=t^.Right^.Left;
      end;
      Start:=CodeGenerator^.ByteCodeSize;
      begin
       Registers[0]:=GetRegisters;
       StartLoop(LabelToken,false);
       JumpOver:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJMP,0);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       begin
        ContinuePos:=CodeGenerator^.ByteCodeSize;
        FixTargetImmediate(JumpOver);
        Registers[1]:=GetRegisters;
        Registers[4]:=GetRegisters;
        GenerateTest(Test,true,false,JumpNext);
        Registers[2]:=GetRegisters;
        Registers[3]:=GetRegisters;
       end;
       BreakPos:=CodeGenerator^.ByteCodeSize;
       EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
      end;
      if not (AreRegistersEqual(Registers[0],Registers[1],false,false) and
              AreRegistersEqual(Registers[4],Registers[1],false,false) and
              AreRegistersEqual(Registers[1],Registers[2],false,false) and
              AreRegistersEqual(Registers[4],Registers[2],false,false)) then begin
       CodeGenerator^.ByteCodeSize:=Start;
       SetRegisters(Registers[0]);
       CombineCurrentRegisters(Registers[1]);
       CombineCurrentRegisters(Registers[4]);
       StartLoop(LabelToken,false);
       JumpOver:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJMP,0);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       begin
        CombineCurrentRegisters(Registers[0]);
        CombineCurrentRegisters(Registers[1]);
        CombineCurrentRegisters(Registers[4]);
        ContinuePos:=CodeGenerator^.ByteCodeSize;
        FixTargetImmediate(JumpOver);
        GenerateTest(Test,true,false,JumpNext);
       end;
       BreakPos:=CodeGenerator^.ByteCodeSize;
       CombineCurrentRegisters(Registers[2]);
       CombineCurrentRegisters(Registers[3]);
       EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
      SetLength(Registers[2],0);
      SetLength(Registers[3],0);
      SetLength(Registers[4],0);
     end;
    end;
    function GenerateDoWhile(t:PPOCAToken;OutReg:longint):longint;
    var Test,Body,LabelToken:PPOCAToken;
        Len,JumpNext,BreakPos,ContinuePos,Start:longint;
        Registers:array[0..4] of TPOCACodeGeneratorRegisters;
    begin
     Registers[0]:=nil;
     Registers[1]:=nil;
     Registers[2]:=nil;
     Registers[3]:=nil;
     Registers[4]:=nil;
     try
      begin
       Body:=t^.Children^.Children;
       Test:=t^.Children^.Next^.Next^.Children;
       LabelToken:=nil;
       Len:=CountList(Test,[ptSEMI,ptAUTOSEMI]);
       if Len=2 then begin
        LabelToken:=Test^.Right;
        if (not assigned(LabelToken)) or (LabelToken^.Token<>ptSYMBOL) then begin
         SyntaxError('Bad loop label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        Test:=Test^.Left;
       end else if Len<>1 then begin
        SyntaxError('Too many semicolons in list',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      Start:=CodeGenerator^.ByteCodeSize;
      begin
       Registers[0]:=GetRegisters;
       StartLoop(LabelToken,false);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       Registers[1]:=GetRegisters;
       Registers[4]:=GetRegisters;
       ContinuePos:=CodeGenerator^.ByteCodeSize;
       GenerateTest(Test,true,false,JumpNext);
       Registers[2]:=GetRegisters;
       Registers[3]:=GetRegisters;
       BreakPos:=CodeGenerator^.ByteCodeSize;
       EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
      end;
      if not (AreRegistersEqual(Registers[0],Registers[1],false,false) and
              AreRegistersEqual(Registers[4],Registers[1],false,false) and
              AreRegistersEqual(Registers[1],Registers[2],false,false) and
              AreRegistersEqual(Registers[4],Registers[2],false,false)) then begin
       CodeGenerator^.ByteCodeSize:=Start;
       SetRegisters(Registers[0]);
       CombineCurrentRegisters(Registers[1]);
       CombineCurrentRegisters(Registers[4]);
       StartLoop(LabelToken,false);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       CombineCurrentRegisters(Registers[0]);
       CombineCurrentRegisters(Registers[1]);
       CombineCurrentRegisters(Registers[4]);
       ContinuePos:=CodeGenerator^.ByteCodeSize;
       GenerateTest(Test,true,false,JumpNext);
       BreakPos:=CodeGenerator^.ByteCodeSize;
       CombineCurrentRegisters(Registers[2]);
       CombineCurrentRegisters(Registers[3]);
       EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
      SetLength(Registers[2],0);
      SetLength(Registers[3],0);
      SetLength(Registers[4],0);
     end;
    end;
    function GenerateFor(t:PPOCAToken;OutReg:longint):longint;
    var Init,Test,Body,Update,LabelToken,h:PPOCAToken;
        Len,JumpNext,JumpOver,BreakPos,ContinuePos,Reg,Start:longint;
        Registers:array[0..5] of TPOCACodeGeneratorRegisters;
    begin
     Registers[0]:=nil;
     Registers[1]:=nil;
     Registers[2]:=nil;
     Registers[3]:=nil;
     Registers[4]:=nil;
     Registers[5]:=nil;
     try
      begin
       LabelToken:=nil;
       h:=t^.Left^.Children;
       Len:=CountList(h,[ptSEMI,ptAUTOSEMI]);
       Init:=h^.Left;
       Test:=h^.Right^.Left;
       Update:=h^.Right^.Right;
       if Len=4 then begin
        LabelToken:=Update^.Right;
        if (not assigned(LabelToken)) or (LabelToken^.Token<>ptSYMBOL) then begin
         SyntaxError('Bad loop label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        Update:=Update^.Left;
       end else if Len<>3 then begin
        SyntaxError('Wrong count of terms in for header',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       Body:=t^.Right^.Children;
      end;
      Start:=CodeGenerator^.ByteCodeSize;
      begin
       Registers[0]:=GetRegisters;
       StartLoop(LabelToken,false);
       if assigned(Init) and (Init^.Token<>ptEMPTY) then begin
        Reg:=GenerateCommaBlock(Init,-1,false,false);
        FreeRegister(Reg);
       end;
       JumpOver:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJMP,0);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       Registers[1]:=GetRegisters;
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       Registers[2]:=GetRegisters;
       Registers[5]:=GetRegisters;
       ContinuePos:=CodeGenerator^.ByteCodeSize;
       if assigned(Update) and (Update^.Token<>ptEMPTY) then begin
        Reg:=GenerateCommaBlock(Update,-1,false,false);
        FreeRegister(Reg);
       end;
       begin
        FixTargetImmediate(JumpOver);
        GenerateTest(Test,true,false,JumpNext);
       end;
       Registers[3]:=GetRegisters;
       Registers[4]:=GetRegisters;
       BreakPos:=CodeGenerator^.ByteCodeSize;
       EndLoop(BreakPos,ContinuePos,Registers[4],Registers[5]);
      end;
      if not (AreRegistersEqual(Registers[0],Registers[1],false,false) and
              AreRegistersEqual(Registers[1],Registers[2],false,false) and
              AreRegistersEqual(Registers[2],Registers[3],false,false) and
              AreRegistersEqual(Registers[4],Registers[3],false,false) and
              AreRegistersEqual(Registers[5],Registers[2],false,false)) then begin
       CodeGenerator^.ByteCodeSize:=Start;
       SetRegisters(Registers[0]);
       StartLoop(LabelToken,false);
       if assigned(Init) and (Init^.Token<>ptEMPTY) then begin
        Reg:=GenerateCommaBlock(Init,-1,false,false);
        FreeRegister(Reg);
       end;
       JumpOver:=CodeGenerator^.ByteCodeSize+1;
       EmitOpcode(popJMP,0);
       JumpNext:=CodeGenerator^.ByteCodeSize;
       SetRegisters(Registers[1]);
       CombineCurrentRegisters(Registers[2]);
       CombineCurrentRegisters(Registers[5]);
       result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
       CombineCurrentRegisters(Registers[1]);
       CombineCurrentRegisters(Registers[2]);
       CombineCurrentRegisters(Registers[5]);
       ContinuePos:=CodeGenerator^.ByteCodeSize;
       if assigned(Update) and (Update^.Token<>ptEMPTY) then begin
        Reg:=GenerateCommaBlock(Update,-1,false,false);
//      Reg:=GenerateExpression(Update,-1,false);
        FreeRegister(Reg);
       end;
       begin
        FixTargetImmediate(JumpOver);
        GenerateTest(Test,true,false,JumpNext);
       end;
       CombineCurrentRegisters(Registers[3]);
       CombineCurrentRegisters(Registers[4]);
       BreakPos:=CodeGenerator^.ByteCodeSize;
       EndLoop(BreakPos,ContinuePos,Registers[4],Registers[5]);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
      SetLength(Registers[2],0);
      SetLength(Registers[3],0);
      SetLength(Registers[4],0);
      SetLength(Registers[5],0);
     end;
    end;
    function GenerateForEachForIndexForKey(t:PPOCAToken;OutReg:longint):longint;
    var JumpNext,JumpOver,BreakPos,ContinuePos,Reg1,Reg2,Reg3,Reg4,Len,Start:longint;
        Element,Body,ArrayInstance,LabelToken,h:PPOCAToken;
        Registers:array[0..4] of TPOCACodeGeneratorRegisters;
    begin
     Registers[0]:=nil;
     Registers[1]:=nil;
     Registers[2]:=nil;
     Registers[3]:=nil;
     Registers[4]:=nil;
     try
      Element:=nil;
      ArrayInstance:=nil;
      LabelToken:=nil;
      h:=t^.Left^.Left;
      Len:=CountList(h,[ptSEMI,ptAUTOSEMI]);
      if (Len=3) and assigned(h^.Right) then begin
       LabelToken:=h^.Right^.Right;
       if (not assigned(LabelToken)) or (LabelToken^.Token<>ptSYMBOL) then begin
        SyntaxError('Bad loop label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       Element:=h^.Left;
       ArrayInstance:=h^.Right^.Left;
      end else if Len=2 then begin
       Element:=h^.Left;
       ArrayInstance:=h^.Right;
      end else begin
       case t^.Token of
        ptFOREACH:begin
         SyntaxError('Wrong count of terms in foreach header',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        ptFORKEY:begin
         SyntaxError('Wrong count of terms in forkey header',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        else begin
         SyntaxError('Wrong count of terms in forindex header',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
       end;
      end;
      if assigned(Element) and (Element^.Token=ptASSIGN) and assigned(Element^.Left) then begin
       Reg1:=GenerateExpression(Element,-1,false);
       FreeRegister(Reg1);
       Element:=Element^.Left;
       if (Element^.Token in [ptVAR,ptREGISTER,ptCONST]) and assigned(Element^.Right) then begin
        Element:=Element^.Right;
       end;
      end;
      Body:=t^.Right^.Children;
      begin
       Reg1:=GenerateExpression(ArrayInstance,-1,true);
       Reg2:=GetRegister(true,false);
       EmitOpcode(popLOADZERO,Reg2);
       Reg3:=GetRegister(true,false);
       case t.Token of
        ptFOREACH,ptFORKEY:begin
         Reg4:=GetRegister(true,false);
         EmitOpcode(popLOADNULL,Reg4);
        end;
        else begin
         Reg4:=-1;
        end;
       end;
       Start:=CodeGenerator^.ByteCodeSize;
       begin
        Registers[0]:=GetRegisters;
        StartLoop(LabelToken,false);
        JumpOver:=CodeGenerator^.ByteCodeSize+1;
        EmitOpcode(popJMP,0);
        JumpNext:=CodeGenerator^.ByteCodeSize;
        GenerateLeftValue(Element,Reg3);
        result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
        ContinuePos:=CodeGenerator^.ByteCodeSize;
        Registers[1]:=GetRegisters;
        Registers[4]:=GetRegisters;
        FixTargetImmediate(JumpOver);
        case t.Token of
         ptFOREACH:begin
          EmitOpcode(popEACH,Reg1,Reg2,Reg3,Reg4,JumpNext);
         end;
         ptFORKEY:begin
          EmitOpcode(popKEY,Reg1,Reg2,Reg3,Reg4,JumpNext);
         end;
         else begin
          EmitOpcode(popINDEX,Reg1,Reg2,Reg3,JumpNext);
         end;
        end;
        Registers[2]:=GetRegisters;
        Registers[3]:=GetRegisters;
        BreakPos:=CodeGenerator^.ByteCodeSize;
        EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
       end;
       if not (AreRegistersEqual(Registers[0],Registers[1],false,false) and
               AreRegistersEqual(Registers[4],Registers[1],false,false) and
               AreRegistersEqual(Registers[1],Registers[2],false,false) and
               AreRegistersEqual(Registers[4],Registers[2],false,false)) then begin
        CodeGenerator^.ByteCodeSize:=Start;
        StartLoop(LabelToken,false);
        JumpOver:=CodeGenerator^.ByteCodeSize+1;
        EmitOpcode(popJMP,0);
        JumpNext:=CodeGenerator^.ByteCodeSize;
        SetRegisters(Registers[0]);
        CombineCurrentRegisters(Registers[1]);
        CombineCurrentRegisters(Registers[4]);
        GenerateLeftValue(Element,Reg3);
        CombineCurrentRegisters(Registers[0]);
        CombineCurrentRegisters(Registers[1]);
        CombineCurrentRegisters(Registers[4]);
        result:=GenerateBlock(Body,OutReg,DoNeedResult,true);
        ContinuePos:=CodeGenerator^.ByteCodeSize;
        CombineCurrentRegisters(Registers[0]);
        CombineCurrentRegisters(Registers[1]);
        CombineCurrentRegisters(Registers[4]);
        FixTargetImmediate(JumpOver);
        case t.Token of
         ptFOREACH:begin
          EmitOpcode(popEACH,Reg1,Reg2,Reg3,Reg4,JumpNext);
         end;
         ptFORKEY:begin
          EmitOpcode(popKEY,Reg1,Reg2,Reg3,Reg4,JumpNext);
         end;
         else begin
          EmitOpcode(popINDEX,Reg1,Reg2,Reg3,JumpNext);
         end;
        end;
        CombineCurrentRegisters(Registers[2]);
        CombineCurrentRegisters(Registers[3]);
        BreakPos:=CodeGenerator^.ByteCodeSize;
        EndLoop(BreakPos,ContinuePos,Registers[3],Registers[4]);
       end;
       FreeRegister(Reg4);
       FreeRegister(Reg3);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
      end;
     finally
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
      SetLength(Registers[2],0);
      SetLength(Registers[3],0);
      SetLength(Registers[4],0);
     end;
    end;
    procedure GenerateBreakContinue(t:PPOCAToken);
    var Levels,Loop,i:longint;
        LabelToken:PPOCAToken;
        LoopItem:PPOCACodeGeneratorLoop;
        SwitchItem:PPOCACodeGeneratorSwitch;
        BreakContinueScope,CurrentBreakContinueScope:PPOCACodeGeneratorBreakContinueScope;
    begin
     Levels:=1;
     Loop:=-1;
     if assigned(t^.Right) then begin
      if t^.Right^.Token<>ptSYMBOL then begin
       if t^.Token=ptBREAK then begin
        SyntaxError('Bad break label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        SyntaxError('Bad continue label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      LabelToken:=t^.Right;
      for i:=0 to CodeGenerator^.LoopTop-1 do begin
       if assigned(CodeGenerator^.Loops[i].LabelToken) and (CodeGenerator^.Loops[i].LabelToken^.Str=LabelToken^.Str) then begin
        Loop:=i;
        break;
       end;
      end;
      if Loop<0 then begin
       if t^.Token=ptBREAK then begin
        SyntaxError('No matching break label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        SyntaxError('No matching continue label',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      Levels:=CodeGenerator^.LoopTop-Loop;
     end else begin
      BreakContinueScope:=nil;
      for i:=CodeGenerator^.CountBreakContinueScopes-1 downto 0 do begin
       CurrentBreakContinueScope:=@CodeGenerator^.BreakContinueScopes[i];
       case CurrentBreakContinueScope^.Kind of
        bcskLOOP:begin
         BreakContinueScope:=CurrentBreakContinueScope;
         break;
        end;
        bcskSWITCH:begin
         if t^.Token=ptBREAK then begin
          BreakContinueScope:=CurrentBreakContinueScope;
          if (BreakContinueScope^.Index<0) or (BreakContinueScope^.Index>=CodeGenerator^.SwitchTop) then begin
           SyntaxError('Invalid break without matching owner switch',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
           exit;
          end;
          SwitchItem:=@CodeGenerator^.Switchs[BreakContinueScope^.Index];
          if SwitchItem^.CountBreakJumps>=length(SwitchItem^.BreakJumps) then begin
           if SwitchItem^.CountBreakJumps=0 then begin
            SetLength(SwitchItem^.BreakJumps,SwitchItem^.CountBreakJumps+256);
            SetLength(SwitchItem^.BreakRegisters,SwitchItem^.CountBreakJumps+256);
           end else begin
            SetLength(SwitchItem^.BreakJumps,SwitchItem^.CountBreakJumps shl 1);
            SetLength(SwitchItem^.BreakRegisters,SwitchItem^.CountBreakJumps shl 1);
           end;
          end;
          SwitchItem^.BreakJumps[SwitchItem^.CountBreakJumps]:=CodeGenerator^.ByteCodeSize+1;
          SwitchItem^.BreakRegisters[SwitchItem^.CountBreakJumps]:=GetRegisters;
          inc(SwitchItem^.CountBreakJumps);
          EmitOpcode(popJMP,0);
          exit;
         end;
        end;
        else begin
         break;
        end;
       end;
      end;
      if assigned(BreakContinueScope) and (BreakContinueScope^.Kind=bcskLOOP) then begin
       Levels:=CodeGenerator^.LoopTop-BreakContinueScope^.Index;
      end else begin
       if t^.Token=ptBREAK then begin
        SyntaxError('Invalid break without matching owner loop',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        SyntaxError('Invalid continue without matching owner loop',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
     end;
     if not ((Levels>0) and (Levels<=CodeGenerator^.LoopTop)) then begin
      if t^.Token=ptBREAK then begin
       SyntaxError('Invalid break without matching owner loop',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end else begin
       SyntaxError('Invalid continue without matching owner loop',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
     i:=CodeGenerator^.LoopTop-Levels;
     LoopItem:=@CodeGenerator^.Loops[i];
     if t^.Token=ptBREAK then begin
      if LoopItem^.CountBreakJumps>=length(LoopItem^.BreakJumps) then begin
       if LoopItem^.CountBreakJumps=0 then begin
        SetLength(LoopItem^.BreakJumps,LoopItem^.CountBreakJumps+256);
        SetLength(LoopItem^.BreakRegisters,LoopItem^.CountBreakJumps+256);
       end else begin
        SetLength(LoopItem^.BreakJumps,LoopItem^.CountBreakJumps shl 1);
        SetLength(LoopItem^.BreakRegisters,LoopItem^.CountBreakJumps shl 1);
       end;
      end;
      LoopItem^.BreakJumps[LoopItem^.CountBreakJumps]:=CodeGenerator^.ByteCodeSize+1;
      LoopItem^.BreakRegisters[LoopItem^.CountBreakJumps]:=GetRegisters;
      inc(LoopItem^.CountBreakJumps);
      EmitOpcode(popJMP,0);
     end else begin
      if LoopItem^.CountContinueJumps>=length(LoopItem^.ContinueJumps) then begin
       if LoopItem^.CountContinueJumps=0 then begin
        SetLength(LoopItem^.ContinueJumps,LoopItem^.CountContinueJumps+256);
        SetLength(LoopItem^.ContinueRegisters,LoopItem^.CountContinueJumps+256);
       end else begin
        SetLength(LoopItem^.ContinueJumps,LoopItem^.CountContinueJumps shl 1);
        SetLength(LoopItem^.ContinueRegisters,LoopItem^.CountContinueJumps shl 1);
       end;
      end;
      LoopItem^.ContinueJumps[LoopItem^.CountContinueJumps]:=CodeGenerator^.ByteCodeSize+1;
      LoopItem^.ContinueRegisters[LoopItem^.CountContinueJumps]:=GetRegisters;
      inc(LoopItem^.CountContinueJumps);
      EmitOpcode(popJMP,0);
     end;
    end;
    function ParameterListLen(t:PPOCAToken):longint;
    begin
     if (not assigned(t)) or ((t^.Token<>ptLPAR) or ((not assigned(t^.Left)) or (t^.Left^.Token<>ptCOMMA))) then begin
      result:=0;
     end else begin
      result:=CountList(t^.Left,ptCOMMA);
     end;
    end;
    function GenerateAssignment(t:PPOCAToken;OutReg:longint):longint;
    var lv,rv:PPOCAToken;
        Len,Variable:longint;
     procedure EmitMultiLeftValue(t:PPOCAToken;Variable,Reg:longint);
     var r:longint;
     begin
      if Variable=0 then begin
       GenerateLeftValue(t,Reg);
      end else begin
       if t^.Token<>ptSYMBOL then begin
        SyntaxError('Bad left value',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        case Variable of
         1:begin
          EmitOpcode(popSETLOCAL,FindConstantIndex(t),Reg,$ffffffff);
         end;
         2,3:begin
          r:=GetSymbolRegister(t,true,Variable=3);
          EmitOpcode(popCOPY,r,Reg);
          SetRegisterNumber(r,GetRegisterNumber(Reg));
         end;
        end;
       end;
      end;
     end;
     function DoList(at,pt:PPOCAToken;Variable,OutReg:longint):longint;
     var Reg,Reg2,Count,Index:longint;
         tat,tpt,t:PPOCAToken;
         Regs:array of longint;
         LastHasNoLeft,OnlyLiterals:boolean;
     begin
      result:=-1;
      try
       OnlyLiterals:=true;
       Regs:=nil;
       Count:=0;
       at:=at^.Left;
       pt:=pt^.Left;
       tat:=at;
       tpt:=pt;
       while (assigned(tat) and (tat^.Token=ptCOMMA)) and (assigned(tpt) and (tpt^.Token=ptCOMMA)) do begin
        if assigned(tpt^.Left) and not (tpt^.Left^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
         OnlyLiterals:=false;
        end;
        inc(Count);
        tat:=tat^.Right;
        tpt:=tpt^.Right;
       end;
       if assigned(tat) and assigned(tpt) then begin
        if assigned(tpt) and not (tpt^.Token in [ptLITERALNUM,ptLITERALSTR]) then begin
         OnlyLiterals:=false;
        end;
        inc(Count);
        LastHasNoLeft:=true;
       end else begin
        LastHasNoLeft:=false;
       end;
       if OnlyLiterals then begin
        while (assigned(at) and (at^.Token=ptCOMMA)) and (assigned(pt) and (pt^.Token=ptCOMMA)) do begin
         if Variable in [2,3] then begin
          if at^.Left^.Token<>ptSYMBOL then begin
           SyntaxError('Bad lvalue',at^.SourceFile,at^.SourceLine,at^.SourceColumn);
          end else begin
           Reg2:=GetSymbolRegister(at^.Left,true,Variable=3);
           Reg:=GenerateExpression(pt^.Left,Reg2,true);
           if Reg<>Reg2 then begin
            EmitOpcode(popCOPY,Reg2,Reg);
            SetRegisterNumber(Reg2,GetRegisterNumber(Reg));
            FreeRegister(Reg);
           end;
          end;
         end else begin
          Reg:=GenerateExpression(pt^.Left,-1,true);
          EmitMultiLeftValue(at^.Left,Variable,Reg);
          FreeRegister(Reg);
         end;
         at:=at^.Right;
         pt:=pt^.Right;
        end;
        if assigned(at) and assigned(pt) then begin
         if Variable in [2,3] then begin
          if at^.Token<>ptSYMBOL then begin
           SyntaxError('Bad lvalue',at^.SourceFile,at^.SourceLine,at^.SourceColumn);
          end else begin
           if OutReg<0 then begin
            result:=GetSymbolRegister(at,true,Variable=3);
            Reg:=GenerateExpression(pt,result,true);
            if Reg<>result then begin
             EmitOpcode(popCOPY,result,Reg);
             SetRegisterNumber(result,GetRegisterNumber(Reg));
             FreeRegister(Reg);
            end;
           end else begin
            result:=OutReg;
            Reg2:=GetSymbolRegister(at,true,Variable=3);
            Reg:=GenerateExpression(pt,Reg2,true);
            EmitOpcode(popCOPY,result,Reg);
            SetRegisterNumber(result,GetRegisterNumber(Reg));
            if Reg<>Reg2 then begin
             EmitOpcode(popCOPY,Reg2,Reg);
             SetRegisterNumber(Reg2,GetRegisterNumber(Reg));
             FreeRegister(Reg);
            end;
           end;
          end;
         end else begin
          result:=GenerateExpression(pt,OutReg,true);
          EmitMultiLeftValue(at,Variable,result);
         end;
        end;
       end else begin
        if Count>0 then begin
         SetLength(Regs,Count);
         tat:=at;
         tpt:=pt;
         for Index:=0 to Count-1 do begin
          Regs[Index]:=GetRegister(Index=(Count-1),false);
          Reg2:=Regs[Index];
          if (Index=(Count-1)) and LastHasNoLeft then begin
           t:=tpt;
          end else begin
           t:=tpt^.Left;
          end;
          Reg:=GenerateExpression(t,Reg2,true);
          if Reg<>Reg2 then begin
           EmitOpcode(popCOPY,Reg2,Reg);
           SetRegisterNumber(Reg2,GetRegisterNumber(Reg));
           FreeRegister(Reg);
          end;
          tpt:=tpt^.Right;
         end;
         for Index:=0 to Count-1 do begin
          Reg:=Regs[Index];
          if (Index=(Count-1)) and LastHasNoLeft then begin
           t:=tat;
          end else begin
           t:=tat^.Left;
          end;
          if Variable in [2,3] then begin
           if t^.Token<>ptSYMBOL then begin
            SyntaxError('Bad lvalue',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
           end else begin
            Reg2:=GetSymbolRegister(t,true,Variable=3);
            EmitOpcode(popCOPY,Reg2,Reg);
            SetRegisterNumber(Reg2,GetRegisterNumber(Reg));
            FreeRegister(Reg2);
           end;
          end else begin
           EmitMultiLeftValue(t,Variable,Reg);
          end;
          if Index=(Count-1) then begin
           result:=Reg;
          end else begin
           FreeRegister(Reg);
          end;
          tat:=tat^.Right;
         end;
        end;
       end;
      finally
       SetLength(Regs,0);
      end;
     end;
     function DoUnpackList(LeftValue,RightValue:PPOCAToken;Count,Variable,OutReg:longint):longint;
     var t:PPOCAToken;
         Reg,i:longint;
         Regs:array of longint;
     begin
      result:=-1;
      Reg:=-1;
      Regs:=nil;
      SetLength(Regs,Count);
      try
       begin
        Reg:=GenerateExpression(RightValue,-1,true);
        i:=0;
        t:=LeftValue^.Left;
        while assigned(t) and (t^.Token=ptCOMMA) do begin
         Regs[i]:=GetRegister(true,false);
         inc(i);
         t:=t^.Right;
        end;
        if assigned(t) then begin
         if OutReg<0 then begin
          result:=GetRegister(true,false);
         end else begin
          result:=OutReg;
         end;
         Regs[i]:=result;
        end;
        EmitImmediate(popUNPACK,1+Count);
        Emit(Reg);
        for i:=0 to Count-1 do begin
         Emit(Regs[i]);
        end;
       end;
       begin
        i:=0;
        t:=LeftValue^.Left;
        while assigned(t) and (t^.Token=ptCOMMA) do begin
         EmitMultiLeftValue(t^.Left,Variable,Regs[i]);
         inc(i);
         t:=t^.Right;
        end;
        if assigned(t) then begin
         EmitMultiLeftValue(t,Variable,Regs[i]);
        end;
       end;
      finally
       FreeRegister(Reg);
       for i:=0 to Count-1 do begin
        if Regs[i]<>result then begin
         FreeRegister(Regs[i]);
        end;
       end;
       SetLength(Regs,0);
      end;
     end;
    begin
     lv:=t^.Left;
     rv:=t^.Right;
     Variable:=0;
     Len:=ParameterListLen(lv);
     if (Len=0) and (lv^.Token in [ptVAR,ptREGISTER,ptCONST]) then begin
      Len:=ParameterListLen(lv^.Right);
     end;
     if Len<>0 then begin
      case lv^.Token of
       ptVAR:begin
        if CodeToken=ptFASTFUNCTION then begin
         SyntaxError('VAR is not allowed in fastfunctions',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        CodeGenerator^.HasLocals:=true;
        lv:=lv^.Right;
        Variable:=1;
       end;
       ptREGISTER:begin
        lv:=lv^.Right;
        Variable:=2;
       end;
       ptCONST:begin
        lv:=lv^.Right;
        Variable:=3;
       end;
      end;                                   
      if (rv^.Token=ptLPAR) and not (Binary(rv) or not assigned(rv^.Right)) then begin
       if Len<>ParameterListLen(rv) then begin
        SyntaxError('Bad assignment count',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       result:=DoList(lv,rv,Variable,OutReg);
      end else begin
       result:=DoUnpackList(lv,rv,Len,Variable,OutReg);
      end;
     end else begin
      if OutReg<0 then begin
       OutReg:=GetLeftValueLocalRegister(lv);
       result:=GenerateExpression(rv,OutReg,true);
       if OutReg<0 then begin
        GenerateLeftValue(lv,result);
       end;
      end else begin
       result:=GenerateExpression(rv,OutReg,true);
       GenerateLeftValue(lv,result);
      end;
     end;
    end;
    procedure GenerateSlice(t:PPOCAToken;DestArrayReg,SourceArrayReg:longint);
    var Reg1,Reg2:longint;
    begin
     if (not assigned(t)) or (t^.Token=ptEMPTY) then begin
      if assigned(t) then begin
       SyntaxError('Empty slice expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end else begin
       SyntaxError('Empty slice expression',Parser.SourceFile,-1,-1);
      end;
     end;
     if t^.Token in [ptCOLON,ptDOTDOT] then begin
      if assigned(t^.Left) then begin
       Reg1:=GenerateExpression(t^.Left,-1,true);
      end else begin
       Reg1:=GetRegister(true,false);
       EmitOpcode(popLOADNULL,Reg1);
      end;
      if assigned(t^.Right) then begin
       Reg2:=GenerateExpression(t^.Right,-1,true);
      end else begin
       Reg2:=GetRegister(true,false);
       EmitOpcode(popLOADNULL,Reg2);
      end;
      if t^.Token=ptDOTDOT then begin
       EmitOpcode(popSLICE2,DestArrayReg,SourceArrayReg,Reg1,Reg2);
      end else begin
       EmitOpcode(popSLICE3,DestArrayReg,SourceArrayReg,Reg1,Reg2);
      end;
      FreeRegister(Reg1);
      FreeRegister(Reg2);
     end else begin
      Reg1:=GenerateExpression(t,-1,true);
      EmitOpcode(popSLICE,DestArrayReg,SourceArrayReg,Reg1);
      FreeRegister(Reg1);
     end;
     SetRegisterNumber(result,false);
    end;
    function GenerateExtract(t:PPOCAToken;OutReg:longint;Safe:boolean):longint;
    var Reg1,Reg2,JumpNull,JumpEnd:longint;
        Registers:TPOCACodeGeneratorRegisters;
    begin
     Reg1:=GenerateExpression(t^.Left,-1,true);
     Registers:=GetRegisters;
     if Safe then begin
      JumpNull:=CodeGenerator^.ByteCodeSize+1;
      EmitOpcode(popJIFFALSE,0,Reg1);
     end else begin
      JumpNull:=0;
     end;
     if (CountList(t^.Right,ptCOMMA)=1) and not (t^.Right^.Token in [ptCOLON,ptDOTDOT]) then begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      Reg2:=GenerateExpression(t^.Right,-1,true);
      EmitOpcode(popEXTRACT,result,Reg1,Reg2);
      FreeRegister(Reg2);
     end else begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      EmitOpcode(popLOADNULL,result);
      t:=t^.Right;
      while assigned(t) and (t^.Token=ptCOMMA) do begin
       GenerateSlice(t^.Left,result,Reg1);
       t:=t^.Right;
      end;
      GenerateSlice(t,result,Reg1);
      EmitOpcode(popUPDATESTRING,result);
     end;
     if Safe then begin
      JumpEnd:=CodeGenerator^.ByteCodeSize+1;
      EmitOpcode(popJMP,0);
      FixTargetImmediate(JumpNull);
      if result<>Reg1 then begin
       EmitOpcode(popCOPY,result,Reg1);
       FreeRegister(Reg1);
      end;
      SetRegisterNumber(result,false);
      CombineCurrentRegisters(Registers);
      FixTargetImmediate(JumpEnd);
     end else begin
      FreeRegister(Reg1);
      SetRegisterNumber(result,false);
     end;
    end;
    procedure StartFallthrough(JumpRetryPos:longword);
    var Item:PPOCACodeGeneratorWhenSwitchCaseBlock;
        i,j:longint;
    begin
     j:=length(CodeGenerator^.WhenSwitchCaseBlocks);
     if CodeGenerator^.CountWhenSwitchCaseBlocks>=j then begin
      if CodeGenerator^.CountWhenSwitchCaseBlocks=0 then begin
       SetLength(CodeGenerator^.WhenSwitchCaseBlocks,8);
      end else begin
       SetLength(CodeGenerator^.WhenSwitchCaseBlocks,CodeGenerator^.CountWhenSwitchCaseBlocks*2);
      end;
      for i:=j to length(CodeGenerator^.WhenSwitchCaseBlocks)-1 do begin
       Item:=@CodeGenerator^.WhenSwitchCaseBlocks[i];
       Item^.Fallthroughs:=nil;
       Item^.CountFallthroughs:=0;
      end;
     end;
     Item:=@CodeGenerator^.WhenSwitchCaseBlocks[CodeGenerator^.CountWhenSwitchCaseBlocks];
     SetLength(Item^.Fallthroughs,16);
     Item^.CountFallthroughs:=0;
     Item^.JumpRetryPos:=JumpRetryPos;
     Item^.HasRetry:=false;
     Item^.HasFallthrough:=false;
     Item^.RetryRegisters:=GetRegisters;
     Item^.FallthroughRegisters:=GetRegisters;
     inc(CodeGenerator^.CountWhenSwitchCaseBlocks);
    end;
    procedure EndFallthrough(EndJumpPos:longword;var RetryRegisters,FallthroughRegisters:TPOCACodeGeneratorRegisters;var HasRetry,HasFallthrough:boolean);
    var Item:PPOCACodeGeneratorWhenSwitchCaseBlock;
        i:longint;
    begin
     if CodeGenerator^.CountWhenSwitchCaseBlocks=0 then begin
      SyntaxError('Invalid falthrough without matching owner when block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      dec(CodeGenerator^.CountWhenSwitchCaseBlocks);
      Item:=@CodeGenerator^.WhenSwitchCaseBlocks[CodeGenerator^.CountWhenSwitchCaseBlocks];
      for i:=0 to Item^.CountFallthroughs-1 do begin
       if Item^.Fallthroughs[i]<>$ffffffff then begin
        CodeGenerator^.ByteCode[Item^.Fallthroughs[i]]:=EndJumpPos;
       end;
      end;
      SetLength(Item^.Fallthroughs,0);
      Item^.CountFallthroughs:=0;
      Item^.JumpRetryPos:=0;
      CombineRegisters(RetryRegisters,Item^.RetryRegisters);
      CombineRegisters(FallthroughRegisters,Item^.FallthroughRegisters);
      SetLength(Item^.RetryRegisters,0);
      SetLength(Item^.FallthroughRegisters,0);
      HasRetry:=HasRetry or Item^.HasRetry;
      HasFallthrough:=HasFallthrough or Item^.HasFallthrough;
     end;
    end;
    procedure GenerateFallthrough(t:PPOCAToken);
    var Item:PPOCACodeGeneratorWhenSwitchCaseBlock;
        i,j:longint;
    begin
     if CodeGenerator^.CountWhenSwitchCaseBlocks=0 then begin
      SyntaxError('Invalid fallthrough without matching owner when block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      Item:=@CodeGenerator^.WhenSwitchCaseBlocks[CodeGenerator^.CountWhenSwitchCaseBlocks-1];
      Item^.HasFallthrough:=true;
      Item^.FallthroughRegisters:=GetRegisters;
      j:=length(Item^.Fallthroughs);
      if Item^.CountFallthroughs>=j then begin
       if Item^.CountFallthroughs=0 then begin
        SetLength(Item^.Fallthroughs,8);
       end else begin
        SetLength(Item^.Fallthroughs,Item^.CountFallthroughs*2);
       end;
       for i:=j to length(Item^.Fallthroughs)-1 do begin
        Item^.Fallthroughs[i]:=$ffffffff;
       end;
      end;
      Item^.Fallthroughs[Item^.CountFallthroughs]:=CodeGenerator^.ByteCodeSize+1;
      EmitOpcode(popJMP,0);
      inc(Item^.CountFallthroughs);
     end;
    end;
    procedure GenerateRetry(t:PPOCAToken);
    var Item:PPOCACodeGeneratorWhenSwitchCaseBlock;
    begin
     if CodeGenerator^.CountWhenSwitchCaseBlocks=0 then begin
      SyntaxError('Invalid retry without matching owner when block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      Item:=@CodeGenerator^.WhenSwitchCaseBlocks[CodeGenerator^.CountWhenSwitchCaseBlocks-1];
      Item^.HasRetry:=true;
      CombineRegisters(Item^.RetryRegisters,GetRegisters);
      EmitOpcode(popJMPLOOP,Item^.JumpRetryPos);
     end;
    end;
    function GenerateWhenOrSwitch(t:PPOCAToken;OutReg:longint;const IsSwitch:boolean):longint;
    type PWhenSwitchCaseExpression=^TWhenSwitchCaseExpression;
         TWhenSwitchCaseExpression=record
          Token:PPOCAToken;
          JumpPosition:longword;
         end;
         PWhenSwitchCase=^TWhenSwitchCase;
         TWhenSwitchCase=record
          IsDefault:boolean;
          Body:PPOCAToken;
          EndJumpPosition:longword;
          Expressions:array of TWhenSwitchCaseExpression;
         end;
         TWhenSwitchCases=array of TWhenSwitchCase;
    var Expression,Current:PPOCAToken;
        WhenSwitchCases:TWhenSwitchCases;
        WhenSwitchCase,DefaultWhenSwitchCase:PWhenSwitchCase;
        WhenSwitchCaseExpression:PWhenSwitchCaseExpression;
        CountWhenSwitchCases,CapacityWhenSwitchCases,Expressions,ExpressionIndex,i,j,RegExpression,RegComparsion,Reg,Reg1,Reg2,TryIndex,Start:longint;
        EndJumpPosition,JumpRetryPos:longword;
        Registers:array[0..7] of TPOCACodeGeneratorRegisters;
        HasDefault,HasRetry,HasBreak,HasFallthrough:boolean;
     procedure AddCaseExpression(t:PPOCAToken);
     begin
      WhenSwitchCaseExpression:=@WhenSwitchCase^.Expressions[ExpressionIndex];
      WhenSwitchCaseExpression^.Token:=t;
      WhenSwitchCaseExpression^.JumpPosition:=0;
      inc(ExpressionIndex);
     end;
     procedure ProcessCommaList(t:PPOCAToken);
     begin
      if assigned(t) then begin
       if t^.Token<>ptCOMMA then begin
        AddCaseExpression(t);
       end else begin
        ProcessCommaList(t^.Right);
        AddCaseExpression(t^.Left);
       end;
      end;
     end;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
      EmitOpcode(popLOADNULL,result);
     end else begin
      result:=OutReg;
     end;
     WhenSwitchCases:=nil;
     Registers[0]:=nil;
     Registers[1]:=nil;
     Registers[2]:=nil;
     Registers[3]:=nil;
     Registers[4]:=nil;
     Registers[5]:=nil;
     Registers[6]:=nil;
     Registers[7]:=nil;
     try
      HasDefault:=false;
      HasRetry:=false;
      HasBreak:=false;
      HasFallthrough:=false;
      begin
       Expression:=t^.Children;
       if (not assigned(Expression)) and (Expression^.Token<>ptLPAR) then begin
        SyntaxError('Missed when expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       Expression:=Expression^.Children;
      end;
      begin
       begin
        Current:=t^.Children^.Next;
        if (not assigned(Current)) and (Current^.Token<>ptLCURL) then begin
         SyntaxError('Missed when block',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
        Current:=Current^.Children;
       end;
       CountWhenSwitchCases:=0;
       while assigned(Current) and (Current^.Token in [ptCASE,ptDEFAULT]) do begin
        if CountWhenSwitchCases>=length(WhenSwitchCases) then begin
         CapacityWhenSwitchCases:=length(WhenSwitchCases)*2;
         if CapacityWhenSwitchCases=0 then begin
          CapacityWhenSwitchCases:=16;
         end;
         SetLength(WhenSwitchCases,CapacityWhenSwitchCases);
        end;
        WhenSwitchCase:=@WhenSwitchCases[CountWhenSwitchCases];
        FillChar(WhenSwitchCase^,sizeof(TWhenSwitchCase),#0);
        WhenSwitchCase^.IsDefault:=Current^.Token=ptDEFAULT;
        WhenSwitchCase^.EndJumpPosition:=$ffffffff;
        WhenSwitchCase^.Expressions:=nil;
        if WhenSwitchCase^.IsDefault then begin
         SetLength(WhenSwitchCase^.Expressions,1);
         WhenSwitchCaseExpression:=@WhenSwitchCase^.Expressions[0];
         WhenSwitchCaseExpression^.Token:=nil;
         WhenSwitchCaseExpression^.JumpPosition:=0;
         if (not assigned(Current^.Children)) and (Current^.Children^.Token<>ptLCURL) then begin
          SyntaxError('Missed default body',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         WhenSwitchCase^.Body:=Current^.Children^.Children;
        end else begin
         if (not assigned(Current^.Children)) and (Current^.Children^.Token<>ptLPAR) then begin
          SyntaxError('Missed case expression',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         Expressions:=ParameterListLen(Current^.Children);
         if Expressions=0 then begin
          SetLength(WhenSwitchCase^.Expressions,1);
          ExpressionIndex:=0;
          AddCaseExpression(Current^.Children^.Children);
         end else begin
          SetLength(WhenSwitchCase^.Expressions,Expressions);
          ExpressionIndex:=0;
          ProcessCommaList(Current^.Children^.Left);
         end;
         if (not assigned(Current^.Children^.Next)) and (Current^.Children^.Next^.Token<>ptLCURL) then begin
          SyntaxError('Missed case body',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         WhenSwitchCase^.Body:=Current^.Children^.Next^.Children;
        end;
        inc(CountWhenSwitchCases);
        if WhenSwitchCase^.IsDefault then begin
         if HasDefault then begin
          SyntaxError('A when block may contain only a default block',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         HasDefault:=true;
        end;
        Current:=Current^.Next;
       end;
       if assigned(Current) then begin
        case Current^.Token of
         ptCASE:begin
          SyntaxError('Illegal case block',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         ptDEFAULT:begin
          SyntaxError('Illegal default block',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
         else begin
          SyntaxError('Illegal token',Current^.SourceFile,Current^.SourceLine,Current^.SourceColumn);
         end;
        end;
       end;
      end; 
      Registers[0]:=GetRegisters;
      Start:=CodeGenerator^.ByteCodeSize;
      for TryIndex:=0 to 1 do begin
       CodeGenerator^.ByteCodeSize:=Start;
       SetRegisters(Registers[0]);
       SetLength(WhenSwitchCases,CountWhenSwitchCases);
       begin
        begin
         if TryIndex=1 then begin
          ClearRegisters;
         end;
         DefaultWhenSwitchCase:=nil;
         JumpRetryPos:=CodeGenerator^.ByteCodeSize;
         RegExpression:=GenerateExpression(Expression,-1,true);
         for i:=0 to CountWhenSwitchCases-1 do begin
          WhenSwitchCase:=@WhenSwitchCases[i];
          if WhenSwitchCase^.IsDefault then begin
           DefaultWhenSwitchCase:=WhenSwitchCase;
          end else begin
           for j:=0 to length(WhenSwitchCase^.Expressions)-1 do begin
            WhenSwitchCaseExpression:=@WhenSwitchCase^.Expressions[j];
            if assigned(WhenSwitchCaseExpression^.Token) and (WhenSwitchCaseExpression^.Token^.Token=ptDOTDOT) then begin
             Reg1:=GenerateExpression(WhenSwitchCaseExpression^.Token^.Left,-1,true);
             Reg2:=GenerateExpression(WhenSwitchCaseExpression^.Token^.Right,-1,true);
             RegComparsion:=GetRegister(true,false);
             if GetRegisterNumber(RegExpression) and GetRegisterNumber(Reg1) and GetRegisterNumber(Reg2) then begin
              EmitOpcode(popN_INRANGE,RegComparsion,RegExpression,Reg1,Reg2);
              SetRegisterNumber(RegComparsion,true);
             end else begin
              EmitOpcode(popINRANGE,RegComparsion,RegExpression,Reg1,Reg2);
              SetRegisterNumber(RegComparsion,false);
             end;
             FreeRegister(Reg1);
             FreeRegister(Reg2);
            end else begin
             RegComparsion:=GenerateExpression(WhenSwitchCaseExpression^.Token,-1,true);
             Reg1:=RegComparsion;
             if GetRegisterConstant(Reg1) then begin
              RegComparsion:=GetRegister(true,false);
             end;
             if GetRegisterNumber(RegComparsion) and GetRegisterNumber(RegExpression) then begin
              EmitOpcode(popN_EQ,RegComparsion,Reg1,RegExpression);
             end else begin
              EmitOpcode(popEQ,RegComparsion,Reg1,RegExpression);
             end;
             if Reg1<>RegComparsion then begin
              FreeRegister(Reg1);
             end;
            end;
            WhenSwitchCaseExpression^.JumpPosition:=CodeGenerator^.ByteCodeSize+1;
            if GetRegisterNumber(RegComparsion) then begin
             EmitOpcode(popN_JIFTRUE,0,RegComparsion);
            end else begin
             EmitOpcode(popJIFTRUE,0,RegComparsion);
            end;
            FreeRegister(RegComparsion);
           end;
          end;
         end;
         FreeRegister(RegExpression);
         if assigned(DefaultWhenSwitchCase) then begin
          DefaultWhenSwitchCase^.Expressions[0].JumpPosition:=CodeGenerator^.ByteCodeSize+1;
          EmitOpcode(popJMP,0);
          EndJumpPosition:=0;
         end else begin
          EndJumpPosition:=CodeGenerator^.ByteCodeSize+1;
          EmitOpcode(popJMP,0);
         end;
        end;
        begin
         if IsSwitch then begin
          StartSwitch;
         end;
         if TryIndex=0 then begin
          Registers[1]:=GetRegisters;
          Registers[2]:=GetRegisters;
          Registers[3]:=GetRegisters;
          Registers[4]:=GetRegisters;
          Registers[5]:=GetRegisters;
         end;
         begin
          for i:=0 to CountWhenSwitchCases-1 do begin
           WhenSwitchCase:=@WhenSwitchCases[i];
           if length(WhenSwitchCase^.Expressions)>0 then begin
            for j:=0 to length(WhenSwitchCase^.Expressions)-1 do begin
             FixTargetImmediate(WhenSwitchCase^.Expressions[j].JumpPosition);
            end;
            if TryIndex=0 then begin
             CombineRegisters(Registers[2],GetRegisters);
            end else begin
             ClearRegisters;
            end;
            StartFallthrough(JumpRetryPos);
            Reg:=GenerateBlock(WhenSwitchCase^.Body,result,DoNeedResult,true);
            if Reg<>result then begin
             EmitOpcode(popCOPY,result,Reg);
             SetRegisterNumber(result,GetRegisterNumber(Reg));
            end;
            WhenSwitchCase^.EndJumpPosition:=CodeGenerator^.ByteCodeSize+1;
            EmitOpcode(popJMP,0);
            if Reg<>result then begin
             EmitOpcode(popCOPY,result,Reg);
             SetRegisterNumber(result,GetRegisterNumber(Reg));
             FreeRegister(Reg);
            end;
            if TryIndex=0 then begin
             CombineRegisters(Registers[3],GetRegisters);
            end else begin
             ClearRegisters;
            end;
            EndFallthrough(CodeGenerator^.ByteCodeSize,Registers[4],Registers[5],HasRetry,HasFallthrough);
           end;
          end;
         end;
         Registers[6]:=GetRegisters;
         if IsSwitch then begin
          EndSwitch(CodeGenerator^.ByteCodeSize,Registers[6],HasBreak);
         end;
         if TryIndex=0 then begin
          Registers[7]:=GetRegisters;
         end else begin
          ClearRegisters;
         end;
         begin
          for i:=0 to CountWhenSwitchCases-1 do begin
           WhenSwitchCase:=@WhenSwitchCases[i];
           if WhenSwitchCase^.EndJumpPosition<>$ffffffff then begin
            FixTargetImmediate(WhenSwitchCase^.EndJumpPosition);
           end;
          end;
          if not assigned(DefaultWhenSwitchCase) then begin
           FixTargetImmediate(EndJumpPosition);
          end;
         end;
        end;
       end;
       if TryIndex=0 then begin
        // 0 = Before switch
        // 1 = After switch expression
        // 2 = Combined before each case block entrypoint
        // 3 = Combined after each case block end
        // 4 = Combined at each retry
        // 5 = Combined at each fallthrough
        // 6 = Combined at break
        // 7 = After switch
        if not AreRegistersEqual(Registers[0],Registers[1],false,false) then begin
         continue;
        end;
        if not AreRegistersEqual(Registers[1],Registers[2],false,false) then begin
         continue;
        end;
        if not AreRegistersEqual(Registers[2],Registers[3],false,false) then begin
         continue;
        end;
        if HasRetry and not (AreRegistersEqual(Registers[0],Registers[4],false,false) and
                             AreRegistersEqual(Registers[1],Registers[2],false,false) and
                             AreRegistersEqual(Registers[1],Registers[4],false,false) and
                             AreRegistersEqual(Registers[2],Registers[4],false,false)) then begin
         continue;
        end;
        if HasFallthrough and not AreRegistersEqual(Registers[2],Registers[5],false,false) then begin
         continue;
        end;
        if HasBreak and not AreRegistersEqual(Registers[6],Registers[7],false,false) then begin
         continue;
        end;
        break;
       end;
      end;
     finally
      SetLength(WhenSwitchCases,0);
      SetLength(Registers[0],0);
      SetLength(Registers[1],0);
      SetLength(Registers[2],0);
      SetLength(Registers[3],0);
      SetLength(Registers[4],0);
      SetLength(Registers[5],0);
      SetLength(Registers[6],0);
      SetLength(Registers[7],0);
     end;
     SetRegisterNumber(result,false);
    end;
    function GenerateDot(t:PPOCAToken;OutReg:longint;Safe:boolean):longint;
    var Reg,JumpNull,JumpEnd:longint;
        Registers:TPOCACodeGeneratorRegisters;
    begin
     result:=-1;
     Reg:=GenerateExpression(t^.Left,-1,true);
     Registers:=GetRegisters;
     if Safe then begin
      JumpNull:=CodeGenerator^.ByteCodeSize+1;
      EmitOpcode(popJIFFALSE,0,Reg);
     end else begin
      JumpNull:=0;
     end;
     if assigned(t^.Right) then begin
      case t^.Right^.Token of
       ptPROTOTYPE:begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popGETPROTOTYPE,result,Reg);
       end;
       ptCONSTRUCTOR:begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popGETCONSTRUCTOR,result,Reg);
       end;
       ptHASHKIND:begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popGETHASHKIND,result,Reg);
       end;
       ptSYMBOL,ptSUPERCODESYMBOL:begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popGETMEMBER,result,Reg,FindConstantIndex(t^.Right),$ffffffff);
       end;
       else begin
        SyntaxError('Object field must be symbol',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
     end;
     if Safe then begin
      JumpEnd:=CodeGenerator^.ByteCodeSize+1;
      EmitOpcode(popJMP,0);
      FixTargetImmediate(JumpNull);
      if result<>Reg then begin
       EmitOpcode(popCOPY,result,Reg);
       FreeRegister(Reg);
      end;
      SetRegisterNumber(result,false);
      CombineCurrentRegisters(Registers);
      FixTargetImmediate(JumpEnd);
     end else begin
      FreeRegister(Reg);
      SetRegisterNumber(result,false);
     end;
    end;
    function GenerateDefined(t:PPOCAToken;OutReg:longint):longint;
    var Reg,Reg1,Reg2,ConstantIndex,EndPos,TryBlockPos,CatchBlockPos:longint;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     if (not assigned(t^.Right)) or (t^.Right^.Token=ptEMPTY) then begin
      SyntaxError('Missed expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      if (t^.Right^.Token=ptSYMBOL) and IsSymbolRegister(t^.Right) then begin
       EmitOpcode(popLOADONE,result);
      end else begin
       EmitImmediate(popTRY,6);
       Emit(result);
       Emit($ffffffff);
       TryBlockPos:=CodeGenerator^.ByteCodeSize;
       Emit($ffffffff);
       CatchBlockPos:=CodeGenerator^.ByteCodeSize;
       Emit($ffffffff);
       Emit($ffffffff);
       EndPos:=CodeGenerator^.ByteCodeSize;
       Emit($ffffffff);
       begin
        FixTargetImmediate(TryBlockPos);
        case t^.Right^.Token of
         ptLBRA,ptSAFELBRA:begin
          if not (assigned(t^.Right^.Left) and assigned(t^.Right^.Right)) then begin
           SyntaxError('Identifier expected',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
           exit;
          end;
          Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
          Reg2:=GenerateExpression(t^.Right^.Right,-1,true);
          EmitOpcode(popDEFINEDEX,result,Reg1,Reg2);
          FreeRegister(Reg2);
          FreeRegister(Reg1);
         end;
         ptDOT,ptSAFEDOT:begin
          if not (assigned(t^.Right^.Left) and assigned(t^.Right^.Right)) then begin
           SyntaxError('Symbol expected',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
           exit;
          end;
          case t^.Right^.Right^.Token of
           ptSYMBOL:begin
            ConstantIndex:=FindConstantIndex(t^.Right^.Right);
            Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
            EmitOpcode(popDEFINED,result,Reg1,ConstantIndex);
            FreeRegister(Reg1);
           end;
           ptPROTOTYPE,ptCONSTRUCTOR,ptHASHKIND:begin
            Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
            EmitOpcode(popLOADONE,result);
            FreeRegister(Reg1);
           end;
           else begin
            SyntaxError('Symbol expected',Parser.SourceFile,t^.Right^.Right^.SourceLine,t^.Right^.Right^.SourceColumn);
           end;
          end;
         end;
         else begin
          Reg:=GenerateExpression(t^.Right,-1,false);
          FreeRegister(Reg);
         end;
        end;
        EmitOpcode(popLOADONE,result);
        EmitOpcode(popTRYBLOCKEND,result);
       end;
       begin
        FixTargetImmediate(CatchBlockPos);
        EmitOpcode(popLOADZERO,result);
        EmitOpcode(popTRYBLOCKEND,result);
       end;
       FixTargetImmediate(EndPos);
      end;
     end;
     SetRegisterNumber(result,true);
    end;
    function GenerateTypeOf(t:PPOCAToken;OutReg:longint):longint;
    var Reg1:longint;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     if (not assigned(t^.Right)) or (t^.Right^.Token=ptEMPTY) then begin
      SyntaxError('Missed expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      Reg1:=GenerateExpression(t^.Right,-1,true);
      EmitOpcode(popTYPEOF,result,Reg1);
      FreeRegister(Reg1);
     end;
     SetRegisterNumber(result,false);
    end;
    function GenerateIDOf(t:PPOCAToken;OutReg:longint):longint;
    var Reg1:longint;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     if (not assigned(t^.Right)) or (t^.Right^.Token=ptEMPTY) then begin
      SyntaxError('Missed expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      Reg1:=GenerateExpression(t^.Right,-1,true);
      EmitOpcode(popIDOF,result,Reg1);
      FreeRegister(Reg1);
     end;
     SetRegisterNumber(result,false);
    end;
    function GenerateGhostTypeOf(t:PPOCAToken;OutReg:longint):longint;
    var Reg1:longint;
    begin
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end else begin
      result:=OutReg;
     end;
     if (not assigned(t^.Right)) or (t^.Right^.Token=ptEMPTY) then begin
      SyntaxError('Missed expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      Reg1:=GenerateExpression(t^.Right,-1,true);
      EmitOpcode(popGHOSTTYPEOF,result,Reg1);
      FreeRegister(Reg1);
     end;
     SetRegisterNumber(result,false);
    end;
    function GenerateLPAR(t:PPOCAToken;OutReg:longint):longint;
    begin
     if Binary(t) or not assigned(t^.Right) then begin
      case t^.Left^.Token of
       ptDEFINED:begin
        result:=GenerateDefined(t,OutReg);
       end;
       ptTYPEOF:begin
        result:=GenerateTypeOf(t,OutReg);
       end;
       ptIDOF:begin
        result:=GenerateIDOf(t,OutReg);
       end;
       ptGHOSTTYPEOF:begin
        result:=GenerateGhostTypeOf(t,OutReg);
       end;
       else begin
        result:=GenerateFunctionCall(t,OutReg);
       end;
      end;
     end else begin
      if assigned(t^.Right) then begin
       case t^.Right^.Token of
        ptCOMMA:begin
         result:=GenerateCommaBlock(t^.Right,OutReg,DoNeedResult,true);
        end;
        ptSEMI,ptAUTOSEMI:begin
         result:=GenerateBlock(t^.Right,OutReg,DoNeedResult,true);
        end;
        else begin
         result:=GenerateExpression(t^.Right,OutReg,DoNeedResult);
        end;
       end;
      end else begin
       result:=GenerateExpression(t^.Right,OutReg,DoNeedResult);
      end;
     end;
    end;
    function GenerateRegExp(t:PPOCAToken;OutReg:longint):longint;
    var Reg:longint;
    begin
     if assigned(t^.Right) then begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      Reg:=GenerateExpression(t^.Right,-1,true);
      EmitOpcode(popREGEXP,result,CodeGenerator^.CountRegExps,Reg);
      FreeRegister(Reg);
      inc(CodeGenerator^.CountRegExps);
     end else begin
      result:=OutReg;
      SyntaxError('Parser error',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
     end;
    end;
    function GenerateReturn(t:PPOCAToken;OutReg:longint):longint;
    var v:longword;
    begin
     if CodeToken in [ptCLASSFUNCTION,ptMODULEFUNCTION] then begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      EmitOpcode(popLOADLOCAL,result);
     end else begin
      if assigned(t^.Right) then begin
       result:=GenerateExpression(t^.Right,-1,true);
      end else begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADNULL,result);
      end;
     end;
     if ((CodeToken=ptFASTFUNCTION) or (assigned(t^.Right) and ((assigned(t^.Right^.Left) and (t^.Right^.Left^.Token=ptSELF)) and (Binary(t^.Right) or not assigned(t^.Right^.Right))))) and ((CodeGenerator^.CountOpcodes>0) and ((CodeGenerator^.ByteCode[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-1]] and $ff) in [popFCALL,popMCALL,popFCALLH,popMCALLH])) then begin
      v:=CodeGenerator^.ByteCode[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-1]];
      case v and $ff of
       popFCALL:begin
        v:=popFTAILCALL or (v and $ffffff00);
       end;
       popMCALL:begin
        v:=popMTAILCALL or (v and $ffffff00);
       end;
       popFCALLH:begin
        v:=popFTAILCALLH or (v and $ffffff00);
       end;
       popMCALLH:begin
        v:=popMTAILCALLH or (v and $ffffff00);
       end;
       else begin
        EmitOpcode(popRETURN,result);
       end;
      end;
      CodeGenerator^.ByteCode[CodeGenerator^.Opcodes[CodeGenerator^.CountOpcodes-1]]:=v;
      exit;
     end;
     EmitOpcode(popRETURN,result);
     SetRegisterNumber(result,false);
    end;
    function GenerateDelete(t:PPOCAToken;OutReg:longint):longint;
    var Reg1,Reg2,ConstantIndex:longint;
    begin
     result:=OutReg;
     if not assigned(t^.Right) then begin
      SyntaxError('Symbol expected',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
      exit;
     end;
     if OutReg<0 then begin
      result:=GetRegister(true,false);
     end;
     case t^.Right^.Token of
      ptLBRA:begin
       if not (assigned(t^.Right^.Left) and assigned(t^.Right^.Right)) then begin
        SyntaxError('Identifier expected',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
        exit;
       end;
       Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
       Reg2:=GenerateExpression(t^.Right^.Right,-1,true);
       EmitOpcode(popDELETEEX,result,Reg1,Reg2);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
      end;
      ptSAFELBRA:begin
       SyntaxError('??[ at Delete is not allowed',Parser.SourceFile,t^.Right^.SourceLine,t^.Right^.SourceColumn);
      end;
      ptDOT:begin
       if not (assigned(t^.Right^.Left) and assigned(t^.Right^.Right)) then begin
        SyntaxError('Symbol expected',Parser.SourceFile,t^.SourceLine,t^.SourceColumn);
        exit;
       end;
       case t^.Right^.Right^.Token of
        ptSYMBOL:begin
         ConstantIndex:=FindConstantIndex(t^.Right^.Right);
         Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
         EmitOpcode(popDELETE,result,Reg1,ConstantIndex);
         FreeRegister(Reg1);
        end;
        ptPROTOTYPE:begin
         Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
         Reg2:=GetRegister(true,false);
         EmitOpcode(popLOADNULL,Reg2);
         EmitOpcode(popSETPROTOTYPE,Reg1,Reg2);
         FreeRegister(Reg2);
         FreeRegister(Reg1);
         EmitOpcode(popLOADONE,result);
        end;
        ptCONSTRUCTOR:begin
         Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
         Reg2:=GetRegister(true,false);
         EmitOpcode(popLOADNULL,Reg2);
         EmitOpcode(popSETCONSTRUCTOR,Reg1,Reg2);
         FreeRegister(Reg2);
         FreeRegister(Reg1);
         EmitOpcode(popLOADONE,result);
        end;
        ptHASHKIND:begin
         Reg1:=GenerateExpression(t^.Right^.Left,-1,true);
         Reg2:=GetRegister(true,false);
         EmitOpcode(popLOADZERO,Reg2);
         EmitOpcode(popSETHASHKIND,Reg1,Reg2);
         FreeRegister(Reg2);
         FreeRegister(Reg1);
         EmitOpcode(popLOADONE,result);
        end;
        else begin
         SyntaxError('Symbol expected',Parser.SourceFile,t^.Right^.Right^.SourceLine,t^.Right^.Right^.SourceColumn);
        end;
       end;
      end;
      ptSAFEDOT:begin
       SyntaxError('??. at Delete is not allowed',Parser.SourceFile,t^.Right^.SourceLine,t^.Right^.SourceColumn);
      end;
      ptSYMBOL:begin
       if IsSymbolRegister(t^.Right) then begin
        if IsSymbolRegisterConstant(t^.Right) then begin
         SyntaxError('Constants aren''t deleteable',Parser.SourceFile,t^.Right^.SourceLine,t^.Right^.SourceColumn);
        end else begin
         if DeleteSymbolRegister(t^.Right,1) then begin
          EmitOpcode(popLOADONE,result);
         end else begin
          SyntaxError('Local symbols outside scope block not deleteable',Parser.SourceFile,t^.Right^.SourceLine,t^.Right^.SourceColumn);
         end;
        enD;
       end else begin
        Reg1:=GetRegister(true,false);
        EmitOpcode(popLOADLOCAL,Reg1);
        ConstantIndex:=FindConstantIndex(t^.Right);
        EmitOpcode(popDELETE,result,Reg1,ConstantIndex);
        FreeRegister(Reg1);
       end;
      end;
      ptPROTOTYPE:begin
       Reg1:=GetRegister(true,false);
       Reg2:=GetRegister(true,false);
       EmitOpcode(popLOADLOCAL,Reg1);
       EmitOpcode(popLOADNULL,Reg2);
       EmitOpcode(popSETPROTOTYPE,Reg1,Reg2);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
       EmitOpcode(popLOADONE,result);
      end;
      ptCONSTRUCTOR:begin
       Reg1:=GetRegister(true,false);
       Reg2:=GetRegister(true,false);
       EmitOpcode(popLOADLOCAL,Reg1);
       EmitOpcode(popLOADNULL,Reg2);
       EmitOpcode(popSETCONSTRUCTOR,Reg1,Reg2);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
       EmitOpcode(popLOADONE,result);
      end;
      ptHASHKIND:begin
       Reg1:=GetRegister(true,false);
       Reg2:=GetRegister(true,false);
       EmitOpcode(popLOADLOCAL,Reg1);
       EmitOpcode(popLOADONE,Reg2);
       EmitOpcode(popSETHASHKIND,Reg1,Reg2);
       FreeRegister(Reg2);
       FreeRegister(Reg1);
       EmitOpcode(popLOADONE,result);
      end;
      else begin
       SyntaxError('Symbol expected',Parser.SourceFile,t^.Right^.Right^.SourceLine,t^.Right^.Right^.SourceColumn);
      end;
     end;
     SetRegisterNumber(result,true);
    end;
   var i:longint;
       ot:TPOCATokenType;
   begin
    result:=-1;
    if not assigned(t) then begin
     SyntaxError('Parser error',Parser.SourceFile,-1,-1);
    end else begin
     if CodeGenerator^.LastLine<>t^.SourceLine then begin
      CodeGenerator^.LastLine:=t^.SourceLine;
      NewLine(t^.SourceLine);
     end;
     case t^.Token of
      ptTOP:begin
       result:=GenerateBlock(t^.Left,OutReg,DoNeedResult,true);
      end;
      ptBLOCK:begin
       if (not assigned(t^.Left)) or (t^.Left^.Token<>ptLCURL) then begin
        SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        result:=GenerateBlock(t^.Left^.Children,OutReg,DoNeedResult,true);
       end;
      end;
      ptINLINEBLOCK:begin
       if (not assigned(t^.Left)) or (t^.Left^.Token<>ptLCURL) then begin
        SyntaxError('Missed curly brace',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end else begin
        result:=GenerateBlock(t^.Left^.Children,OutReg,DoNeedResult,false);
       end;
      end;
      ptNEW:begin
       if assigned(t^.Right) and (t^.Right^.Token=ptLPAR) then begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        result:=GenerateFunctionCall(t^.Right,result,'create');
       end else begin
        SyntaxError('Invalid new usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptSUPERTHAT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADTHAT,result);
       SetRegisterNumber(result,false);
      end;
      ptTHAT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADTHAT,result);
       SetRegisterNumber(result,false);
      end;
      ptTHIS:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADTHIS,result);
       SetRegisterNumber(result,false);
      end;
      ptSELF:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADSELF,result);
       SetRegisterNumber(result,false);
      end;
      ptLOCAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADLOCAL,result);
       SetRegisterNumber(result,false);
      end;
      ptGLOBAL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADGLOBAL,result);
       SetRegisterNumber(result,false);
      end;
      ptBASECLASS:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADBASECLASS,result);
       SetRegisterNumber(result,false);
      end;
      ptSYMBOL:begin
       if IsSymbolRegister(t) then begin
        result:=GetSymbolRegister(t,false,false);
        if OutReg>=0 then begin
         EmitOpcode(popCOPY,OutReg,result);
         SetRegisterNumber(OutReg,GetRegisterNumber(result));
         result:=OutReg;
        end;
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popGETLOCAL,result,FindConstantIndex(t),$ffffffff);
        SetRegisterNumber(result,false);
       end;
      end;
      ptLITERALNUM,ptLITERALSTR:begin
       if OutReg<0 then begin
        result:=FindConstantRegister(t);
        if result<0 then begin
         result:=GenerateScalarConstant(t,OutReg);
        end;
       end else begin
        result:=GenerateScalarConstant(t,OutReg);
       end;
       SetRegisterNumber(result,t^.Token=ptLITERALNUM);
      end;
      ptVAR:begin
       if CodeToken=ptFASTFUNCTION then begin
        SyntaxError('VAR is not allowed in fastfunctions',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
       if assigned(t^.Right) and (t^.Right^.Token=ptSYMBOL) then begin
        CodeGenerator^.HasLocals:=true;
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popLOADNULL,result);
        SetRegisterNumber(result,false);
        EmitOpcode(popSETLOCAL,FindConstantIndex(t^.Right),result,$ffffffff);
       end else begin
        SyntaxError('Symbol expected',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptREGISTER,ptCONST:begin
       ot:=t^.Token;
       if assigned(t^.Right) and (t^.Right^.Token=ptSYMBOL) then begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popLOADNULL,result);
        SetRegisterNumber(result,false);
        i:=GetSymbolRegister(t^.Right,true,ot=ptCONST);
        EmitOpcode(popCOPY,i,result);
        SetRegisterNumber(i,GetRegisterNumber(result));
       end else begin
        SyntaxError('Symbol expected',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptFUNCTION,ptFASTFUNCTION,ptCLASSFUNCTION,ptMODULEFUNCTION:begin
       result:=GenerateLambda(t,OutReg);
       SetRegisterNumber(result,false);
      end;
      ptTRY:begin
       result:=GenerateTry(t,OutReg);
       SetRegisterNumber(result,false);
      end;
      ptIF:begin
       result:=GenerateIFELSE(t,OutReg);
      end;
      ptQUESTION:begin
       result:=GenerateQuestion(t,OutReg);
      end;
      ptWHILE:begin
       result:=GenerateWhile(t,OutReg);
      end;
      ptDO:begin
       result:=GenerateDoWhile(t,OutReg);
      end;
      ptFOR:begin
       result:=GenerateFor(t,OutReg);
      end;
      ptLPAR:begin
       result:=GenerateLPAR(t,OutReg);
      end;
      ptFOREACH,ptFORINDEX,ptFORKEY:begin
       result:=GenerateForEachForIndexForKey(t,OutReg);
      end;
      ptBREAK,ptCONTINUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       GenerateBreakContinue(t);
      end;
      ptFALLTHROUGH:begin
       GenerateFallthrough(t);
      end;
      ptRETRY:begin
       GenerateRetry(t);
      end;
      ptASSIGN:begin
       result:=GenerateAssignment(t,OutReg);
      end;
      ptLCURL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popNEWHASH,result);
       GenerateHash(t^.Left,result);
       SetRegisterNumber(result,false);
      end;
      ptLBRA:begin
       if Unary(t) then begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popNEWARRAY,result);
        GenerateArray(t^.Left,result);
        SetRegisterNumber(result,false);
       end else if Binary(t) then begin
        result:=GenerateExtract(t,OutReg,false);
       end else begin
        SyntaxError('Invalid token usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptSAFELBRA:begin
       if Binary(t) then begin
        result:=GenerateExtract(t,OutReg,true);
       end else begin
        SyntaxError('Invalid token usage',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptREGEXP:begin
       result:=GenerateRegExp(t,OutReg);
      end;
      ptRETURN:begin
       result:=GenerateReturn(t,OutReg);
      end;
      ptTHROW:begin
       if assigned(t^.Right) then begin
        result:=GenerateExpression(t^.Right,-1,true);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popLOADNULL,result);
        SetRegisterNumber(result,false);
       end;
       EmitOpcode(popTHROW,result);
      end;
      ptNOT:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       i:=GenerateExpression(t^.Right,-1,true);
       EmitOpcode(popNOT,result,i);
       SetRegisterNumber(result,GetRegisterNumber(i));
       FreeRegister(i);
      end;
      ptWHEN:begin
       result:=GenerateWhenOrSwitch(t,OutReg,false);
      end;
      ptSWITCH:begin
       result:=GenerateWhenOrSwitch(t,OutReg,true);
      end;
      ptMINUS:begin
       if Binary(t) then begin
        result:=GenerateBinaryOperation(popSUB,t,OutReg);
       end else if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
        t^.Right^.Num:=-t^.Right^.Num;
        result:=GenerateScalarConstant(t^.Right,OutReg);
        SetRegisterNumber(result,true);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        EmitOpcode(popNEG,result,i);
        SetRegisterNumber(result,GetRegisterNumber(i));
        FreeRegister(i);
       end;
      end;
      ptNEG:begin
       if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
        t^.Right^.Num:=-t^.Right^.Num;
        result:=GenerateScalarConstant(t^.Right,OutReg);
        SetRegisterNumber(result,true);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        EmitOpcode(popNEG,result,i);
        SetRegisterNumber(result,GetRegisterNumber(i));
        FreeRegister(i);
       end;
      end;
      ptNUM:begin
       if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
        result:=GenerateScalarConstant(t^.Right,OutReg);
        SetRegisterNumber(result,true);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        EmitOpcode(popNUM,result,i);
        SetRegisterNumber(result,true);
        FreeRegister(i);
       end;
      end;
      ptDOT:begin
       result:=GenerateDot(t,OutReg,false);
      end;
      ptSAFEDOT:begin
       result:=GenerateDot(t,OutReg,true);
      end;
      ptEMPTY:begin
       if OutReg<0 then begin
        if DoNeedResult then begin
         result:=GetRegister(true,false);
         EmitOpcode(popLOADNULL,result);
         SetRegisterNumber(result,false);
        end else begin
         result:=OutReg;
         exit;
        end;
       end else begin
        result:=OutReg;
        EmitOpcode(popLOADNULL,result);
        SetRegisterNumber(result,false);
       end;
      end;
      ptNULL:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADNULL,result);
       SetRegisterNumber(result,false);
      end;
      ptAND,ptOR,ptELVIS:begin
       result:=GenerateShortCircuit(t,OutReg);
      end;
      ptMUL:begin
       result:=GenerateBinaryOperation(popMUL,t,OutReg);
      end;
      ptPLUS:begin
       if t^.Rule=prPREFIX then begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        EmitOpcode(popNUM,result,i);
        SetRegisterNumber(result,true);
        FreeRegister(i);
       end else begin
        result:=GenerateBinaryOperation(popADD,t,OutReg);
       end;
      end;
      ptDIV:begin
       result:=GenerateBinaryOperation(popDIV,t,OutReg);
      end;
      ptLT:begin
       result:=GenerateBinaryOperation(popLT,t,OutReg);
      end;
      ptLTEQ:begin
       result:=GenerateBinaryOperation(popLTEQ,t,OutReg);
      end;
      ptEQ:begin
       result:=GenerateBinaryOperation(popEQ,t,OutReg);
      end;
      ptNEQ:begin
       result:=GenerateBinaryOperation(popNEQ,t,OutReg);
      end;
      ptGT:begin
       result:=GenerateBinaryOperation(popGT,t,OutReg);
      end;
      ptGTEQ:begin
       result:=GenerateBinaryOperation(popGTEQ,t,OutReg);
      end;
      ptCMP:begin
       result:=GenerateBinaryOperation(popCMP,t,OutReg);
      end;
      ptPOSTDEC:begin
       result:=GeneratePostfixDecIncOp(popDEC,t,OutReg);
      end;
      ptPOSTINC:begin
       result:=GeneratePostfixDecIncOp(popINC,t,OutReg);
      end;
      ptPREDEC:begin
       result:=GeneratePrefixDecIncOp(popDEC,t,OutReg);
      end;
      ptPREINC:begin
       result:=GeneratePrefixDecIncOp(popINC,t,OutReg);
      end;
      ptPLUSEQ:begin
       result:=GenerateAssignOp(popADD,t,OutReg);
      end;
      ptMINUSEQ:begin
       result:=GenerateAssignOp(popSUB,t,OutReg);
      end;
      ptMULEQ:begin
       result:=GenerateAssignOp(popMUL,t,OutReg);
      end;
      ptDIVEQ:begin
       result:=GenerateAssignOp(popDIV,t,OutReg);
      end;
      ptCATEQ:begin
       result:=GenerateAssignOp(popCAT,t,OutReg);
      end;
      ptCAT:begin
       if Binary(t) then begin
        result:=GenerateBinaryOperation(popCAT,t,OutReg);
       end else if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
        t^.Right^.Num:=not int64(trunc(t^.Right^.Num));
        result:=GenerateScalarConstant(t^.Right,OutReg);
        SetRegisterNumber(result,true);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        if GetRegisterNumber(i) then begin
         EmitOpcode(popN_BNOT,result,i);
        end else begin
         EmitOpcode(popBNOT,result,i);
        end;
        SetRegisterNumber(result,GetRegisterNumber(i));
        FreeRegister(i);
       end;
      end;
      ptBNOT:begin
       if assigned(t^.Right) and (t^.Right^.Token=ptLITERALNUM) then begin
        t^.Right^.Num:=not int64(trunc(t^.Right^.Num));
        result:=GenerateScalarConstant(t^.Right,OutReg);
        SetRegisterNumber(result,true);
       end else begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Right,-1,true);
        if GetRegisterNumber(i) then begin
         EmitOpcode(popN_BNOT,result,i);
        end else begin
         EmitOpcode(popBNOT,result,i);
        end;
        SetRegisterNumber(result,GetRegisterNumber(i));
        FreeRegister(i);
       end;
      end;
      ptBAND:begin
       result:=GenerateBinaryOperation(popBAND,t,OutReg);
      end;
      ptBOR:begin
       result:=GenerateBinaryOperation(popBOR,t,OutReg);
      end;
      ptBXOR:begin
       result:=GenerateBinaryOperation(popBXOR,t,OutReg);
      end;
      ptBSHL:begin
       result:=GenerateBinaryOperation(popBSHL,t,OutReg);
      end;
      ptBSHR:begin
       result:=GenerateBinaryOperation(popBSHR,t,OutReg);
      end;
      ptBUSHR:begin
       result:=GenerateBinaryOperation(popBUSHR,t,OutReg);
      end;
      ptMOD:begin
       result:=GenerateBinaryOperation(popMOD,t,OutReg);
      end;
      ptPOW:begin
       if ((Binary(t) and assigned(t^.Right)) and (t^.Right^.Token=ptLITERALNUM)) and (t^.Right^.Num=0.5) then begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        i:=GenerateExpression(t^.Left,-1,true);
        if GetRegisterNumber(i) then begin
         EmitOpcode(popN_SQRT,result,i);
         SetRegisterNumber(result,true);
        end else begin
         EmitOpcode(popSQRT,result,i);
         SetRegisterNumber(result,false);
        end;
        FreeRegister(i);
       end else begin
        result:=GenerateBinaryOperation(popPOW,t,OutReg);
       end;
      end;
      ptBOREQ:begin
       result:=GenerateAssignOp(popBOR,t,OutReg);
      end;
      ptBANDEQ:begin
       result:=GenerateAssignOp(popBAND,t,OutReg);
      end;
      ptBXOREQ:begin
       result:=GenerateAssignOp(popBXOR,t,OutReg);
      end;
      ptBSHLEQ:begin
       result:=GenerateAssignOp(popBSHL,t,OutReg);
      end;
      ptBSHREQ:begin
       result:=GenerateAssignOp(popBSHR,t,OutReg);
      end;
      ptBUSHREQ:begin
       result:=GenerateAssignOp(popBUSHR,t,OutReg);
      end;
      ptMODEQ:begin
       result:=GenerateAssignOp(popMOD,t,OutReg);
      end;
      ptPOWEQ:begin
       result:=GenerateAssignOp(popPOW,t,OutReg);
      end;
      ptELVISEQ:begin
       result:=GenerateElvisAssignOp(t,OutReg);
      end;
      ptINSTANCEOF:begin
       result:=GenerateBinaryOperation(popINSTANCEOF,t,OutReg);
       SetRegisterNumber(result,true);
      end;
      ptSEQ:begin
       result:=GenerateBinaryOperation(popSEQ,t,OutReg);
      end;
      ptSNEQ:begin
       result:=GenerateBinaryOperation(popSNEQ,t,OutReg);
      end;
      ptIN:begin
       result:=GenerateInOperation(t,OutReg);
      end;
      ptIS:begin
       result:=GenerateBinaryOperation(popIS,t,OutReg);
       SetRegisterNumber(result,true);
      end;
      ptTRUE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADONE,result);
       SetRegisterNumber(result,true);
      end;
      ptFALSE:begin
       if OutReg<0 then begin
        result:=GetRegister(true,false);
       end else begin
        result:=OutReg;
       end;
       EmitOpcode(popLOADZERO,result);
       SetRegisterNumber(result,true);
      end;
      ptREGEXPEQ:begin
       result:=GenerateBinaryOperation(popREGEXPEQ,t,OutReg);
      end;
      ptREGEXPNEQ:begin
       result:=GenerateBinaryOperation(popREGEXPNEQ,t,OutReg);
      end;
      ptBREAKPOINT:begin
       if DoNeedResult then begin
        if OutReg<0 then begin
         result:=GetRegister(true,false);
        end else begin
         result:=OutReg;
        end;
        EmitOpcode(popLOADNULL,result);
        SetRegisterNumber(result,false);
        EmitOpcode(popBREAKPOINT);
       end else begin
        result:=OutReg;
        EmitOpcode(popBREAKPOINT);
       end;
      end;
      ptDELETE:begin
       result:=GenerateDelete(t,OutReg);
      end;
      else begin
       SyntaxError('Invalid token',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
     if result<0 then begin
      if OutReg<0 then begin
       result:=GetRegister(true,false);
      end else begin
       result:=OutReg;
      end;
      EmitOpcode(popLOADNULL,result);
     end;
    end;
   end;
   procedure PreprocessArgumentList(t:PPOCAToken);
   var IsLocal,IsConst:boolean;
       Symbol:PPOCAToken;
   begin
    IsConst:=false;
    if assigned(t) and (t^.Token<>ptEMPTY) then begin
     Symbol:=nil;
     case t^.Token of
      ptELLIPSIS:begin
       IsLocal:=false;
       if CodeToken=ptFASTFUNCTION then begin
        SyntaxError('Bad fastfunction argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      ptASSIGN:begin
       IsLocal:=assigned(t^.Left) and (t^.Left^.Token in [ptREGISTER,ptCONST]);
       if IsLocal then begin
        if assigned(t^.Left^.Right) and (t^.Left^.Right^.Token=ptSYMBOL) then begin
         Symbol:=t^.Left^.Right;
        end else begin
         SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end;
       end else if CodeToken=ptFASTFUNCTION then begin
        if assigned(t^.Left) and (t^.Left^.Token=ptVAR) then begin
         SyntaxError('Bad fastfunction argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end else begin
         IsLocal:=true;
         Symbol:=t^.Left;
        end;
       end;
      end;
      ptREGISTER,ptCONST:begin
       IsLocal:=true;
       IsConst:=t^.Token=ptCONST;
       if assigned(t^.Right) and (t^.Right^.Token=ptSYMBOL) then begin
        Symbol:=t^.Right;
       end;
      end;
      ptVAR:begin
       if CodeToken=ptFASTFUNCTION then begin
        IsLocal:=true;
        Symbol:=t^.Right;
       end else begin
        IsLocal:=false;
       end;
      end;
      ptSYMBOL:begin
       if CodeToken=ptFASTFUNCTION then begin
        IsLocal:=true;
        Symbol:=t;
       end else begin
        IsLocal:=false;
       end;
      end;
      ptCOMMA:begin
       PreprocessArgumentList(t^.Left);
       PreprocessArgumentList(t^.Right);
       exit;
      end;
      else begin
       IsLocal:=false;
       SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
      end;
     end;
     if CodeGenerator^.CountLocalArguments>=length(CodeGenerator^.LocalArguments) then begin
      if CodeGenerator^.CountLocalArguments=0 then begin
       SetLength(CodeGenerator^.LocalArguments,128);
      end else begin
       SetLength(CodeGenerator^.LocalArguments,CodeGenerator^.CountLocalArguments*2);
      end;
     end;
     if IsLocal then begin
      CodeGenerator^.LocalArguments[CodeGenerator^.CountLocalArguments]:=GetSymbolRegister(Symbol,true,IsConst);
     end else begin
      CodeGenerator^.LocalArguments[CodeGenerator^.CountLocalArguments]:=-1;
      CodeGenerator^.HasLocals:=true;
     end;
     inc(CodeGenerator^.CountLocalArguments);
    end;
   end;
   procedure GenerateArgumentList(t:PPOCAToken;Code:PPOCACode);
   begin
    if assigned(t) and (t^.Token<>ptEMPTY) then begin
     if not POCAIsValueIdentical(CodeGenerator^.RestArgSym,Instance^.Globals.ArgumentsValueReference) then begin
      SyntaxError('Remainder must be last',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
     end else begin
      case t^.Token of
       ptELLIPSIS:begin
        if (not assigned(t^.Left)) or (t^.Left^.Token<>ptSYMBOL) then begin
         SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end else begin
         CodeGenerator^.RestArgSym:=POCAInternSymbol(Parser.Context,Instance,POCANewString(Parser.Context,t^.Left^.Str));
        end;
       end;
       ptASSIGN:begin
        if assigned(t^.Left) and (t^.Left^.Token in [ptREGISTER,ptCONST]) then begin
         if (not assigned(t^.Left^.Right)) or (t^.Left^.Right^.Token<>ptSYMBOL) then begin
          SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end else begin
          if Code^.CountOptionalArguments>=CodeGenerator^.OptionalArgumentAllocated then begin
           CodeGenerator^.OptionalArgumentAllocated:=Code^.CountOptionalArguments*2;
           ReallocMem(CodeGenerator^.OptionalArgumentSymbols,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
           ReallocMem(CodeGenerator^.OptionalArgumentLocals,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
           ReallocMem(CodeGenerator^.OptionalArgumentValues,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
          end;
          CodeGenerator^.OptionalArgumentSymbols[Code^.CountOptionalArguments]:=FindConstantIndex(t^.Left^.Right);
          CodeGenerator^.OptionalArgumentLocals[Code^.CountOptionalArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
          CodeGenerator^.OptionalArgumentValues[Code^.CountOptionalArguments]:=DefineArgument(t^.Right);
          inc(Code^.CountOptionalArguments);
          Code^.HasArgumentLocals:=true;
         end;
        end else if assigned(t^.Left) and (t^.Left^.Token=ptVAR) then begin
         if (not assigned(t^.Left^.Right)) or (t^.Left^.Right^.Token<>ptSYMBOL) then begin
          SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end else begin
          if Code^.CountOptionalArguments>=CodeGenerator^.OptionalArgumentAllocated then begin
           CodeGenerator^.OptionalArgumentAllocated:=Code^.CountOptionalArguments*2;
           ReallocMem(CodeGenerator^.OptionalArgumentSymbols,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
           ReallocMem(CodeGenerator^.OptionalArgumentLocals,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
           ReallocMem(CodeGenerator^.OptionalArgumentValues,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
          end;
          CodeGenerator^.OptionalArgumentSymbols[Code^.CountOptionalArguments]:=FindConstantIndex(t^.Left^.Right);
          CodeGenerator^.OptionalArgumentLocals[Code^.CountOptionalArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
          CodeGenerator^.OptionalArgumentValues[Code^.CountOptionalArguments]:=DefineArgument(t^.Right);
          inc(Code^.CountOptionalArguments);
         end;
        end else begin
         if (not assigned(t^.Left)) or (t^.Left^.Token<>ptSYMBOL) then begin
          SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end else begin
          if Code^.CountOptionalArguments>=CodeGenerator^.OptionalArgumentAllocated then begin
           CodeGenerator^.OptionalArgumentAllocated:=Code^.CountOptionalArguments*2;
           ReallocMem(CodeGenerator^.OptionalArgumentSymbols,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
           ReallocMem(CodeGenerator^.OptionalArgumentLocals,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
           ReallocMem(CodeGenerator^.OptionalArgumentValues,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
          end;
          CodeGenerator^.OptionalArgumentSymbols[Code^.CountOptionalArguments]:=FindConstantIndex(t^.Left);
          CodeGenerator^.OptionalArgumentLocals[Code^.CountOptionalArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
          CodeGenerator^.OptionalArgumentValues[Code^.CountOptionalArguments]:=DefineArgument(t^.Right);
          inc(Code^.CountOptionalArguments);
         end;
        end;
       end;
       ptREGISTER,ptCONST:begin
        if Code^.CountOptionalArguments>0 then begin
         SyntaxError('Optional arguments must be last',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end else begin
         if (not assigned(t^.Right)) or (t^.Right^.Token<>ptSYMBOL) then begin
          SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end else begin
          if Code^.CountArguments>=CodeGenerator^.ArgAllocated then begin
           CodeGenerator^.ArgAllocated:=Code^.CountArguments*2;
           ReallocMem(CodeGenerator^.ArgumentSymbols,CodeGenerator^.ArgAllocated*sizeof(longint));
           ReallocMem(CodeGenerator^.ArgumentLocals,CodeGenerator^.ArgAllocated*sizeof(longint));
          end;
          CodeGenerator^.ArgumentSymbols[Code^.CountArguments]:=FindConstantIndex(t^.Right);
          CodeGenerator^.ArgumentLocals[Code^.CountArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
          inc(Code^.CountArguments);
          Code^.HasArgumentLocals:=true;
         end;
        end;
       end;
       ptVAR:begin
        if Code^.CountOptionalArguments>0 then begin
         SyntaxError('Optional arguments must be last',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end else begin
         if (not assigned(t^.Right)) or (t^.Right^.Token<>ptSYMBOL) then begin
          SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
         end else begin
          if Code^.CountArguments>=CodeGenerator^.ArgAllocated then begin
           CodeGenerator^.ArgAllocated:=Code^.CountArguments*2;
           ReallocMem(CodeGenerator^.ArgumentSymbols,CodeGenerator^.ArgAllocated*sizeof(longint));
           ReallocMem(CodeGenerator^.ArgumentLocals,CodeGenerator^.ArgAllocated*sizeof(longint));
          end;
          CodeGenerator^.ArgumentSymbols[Code^.CountArguments]:=FindConstantIndex(t^.Right);
          CodeGenerator^.ArgumentLocals[Code^.CountArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
          inc(Code^.CountArguments);
         end;
        end;
       end;
       ptSYMBOL:begin
        if Code^.CountOptionalArguments>0 then begin
         SyntaxError('Optional arguments must be last',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
        end else begin
         if Code^.CountArguments>=CodeGenerator^.ArgAllocated then begin
          CodeGenerator^.ArgAllocated:=Code^.CountArguments*2;
          ReallocMem(CodeGenerator^.ArgumentSymbols,CodeGenerator^.ArgAllocated*sizeof(longint));
          ReallocMem(CodeGenerator^.ArgumentLocals,CodeGenerator^.ArgAllocated*sizeof(longint));
         end;
         CodeGenerator^.ArgumentSymbols[Code^.CountArguments]:=FindConstantIndex(t);
         CodeGenerator^.ArgumentLocals[Code^.CountArguments]:=CodeGenerator^.LocalArguments[CodeGenerator^.LocalArgumentIndex];
         inc(Code^.CountArguments);
        end;
       end;
       ptCOMMA:begin
        GenerateArgumentList(t^.Left,Code);
        GenerateArgumentList(t^.Right,Code);
        exit;
       end;
       else begin
        SyntaxError('Bad function argument expression',t^.SourceFile,t^.SourceLine,t^.SourceColumn);
       end;
      end;
      inc(CodeGenerator^.LocalArgumentIndex);
     end;
    end;
   end;
  var Code:PPOCACode;
      i:longint;
      IsEmpty:longbool;
  begin
   New(CodeGenerator);
   try
    begin
     FillChar(CodeGenerator^,sizeof(TPOCACodeGenerator),#0);
     CodeGenerator^.ByteCodeAllocated:=1024;
     GetMem(CodeGenerator^.ByteCode,CodeGenerator^.ByteCodeAllocated*sizeof(longword));
     FillChar(CodeGenerator^.ByteCode^,CodeGenerator^.ByteCodeAllocated*sizeof(longword),#0);
     CodeGenerator^.HasLocals:=false;
     CodeGenerator^.FastFunction:=CodeToken=ptFASTFUNCTION;
     CodeGenerator^.Consts:=POCANewArray(Parser.Context);
     CodeGenerator^.SwitchTop:=0;
     CodeGenerator^.SwitchAllocated:=4;
     CodeGenerator^.Switchs:=nil;
     SetLength(CodeGenerator^.Switchs,CodeGenerator^.SwitchAllocated);
     CodeGenerator^.LoopTop:=0;
     CodeGenerator^.LoopAllocated:=4;
     CodeGenerator^.Loops:=nil;
     SetLength(CodeGenerator^.Loops,CodeGenerator^.LoopAllocated);
     CodeGenerator^.Scopes:=nil;
     CodeGenerator^.CountScopes:=0;
     CodeGenerator^.Registers:=nil;
     CodeGenerator^.CountRegisters:=0;
     CodeGenerator^.LocalArguments:=nil;
     CodeGenerator^.CountLocalArguments:=0;
     CodeGenerator^.LocalArgumentIndex:=0;
     CodeGenerator^.WhenSwitchCaseBlocks:=nil;
     CodeGenerator^.CountWhenSwitchCaseBlocks:=0;
     CodeGenerator^.BreakContinueScopes:=nil;
     CodeGenerator^.CountBreakContinueScopes:=0;
     CodeGenerator^.Opcodes:=nil;
     CodeGenerator^.CountOpcodes:=0;
     CodeGenerator^.Constants:=nil;
     CodeGenerator^.ConstantRegisters:=nil;
     CodeGenerator^.CountConstants:=0;
     CodeGenerator^.CountRegExps:=0;
    end;
    begin
     ScopeStart;
     ProcessConstantFolding(ArgumentList);
     PreprocessArgumentList(ArgumentList);                                 
     if assigned(Block) and not (((Block^.Token=ptEMPTY) and not (assigned(Block^.Left) or assigned(Block^.Right))) or ((Block^.Token=ptTOP) and ((not assigned(Block^.Left)) or (((Block^.Left^.Token=ptEMPTY) and not (assigned(Block^.Left^.Left) or assigned(Block^.Left^.Right))))))) then begin
      ProcessConstantFolding(Block);
      CollectConstants(Block);
      ScopeStart;
      i:=GenerateBlock(Block,-1,true,true);
      if CodeToken in [ptCLASSFUNCTION,ptMODULEFUNCTION] then begin
       EmitOpcode(popLOADLOCAL,i);
      end;
      EmitOpcode(popRETURN,i);
      IsEmpty:=false;
     end else begin
      i:=GetRegister(true,false);
      if CodeToken in [ptCLASSFUNCTION,ptMODULEFUNCTION] then begin
       EmitOpcode(popLOADLOCAL,i);
      end else begin
       EmitOpcode(popLOADNULL,i);
      end;
      EmitOpcode(popRETURN,i);
      FreeRegister(i);
      IsEmpty:=true;
     end;
     ScopeEnd;
    end;
    begin
     result:=POCANewCode(Parser.Context);
     Code:=POCAGetValueReferencePointer(result);
     begin
      CodeGenerator^.FastFunction:=(not (CodeToken in [ptCLASSFUNCTION,ptMODULEFUNCTION])) and (CodeGenerator^.FastFunction or not CodeGenerator^.HasLocals);
      Code^.Name:=CodeName;
      Code^.ClassFunction:=CodeToken=ptCLASSFUNCTION;
      Code^.FastFunction:=CodeGenerator^.FastFunction;
      Code^.IsEmpty:=IsEmpty;
      Code^.LocalsAsThisObj:=CodeToken in [ptCLASSFUNCTION,ptMODULEFUNCTION];
      Code^.CountRegisters:=CodeGenerator^.CountRegisters;
      CodeGenerator^.RestArgSym:=Instance^.Globals.ArgumentsValueReference;
      Code^.CountArguments:=0;
      Code^.CountOptionalArguments:=0;
      Code^.HasArgumentLocals:=false;
      Code^.ArgumentSymbols:=nil;
      Code^.ArgumentLocals:=nil;
      Code^.OptionalArgumentSymbols:=nil;
      Code^.OptionalArgumentLocals:=nil;
      Code^.OptionalArgumentValues:=nil;
      Code^.NeedArgumentArray:=true;
      if assigned(ArgumentList) then begin
       Code^.NeedArgumentArray:=false;
       CodeGenerator^.ArgAllocated:=1024;
       CodeGenerator^.OptionalArgumentAllocated:=1024;
       GetMem(CodeGenerator^.ArgumentSymbols,CodeGenerator^.ArgAllocated*sizeof(longint));
       GetMem(CodeGenerator^.ArgumentLocals,CodeGenerator^.ArgAllocated*sizeof(longint));
       GetMem(CodeGenerator^.OptionalArgumentSymbols,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
       GetMem(CodeGenerator^.OptionalArgumentLocals,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
       GetMem(CodeGenerator^.OptionalArgumentValues,CodeGenerator^.OptionalArgumentAllocated*sizeof(longint));
       GenerateArgumentList(ArgumentList,Code);
      end;
      Code^.RestArgSym:=InternConstant(CodeGenerator^.RestArgSym);
      begin
       Code^.SourceFile:=Parser.SourceFile;
       begin
        Code^.ConstantCount:=POCAArraySize(CodeGenerator^.Consts);
        GetMem(Code^.Constants,Code^.ConstantCount*sizeof(TPOCAValue));
        for i:=0 to Code^.ConstantCount-1 do begin
         Code^.Constants^[i]:=POCAArrayGet(CodeGenerator^.Consts,i);
        end;
       end;
       begin
        Code^.ByteCodeSize:=CodeGenerator^.ByteCodeSize;
        GetMem(Code^.ByteCode,Code^.ByteCodeSize*sizeof(longword));
        Move(CodeGenerator^.ByteCode^,Code^.ByteCode^,Code^.ByteCodeSize*sizeof(longword));
{$ifdef POCAHasJIT}
        begin
         SetLength(Code^.InterpretByteCodeMap,Code^.ByteCodeSize);
         for i:=0 to Code^.ByteCodeSize-1 do begin
          Code^.InterpretByteCodeMap[i]:=true;
         end;
        end;
{$Endif}
       end;
       begin
        Code^.CountRegExps:=CodeGenerator^.CountRegExps;
        if Code^.CountRegExps>0 then begin
         GetMem(Code^.RegExps,Code^.CountRegExps*sizeof(TPOCAValue));
         for i:=0 to Code^.CountRegExps-1 do begin
          Code^.RegExps^[i]:=POCAValueNull;
         end;
        end;
       end;
       begin
        if Code^.CountArguments>0 then begin
         GetMem(Code^.ArgumentSymbols,Code^.CountArguments*sizeof(longint));
         GetMem(Code^.ArgumentLocals,Code^.CountArguments*sizeof(longint));
         Move(CodeGenerator^.ArgumentSymbols^,Code^.ArgumentSymbols^,Code^.CountArguments*sizeof(longint));
         Move(CodeGenerator^.ArgumentLocals^,Code^.ArgumentLocals^,Code^.CountArguments*sizeof(longint));
        end;
        if Code^.CountOptionalArguments>0 then begin
         GetMem(Code^.OptionalArgumentSymbols,Code^.CountOptionalArguments*sizeof(longint));
         GetMem(Code^.OptionalArgumentLocals,Code^.CountOptionalArguments*sizeof(longint));
         GetMem(Code^.OptionalArgumentValues,Code^.CountOptionalArguments*sizeof(longint));
         Move(CodeGenerator^.OptionalArgumentSymbols^,Code^.OptionalArgumentSymbols^,Code^.CountOptionalArguments*sizeof(longint));
         Move(CodeGenerator^.OptionalArgumentLocals^,Code^.OptionalArgumentLocals^,Code^.CountOptionalArguments*sizeof(longint));
         Move(CodeGenerator^.OptionalArgumentValues^,Code^.OptionalArgumentValues^,Code^.CountOptionalArguments*sizeof(longint));
        end;
        Code^.Lines:=copy(CodeGenerator^.Lines,0,CodeGenerator^.LineCount);
       end;
      end;
      Code^.HasArguments:=(Code^.CountArguments+Code^.CountOptionalArguments)<>0;
     end;
    end;
   finally
    if assigned(CodeGenerator^.ByteCode) then begin
     FreeMem(CodeGenerator^.ByteCode);
     CodeGenerator^.ByteCode:=nil;
    end;
    if assigned(CodeGenerator^.ArgumentSymbols) then begin
     FreeMem(CodeGenerator^.ArgumentSymbols);
     CodeGenerator^.ArgumentSymbols:=nil;
    end;
    if assigned(CodeGenerator^.ArgumentLocals) then begin
     FreeMem(CodeGenerator^.ArgumentLocals);
     CodeGenerator^.ArgumentLocals:=nil;
    end;
    if assigned(CodeGenerator^.OptionalArgumentSymbols) then begin
     FreeMem(CodeGenerator^.OptionalArgumentSymbols);
     CodeGenerator^.OptionalArgumentSymbols:=nil;
    end;
    if assigned(CodeGenerator^.OptionalArgumentLocals) then begin
     FreeMem(CodeGenerator^.OptionalArgumentLocals);
     CodeGenerator^.OptionalArgumentLocals:=nil;
    end;
    if assigned(CodeGenerator^.OptionalArgumentValues) then begin
     FreeMem(CodeGenerator^.OptionalArgumentValues);
     CodeGenerator^.OptionalArgumentValues:=nil;
    end;
    SetLength(CodeGenerator^.Lines,0);
    for i:=0 to length(CodeGenerator^.Loops)-1 do begin
     SetLength(CodeGenerator^.Loops[i].BreakJumps,0);
     SetLength(CodeGenerator^.Loops[i].ContinueJumps,0);
    end;
    for i:=0 to length(CodeGenerator^.WhenSwitchCaseBlocks)-1 do begin
     SetLength(CodeGenerator^.WhenSwitchCaseBlocks[i].Fallthroughs,0);
    end;
    SetLength(CodeGenerator^.WhenSwitchCaseBlocks,0);
    SetLength(CodeGenerator^.BreakContinueScopes,0);
    for i:=0 to length(CodeGenerator^.Scopes)-1 do begin
     if assigned(CodeGenerator^.Scopes[i].SymbolRegisterHashMap) then begin
      FreeAndNil(CodeGenerator^.Scopes[i].SymbolRegisterHashMap);
     end;
    end;
    SetLength(CodeGenerator^.Scopes,0);
    SetLength(CodeGenerator^.Registers,0);
    SetLength(CodeGenerator^.LocalArguments,0);
    SetLength(CodeGenerator^.Opcodes,0);
    SetLength(CodeGenerator^.Constants,0);
    SetLength(CodeGenerator^.ConstantRegisters,0);
    Dispose(CodeGenerator);
   end;
  end;
 begin
  result:=GenerateCode(Parser,@Parser.Tree,nil,ptTOP,'');
 end;
 procedure FreeParser(var Parser:TPOCAParser);
 var CurrentToken,NextToken:PPOCAToken;
 begin
  CurrentToken:=TokenList;
  TokenList:=nil;
  while assigned(CurrentToken) do begin
   NextToken:=CurrentToken^.TokenListNext;
   CurrentToken^.Str:='';
   Dispose(CurrentToken);
   CurrentToken:=NextToken;
  end;
  Finalize(Parser);
  FillChar(Parser,sizeof(TPOCAParser),#0);
 end;
var Parser:TPOCAParser;
    i:longint;
    OldFPUExceptionMask:TFPUExceptionMask;
    OldFPURoundingMode:TFPURoundingMode;
    OldFPUPrecisionMode:TFPUPrecisionMode;
begin
 OldFPUExceptionMask:=GetExceptionMask;
 OldFPURoundingMode:=GetRoundMode;
 OldFPUPrecisionMode:=GetPrecisionMode;
 try
  if OldFPUExceptionMask<>FPUExceptionMask then begin
   SetExceptionMask(FPUExceptionMask);
  end;
  if OldFPURoundingMode<>FPURoundingMode then begin
   SetRoundMode(FPURoundingMode);
  end;
  if OldFPUPrecisionMode<>FPUPrecisionMode then begin
   SetPrecisionMode(FPUPrecisionMode);
  end;
  TokenList:=nil;
  FillChar(Parser,sizeof(TPOCAParser),#0);
  FillChar(PreprocessorInstance,SizeOf(TPOCAPreprocessorInstance),#0);
  try
   Parser.Context:=Context;
   Parser.SourceFile:=Instance^.SourceFiles.IndexOf(String(SourceFileName));
   if Parser.SourceFile<0 then begin
    Parser.SourceFile:=Instance^.SourceFiles.Add(String(SourceFileName));
    if Parser.SourceFile=longint(POCAArraySize(Context^.Instance.Globals.SourceFiles)) then begin
     POCAArrayPush(Context^.Instance.Globals.SourceFiles,POCANewString(Context,SourceFileName));
    end else begin
     POCAArraySetSize(Context^.Instance.Globals.SourceFiles,Instance^.SourceFiles.Count);
     for i:=0 to Instance^.SourceFiles.Count-1 do begin
      POCAArraySet(Context^.Instance.Globals.SourceFiles,i,POCANewString(Context,TPOCARawByteString(Instance^.SourceFiles[i])));
     end;
    end;
   end;
   Parser.Tree.Token:=ptTOP;
   begin
    PreprocessorInstance.Preprocessor.InputKind:=iskFILE;
    PreprocessorInstance.Preprocessor.InputName:=SourceFileName;
    PreprocessorInstance.Preprocessor.InputText:=Source;
    ProcessPreprocessor(PreprocessorInstance,Parser);
   end;
   ProcessLexer(Parser,PreprocessorInstance.Preprocessor.OutputText);
   ProcessTransformer(Parser);
   ProcessParser(Parser);
   result:=ProcessCodeGenerator(Parser);
   POCATemporarySave(Context,result);
  finally
   Finalize(PreprocessorInstance);
   FreeParser(Parser);
  end;
 finally
  if OldFPUExceptionMask<>FPUExceptionMask then begin
   SetExceptionMask(OldFPUExceptionMask);
  end;
  if OldFPURoundingMode<>FPURoundingMode then begin
   SetRoundMode(OldFPURoundingMode);
  end;
  if OldFPUPrecisionMode<>FPUPrecisionMode then begin
   SetPrecisionMode(OldFPUPrecisionMode);
  end;
 end;
end;

procedure POCASave(Context:PPOCAContext;Obj:TPOCAValue);
begin
 POCAArrayPush(Context^.Instance^.Globals.Save,Obj);
end;

function POCAStackDepth(Context:PPOCAContext):longint;
begin
 if assigned(Context) then begin
  result:=Context^.FrameTop+POCAStackDepth(Context^.CallChild);
 end else begin
  result:=0;
 end;
end;

function POCAFindFrame(Context:PPOCAContext;var OutContext:PPOCAContext;FrameNumber:longint):longint;
var StackDepth:longint;
begin
 if assigned(Context) then begin
  StackDepth:=POCAStackDepth(Context);
  if FrameNumber<StackDepth then begin
   result:=POCAFindFrame(Context^.CallChild,OutContext,FrameNumber);
  end else begin
   OutContext:=Context;
   result:=Context^.FrameTop-(1+(FrameNumber-StackDepth));
  end;
 end else begin
  result:=0;
 end;
end;

function POCAGetSourceLine(Context:PPOCAContext;FrameNumber:longint):longint;
var Frame:PPOCAFrame;
    Code:PPOCACode;
    i:longint;
begin
 result:=-1;
 FrameNumber:=POCAFindFrame(Context,Context,FrameNumber);
 if FrameNumber>=0 then begin
  Frame:=@Context^.FrameStack[FrameNumber];
  if assigned(Frame) and (POCAIsValueFunction(Frame^.Func) and POCAIsValueCode(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code)) then begin
   Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code));
   for i:=0 to length(Code^.Lines)-1 do begin
    if Code^.Lines[i].InstructionPointer>longword(Frame^.InstructionPointer) then begin
     break;
    end;
    result:=Code^.Lines[i].Line;
   end;
  end;
 end;
end;

function POCAGetSourceFile(Context:PPOCAContext;FrameNumber:longint):longint;
var Frame:PPOCAFrame;
    Code:PPOCACode;
begin
 result:=-1;
 FrameNumber:=POCAFindFrame(Context,Context,FrameNumber);
 if FrameNumber>=0 then begin
  Frame:=@Context^.FrameStack[FrameNumber];
  if assigned(Frame) and (POCAIsValueFunction(Frame^.Func) and POCAIsValueCode(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code)) then begin
   Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func))^.Code));
   result:=Code^.SourceFile;
  end;
 end;
end;

procedure POCARuntimeError(Context:PPOCAContext;const Msg:TPOCAUTF8String);
var StackDepth:longint;
begin
 StackDepth:=POCAStackDepth(Context);
 raise EPOCARuntimeError.Create(POCAGetSourceFile(Context,StackDepth),POCAGetSourceLine(Context,StackDepth),-1,Msg);
end;

function POCAGetMember(Context:PPOCAContext;const Obj,Field:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:longword;const IsInherited,Throw:boolean):boolean;
var p:TPOCAValue;
    Ghost:PPOCAGhost;
    PropertyIndex:longint;
begin
 case POCAGetValueType(Obj) of
  pvtARRAY:begin
   result:=POCAHashGetCache(Context,Context.Instance^.Globals.ArrayHash,Field,OutValue,CacheIndex);
   if (not result) and Throw then begin
    POCARuntimeError(Context,'No such member: '+POCAGetStringValue(Context,Field));
   end;
  end;
  pvtNUMBER:begin
   result:=POCAHashGetCache(Context,Context.Instance^.Globals.NumberHash,Field,OutValue,CacheIndex);
   if (not result) and Throw then begin
    POCARuntimeError(Context,'No such member: '+POCAGetStringValue(Context,Field));
   end;
  end;
  pvtSTRING:begin
   result:=POCAHashGetCache(Context,Context.Instance^.Globals.StringHash,Field,OutValue,CacheIndex);
   if (not result) and Throw then begin
    POCARuntimeError(Context,'No such member: '+POCAGetStringValue(Context,Field));
   end;
  end;
  pvtHASH:begin
   result:=false;
   if IsInherited then begin
    if POCAHashGetInheritedCache(Context,Obj,Field,OutValue,CacheIndex) then begin
     result:=true;
     exit;
    end;
   end else begin
    if POCAHashGetCache(Context,Obj,Field,OutValue,CacheIndex) then begin
     result:=true;
     exit;
    end;
   end;
   if Throw then begin
    POCARuntimeError(Context,'No such member: '+POCAGetStringValue(Context,Field));
   end;
   exit;
  end;
  pvtGHOST:begin
   Ghost:=POCAGetValueReferencePointer(Obj);
   if (Ghost^.PtrType=pgptOBJECT) and assigned(Ghost^.Ptr) and (TObject(Ghost^.Ptr) is TPOCANativeObject) then begin
    PropertyIndex:=TPOCANativeObject(Ghost^.Ptr).FindPropertyIndex(Context,Field,@CacheIndex);
    if (PropertyIndex>=0) and TPOCANativeObject(Ghost^.Ptr).GetPropertyValue(Context,PropertyIndex,OutValue) then begin
     result:=true;
     exit;
    end;
   end;
   p:=POCAGhostGetHashValue(Obj);
   if POCAIsValueHash(p) then begin
    result:=POCAGetMember(Context,p,Field,OutValue,CacheIndex,false,Throw);
{   if not result then begin
     p:=POCAHashGetPrototypeValue(p);
     if POCAIsValueHash(p) and assigned(POCAHashGetGhost(p)) then begin
      p:=POCAHashGetGhostValue(p);
     end;
     if POCAIsValueHash(p) or POCAIsValueGhost(p) then begin
      result:=POCAGetMember(Context,p,Field,OutValue,CacheIndex,false,Throw);
     end;
    end;{}
   end else begin
    result:=false;
   end;
   if (not result) and Throw then begin
    POCARuntimeError(Context,'No such member: '+POCAGetStringValue(Context,Field));
   end;
  end;
  pvtNULL:begin
   result:=false;
   if Throw then begin
    POCARuntimeError(Context,'Non-null object expected');
   end;
  end;
  else begin
   result:=false;
   if Throw then begin
    POCARuntimeError(Context,'Non-objects have no members');
   end;
  end;
 end;
end;

function POCASetMember(Context:PPOCAContext;const Obj,Field,Value:TPOCAValue;var CacheIndex:longword;Throw:boolean):boolean;
var p:TPOCAValue;
    Ghost:PPOCAGhost;
    PropertyIndex:longint;
begin
 case POCAGetValueType(Obj) of
  pvtHASH:begin
   result:=POCAHashSetCache(Context,Obj,Field,Value,CacheIndex);
  end;
  pvtGHOST:begin
   Ghost:=POCAGetValueReferencePointer(Obj);
   if (Ghost^.PtrType=pgptOBJECT) and assigned(Ghost^.Ptr) and (TObject(Ghost^.Ptr) is TPOCANativeObject) then begin
    PropertyIndex:=TPOCANativeObject(Ghost^.Ptr).FindPropertyIndex(Context,Field,@CacheIndex);
    if (PropertyIndex>=0) and TPOCANativeObject(Ghost^.Ptr).SetPropertyValue(Context,PropertyIndex,Value) then begin
     result:=true;
     exit;
    end;
    if not TPOCANativeObject(Ghost^.Ptr).fExpandable then begin
     POCARuntimeError(Context,'Expandable-write-access to a non-expandable native object isn''t allowed');
    end;
   end;
   p:=POCAGhostGetHashValue(Obj);
   if POCAIsValueHash(p) then begin
    result:=POCASetMember(Context,p,Field,Value,CacheIndex,Throw);
{   if not result then begin
     p:=POCAHashGetPrototypeValue(p);
     if POCAIsValueHash(p) and assigned(POCAHashGetGhost(p)) then begin
      p:=POCAHashGetGhostValue(p);
     end;
     if POCAIsValueHash(p) or POCAIsValueGhost(p) then begin
      result:=POCASetMember(Context,p,Field,Value,CacheIndex,Throw);
     end;
    end;{}
   end else begin
    result:=false;
   end;
   if (not result) and Throw then begin
    POCARuntimeError(Context,'Error at setting member: '+POCAGetStringValue(Context,Field));
   end;
  end;
  else begin
   result:=false;
   if Throw then begin
    POCARuntimeError(Context,'Non-objects have no members');
   end;
  end;
 end;
end;

function POCABindClassFunction(Context:PPOCAContext;Frame:PPOCAFrame;const Code:TPOCAValue):TPOCAValue;
var Func:PPOCAFunction;
begin
 result:=POCANewFunction(Context,Code);
 Func:=PPOCAFunction(POCAGetValueReferencePointer(result));
 Func^.Namespace:=POCAValueNull;
 Func^.Obj:=Frame^.Obj;
 Func^.Next:=Frame^.Func;
end;

function POCABindFunction(Context:PPOCAContext;Frame:PPOCAFrame;const Code:TPOCAValue):TPOCAValue;
var Func:PPOCAFunction;
begin
 result:=POCANewFunction(Context,Code);
 Func:=PPOCAFunction(POCAGetValueReferencePointer(result));
 Func^.Namespace:=Frame^.Locals;
 Func^.Obj:=Frame^.Obj;
 Func^.Next:=Frame^.Func;
end;

function POCABindToContext(Context:PPOCAContext;Code:TPOCAValue):TPOCAValue;
var Frame:PPOCAFrame;
    Func:PPOCAFunction;
begin
 result:=POCANewFunction(Context,Code);
 if Context^.FrameTop<>0 then begin
  Frame:=@Context^.FrameStack[Context^.FrameTop-1];
  Func:=PPOCAFunction(POCAGetValueReferencePointer(result));
  Func^.Namespace:=Frame^.Locals;
  Func^.Obj:=Frame^.Obj;
  Func^.Next:=Frame^.Func;
 end;
end;

procedure POCASetupArguments(Context:PPOCAContext;Frame:PPOCAFrame;Code:PPOCACode;Args:PPOCAValues;CountArguments:longint;ArgIndices:PLongwords=nil);
var i,j:longint;
    Hash:PPOCAHash;
    Value,Arguments:TPOCAValue;
    ArrayRecord:PPOCAArrayRecord;
begin
 if CountArguments<longint(Code^.CountArguments) then begin
  POCARuntimeError(Context,'Too few function arguments (we have '+TPOCARawByteString(IntToStr(CountArguments))+' but we do need '+TPOCARawByteString(IntToStr(Code^.CountArguments))+')');
 end else begin
  Hash:=PPOCAHash(POCAGetValueReferencePointer(Frame^.Locals));
  j:=0;
  for i:=0 to Code^.CountArguments-1 do begin
   if assigned(ArgIndices) then begin
    Value:=Args^[ArgIndices^[i]];
   end else begin
    Value:=Args^[i];
   end;
   if POCAIsValueCode(Value) then begin
    Value:=POCABindFunction(Context,Frame,Value);
   end;
   if Code^.ArgumentLocals[i]<0 then begin
    if assigned(Hash) then begin
     if assigned(Hash^.Events) then begin
      POCAHashSet(Context,Frame^.Locals,Code^.Constants[Code^.ArgumentSymbols[i]],Value);
     end else begin
      POCAHashNewSymbol(Context^.Instance,Hash,Code^.Constants[Code^.ArgumentSymbols[i]],Value);
     end;
    end else begin
     POCARuntimeError(Context,'Function has no locals');
    end;
   end else begin
    Frame^.Registers[Code^.ArgumentLocals[i]]:=Value;
   end;
  end;
  inc(j,Code^.CountArguments);
  dec(CountArguments,Code^.CountArguments);
  for i:=0 to Code^.CountOptionalArguments-1 do begin
   if CountArguments>0 then begin
    if assigned(ArgIndices) then begin
     Value:=Args^[ArgIndices^[i+j]];
    end else begin
     Value:=Args^[i+j];
    end;
   end else begin
    Value:=Code^.Constants[Code^.OptionalArgumentValues[i]];
   end;
   if POCAIsValueCode(Value) then begin
    Value:=POCABindFunction(Context,Frame,Value);
   end;
   if Code^.OptionalArgumentLocals[i]<0 then begin
    if assigned(Hash) then begin
     if assigned(Hash^.Events) then begin
      POCAHashSet(Context,Frame^.Locals,Code^.Constants[Code^.OptionalArgumentSymbols[i]],Value);
     end else begin
      POCAHashNewSymbol(Context^.Instance,Hash,Code^.Constants[Code^.OptionalArgumentSymbols[i]],Value);
     end;
    end else begin
     POCARuntimeError(Context,'Function has no locals');
    end;
   end else begin
    Frame^.Registers[Code^.OptionalArgumentLocals[i]]:=Value;
   end;
   dec(CountArguments);
  end;
  inc(j,Code^.CountOptionalArguments);
  if Code^.NeedArgumentArray or (CountArguments>0) then begin
   Arguments:=POCANewArray(Context);
   if CountArguments<=0 then begin
    CountArguments:=0;
   end;
   POCAArraySetSize(Arguments,CountArguments);
   if CountArguments>0 then begin
    ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(Arguments))^.ArrayRecord;
    for i:=0 to CountArguments-1 do begin
     if assigned(ArgIndices) then begin
      Value:=Args^[ArgIndices^[i+j]];
     end else begin
      Value:=Args^[i+j];
     end;
     if POCAIsValueCode(Value) then begin
      Value:=POCABindFunction(Context,Frame,Value);
     end;
     ArrayRecord^.Data[i]:=Value;
    end;
   end;
   if assigned(Hash) then begin
    if assigned(Hash^.Events) then begin
     POCAHashSet(Context,Frame^.Locals,Code^.Constants[Code^.RestArgSym],Arguments);
    end else begin
     POCAHashNewSymbol(Context^.Instance,Hash,Code^.Constants[Code^.RestArgSym],Arguments);
    end;
   end else begin
    POCARuntimeError(Context,'Function has no locals');
   end;
  end;
 end;
end;

procedure POCACheckNamedArguments(Context:PPOCAContext;Code:PPOCACode;Hash:PPOCAHash;const HashValue:TPOCAValue);
var i:longint;
    Sym,Value:TPOCAValue;
begin
 Value:=POCAValueNull;
 for i:=0 to Code^.CountArguments-1 do begin
  Sym:=Code^.Constants[Code^.ArgumentSymbols[i]];
  if assigned(Hash^.Events) then begin
   if not POCAHashGet(Context,HashValue,Sym,Value) then begin
    POCARuntimeError(Context,'Missing argument "'+PPOCAString(POCAGetValueReferencePointer(Sym))^.Data+'"');
    exit;
   end;
  end else begin
   if not POCAHashSymbol(Hash,PPOCAString(POCAGetValueReferencePointer(Sym)),Value) then begin
    POCARuntimeError(Context,'Missing argument "'+PPOCAString(POCAGetValueReferencePointer(Sym))^.Data+'"');
    exit;
   end;
  end;
 end;
 for i:=0 to Code^.CountOptionalArguments-1 do begin
  Sym:=Code^.Constants[Code^.OptionalArgumentSymbols[i]];
  if assigned(Hash^.Events) then begin
   if not POCAHashGet(Context,HashValue,Sym,Value) then begin
    POCAHashSet(Context,HashValue,Sym,Code^.Constants[Code^.OptionalArgumentValues[i]]);
   end;
  end else begin
   if not POCAHashSymbol(Hash,PPOCAString(POCAGetValueReferencePointer(Sym)),Value) then begin
    POCAHashNewSymbol(Context^.Instance,Hash,Sym,Code^.Constants[Code^.OptionalArgumentValues[i]]);
   end;
  end;
 end;
 if Code^.NeedArgumentArray then begin
  Sym:=Code^.Constants[Code^.RestArgSym];
  if assigned(Hash^.Events) then begin
   if not POCAHashGet(Context,HashValue,Sym,Value) then begin
    POCAHashSet(Context,HashValue,Sym,POCANewArray(Context));
   end;
  end else begin
   if not POCAHashSymbol(Hash,PPOCAString(POCAGetValueReferencePointer(Sym)),Value) then begin
    POCAHashNewSymbol(Context^.Instance,Hash,Sym,POCANewArray(Context));
   end;
  end;
 end;
end;

procedure POCASetupNamedArgumentsWithLocals(Context:PPOCAContext;Frame:PPOCAFrame;Code:PPOCACode;const Hash,Locals:TPOCAValue);
var i:longint;
    Sym,Value:TPOCAValue;
begin
 Value:=POCAValueNull;
 for i:=0 to Code^.CountArguments-1 do begin
  Sym:=Code^.Constants[Code^.ArgumentSymbols[i]];
  if POCAHashGet(Context,Hash,Sym,Value) then begin
   if Code^.ArgumentLocals[i]<0 then begin
    if POCAIsValueHash(Locals) then begin
     POCAHashSet(Context,Locals,Sym,Value);
    end else begin
     POCARuntimeError(Context,'Function has no locals');
    end;
   end else begin
    Frame^.Registers[Code^.ArgumentLocals[i]]:=Value;
   end;
  end else begin
   POCARuntimeError(Context,'Missing argument "'+PPOCAString(POCAGetValueReferencePointer(Sym))^.Data+'"');
   exit;
  end;
 end;
 for i:=0 to Code^.CountOptionalArguments-1 do begin
  Sym:=Code^.Constants[Code^.OptionalArgumentSymbols[i]];
  if not POCAHashGet(Context,Hash,Sym,Value) then begin
   Value:=Code^.Constants[Code^.OptionalArgumentValues[i]];
  end;
  if Code^.OptionalArgumentLocals[i]<0 then begin
   if POCAIsValueHash(Locals) then begin
    POCAHashSet(Context,Locals,Sym,Value);
   end else begin
    POCARuntimeError(Context,'Function has no locals');
   end;
  end else begin
   Frame^.Registers[Code^.OptionalArgumentLocals[i]]:=Value;
  end;
 end;
 if Code^.NeedArgumentArray then begin
  Sym:=Code^.Constants[Code^.RestArgSym];
  if not POCAHashGet(Context,Hash,Sym,Value) then begin
   Value:=POCANewArray(Context);
  end;
  if POCAIsValueHash(Locals) then begin
   POCAHashSet(Context,Locals,Sym,Value);
  end else begin
   POCARuntimeError(Context,'Function has no locals');
  end;
 end;
end;

procedure POCASetupRegisters(Frame:PPOCAFrame;Code:PPOCACode);
var i:longint;
begin
 Frame^.CountRegisters:=Code^.CountRegisters;
 if Frame^.CountRegisters>0 then begin
  if length(Frame^.Registers)<longint(Frame^.CountRegisters) then begin
   SetLength(Frame^.Registers,POCARoundUpToPowerOfTwo(Frame^.CountRegisters+1));
  end;
  for i:=0 to Frame^.CountRegisters-1 do begin
   Frame^.Registers[i]:=POCAValueNull;
  end;
 end;
end;

function POCASetupFunctionCall(Context:PPOCAContext;Frame:PPOCAFrame;Opcode:longword;Operands:PLongwords;MethodCall,Named:boolean;TheFunc:PPOCAValue=nil):PPOCAFrame;
var Func,Obj,Code:TPOCAValue;
    i,CountArguments,ArgumentIndex:longint;
    ObjPtr:PPOCAObject;
begin
 Obj:=POCAValueNull;

 CountArguments:=Opcode shr 8;

 Frame^.ResultRegister:=Operands^[0];

 if MethodCall then begin
  Obj:=Frame^.Registers[Operands^[1]];
  Func:=Frame^.Registers[Operands^[2]];
  dec(CountArguments,3);
  ArgumentIndex:=3;
 end else begin
  if assigned(TheFunc) then begin
   Func:=TheFunc^;
   dec(CountArguments);
   ArgumentIndex:=1;
  end else begin
   Func:=Frame^.Registers[Operands^[1]];
   dec(CountArguments,2);
   ArgumentIndex:=2;
  end;
 end;

 ObjPtr:=nil;
 repeat
  if {$ifdef cpu64}((UInt64(pointer(@Func.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and assigned(pointer(TPOCAPtrUInt(Func.Reference.Ptr) and POCAValueReferenceMask)){$else}(Func.ReferenceTag=POCAValueReferenceTag) and assigned(Func.Reference.Ptr){$endif} then begin
   ObjPtr:={$ifdef cpu64}pointer(TPOCAPtrUInt(Func.Reference.Ptr) and POCAValueReferenceMask){$else}Func.Reference.Ptr{$endif};
   case ObjPtr^.Header.ValueType of
    pvtFUNCTION:begin
     if not MethodCall then begin
      Obj:=PPOCAFunction(ObjPtr)^.Obj;
     end;
     break;
    end;
    pvtHASH:begin
     if assigned(PPOCAHash(ObjPtr)^.Events) and assigned(PPOCAHash(ObjPtr)^.Events^.HashRecord^.Events) then begin
      if POCAIsValueNull(Obj) then begin
       Obj:=Func;
      end;
      Func:=PPOCAHash(ObjPtr)^.Events^.HashRecord^.Events^[pmoCALL];
      if {$ifdef cpu64}((UInt64(pointer(@Func.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and assigned(pointer(TPOCAPtrUInt(Func.Reference.Ptr) and POCAValueReferenceMask)){$else}(Func.ReferenceTag=POCAValueReferenceTag) and assigned(Func.Reference.Ptr){$endif} then begin
       ObjPtr:={$ifdef cpu64}pointer(TPOCAPtrUInt(Func.Reference.Ptr) and POCAValueReferenceMask){$else}Func.Reference.Ptr{$endif};
       if ObjPtr^.Header.ValueType=pvtFUNCTION then begin
        break;
       end;
      end;
     end;
    end;
   end;
  end;
  if not MethodCall then begin
   POCARuntimeError(Context,'Method call on uncallable object');
  end else begin
   POCARuntimeError(Context,'Function call on uncallable object');
  end;
  break;
 until false;

 Code:=PPOCAFunction(ObjPtr)^.Code;

 if {$ifdef cpu64}((UInt64(pointer(@Code.Num)^) and POCAValueReferenceSignalMask)=POCAValueReferenceSignalMask) and assigned(pointer(TPOCAPtrUInt(Code.Reference.Ptr) and POCAValueReferenceMask)){$else}(Code.ReferenceTag=POCAValueReferenceTag) and assigned(Code.Reference.Ptr){$endif} then begin
  ObjPtr:={$ifdef cpu64}pointer(TPOCAPtrUInt(Code.Reference.Ptr) and POCAValueReferenceMask){$else}Code.Reference.Ptr{$endif};
  case ObjPtr^.Header.ValueType of
   pvtNATIVECODE:begin
    if CountArguments>length(Frame^.Arguments) then begin
     SetLength(Frame^.Arguments,CountArguments);
    end;
    for i:=0 to CountArguments-1 do begin
     Frame^.Arguments[i]:=Frame^.Registers[Operands^[i+ArgumentIndex]];
    end;
    Frame^.CountArguments:=CountArguments;
    if Named then begin
     POCARuntimeError(Context,'Native functions have no named arguments');
    end;
    if assigned(PPOCANativeCode(ObjPtr)^.UserData) then begin
     Frame^.Registers[Frame^.ResultRegister]:=PPOCANativeCode(ObjPtr)^.FunctionPointer(Context,Obj,@Frame^.Arguments[0],Frame^.CountArguments,PPOCANativeCode(ObjPtr)^.UserData);
    end else begin
     Frame^.Registers[Frame^.ResultRegister]:=PPOCANativeCode(ObjPtr)^.FunctionPointer(Context,Obj,@Frame^.Arguments[0],Frame^.CountArguments,PPOCANativeCode(ObjPtr)^.UserData);
    end;
    Frame^.CountArguments:=0;
    result:=@Context.FrameStack[Context.FrameTop-1];
    exit;
   end;
   pvtCODE:begin
    if Context^.FrameTop>=POCA_MAX_RECURSION then begin
     POCARuntimeError(Context,'Call frame overflow');
    end;

{$ifdef POCAHasJIT}
    if not assigned(PPOCACode(ObjPtr)^.NativeCode) then begin
     POCAGenerateNativeCode(Context,PPOCACode(ObjPtr));
    end;
{$endif}

    result:=@Context^.FrameStack[Context^.FrameTop];
    if Named and not PPOCACode(ObjPtr)^.HasArgumentLocals then begin
     result^.Locals:=Frame^.Registers[Operands^[ArgumentIndex]];
     inc(ArgumentIndex);
     dec(CountArguments);
    end else begin
     if PPOCACode(ObjPtr)^.FastFunction then begin
      result^.Locals:=POCAValueNull;
     end else begin
      result^.Locals:=POCANewHash(Context);
     end;
    end;
    result^.Func:=Func;
    result^.InstructionPointer:=0;
    if PPOCACode(ObjPtr)^.LocalsAsThisObj then begin
     result^.Obj:=result^.Locals;
    end else begin
     result^.Obj:=Obj;
    end;

    if PPOCACode(ObjPtr)^.HasArguments or not PPOCACode(ObjPtr)^.IsEmpty then begin
     POCASetupRegisters(result,PPOCACode(ObjPtr));

     if PPOCACode(ObjPtr)^.HasArguments then begin
      if Named then begin
       if PPOCACode(ObjPtr)^.HasArgumentLocals then begin
        POCASetupNamedArgumentsWithLocals(Context,result,PPOCACode(ObjPtr),Frame^.Registers[Operands^[ArgumentIndex]],result^.Locals);
       end else begin
        POCACheckNamedArguments(Context,PPOCACode(ObjPtr),PPOCAHash(POCAGetValueReferencePointer(result^.Locals)),result^.Locals);
       end;
      end else begin
       POCASetupArguments(Context,result,PPOCACode(ObjPtr),@Frame^.Registers[0],CountArguments,@Operands^[ArgumentIndex]);
      end;
     end;
    end;

    if PPOCACode(ObjPtr)^.IsEmpty then begin
     Frame^.Registers[Frame^.ResultRegister]:=POCAValueNull;
     Frame^.CountArguments:=0;
     result:=@Context.FrameStack[Context.FrameTop-1];
    end else begin
     inc(Context^.FrameTop);
    end;
    exit;
   end;
  end;
 end;

 Frame^.Registers[Frame^.ResultRegister]:=POCAValueNull;
 Frame^.CountArguments:=0;
 result:=@Context.FrameStack[Context.FrameTop-1];
end;

procedure POCARunStackOverflow(Context:PPOCAContext);
begin
 POCARuntimeError(Context,'Stack overflow');
end;

function POCARunEvalCat(Context:PPOCAContext;const l,r:TPOCAValue):TPOCAValue;
var i,ls,rs:longint;
begin
 if POCAIsValueArray(l) and POCAIsValueArray(r) then begin
  ls:=POCAArraySize(l);
  rs:=POCAArraySize(r);
  result:=POCANewArray(Context);
  POCAArraySetSize(result,ls+rs);
  for i:=0 to ls-1 do begin
   POCAArraySet(result,i,POCAArrayGet(l,i));
  end;
  for i:=0 to rs-1 do begin
   POCAArraySet(result,i+ls,POCAArrayGet(r,i));
  end;
 end else if POCAIsValueHash(l) and POCAIsValueHash(r) then begin
  result:=POCANewHash(Context);
  POCAHashCombine(Context,result,l);
  POCAHashCombine(Context,result,r);
 end else if POCAIsValueString(l) and POCAIsValueString(r) then begin
  result:=POCANewString(Context,'');
  if PPOCAString(POCAGetValueReferencePointer(l))^.UTF8<>suNOUTF8 then begin
   case PPOCAString(POCAGetValueReferencePointer(r))^.UTF8 of
    suPOSSIBLEUTF8:begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PPOCAString(POCAGetValueReferencePointer(l))^.Data+PPOCAString(POCAGetValueReferencePointer(r))^.Data;
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=PPOCAString(POCAGetValueReferencePointer(l))^.UTF8;
    end;
    suISUTF8:begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PPOCAString(POCAGetValueReferencePointer(l))^.Data+PPOCAString(POCAGetValueReferencePointer(r))^.Data;
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suISUTF8;
    end;
    else begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PPOCAString(POCAGetValueReferencePointer(l))^.Data+PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(r))^.Data);
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suISUTF8;
    end;
   end;
  end else begin
   case PPOCAString(POCAGetValueReferencePointer(r))^.UTF8 of
    suPOSSIBLEUTF8:begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(l))^.Data)+PPOCAString(POCAGetValueReferencePointer(r))^.Data;
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suISUTF8;
    end;
    suISUTF8:begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(l))^.Data)+PPOCAString(POCAGetValueReferencePointer(r))^.Data;
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suISUTF8;
    end;
    else begin
     PPOCAString(POCAGetValueReferencePointer(result))^.Data:=PPOCAString(POCAGetValueReferencePointer(l))^.Data+PPOCAString(POCAGetValueReferencePointer(r))^.Data;
     PPOCAString(POCAGetValueReferencePointer(result))^.UTF8:=suNOUTF8;
    end;
   end;
  end;
  PPOCAString(POCAGetValueReferencePointer(result))^.DataLength:=length(PPOCAString(POCAGetValueReferencePointer(result))^.Data);
  PPOCAString(POCAGetValueReferencePointer(result))^.UTF8Length:=PPOCAString(POCAGetValueReferencePointer(l))^.UTF8Length+PPOCAString(POCAGetValueReferencePointer(r))^.UTF8Length;
  PPOCAString(POCAGetValueReferencePointer(result))^.HashCode:=0;
  if PPOCAString(POCAGetValueReferencePointer(result))^.UTF8=suISUTF8 then begin
   PPOCAString(POCAGetValueReferencePointer(result))^.Dirty:=true;
   POCAStringUpdate(Context,result);
  end;
 end else begin
  result:=POCANewString(Context,POCAGetStringValue(Context,l)+POCAGetStringValue(Context,r));
 end;
end;

procedure POCARunGetLocalError(Context:PPOCAContext;const Sym:TPOCAValue);
begin
 POCARuntimeError(Context,'Undefined symbol: '+POCAGetStringValue(Context,Sym));
end;

procedure POCARunGetLocal(Context:PPOCAContext;Frame:PPOCAFrame;const Sym:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:longword);
var Func:PPOCAFunction;
begin
 // Optimized search
 repeat
  // 1. Function frame locals
  case POCAHashSymbolCache(PPOCAHash(POCAGetValueReferencePointer(Frame^.Locals)),Sym,OutValue,CacheIndex) of
   1:begin
    exit;
   end;
   2:begin
    break;
   end;
  end;

  // 2. Outer closure name spaces
  Func:=PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func));
  while assigned(Func) do begin
   case POCAHashSymbolCache(PPOCAHash(POCAGetValueReferencePointer(Func^.Namespace)),Sym,OutValue,CacheIndex) of
    1:begin
     exit;
    end;
    2:begin
     break;
    end;
   end;
   Func:=PPOCAFunction(POCAGetValueReferencePointer(Func^.Next));
  end;

  break;
 until false;

 // Full search
 begin
  // 1. Function frame locals
  if POCAHashGet(Context,Frame^.Locals,Sym,OutValue) then begin
   exit;
  end;
 end;
 begin
  // 2. Outer closure name spaces
  Func:=PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func));
  while assigned(Func) do begin
   if POCAHashGet(Context,Func^.Namespace,Sym,OutValue) then begin
    exit;
   end;
   Func:=PPOCAFunction(POCAGetValueReferencePointer(Func^.Next));
  end;
 end;

 POCARunGetLocalError(Context,Sym);
end;

procedure POCARunSetSymbol(Context:PPOCAContext;Frame:PPOCAFrame;const Sym,Value:TPOCAValue;var CacheIndex:longword);
var Func:PPOCAFunction;
begin
 begin
  // 1. Function frame locals "if exist"
  if POCAHashTrySetCache(Context,Frame^.Locals,Sym,Value,CacheIndex) then begin
   exit;
  end;
 end;
 begin
  // 2. Outer closure name spaces
  Func:=PPOCAFunction(POCAGetValueReferencePointer(Frame^.Func));
  while assigned(Func) do begin
   if POCAHashTrySetCache(Context,Func^.Namespace,Sym,Value,CacheIndex) then begin
    exit;
   end;
   Func:=PPOCAFunction(POCAGetValueReferencePointer(Func.Next));
  end;
 end;
 begin
  if POCAIsValueHash(Frame^.Locals) then begin
   // 3. Function frame locals with creation, because symbol isn't existing already
   POCAHashSetCache(Context,Frame^.Locals,Sym,Value,CacheIndex);
  end else begin
   POCARuntimeError(Context,'Could not define symbol: '+POCAGetStringValue(Context,Sym));
  end;
 end;
end;

procedure POCARunGetMember(Context:PPOCAContext;const Obj,Fld:TPOCAValue;var OutValue:TPOCAValue;var CacheIndex:longword;const IsInherited:boolean); {$ifdef caninline}inline;{$endif}
begin
 POCAGetMember(Context,Obj,Fld,OutValue,CacheIndex,IsInherited,true);
end;

procedure POCARunSetMember(Context:PPOCAContext;const Obj,Fld,Value:TPOCAValue;var CacheIndex:longword); {$ifdef caninline}inline;{$endif}
begin
 POCASetMember(Context,Obj,Fld,Value,CacheIndex,true);
end;

procedure POCARunGetThat(Context:PPOCAContext;const Frame:PPOCAFrame;out Value:TPOCAValue); {$ifdef caninline}inline;{$endif}
var Func:PPOCAFunction;
begin
 if POCAIsValueFunction(Frame^.Func) then begin
  Func:=POCAGetValueReferencePointer(Frame^.Func);
  Value:=Func^.Obj;
 end else begin
  Value:=POCAValueNull;
 end;
end;

function POCARunCheckArray(Context:PPOCAContext;const r,Index:TPOCAValue):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=trunc(POCAGetNumberValue(Context,Index));
 if result<0 then begin
  inc(result,POCAArraySize(r));
 end;
 if (result<0) or (result>=longint(POCAArraySize(r))) then begin
  POCARuntimeError(Context,'Array index '+TPOCARawByteString(IntToStr(result))+' is out of bounds with size '+TPOCARawByteString(IntToStr(POCAArraySize(r))));
 end;
end;

function POCARunCheckString(Context:PPOCAContext;const r,Index:TPOCAValue):longint;
var s:TPOCARawByteString;
begin
 s:=POCAGetStringValue(Context,r);
 try
  result:=trunc(POCAGetNumberValue(Context,Index));
  if result<0 then begin
   inc(result,length(s));
  end;
  if (result<0) or (result>=length(s)) then begin
   POCARuntimeError(Context,'String index '+TPOCARawByteString(IntToStr(result))+' is out of bounds with size '+TPOCARawByteString(IntToStr(length(s))));
  end;
 finally
  s:='';
 end;
end;

function POCARunCheckStringUTF8(Context:PPOCAContext;const r,Index:TPOCAValue):longint;
var l:longint;
begin
 l:=POCAGetStringUTF8Length(Context,r);
 try
  result:=trunc(POCAGetNumberValue(Context,Index));
  if result<0 then begin
   inc(result,l);
  end;
  if (result<0) or (result>=l) then begin
   POCARuntimeError(Context,'String index '+TPOCARawByteString(IntToStr(result))+' is out of bounds with size '+TPOCARawByteString(IntToStr(l)));
  end;
 finally
 end;
end;

function POCARunContainerGet(Context:PPOCAContext;const Box,Key:TPOCAValue):TPOCAValue;
var CodePoint,CodeUnit:longint;
begin
 result:=POCAValueNull;
 if not POCAIsValueScalarType(Key) then begin
  POCARuntimeError(Context,'Container index not scalar');
 end else begin
  case POCAGetValueType(Box) of
   pvtNUMBER:begin
    if not POCAHashGet(Context,Context.Instance^.Globals.NumberHash,Key,result) then begin
     POCARuntimeError(Context,'No such key member: '+POCAGetStringValue(Context,Key));
    end;
   end;
   pvtHASH:begin
    if not POCAHashGet(Context,Box,Key,result) then begin
     POCARuntimeError(Context,'No such key member: '+POCAGetStringValue(Context,Key));
    end;
   end;
   pvtARRAY:begin
    if POCAIsValueString(Key) then begin
     if not POCAHashGet(Context,Context.Instance^.Globals.ArrayHash,Key,result) then begin
      POCARuntimeError(Context,'No such key member: '+POCAGetStringValue(Context,Key));
     end;
    end else begin
     result:=POCAArrayGet(Box,POCARunCheckArray(Context,Box,Key));
    end;
   end;
   pvtSTRING:begin
    if POCAIsValueString(Key) then begin
     if not POCAHashGet(Context,Context.Instance^.Globals.StringHash,Key,result) then begin
      POCARuntimeError(Context,'No such key member: '+POCAGetStringValue(Context,Key));
     end;
    end else begin
     if PPOCAString(POCAGetValueReferencePointer(Box))^.UTF8=suISUTF8 then begin
      CodePoint:=POCARunCheckStringUTF8(Context,Box,Key);
      CodeUnit:=POCAStringUTF8GetCodeUnit(Context,Box,CodePoint);
      if (CodeUnit>0) and (CodeUnit<=length(PPOCAString(POCAGetValueReferencePointer(Box))^.Data)) then begin
       result.Num:=PUCUUTF8CodeUnitGetChar(PPOCAString(POCAGetValueReferencePointer(Box))^.Data,CodeUnit);
      end else begin
       result.Num:=PUCUUTF8CodePointGetChar(PPOCAString(POCAGetValueReferencePointer(Box))^.Data,CodePoint);
      end;
     end else begin
      result.Num:=ord(PPOCAString(POCAGetValueReferencePointer(Box))^.Data[POCARunCheckString(Context,Box,Key)+1]);
     end;
    end;
   end;
   pvtGHOST:begin
    if not POCAHashGet(Context,POCAGhostGetHashValue(Box),Key,result) then begin
     POCARuntimeError(Context,'No such key member: '+POCAGetStringValue(Context,Key));
    end;
   end;
   else begin
    POCARuntimeError(Context,'Extract from non-container');
   end;
  end;
 end;
end;

procedure POCARunContainerSet(Context:PPOCAContext;const Box,Key,Value:TPOCAValue);
var CodePoint:longint;
    CharValue:longword;
begin
 if not POCAIsValueScalarType(Key) then begin
  POCARuntimeError(Context,'Container index not scalar');
 end else begin
  case POCAGetValueType(Box) of
   pvtHASH:begin
    POCAHashSet(Context,Box,Key,Value);
   end;
   pvtARRAY:begin
    POCAArraySet(Box,POCARunCheckArray(Context,Box,Key),Value);
   end;
   pvtSTRING:begin
    if PPOCAString(POCAGetValueReferencePointer(Box))^.HashCode<>0 then begin
     POCARuntimeError(Context,'Cannot change immutable string');
    end else begin
     CharValue:=trunc(POCAGetNumberValue(Context,Value));
     if (PPOCAString(POCAGetValueReferencePointer(Box))^.UTF8=suISUTF8) or ((PPOCAString(POCAGetValueReferencePointer(Box))^.UTF8=suPOSSIBLEUTF8) and (CharValue>$7f)) then begin
      CodePoint:=POCARunCheckStringUTF8(Context,Box,Key);
      PPOCAString(POCAGetValueReferencePointer(Box))^.Data:=POCAStringUTF8CopyCodePointRange(Context,Box,0,CodePoint-1)+PUCUUTF32CharToUTF8(CharValue)+POCAStringUTF8CopyCodePointRange(Context,Box,CodePoint+1,PPOCAString(POCAGetValueReferencePointer(Box))^.UTF8Length-1);
      PPOCAString(POCAGetValueReferencePointer(Box))^.Dirty:=true;
      POCAStringUpdate(Context,Box);
     end else begin
      PPOCAString(POCAGetValueReferencePointer(Box))^.Data[POCARunCheckString(Context,Box,Key)+1]:=ansichar(byte(CharValue));
     end;
    end;
   end;
   else begin
    POCARuntimeError(Context,'Insert into non-container');
   end;
  end;
 end;
end;

function POCARunEvalForEach(Context:PPOCAContext;const Obj:TPOCAValue;var Index,Value,Keys:TPOCAValue):boolean;
var CurrentIndex,Cell,Entity,CodePoint,CodeUnit:longint;
    ArrayRecord:PPOCAArrayRecord;
    Str:PPOCAString;
    HashRecord:PPOCAHashRecord;
begin
 result:=false;
 CurrentIndex:=trunc(Index.Num);
 case POCAGetValueType(Obj) of
  pvtARRAY:begin
   ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(Obj))^.ArrayRecord;
   if assigned(ArrayRecord) and ((CurrentIndex>=0) and (CurrentIndex<ArrayRecord^.Size)) then begin
    Index.Num:=CurrentIndex+1;
    Value:=POCAArrayGet(Obj,CurrentIndex);
    result:=true;
   end;
  end;
  pvtSTRING:begin
   Str:=PPOCAString(POCAGetValueReferencePointer(Obj));
   if assigned(Str) then begin
    if Str^.UTF8=suISUTF8 then begin
     if ((CurrentIndex>=0) and (CurrentIndex<Str^.UTF8Length)) then begin
      Index.Num:=CurrentIndex+1;
      CodePoint:=CurrentIndex;
      CodeUnit:=POCAStringUTF8GetCodeUnit(Context,Obj,CodePoint);
      if (CodeUnit>0) and (CodeUnit<=Str^.DataLength) then begin
       Value.Num:=PUCUUTF8CodeUnitGetChar(Str^.Data,CodeUnit);
      end else begin
       Value.Num:=PUCUUTF8CodePointGetChar(Str^.Data,CodePoint);
      end;
      result:=true;
     end;
    end else begin
     if ((CurrentIndex>=0) and (CurrentIndex<Str^.DataLength)) then begin
      Index.Num:=CurrentIndex+1;
      CodeUnit:=CurrentIndex+1;
      Value.Num:=byte(AnsiChar(Str^.Data[CodeUnit]));
      result:=true;
     end;
    end;
   end;
  end;
  pvtHASH:begin
   if CurrentIndex=0 then begin
    Keys:=POCANewArray(Context);
    POCAHashKeys(Context,Keys,Obj);
    POCAArraySort(Context,Keys);
   end;
   if POCAIsValueArray(Keys) then begin
    ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(Keys))^.ArrayRecord;
    if assigned(ArrayRecord) and ((CurrentIndex>=0) and (CurrentIndex<ArrayRecord^.Size)) then begin
     Index.Num:=CurrentIndex+1;
     result:=POCAHashGet(Context,Obj,POCAArrayGet(Keys,CurrentIndex),Value);
    end;
   end else begin
    HashRecord:=PPOCAHash(POCAGetValueReferencePointer(Obj))^.HashRecord;
    if assigned(HashRecord) then begin
     while ((CurrentIndex>=0) and (CurrentIndex<(2 shl HashRecord^.LogSize))) do begin
      Cell:=HashRecord^.EntityToCellIndex^[CurrentIndex];
      if Cell>=0 then begin
       Entity:=HashRecord^.CellToEntityIndex^[Cell];
       if Entity>=0 then begin
        Index.Num:=CurrentIndex+1;
        Value:=HashRecord^.Entities^[Entity].Value;
        result:=true;
        break;
       end;
      end;
      inc(CurrentIndex);
     end;
    end;
   end;
  end;
  else begin
   POCARuntimeError(Context,'foreach emumeration of non-array, non-string and non-hash');
  end;
 end;
end;

function POCARunEvalForKey(Context:PPOCAContext;const Obj:TPOCAValue;var Index,Value,Keys:TPOCAValue):boolean;
var CurrentIndex,Cell,Entity:longint;
    ArrayRecord:PPOCAArrayRecord;
    HashRecord:PPOCAHashRecord;
begin
 result:=false;
 CurrentIndex:=trunc(Index.Num);
 if POCAIsValueHash(Obj) then begin
  if CurrentIndex=0 then begin
   Keys:=POCANewArray(Context);
   POCAHashKeys(Context,Keys,Obj);
   POCAArraySort(Context,Keys);
  end;
  if POCAIsValueArray(Keys) then begin
   ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(Keys))^.ArrayRecord;
   if assigned(ArrayRecord) and ((CurrentIndex>=0) and (CurrentIndex<ArrayRecord^.Size)) then begin
    Index.Num:=CurrentIndex+1;
    Value:=POCAArrayGet(Keys,CurrentIndex);
    result:=true;
   end;
  end else begin
   HashRecord:=PPOCAHash(POCAGetValueReferencePointer(Obj))^.HashRecord;
   if assigned(HashRecord) then begin
    while ((CurrentIndex>=0) and (CurrentIndex<(2 shl HashRecord^.LogSize))) do begin
     Cell:=HashRecord^.EntityToCellIndex^[CurrentIndex];
     if Cell>=0 then begin
      Entity:=HashRecord^.CellToEntityIndex^[Cell];
      if Entity>=0 then begin
       Index.Num:=CurrentIndex+1;
       Value:=HashRecord^.Entities^[Entity].Key;
       result:=true;
       break;
      end;
     end;
     inc(CurrentIndex);
    end;
   end;
  end;
 end else begin
  POCARuntimeError(Context,'forkey emumeration of non-hash');
 end;
end;

function POCARunEvalForIndex(Context:PPOCAContext;const Obj:TPOCAValue;var Index,Value:TPOCAValue):boolean;
var CurrentIndex:longint;
    ArrayRecord:PPOCAArrayRecord;
    Str:PPOCAString;
begin
 result:=false;
 CurrentIndex:=trunc(Index.Num);
 case POCAGetValueType(Obj) of
  pvtARRAY:begin
   ArrayRecord:=PPOCAArray(POCAGetValueReferencePointer(Obj))^.ArrayRecord;
   if assigned(ArrayRecord) and ((CurrentIndex>=0) and (CurrentIndex<ArrayRecord^.Size)) then begin
    Index.Num:=CurrentIndex+1;
    Value.Num:=CurrentIndex;
    result:=true;
   end;
  end;
  pvtSTRING:begin
   Str:=PPOCAString(POCAGetValueReferencePointer(Obj));
   if assigned(Str) then begin
    if Str^.UTF8=suISUTF8 then begin
     if ((CurrentIndex>=0) and (CurrentIndex<Str^.UTF8Length)) then begin
      Index.Num:=CurrentIndex+1;
      Value.Num:=CurrentIndex;
      result:=true;
     end;
    end else begin
     if ((CurrentIndex>=0) and (CurrentIndex<Str^.DataLength)) then begin
      Index.Num:=CurrentIndex+1;
      Value.Num:=CurrentIndex;
      result:=true;
     end;
    end;
   end;
  end;
  else begin
   POCARuntimeError(Context,'forindex emumeration of non-array and non-string');
  end;
 end;
end;

procedure POCARunEvalUnpack(Context:PPOCAContext;Frame:PPOCAFrame;Opcode:longword;Operands:PLongwords);
var ArrayObject:TPOCAValue;
    i,Count:longint;
begin
 ArrayObject:=Frame^.Registers[Operands^[0]];
 Count:=(Opcode shr 8)-1;
 if (not POCAIsValueArray(ArrayObject)) or (longint(POCAArraySize(ArrayObject))<Count) then begin
  POCARuntimeError(Context,'Short or invalid multi-assignment array');
 end else begin
  for i:=0 to Count-1 do begin
   Frame^.Registers[Operands^[i+1]]:=POCAArrayGet(ArrayObject,i);
  end;
 end;
end;

procedure POCARunEvalSlice(Context:PPOCAContext;var Dst:TPOCAValue;const Src,Idx:TPOCAValue);
var DstType,CodePoint:longint;
begin
 DstType:=POCAGetValueType(Dst);
 if DstType=pvtNULL then begin
  case POCAGetValueType(Src) of
   pvtSTRING:begin
    Dst:=POCANewString(Context,'');
    DstType:=pvtSTRING;
   end;
   pvtARRAY:begin
    Dst:=POCANewArray(Context);
    DstType:=pvtARRAY;
   end;
   else begin
    POCARuntimeError(Context,'Cannot slice non-string-or-array');
   end;
  end;
 end;
 if DstType=POCAGetValueType(Src) then begin
  case DstType of
   pvtSTRING:begin
    if PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode<>0 then begin
     POCARuntimeError(Context,'Cannot slice to immutable strings');
    end else begin
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8<>suNOUTF8 then begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        CodePoint:=POCARunCheckString(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,CodePoint+1,1);
       end;
       suISUTF8:begin
        CodePoint:=POCARunCheckStringUTF8(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+POCAStringUTF8CopyCodePointRange(Context,Src,CodePoint,CodePoint);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        CodePoint:=POCARunCheckString(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+PUCUUTF8Correct(copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,CodePoint+1,1));
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
      end;
     end else begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        CodePoint:=POCARunCheckString(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,CodePoint+1,1);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       suISUTF8:begin
        CodePoint:=POCARunCheckStringUTF8(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+POCAStringUTF8CopyCodePointRange(Context,Src,CodePoint,CodePoint);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        CodePoint:=POCARunCheckString(Context,Src,Idx);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,CodePoint+1,1);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suNOUTF8;
       end;
      end;
     end;
     inc(PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8Length);
     PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode:=0;
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8=suISUTF8 then begin
      PPOCAString(POCAGetValueReferencePointer(Dst))^.Dirty:=true;
//    POCAStringUpdate(Context,Dst);
     end;
    end;
   end;
   pvtARRAY:begin
    POCAArrayPush(Dst,POCAArrayGet(Src,POCARunCheckArray(Context,Src,Idx)));
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Slice data types mismatch');
 end;
end;

procedure POCARunEvalSlice2(Context:PPOCAContext;var Dst:TPOCAValue;const Src,Start,EndR:TPOCAValue);
var Size:longint;
 function Bound(const ir:TPOCAValue;IsEnd:boolean;IsString:boolean):longint;
 begin
  if POCAIsValueNull(ir) then begin
   if IsEnd then begin
    result:=-1;
   end else begin
    result:=0;
   end;
  end else begin
   result:=trunc(POCAGetNumberValue(Context,ir));
  end;
  if POCAIsValueNull(ir) and (Size=0) then begin
   exit;
  end;
  if result<0 then begin
   inc(result,Size);
  end;
  if (result<0) or (result>=Size) then begin
   if IsString then begin
    POCARuntimeError(Context,'String index '+TPOCARawByteString(IntToStr(result))+' is out of bounds with size '+TPOCARawByteString(IntToStr(Size)));
   end else begin
    POCARuntimeError(Context,'Array index '+TPOCARawByteString(IntToStr(result))+' is out of bounds with size '+TPOCARawByteString(IntToStr(Size)));
   end;
  end;
 end;
var DstType,i,s,e,l:longint;
begin
 DstType:=POCAGetValueType(Dst);
 if DstType=pvtNULL then begin
  case POCAGetValueType(Src) of
   pvtSTRING:begin
    Dst:=POCANewString(Context,'');
    DstType:=pvtSTRING;
   end;
   pvtARRAY:begin
    Dst:=POCANewArray(Context);
    DstType:=pvtARRAY;
   end;
   else begin
    POCARuntimeError(Context,'Cannot slice non-string-or-array');
   end;
  end;
 end;
 if DstType=POCAGetValueType(Src) then begin
  case DstType of
   pvtSTRING:begin
    if PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode<>0 then begin
     POCARuntimeError(Context,'Cannot slice to immutable strings');
    end else begin
     if PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8=suISUTF8 then begin
      Size:=PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8Length;
     end else begin
      Size:=length(PPOCAString(POCAGetValueReferencePointer(Src))^.Data);
     end;
     s:=Bound(Start,false,true);
     e:=Bound(EndR,true,true);
     l:=(e-s)+1;
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8<>suNOUTF8 then begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
       end;
       suISUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+POCAStringUTF8CopyCodePointRange(Context,Src,s,e);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+PUCUUTF8Correct(copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l));
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
      end;
     end else begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       suISUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+POCAStringUTF8CopyCodePointRange(Context,Src,s,e);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suNOUTF8;
       end;
      end;
     end;
     inc(PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8Length,l);
     PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode:=0;
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8=suISUTF8 then begin
      PPOCAString(POCAGetValueReferencePointer(Dst))^.Dirty:=true;
//    POCAStringUpdate(Context,Dst);
     end;
    end;
   end;
   pvtARRAY:begin
    Size:=POCAArraySize(Src);
    for i:=Bound(Start,false,false) to Bound(EndR,true,false) do begin
     POCAArrayPush(Dst,POCAArrayGet(Src,i));
    end;
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Slice data types mismatch');
 end;
end;

procedure POCARunEvalSlice3(Context:PPOCAContext;var Dst:TPOCAValue;const Src,Start,Len:TPOCAValue);
var DstType,Size,i,s,e,l:longint;
begin
 DstType:=POCAGetValueType(Dst);
 if DstType=pvtNULL then begin
  case POCAGetValueType(Src) of
   pvtSTRING:begin
    Dst:=POCANewString(Context,'');
    DstType:=pvtSTRING;
   end;
   pvtARRAY:begin
    Dst:=POCANewArray(Context);
    DstType:=pvtARRAY;
   end;
   else begin
    POCARuntimeError(Context,'Cannot slice non-string-or-array');
   end;
  end;
 end;
 if DstType=POCAGetValueType(Src) then begin
  case DstType of
   pvtSTRING:begin
    if PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode<>0 then begin
     POCARuntimeError(Context,'Cannot slice to immutable strings');
    end else begin
     if PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8=suISUTF8 then begin
      Size:=PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8Length;
     end else begin
      Size:=length(PPOCAString(POCAGetValueReferencePointer(Src))^.Data);
     end;
     if POCAIsValueNull(Start) then begin
      s:=0;
     end else begin
      s:=trunc(POCAGetNumberValue(Context,Start));
     end;
     if POCAIsValueNull(Start) and (Size=0) then begin
      exit;
     end;
     if s<0 then begin
      inc(s,Size);
     end;
     if (s<0) or (s>=Size) then begin
      POCARuntimeError(Context,'String index '+TPOCARawByteString(IntToStr(s))+' is out of bounds with size '+TPOCARawByteString(IntToStr(Size)));
     end;
     if POCAIsValueNull(Len) then begin
      e:=Size-s;
     end else begin
      e:=trunc(POCAGetNumberValue(Context,Len));
     end;
     if e<=0 then begin
      inc(e,Size-s);
     end;
     e:=(s+e)-1;
     if e>=Size then begin
      e:=Size-1;
     end;
     l:=(e-s)+1;
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8<>suNOUTF8 then begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
       end;
       suISUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+POCAStringUTF8CopyCodePointRange(Context,Src,s,e);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+PUCUUTF8Correct(copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l));
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
      end;
     end else begin
      case PPOCAString(POCAGetValueReferencePointer(Src))^.UTF8 of
       suPOSSIBLEUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       suISUTF8:begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PUCUUTF8Correct(PPOCAString(POCAGetValueReferencePointer(Dst))^.Data)+POCAStringUTF8CopyCodePointRange(Context,Src,s,e);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suISUTF8;
       end;
       else begin
        PPOCAString(POCAGetValueReferencePointer(Dst))^.Data:=PPOCAString(POCAGetValueReferencePointer(Dst))^.Data+copy(PPOCAString(POCAGetValueReferencePointer(Src))^.Data,s+1,l);
        PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8:=suNOUTF8;
       end;
      end;
     end;
     inc(PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8Length,l);
     PPOCAString(POCAGetValueReferencePointer(Dst))^.HashCode:=0;
     if PPOCAString(POCAGetValueReferencePointer(Dst))^.UTF8=suISUTF8 then begin
      PPOCAString(POCAGetValueReferencePointer(Dst))^.Dirty:=true;
//    POCAStringUpdate(Context,Dst);
     end;
    end;
   end;
   pvtARRAY:begin
    Size:=POCAArraySize(Src);
    if POCAIsValueNull(Start) then begin
     s:=0;
    end else begin
     s:=trunc(POCAGetNumberValue(Context,Start));
    end;
    if POCAIsValueNull(Start) and (Size=0) then begin
     exit;
    end;
    if s<0 then begin
     inc(s,Size);
    end;
    if (s<0) or (s>=Size) then begin
     POCARuntimeError(Context,'Array index '+TPOCARawByteString(IntToStr(s))+' is out of bounds with size '+TPOCARawByteString(IntToStr(Size)));
    end;
    if POCAIsValueNull(Len) then begin
     e:=Size-s;
    end else begin
     e:=trunc(POCAGetNumberValue(Context,Len));
    end;
    if e<=0 then begin
     inc(e,Size-s);
    end;
    e:=(s+e)-1;
    if e>=Size then begin
     e:=Size-1;
    end;
    for i:=s to e do begin
     POCAArrayPush(Dst,POCAArrayGet(Src,i));
    end;
   end;
  end;
 end else begin
  POCARuntimeError(Context,'Slice data types mismatch');
 end;
end;

function POCARunByteCode(Context:PPOCAContext):TPOCAValue; forward;

function POCARunTry(Context:PPOCAContext;Frame:PPOCAFrame;ResultReg,CatchReg,TryBlockPos,CatchBlockPos,FinallyBlockPos,EndPos:longword):longword;
var FrameTop:longint;
    rv,v:TPOCAValue;
begin
 FrameTop:=Context^.FrameTop;
 try
  try
   if TryBlockPos<>$ffffffff then begin
    Context^.FrameTop:=FrameTop;
    Frame^.InstructionPointer:=TryBlockPos;
    rv:=POCARunByteCode(Context);
   end else begin
    rv:=POCAValueNull;
   end;
  except
   on CurrentException:Exception do begin
    if CatchBlockPos=$ffffffff then begin
     raise;
    end else begin
     Context^.FrameTop:=FrameTop;
     Frame^.InstructionPointer:=CatchBlockPos;
     if CatchReg<>$ffffffff then begin
      if CurrentException is EPOCAError then begin
       if length(CurrentException.Message)>0 then begin
        v:=POCANewArray(Context);
        POCAArraySetSize(v,4);
        POCAArraySet(v,0,POCANewString(Context,PUCUUTF16ToUTF8(TPOCAUTF16String(CurrentException.Message))));
        if CurrentException is EPOCASyntaxError then begin
         POCAArraySet(v,1,POCANewUniqueString(Context,'SyntaxError'));
        end else if CurrentException is EPOCARuntimeError then begin
         POCAArraySet(v,1,POCANewUniqueString(Context,'RuntimeError'));
        end else if CurrentException is EPOCAScriptError then begin
         POCAArraySet(v,1,POCANewUniqueString(Context,'ScriptError'));
        end else begin
         POCAArraySet(v,1,POCANewUniqueString(Context,'Error'));
        end;
        if EPOCAError(CurrentException).SourceFile>=0 then begin
         POCAArraySet(v,2,POCAArrayGet(Context^.Instance^.Globals.SourceFiles,EPOCAError(CurrentException).SourceFile));
        end else begin
         POCAArraySet(v,2,POCAValueNull);
        end;
        POCAArraySet(v,3,POCANumber(EPOCAError(CurrentException).SourceLine));
       end else begin
        v:=EPOCAError(CurrentException).Value;
       end;
      end else begin
       v:=POCANewArray(Context);
       POCAArraySetSize(v,4);
       POCAArraySet(v,0,POCANewString(Context,PUCUUTF16ToUTF8(TPOCAUTF16String(CurrentException.Message))));
       POCAArraySet(v,1,POCANewUniqueString(Context,PUCUUTF16ToUTF8(TPOCAUTF16String(CurrentException.ClassName))));
       POCAArraySet(v,2,POCAValueNull);
       POCAArraySet(v,3,POCANumber(-1));
      end;
      Frame^.Registers[CatchReg]:=v;
     end;
     rv:=POCARunByteCode(Context);
    end;
   end;
  end;
 finally
  if FinallyBlockPos<>$ffffffff then begin
   Context^.FrameTop:=FrameTop;
   Frame^.InstructionPointer:=FinallyBlockPos;
   rv:=POCARunByteCode(Context);
  end;
  Context^.FrameTop:=FrameTop;
 end;
 result:=EndPos;
 Frame^.Registers[ResultReg]:=rv;
end;

procedure POCARunThrow(Context:PPOCAContext;Parameter:TPOCAValue);
var Value:longword;
begin
 Value:=POCAStackDepth(Context);
 if POCAIsValueString(Parameter) then begin
  raise EPOCAScriptError.Create(POCAGetSourceFile(Context,Value),POCAGetSourceLine(Context,Value),-1,POCAGetStringValue(Context,Parameter));
 end else begin
  raise EPOCAScriptError.Create(POCAGetSourceFile(Context,Value),POCAGetSourceLine(Context,Value),-1,Parameter);
 end;
end;

procedure POCARunIn(Context:PPOCAContext;var r:TPOCAValue;const a,b:TPOCAValue);
var CurrentIndex:longint;
    c:TPOCAValue;
    d:longword;
begin
 c:=POCAValueNull;
 if POCAIsValueArray(b) then begin
  if POCAIsValueArray(a) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
   r.Num:=1;
  end else begin
   r.Num:=0;
   CurrentIndex:=0;
   while CurrentIndex<longint(POCAArraySize(b)) do begin
    if POCACompare(Context,a,POCAArrayGet(b,CurrentIndex))=0 then begin
     r.Num:=1;
     break;
    end else begin
     inc(CurrentIndex);
    end;
   end;
  end;
 end else if POCAIsValueHash(b) then begin
  if POCAIsValueHash(a) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
   r.Num:=1;
  end else begin
   d:=0;
   r.Num:=ord(POCAGetMember(Context,b,a,c,d,false,false));
  end;
 end else if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
  r.Num:=ord(a.Num=b.Num);
 end else begin
  r.Num:=ord(POCACompare(Context,a,b)=0);
 end;
end;

procedure POCARunInRange(Context:PPOCAContext;var r:TPOCAValue;const a,b,c:TPOCAValue);
begin
 if POCAIsValueNumber(a) and POCAIsValueNumber(b) and POCAIsValueNumber(c) then begin
  r.Num:=ord((b.Num<=a.Num) and (a.Num<=c.Num));
 end else begin
  r.Num:=ord((POCACompare(Context,b,a)<=0) and (POCACompare(Context,a,c)<=0));
 end;
end;

function POCARunHashEventBinaryOp(Context:PPOCAContext;var Frame:PPOCAFrame;const Operands:PLongwords;const Operation:TPOCAMetaOp):boolean;
var HashEvents:PPOCAHashEvents;
begin
 HashEvents:=POCAHashGetHashEvents(Frame^.Registers[Operands^[1]],Frame^.Registers[Operands^[2]],Operation);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[Operation]) then begin
  Frame:=POCASetupFunctionCall(Context,Frame,3 shl 8,Operands,false,false,@HashEvents^[Operation]);
  result:=true;
 end else begin
  result:=false;
 end;
end;

function POCARunHashEventRightBinaryOp(Context:PPOCAContext;var Frame:PPOCAFrame;const Operands:PLongwords;const Operation:TPOCAMetaOp):boolean;
var HashEvents:PPOCAHashEvents;
begin
 HashEvents:=POCAHashGetHashEvents(Frame^.Registers[Operands^[2]],Operation);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[Operation]) then begin
  Frame:=POCASetupFunctionCall(Context,Frame,3 shl 8,Operands,false,false,@HashEvents^[Operation]);
  result:=true;
 end else begin
  result:=false;
 end;
end;

function POCARunHashEventUnaryOp(Context:PPOCAContext;var Frame:PPOCAFrame;const Operands:PLongwords;const Operation:TPOCAMetaOp):boolean;
var HashEvents:PPOCAHashEvents;
begin
 HashEvents:=POCAHashGetHashEvents(Frame^.Registers[Operands^[1]]);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[Operation]) then begin
  Frame:=POCASetupFunctionCall(Context,Frame,2 shl 8,Operands,false,false,@HashEvents^[Operation]);
  result:=true;
 end else begin
  result:=false;
 end;
end;

function POCARunHashEventInRangeOp(Context:PPOCAContext;var Frame:PPOCAFrame;const Operands:PLongwords;const Operation:TPOCAMetaOp):boolean;
var HashEvents:PPOCAHashEvents;
begin
 HashEvents:=POCAHashGetHashEvents(Frame^.Registers[Operands^[1]],Frame^.Registers[Operands^[2]],Frame^.Registers[Operands^[3]],Operation);
 if assigned(HashEvents) and POCAIsValueFunctionOrNativeCode(HashEvents^[Operation]) then begin
  Frame:=POCASetupFunctionCall(Context,Frame,4 shl 8,Operands,false,false,@HashEvents^[Operation]);
  result:=true;
 end else begin
  result:=false;
 end;
end;

{$ifdef POCAHasJIT}
{$ifdef cpu386}
{$warnings off}
function POCAGenerateNativeCode(Context:PPOCAContext;Code:PPOCACode):boolean;
type TFixupKind=(fkPTR,fkRET,fkOFS);
     TFixup=record
      Kind:TFixupKind;
      Ofs:longint;
      Dest:pointer;
      ToOfs:longint;
     end;
     TFixups=array of TFixup;
var Fixups:TFixups;
    CountFixups,i:longint;
    Offsets:array of longword;
    Opcode,Instruction:longword;
    CodeBuffer:array of byte;
    CodeBufferLen,OldCodeBufferLen:longint;
    CurrentPC,LastPC,Temp,RetOfs,Literal:longword;
    CodeBegin,CodeEnd:pointer;
    CodeVars:array[0..8] of pointer;
    Operands:PLongints;
    v:TPOCAValue;
 procedure Add(const s:TPUCURawByteString);
 begin
  if length(s)>0 then begin
   if (CodeBufferLen+length(s))>=length(CodeBuffer) then begin
    SetLength(CodeBuffer,(CodeBufferLen+length(s)+4096) and not 4095);
   end;
   move(s[1],CodeBuffer[CodeBufferLen],length(s));
   inc(CodeBufferLen,length(s));
  end;
 end;
 procedure AddCode(CodeBegin,CodeEnd:pointer);
 var CodeLen:TPOCAPtrInt;
{$ifdef windows}
     OldProtect,OldProtectDummy:longword;
     OK:boolean;
{$endif}
 begin
  CodeLen:=TPOCAPtrInt(TPOCAPtrUInt(CodeEnd)-TPOCAPtrUInt(CodeBegin));
  if CodeLen>0 then begin
{$ifdef windows}
   OK:=VirtualProtect(CodeBegin,CodeLen,PAGE_EXECUTE_READWRITE,OldProtect);
{$endif}
{$ifdef unix}
   fpmprotect(CodeBegin,CodeLen,PROT_READ or PROT_WRITE or PROT_EXEC);
{$endif}
   if (CodeBufferLen+CodeLen)>=length(CodeBuffer) then begin
    SetLength(CodeBuffer,(CodeBufferLen+CodeLen+4096) and not 4095);
   end;
   move(CodeBegin^,CodeBuffer[CodeBufferLen],CodeLen);
   inc(CodeBufferLen,CodeLen);
{$ifdef windows}
   if OK then begin
    VirtualProtect(CodeBegin,CodeLen,OldProtect,OldProtectDummy);
   end;
{$endif}
  end;
 end;
 procedure AddDWord(const v:longword);
 begin
  if (CodeBufferLen+sizeof(longword))>=length(CodeBuffer) then begin
   SetLength(CodeBuffer,(CodeBufferLen+sizeof(longword)+4096) and not 4095);
  end;
  move(v,CodeBuffer[CodeBufferLen],sizeof(longword));
  inc(CodeBufferLen,sizeof(longword));
 end;
 procedure DoItByVMOpcodeDispatcher;
 begin
  Code^.InterpretByteCodeMap[LastPC]:=true;
  
  Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
  AddDWord(LastPC);

  Add(#$31#$c0); // xor eax,eax

  Add(#$c3); // ret
 end;
begin
 try
  if assigned(Code^.NativeCode) then begin
   POCANativeCodeMemoryManagerFreeMemory(Code^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance^.Globals.NativeCodeMemoryManager,Code^.NativeCode);
   Code^.NativeCode:=nil;
   Code^.NativeCodeSize:=0;
  end;
  CodeBuffer:=nil;
  CodeBufferLen:=0;
  Fixups:=nil;
  CountFixups:=0;
  Offsets:=nil;
  SetLength(Offsets,Code^.ByteCodeSize);
  if length(Code^.InterpretByteCodeMap)<>Code^.ByteCodeSize then begin
   SetLength(Code^.InterpretByteCodeMap,Code^.ByteCodeSize);
  end;
  CurrentPC:=0;
  while CurrentPC<Code^.ByteCodeSize do begin
   LastPC:=CurrentPC;
   Code^.InterpretByteCodeMap[LastPC]:=false;
   Offsets[CurrentPC]:=CodeBufferLen;
   Instruction:=Code^.ByteCode^[CurrentPC];
   Operands:=@Code^.ByteCode^[CurrentPC+1];
   inc(CurrentPC,1+(Instruction shr 8));
   Opcode:=Instruction and $ff;
// writeln({LastPC,' ',}Opcode);
   case Opcode of
    popNOP:begin
    end;
    popADD:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$83); // fadd qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popSUB:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$a3); // fsub qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popMUL:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$8b); // fmul qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popDIV:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$b3); // fdiv qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popNEG:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$d9#$ee); // fldz

     Add(#$dc#$a3); // fsub qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popNOT:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fcomp qword ptr [POCADoubleZero]
        fstsw ax
        sahf
        setz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popCAT:begin
     DoItByVMOpcodeDispatcher;
    end;
    popLT:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setb al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popLTEQ:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setbe al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popGT:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnbe al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popGTEQ:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnb al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popEQ:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popNEQ:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popCMP:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSEQ:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSNEQ:begin
     DoItByVMOpcodeDispatcher;
    end;
    popEACH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popJMP:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$e9); // jmp Arg
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
      Add(#$00#$00#$00#$00);
     end;
    end;
    popJMPLOOP:begin
     asm
      jmp @Skip
       @CodeBegin:
        lea eax,[esi+TPOCAContext.Instance]
        mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
        test eax,eax
        jz @CodeEnd
         lea eax,[esi+TPOCAContext.Instance]
         db $e8,$00,$00,$00,$00
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     if CountFixups>=length(Fixups) then begin
      SetLength(Fixups,CountFixups+4096);
     end;
     Fixups[CountFixups].Kind:=fkPTR;
     Fixups[CountFixups].Ofs:=CodeBufferLen-4;
     Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
     inc(CountFixups);

     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$e9); // jmp Arg
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
      Add(#$00#$00#$00#$00);
     end;
    end;
    popJIFTRUE:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
      AddDWord((Operands^[1]*sizeof(double))+4);
      AddDWord(POCAValueReferenceTag);

      Add(#$75#$0a); // jnz +$0a

      Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
      AddDWord(LastPC);

      Add(#$31#$c0); // xor eax,eax

      Add(#$c3); // ret

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         db $0f,$85,$00,$00,$00,$00 // jnz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popJIFFALSE:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
      AddDWord((Operands^[1]*sizeof(double))+4);
      AddDWord(POCAValueReferenceTag);

      Add(#$75#$0a); // jnz +$0a

      Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
      AddDWord(LastPC);

      Add(#$31#$c0); // xor eax,eax

      Add(#$c3); // ret

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         db $0f,$84,$00,$00,$00,$00 // jz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popJIFTRUELOOP:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
      AddDWord((Operands^[1]*sizeof(double))+4);
      AddDWord(POCAValueReferenceTag);

      Add(#$75#$0a); // jnz +$0a

      Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
      AddDWord(LastPC);

      Add(#$31#$c0); // xor eax,eax

      Add(#$c3); // ret

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         jz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popJIFFALSELOOP:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
      AddDWord((Operands^[1]*sizeof(double))+4);
      AddDWord(POCAValueReferenceTag);

      Add(#$75#$0a); // jnz +$0a

      Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
      AddDWord(LastPC);

      Add(#$31#$c0); // xor eax,eax

      Add(#$c3); // ret

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         jnz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popFCALL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popMCALL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popRETURN:begin
     DoItByVMOpcodeDispatcher;
    end;
    popLOADCONST:begin
     v:=Code^.Constants^[Operands^[1]];
     if POCAIsValueCode(v) then begin
      DoItByVMOpcodeDispatcher;
     end else begin
      Add(#$c7#$83); // mov dword ptr [ebx+Reg+0],[v+0]
      AddDWord(Operands^[0]*sizeof(double));
      AddDWord(longword(pointer(@v)^));

      Add(#$c7#$83); // mov dword ptr [ebx+Reg+4],[v+4]
      AddDWord((Operands^[0]*sizeof(double))+4);
      AddDWord(longword(pointer(@pansichar(@v)[4])^));
     end;
    end;
    popLOADONE:begin
     Add(#$c7#$83); // mov dword ptr [ebx+Reg+0],[POCADoubleOne+0]
     AddDWord(Operands^[0]*sizeof(double));
     AddDWord(longword(pointer(@POCADoubleOne)^));

     Add(#$c7#$83); // mov dword ptr [ebx+Reg+4],[POCADoubleOne+4]
     AddDWord((Operands^[0]*sizeof(double))+4);
     AddDWord(longword(pointer(@pansichar(@POCADoubleOne)[4])^));
    end;
    popLOADZERO:begin
     Add(#$c7#$83); // mov dword ptr [ebx+Reg+0],[POCADoubleZero+0]
     AddDWord(Operands^[0]*sizeof(double));
     AddDWord(longword(pointer(@POCADoubleZero)^));

     Add(#$c7#$83); // mov dword ptr [ebx+Reg+4],[POCADoubleZero+4]
     AddDWord((Operands^[0]*sizeof(double))+4);
     AddDWord(longword(pointer(@pansichar(@POCADoubleZero)[4])^));
    end;
    popLOADINT32:begin
     v.Num:=Operands^[1];

     Add(#$c7#$83); // mov dword ptr [ebx+Reg+0],[v+0]
     AddDWord(Operands^[0]*sizeof(double));
     AddDWord(longword(pointer(@v)^));

     Add(#$c7#$83); // mov dword ptr [ebx+Reg+4],[v+4]
     AddDWord((Operands^[0]*sizeof(double))+4);
     AddDWord(longword(pointer(@pansichar(@v)[4])^));
    end;
    popLOADNULL:begin
     Add(#$c7#$83); // mov dword ptr [ebx+Reg+0],[POCAValueNull+0]
     AddDWord(Operands^[0]*sizeof(double));
     AddDWord(longword(pointer(@POCAValueNull)^));

     Add(#$c7#$83); // mov dword ptr [ebx+Reg+4],[POCAValueNull+4]
     AddDWord((Operands^[0]*sizeof(double))+4);
     AddDWord(longword(pointer(@pansichar(@POCAValueNull)[4])^));
    end;
    popLOADTHAT:begin
     DoItByVMOpcodeDispatcher;
    end;
    popLOADTHIS:begin
     Add(#$b8); // mov eax,RegisterOfs
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        mov ecx,dword ptr [edi+TPOCAFrame.Obj]
        mov dword ptr [ebx+eax],ecx
        mov ecx,dword ptr [edi+TPOCAFrame.Obj+4]
        mov dword ptr [ebx+eax+4],ecx
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popLOADSELF:begin
     Add(#$b8); // mov eax,RegisterOfs
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        mov ecx,dword ptr [edi+TPOCAFrame.Func]
        mov dword ptr [ebx+eax],ecx
        mov ecx,dword ptr [edi+TPOCAFrame.Func+4]
        mov dword ptr [ebx+eax+4],ecx
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popLOADLOCAL:begin
     Add(#$b8); // mov eax,RegisterOfs
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        mov ecx,dword ptr [edi+TPOCAFrame.Locals]
        mov dword ptr [ebx+eax],ecx
        mov ecx,dword ptr [edi+TPOCAFrame.Locals+4]
        mov dword ptr [ebx+eax+4],ecx
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popCOPY:begin
     if Operands^[0]<>Operands^[1] then begin
      Add(#$8b#$83); // mov eax,dword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$89#$83); // mov dword ptr [ebx+RegisterOfs],eax
      AddDWord(Operands^[0]*sizeof(double));

      Add(#$8b#$83); // mov eax,dword ptr [ebx+RegisterOfs]
      AddDWord((Operands^[1]*sizeof(double))+4);

      Add(#$89#$83); // mov dword ptr [ebx+RegisterOfs],eax
      AddDWord((Operands^[0]*sizeof(double))+4);
     end;
    end;
    popINSERT:begin
     DoItByVMOpcodeDispatcher;
    end;
    popEXTRACT:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGETMEMBER:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETMEMBER:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGETLOCAL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETLOCAL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popNEWARRAY:begin
     DoItByVMOpcodeDispatcher;
    end;
    popARRAYPUSH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popARRAYRANGEPUSH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popNEWHASH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popHASHAPPEND:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETSYM:begin
     DoItByVMOpcodeDispatcher;
    end;
    popINDEX:begin
     DoItByVMOpcodeDispatcher;
    end;
    popFCALLH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popMCALLH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popUNPACK:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSLICE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSLICE2:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSLICE3:begin
     DoItByVMOpcodeDispatcher;
    end;
    popTRY:begin
     DoItByVMOpcodeDispatcher;
    end;
    popTRYBLOCKEND:begin
     DoItByVMOpcodeDispatcher;
    end;
    popTHROW:begin
     DoItByVMOpcodeDispatcher;
    end;
    popDEC:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fsub qword ptr [POCADoubleOne]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popINC:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fadd qword ptr [POCADoubleOne]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popBAND:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        and dword ptr [esp+$04],eax
        and dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popBXOR:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        xor dword ptr [esp+$04],eax
        xor dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popBOR:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        or dword ptr [esp+$04],eax
        or dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popBNOT:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        not dword ptr [esp+$04]
        not dword ptr [esp+$08]
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popBSHL:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov ecx,dword ptr [esp+$04]
        shld eax,edx,cl
        mov dword ptr [esp+$04],eax
        mov dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popBSHR:begin
     DoItByVMOpcodeDispatcher;
    end;
    popBUSHR:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov ecx,dword ptr [esp+$04]
        shrd eax,edx,cl
        mov dword ptr [esp+$04],eax
        mov dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popMOD:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$74#$0c); // jz +$0c

     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[2]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        @Repeat:
         fprem
         fstsw ax
         sahf
         jp @Repeat
         fstp st(1)
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popPOW:begin
     DoItByVMOpcodeDispatcher;
    end;
    popINHERITEDMETHOD:begin
     DoItByVMOpcodeDispatcher;
    end;
    popKEY:begin
     DoItByVMOpcodeDispatcher;
    end;
    popIN:begin
     DoItByVMOpcodeDispatcher;
    end;
    popINRANGE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popFTAILCALL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popMTAILCALL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popFTAILCALLH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popMTAILCALLH:begin
     DoItByVMOpcodeDispatcher;
    end;
    popINSTANCEOF:begin
     DoItByVMOpcodeDispatcher;
    end;
    popBREAKPOINT:begin
     Add(#$cc); // int3
    end;
    popNUM:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     if Operands^[0]<>Operands^[1] then begin
      Add(#$8b#$83); // mov eax,dword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$89#$83); // mov dword ptr [ebx+RegisterOfs],eax
      AddDWord(Operands^[0]*sizeof(double));

      Add(#$8b#$83); // mov eax,dword ptr [ebx+RegisterOfs]
      AddDWord((Operands^[1]*sizeof(double))+4);

      Add(#$89#$83); // mov dword ptr [ebx+RegisterOfs],eax
      AddDWord((Operands^[0]*sizeof(double))+4);
     end;
    end;
    popN_NOT:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fcomp qword ptr [POCADoubleZero]
        fstsw ax
        sahf
        setz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_ADD:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$83); // fadd qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_SUB:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$a3); // fsub qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_MUL:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$8b); // fmul qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_DIV:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$b3); // fdiv qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_NEG:begin
     Add(#$d9#$ee); // fldz

     Add(#$dc#$a3); // fsub qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_LT:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setb al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_LTEQ:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setbe al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_GT:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnbe al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_GTEQ:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnb al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_EQ:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_NEQ:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fstsw ax
        sahf
        setnz al
        movzx eax,al
        mov dword ptr [esp-4],eax
        fild dword ptr [esp-4]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_CMP:begin
     DoItByVMOpcodeDispatcher;
    end;
    popN_DEC:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fsub qword ptr [POCADoubleOne]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_INC:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fadd qword ptr [POCADoubleOne]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_BAND:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        and dword ptr [esp+$04],eax
        and dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_BXOR:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        xor dword ptr [esp+$04],eax
        xor dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_BOR:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        or dword ptr [esp+$04],eax
        or dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_BNOT:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        not dword ptr [esp+$04]
        not dword ptr [esp+$08]
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_BSHL:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov ecx,dword ptr [esp+$04]
        shld eax,edx,cl
        mov dword ptr [esp+$04],eax
        mov dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_BSHR:begin
     DoItByVMOpcodeDispatcher;
    end;
    popN_BUSHR:begin
     asm
      jmp @Skip
       @CodeBegin:
        push eax
        push edx
        sub esp,$0c
        fstcw word ptr [esp]
        fstcw word ptr [esp+$02]
        fwait
        or word ptr [esp+$02],$0f00
        fldcw word ptr [esp+$02]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov eax,dword ptr [esp+$04]
        mov edx,dword ptr [esp+$08]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));
     asm
      jmp @Skip
       @CodeBegin:
        fistp qword ptr [esp+$04]
        fwait
        mov ecx,dword ptr [esp+$04]
        shrd eax,edx,cl
        mov dword ptr [esp+$04],eax
        mov dword ptr [esp+$08],edx
        fild qword ptr [esp+$04]
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        fldcw word ptr [esp]
        add esp,$0c
        pop edx
        pop eax
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);
    end;
    popN_MOD:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[2]*sizeof(double));

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     asm
      jmp @Skip
       @CodeBegin:
        @Repeat:
         fprem
         fstsw ax
         sahf
         jp @Repeat
         fstp st(1)
       @CodeEnd:
      @Skip:
      mov dword ptr CodeBegin,offset @CodeBegin
      mov dword ptr CodeEnd,offset @CodeEnd
     end;
     AddCode(CodeBegin,CodeEnd);

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_POW:begin
     DoItByVMOpcodeDispatcher;
    end;
    popN_INRANGE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popN_JIFTRUE:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         db $0f,$85,$00,$00,$00,$00 // jnz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFFALSE:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         db $0f,$84,$00,$00,$00,$00 // jz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFTRUELOOP:begin
     if longword(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         jz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFFALSELOOP:begin
     if longword(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));
      asm
       jmp @Skip
        @CodeBegin:
         fcomp qword ptr [POCADoubleZero]
         fstsw ax
         sahf
         jnz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFLT:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$82,$00,$00,$00,$00 // jb
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFLTEQ:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$86,$00,$00,$00,$00 // jbe
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFGT:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$87,$00,$00,$00,$00 // jnbe
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFGTEQ:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$83,$00,$00,$00,$00 // jnb
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFEQ:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$84,$00,$00,$00,$00 // jz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFNEQ:begin
     if longword(Operands^[0])<>CurrentPC then begin
      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         db $0f,$85,$00,$00,$00,$00 // jnz
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
      end;
      AddCode(CodeBegin,CodeEnd);
      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFLTLOOP:begin
     if longword(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jnb @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFLTEQLOOP:begin
     if longword(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jnbe @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFGTLOOP:begin
     if longword(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jbe @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFGTEQLOOP:begin
     if longword(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jb @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFEQLOOP:begin
     if longword(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));

      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jnz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popN_JIFNEQLOOP:begin
     if longword(Operands^[0])<>CurrentPC then begin

      Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[1]*sizeof(double));

      Add(#$dc#$9b); // fcomp qword ptr [ebx+RegisterOfs]
      AddDWord(Operands^[2]*sizeof(double));
      
      asm
       jmp @Skip
        @CodeBegin:
         fstsw ax
         sahf
         jz @SkipIt
          lea eax,[esi+TPOCAContext.Instance]
          mov eax,[eax+TPOCAInstance.Globals+TPOCAGlobals.Bottleneck]
          test eax,eax
          jz @DoNot
           lea eax,[esi+TPOCAContext.Instance]
           @CodeVars0:
           db $e8,$00,$00,$00,$00
          @DoNot:
          db $e9,$00,$00,$00,$00
         @SkipIt:
        @CodeEnd:
       @Skip:
       mov dword ptr CodeBegin,offset @CodeBegin
       mov dword ptr CodeEnd,offset @CodeEnd
       mov dword ptr [CodeVars+0*4],offset @CodeVars0+1
      end;
      OldCodeBufferLen:=CodeBufferLen;
      AddCode(CodeBegin,CodeEnd);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkPTR;
      Fixups[CountFixups].Ofs:=TPOCAPtrUInt(OldCodeBufferLen)+TPOCAPtrUInt(TPOCAPtrUInt(CodeVars[0])-TPOCAPtrUInt(CodeBegin));
      Fixups[CountFixups].Dest:=@POCAGarbageCollectorDoBottleneck;
      inc(CountFixups);

      if CountFixups>=length(Fixups) then begin
       SetLength(Fixups,CountFixups+4096);
      end;
      Fixups[CountFixups].Kind:=fkOFS;
      Fixups[CountFixups].Ofs:=CodeBufferLen-4;
      Fixups[CountFixups].ToOfs:=Operands^[0];
      inc(CountFixups);
     end;
    end;
    popUPDATESTRING:begin
     DoItByVMOpcodeDispatcher;
    end;
    popREGEXP:begin
     DoItByVMOpcodeDispatcher;
    end;
    popREGEXPEQ:begin
     DoItByVMOpcodeDispatcher;
    end;
    popREGEXPNEQ:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSQRT:begin
     Add(#$81#$bb); // cmp dword ptr [ebx+RegisterOfs+4],POCAValueReferenceTag
     AddDWord((Operands^[1]*sizeof(double))+4);
     AddDWord(POCAValueReferenceTag);

     Add(#$75#$0a); // jnz +$0a

     Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
     AddDWord(LastPC);

     Add(#$31#$c0); // xor eax,eax

     Add(#$c3); // ret

     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$d9#$fa); // fsqrt

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popN_SQRT:begin
     Add(#$dd#$83); // fld qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[1]*sizeof(double));

     Add(#$d9#$fa); // fsqrt

     Add(#$dd#$9b); // fstp qword ptr [ebx+RegisterOfs]
     AddDWord(Operands^[0]*sizeof(double));
    end;
    popGETPROTOTYPE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETPROTOTYPE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGETCONSTRUCTOR:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETCONSTRUCTOR:begin
     DoItByVMOpcodeDispatcher;
    end;
    popDELETE:begin
     DoItByVMOpcodeDispatcher;
    end;
    popDELETEEX:begin
     DoItByVMOpcodeDispatcher;
    end;
    popDEFINED:begin
     DoItByVMOpcodeDispatcher;
    end;
    popDEFINEDEX:begin
     DoItByVMOpcodeDispatcher;
    end;
    popLOADGLOBAL:begin
     DoItByVMOpcodeDispatcher;
    end;
    popLOADBASECLASS:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGETHASHKIND:begin
     DoItByVMOpcodeDispatcher;
    end;
    popSETHASHKIND:begin
     DoItByVMOpcodeDispatcher;
    end;
    popTYPEOF:begin
     DoItByVMOpcodeDispatcher;
    end;
    popIDOF:begin
     DoItByVMOpcodeDispatcher;
    end;
    popGHOSTTYPEOF:begin
     DoItByVMOpcodeDispatcher;
    end;
    popELVIS:begin
     DoItByVMOpcodeDispatcher;
    end;
    popIS:begin
     DoItByVMOpcodeDispatcher;
    end;
    popJIFNULL:begin
     DoItByVMOpcodeDispatcher;
    end;
    else begin
     DoItByVMOpcodeDispatcher;
    end;
   end;
  end;
  RetOfs:=CodeBufferLen;
  begin
   Add(#$c7#$45#$00); // mov dword ptr [ebp+$00],LastPC
   AddDWord(CurrentPC);

   Add(#$31#$c0); // xor eax,eax

   Add(#$f7#$d0); // not eax

   Add(#$c3); // ret
  end;
  SetLength(CodeBuffer,CodeBufferLen);
  Code.NativeCodeSize:=CodeBufferLen;
  Code.NativeCode:=POCANativeCodeMemoryManagerGetMemory(Code^.Header.{$ifdef POCAGarbageCollectorPoolBlockInstance}PoolBlock^.{$endif}Instance^.Globals.NativeCodeMemoryManager,Code.NativeCodeSize);
  Move(CodeBuffer[0],Code.NativeCode^,Code.NativeCodeSize);
  SetLength(Code.ByteCodeToNativeCodeMap,Code.ByteCodeSize);
  for i:=0 to Code.ByteCodeSize-1 do begin
   Code.ByteCodeToNativeCodeMap[i]:=Offsets[i];
  end;
  for i:=0 to CountFixups-1 do begin
   case FixUps[i].Kind of
    fkPTR:begin
     TPOCAPtrUInt(pointer(@pansichar(Code.NativeCode)[FixUps[i].Ofs])^):=(TPOCAPtrUInt(FixUps[i].Dest)-(TPOCAPtrUInt(pointer(@pansichar(Code.NativeCode)[FixUps[i].Ofs]))+4));
    end;
    fkRET:begin
     TPOCAPtrUInt(pointer(@pansichar(Code.NativeCode)[FixUps[i].Ofs])^):=(TPOCAPtrUInt(pointer(@pansichar(Code.NativeCode)[RetOfs]))-(TPOCAPtrUInt(pointer(@pansichar(Code.NativeCode)[FixUps[i].Ofs]))+4));
    end;
    fkOFS:begin
     TPOCAPtrUInt(pointer(@pansichar(Code.NativeCode)[FixUps[i].Ofs])^):=(TPOCAPtrUInt(pointer(@pansichar(Code.NativeCode)[Offsets[FixUps[i].ToOfs]]))-(TPOCAPtrUInt(pointer(@pansichar(Code.NativeCode)[FixUps[i].Ofs]))+4));
    end;
   end;
  end;
  result:=true;
 finally
  SetLength(Fixups,0);
  SetLength(Offsets,0);
  SetLength(CodeBuffer,0);
 end;
end;
{$warnings on}

function POCARunNativeCode(Context:PPOCAContext;Frame:PPOCAFrame;Code:PPOCACode):longbool; register; assembler;
asm
 push ebx
 push esi
 push edi
 push ebp
 mov esi,eax // ESI = Context
 mov edi,edx // EDI = Frame
 mov eax,dword ptr [ecx+TPOCACode.NativeCode]
 mov ebx,dword ptr [edx+TPOCAFrame.Registers] // EBX = Register
 lea ebp,dword ptr [edx+TPOCAFrame.InstructionPointer] // EBP = Byte code ip
 mov ecx,dword ptr [ecx+TPOCACode.ByteCodeToNativeCodeMap]
 mov edx,dword ptr [ebp]
 add eax,dword ptr [ecx+edx*4]
 call eax
 not eax
 pop ebp
 pop edi
 pop esi
 pop ebx
end;
{$endif}
{$endif}

function POCARunByteCode(Context:PPOCAContext):TPOCAValue;
var Code:PPOCACode;
    Frame:PPOCAFrame;
    Opcode,CurrentPC:longword;
    Operands:PLongwords;
    Registers:PPOCAValues;
    a,b:TPOCAValue;
begin
 result:=POCAValueNull;
 Frame:=@Context^.FrameStack[Context^.FrameTop-1];
 Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
{$ifdef POCAHasJIT}
 if not assigned(Code^.NativeCode) then begin
  POCAGenerateNativeCode(Context,Code);
 end;
{$endif}
 Registers:=@Frame^.Registers[0];
 while {$ifdef POCAHasJIT}Code^.InterpretByteCodeMap[Frame^.InstructionPointer] or POCARunNativeCode(Context,Frame,Code){$else}true{$endif} do begin
  Opcode:=Code^.ByteCode^[Frame^.InstructionPointer];
  Operands:=@Code^.ByteCode^[Frame^.InstructionPointer+1];
  inc(Frame^.InstructionPointer,1+(Opcode shr 8));
  case Opcode and $ff of
   popNOP:begin
   end;
   popADD:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=a.Num+b.Num;
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoADD) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=a.Num+b.Num;
    end;
   end;
   popSUB:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=a.Num-b.Num;
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoSUB) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=a.Num-b.Num;
    end;
   end;
   popMUL:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=a.Num*b.Num;
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoMUL) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=a.Num*b.Num;
    end;
   end;
   popDIV:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=a.Num/b.Num;
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoDIV) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=a.Num/b.Num;
    end;
   end;
   popNEG:begin
    if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoNEG) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     Registers^[Operands^[0]].Num:=-POCAGetNumberValue(Context,Registers^[Operands^[1]]);
    end;
   end;
   popNOT:begin
    if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoLNOT) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     Registers^[Operands^[0]].Num:=ord(not POCAGetBooleanValue(Context,Registers^[Operands^[1]]));
    end;
   end;
   popCAT:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoCONCAT) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     Registers^[Operands^[0]]:=POCARunEvalCat(Context,a,b);
    end;
    Context^.TemporarySavedObjectCount:=0;
   end;
   popLT:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num<b.Num);
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=0;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoLT) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<0);
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<0);
    end;
   end;
   popLTEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num<=b.Num);
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=1;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoLTEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<=0);
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<=0);
    end;
   end;
   popGT:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num>b.Num);
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=0;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoGT) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)>0);
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)>0);
    end;
   end;
   popGTEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num>=b.Num);
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=1;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoGTEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)>=0);
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)>=0);
    end;
   end;
   popEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num=b.Num);
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=1;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)=0);
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)=0);
    end;
   end;
   popNEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num<>b.Num);
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=0;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoNEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<>0);
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCACompare(Context,a,b)<>0);
    end;
   end;
   popCMP:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     if a.Num<b.Num then begin
      Registers^[Operands^[0]].Num:=-1;
     end else if a.Num>b.Num then begin
      Registers^[Operands^[0]].Num:=1;
     end else begin
      Registers^[Operands^[0]].Num:=0;
     end;
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=0;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoCOMPARE) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=POCACompare(Context,a,b);
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=POCACompare(Context,a,b);
    end;
   end;
   popSEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num=b.Num);
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=1;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoSEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(POCAStrictEqual(a,b));
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(POCAStrictEqual(a,b));
    end;
   end;
   popSNEQ:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=ord(a.Num<>b.Num);
    end else if POCAIsValueHash(a) or POCAIsValueHash(b) then begin
     if (POCAIsValueHash(a) and POCAIsValueHash(b)) and (POCAGetValueReferencePointer(a)=POCAGetValueReferencePointer(b)) then begin
      Registers^[Operands^[0]].Num:=0;
     end else begin
      if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoSNEQ) then begin
       Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
       Registers:=@Frame^.Registers[0];
      end else begin
       Registers^[Operands^[0]].Num:=ord(not POCAStrictEqual(a,b));
      end;
     end;
    end else begin
     Registers^[Operands^[0]].Num:=ord(not POCAStrictEqual(a,b));
    end;
   end;
   popEACH:begin
    if POCARunEvalForEach(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],Registers^[Operands^[3]]) then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[4];
    end;
   end;
   popJMP:begin
    Frame^.InstructionPointer:=Operands^[0];
   end;
   popJMPLOOP:begin
    if Context^.Instance^.Globals.Bottleneck then begin
     POCAGarbageCollectorDoBottleneck(Context^.Instance);
    end;
    Frame^.InstructionPointer:=Operands^[0];
   end;
   popJIFTRUE:begin
    if POCAGetBooleanValue(Context,Registers^[Operands^[1]]) then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popJIFFALSE:begin
    if ((Registers^[Operands^[1]].CastedInt64 and $7fffffffffffffff)=0) or not POCAGetBooleanValue(Context,Registers^[Operands^[1]]) then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popJIFTRUELOOP:begin
    if POCAGetBooleanValue(Context,Registers^[Operands^[1]]) then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popJIFFALSELOOP:begin
    if ((Registers^[Operands^[1]].CastedInt64 and $7fffffffffffffff)=0) or not POCAGetBooleanValue(Context,Registers^[Operands^[1]]) then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popFCALL:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,false,false);
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popMCALL:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,true,false);
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popRETURN:begin
    a:=Registers^[Operands^[0]];
    if assigned(Context^.CallChild) then begin
     POCAContextDestroy(Context^.CallChild);
     Context^.CallChild:=nil;
    end;
    dec(Context^.FrameTop);
    if Context^.FrameTop<=0 then begin
     Context^.Active:=false;
     result:=a;
     exit;
    end;
    begin
     Frame:=@Context^.FrameStack[Context^.FrameTop-1];
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end;
    Registers^[Frame^.ResultRegister]:=a;
    Context^.TemporarySavedObjectCount:=0;
   end;
   popLOADCONST:begin
    a:=Code^.Constants^[Operands^[1]];
    if POCAIsValueCode(a) then begin
     if Code^.ClassFunction then begin
      a:=POCABindClassFunction(Context,Frame,a);
     end else begin
      a:=POCABindFunction(Context,Frame,a);
     end;
    end;
    Registers^[Operands^[0]]:=a;
   end;
   popLOADONE:begin
    Registers^[Operands^[0]].Num:=1;
   end;
   popLOADZERO:begin
    Registers^[Operands^[0]].Num:=0;
   end;
   popLOADINT32:begin
    Registers^[Operands^[0]].Num:=longint(longword(Operands^[1]));
   end;
   popLOADNULL:begin
    Registers^[Operands^[0]]:=POCAValueNull;
   end;
   popLOADTHAT:begin
    POCARunGetThat(Context,Frame,Registers^[Operands^[0]]);
   end;
   popLOADTHIS:begin
    Registers^[Operands^[0]]:=Frame^.Obj;
   end;
   popLOADSELF:begin
    Registers^[Operands^[0]]:=Frame^.Func;
   end;
   popLOADLOCAL:begin
    Registers^[Operands^[0]]:=Frame^.Locals;
   end;
   popCOPY:begin
    Registers^[Operands^[0]]:=Registers^[Operands^[1]];
   end;
   popINSERT:begin
    POCARunContainerSet(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popEXTRACT:begin
    Registers^[Operands^[0]]:=POCARunContainerGet(Context,Registers^[Operands^[1]],Registers^[Operands^[2]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popGETMEMBER:begin
    POCARunGetMember(Context,Registers^[Operands^[1]],Code^.Constants^[Operands^[2]],Registers^[Operands^[0]],Operands^[3],false);
   end;
   popSETMEMBER:begin
    POCARunSetMember(Context,Registers^[Operands^[0]],Code^.Constants^[Operands^[1]],Registers^[Operands^[2]],Operands^[3]);
   end;
   popGETLOCAL:begin
    POCARunGetLocal(Context,Frame,Code^.Constants^[Operands^[1]],Registers^[Operands^[0]],Operands^[2]);
   end;
   popSETLOCAL:begin
    POCAHashSetCache(Context,Frame^.Locals,Code^.Constants^[Operands^[0]],Registers^[Operands^[1]],Operands^[2]);
   end;
   popNEWARRAY:begin
    Registers^[Operands^[0]]:=POCANewArray(Context);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popARRAYPUSH:begin
    POCAArrayPush(Registers^[Operands^[0]],Registers^[Operands^[1]]);
   end;
   popARRAYRANGEPUSH:begin
    POCAArrayRangePush(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]]);
   end;
   popNEWHASH:begin
    Registers^[Operands^[0]]:=POCANewHash(Context);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popHASHAPPEND:begin
    POCAHashSet(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]]);
   end;
   popSETSYM:begin
    POCARunSetSymbol(Context,Frame,Code^.Constants^[Operands^[0]],Registers^[Operands^[1]],Operands^[2]);
   end;
   popINDEX:begin
    if POCARunEvalForIndex(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]]) then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[3];
    end;
   end;
   popFCALLH:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,false,true);
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popMCALLH:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,true,true);
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popUNPACK:begin
    POCARunEvalUnpack(Context,Frame,Opcode,Operands);
   end;
   popSLICE:begin
    POCARunEvalSlice(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popSLICE2:begin
    POCARunEvalSlice2(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],Registers^[Operands^[3]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popSLICE3:begin
    POCARunEvalSlice3(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],Registers^[Operands^[3]]);
    Context^.TemporarySavedObjectCount:=0;
   end;
   popTRY:begin
    Frame^.InstructionPointer:=POCARunTry(Context,Frame,Operands^[0],Operands^[1],Operands^[2],Operands^[3],Operands^[4],Operands^[5]);
   end;
   popTRYBLOCKEND:begin
    result:=Registers^[Operands^[0]];
    exit;
   end;
   popTHROW:begin
    result:=Registers^[Operands^[0]];
    POCARunThrow(Context,result);
    exit;
   end;
   popDEC:begin
    a:=Registers^[Operands^[1]];
    if POCAIsValueNumber(a) then begin
     Registers^[Operands^[0]].Num:=a.Num-1.0;
    end else if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoDEC) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     a.Num:=POCAGetNumberValue(Context,a);
     Registers^[Operands^[0]].Num:=a.Num-1.0;
    end;
   end;
   popINC:begin
    a:=Registers^[Operands^[1]];
    if POCAIsValueNumber(a) then begin
     Registers^[Operands^[0]].Num:=a.Num+1.0;
    end else if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoDEC) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     a.Num:=POCAGetNumberValue(Context,a);
     Registers^[Operands^[0]].Num:=a.Num+1.0;
    end;
   end;
   popBAND:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=int64(System.trunc(a.Num)) and int64(System.trunc(b.Num));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBAND) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=int64(System.trunc(a.Num)) and int64(System.trunc(b.Num));
    end;
   end;
   popBXOR:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=int64(System.trunc(a.Num)) xor int64(System.trunc(b.Num));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBXOR) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=int64(System.trunc(a.Num)) xor int64(System.trunc(b.Num));
    end;
   end;
   popBOR:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=int64(System.trunc(a.Num)) or int64(System.trunc(b.Num));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBOR) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=int64(System.trunc(a.Num)) or int64(System.trunc(b.Num));
    end;
   end;
   popBNOT:begin
    if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoBNOT) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     Registers^[Operands^[0]].Num:=int64(not int64(System.trunc(POCAGetNumberValue(Context,Registers^[Operands^[1]]))));
    end;
   end;
   popBSHL:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=int64(System.trunc(a.Num)) shl longint(trunc(b.Num));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBSHL) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=int64(System.trunc(a.Num)) shl longint(System.trunc(b.Num));
    end;
   end;
   popBSHR:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=sar64(int64(System.trunc(a.Num)),longint(System.trunc(b.Num)));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBSHR) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=sar64(int64(System.trunc(a.Num)),longint(System.trunc(b.Num)));
    end;
   end;
   popBUSHR:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=int64(System.trunc(a.Num)) shr longint(System.trunc(b.Num));
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoBUSHR) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=int64(System.trunc(a.Num)) shr longint(System.trunc(b.Num));
    end;
   end;
   popMOD:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=Modulo(a.Num,b.Num);
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoMOD) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=Modulo(a.Num,b.Num);
    end;
   end;
   popPOW:begin
    a:=Registers^[Operands^[1]];
    b:=Registers^[Operands^[2]];
    if POCAIsValueNumber(a) and POCAIsValueNumber(b) then begin
     Registers^[Operands^[0]].Num:=Math.Power(a.Num,b.Num);
    end else if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoPOW) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     if not POCAIsValueNumber(a) then begin
      a.Num:=POCAGetNumberValue(Context,a);
     end;
     if not POCAIsValueNumber(b) then begin
      b.Num:=POCAGetNumberValue(Context,b);
     end;
     Registers^[Operands^[0]].Num:=Math.Power(a.Num,b.Num);
    end;
   end;
   popINHERITEDMETHOD:begin
    POCARunGetMember(Context,Registers^[Operands^[1]],Code^.Constants^[Operands^[2]],Registers^[Operands^[0]],Operands^[3],true);
   end;
   popKEY:begin
    if POCARunEvalForKey(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],Registers^[Operands^[3]]) then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[4];
    end;
   end;
   popIN:begin
    if POCARunHashEventRightBinaryOp(Context,Frame,Operands,pmoIN) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     POCARunIn(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]]);
    end;
   end;
   popINRANGE:begin
    if POCARunHashEventInRangeOp(Context,Frame,Operands,pmoINRANGE) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     POCARunInRange(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],Registers^[Operands^[2]],Registers^[Operands^[3]]);
    end;
   end;
   popFTAILCALL:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,false,false);
    dec(Context^.FrameTop);
    Frame:=@Context^.FrameStack[Context^.FrameTop-1];
    Frame^:=Context^.FrameStack[Context^.FrameTop];
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popMTAILCALL:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,true,false);
    dec(Context^.FrameTop);
    Frame:=@Context^.FrameStack[Context^.FrameTop-1];
    Frame^:=Context^.FrameStack[Context^.FrameTop];
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popFTAILCALLH:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,false,true);
    dec(Context^.FrameTop);
    Frame:=@Context^.FrameStack[Context^.FrameTop-1];
    Frame^:=Context^.FrameStack[Context^.FrameTop];
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popMTAILCALLH:begin
    Frame:=POCASetupFunctionCall(Context,Frame,Opcode,Operands,true,true);
    dec(Context^.FrameTop);
    Frame:=@Context^.FrameStack[Context^.FrameTop-1];
    Frame^:=Context^.FrameStack[Context^.FrameTop];
    Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
    Registers:=@Frame^.Registers[0];
    Context^.TemporarySavedObjectCount:=0;
   end;
   popINSTANCEOF:begin
    Registers^[Operands^[0]].Num:=ord(POCAObjectInstanceOf(Context,Registers^[Operands^[1]],Registers^[Operands^[2]]));
   end;
   popBREAKPOINT:begin
{$ifdef cpu386}
    asm
     db $cc
    end;
{$else}
    if (Opcode and $ff)=popBREAKPOINT then begin
    end;
{$endif}
   end;
   popNUM:begin
    Registers^[Operands^[0]].Num:=POCAGetNumberValue(Context,Registers^[Operands^[1]]);
   end;
   popN_NOT:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num=0);
   end;
   popN_ADD:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num+Registers^[Operands^[2]].Num;
   end;
   popN_SUB:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num-Registers^[Operands^[2]].Num;
   end;
   popN_MUL:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num*Registers^[Operands^[2]].Num;
   end;
   popN_DIV:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num/Registers^[Operands^[2]].Num;
   end;
   popN_NEG:begin
    Registers^[Operands^[0]].Num:=-Registers^[Operands^[1]].Num;
   end;
   popN_LT:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num<Registers^[Operands^[2]].Num);
   end;
   popN_LTEQ:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num<=Registers^[Operands^[2]].Num);
   end;
   popN_GT:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num>Registers^[Operands^[2]].Num);
   end;
   popN_GTEQ:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num>=Registers^[Operands^[2]].Num);
   end;
   popN_EQ:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num=Registers^[Operands^[2]].Num);
   end;
   popN_NEQ:begin
    Registers^[Operands^[0]].Num:=ord(Registers^[Operands^[1]].Num<>Registers^[Operands^[2]].Num);
   end;
   popN_CMP:begin
    if Registers^[Operands^[1]].Num<Registers^[Operands^[2]].Num then begin
     Registers^[Operands^[0]].Num:=-1;
    end else if Registers^[Operands^[1]].Num>Registers^[Operands^[2]].Num then begin
     Registers^[Operands^[0]].Num:=1;
    end else begin
     Registers^[Operands^[0]].Num:=0;
    end;
   end;
   popN_DEC:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num-1.0;
   end;
   popN_INC:begin
    Registers^[Operands^[0]].Num:=Registers^[Operands^[1]].Num+1.0;
   end;
   popN_BAND:begin
    Registers^[Operands^[0]].Num:=int64(System.trunc(Registers^[Operands^[1]].Num)) and int64(System.trunc(Registers^[Operands^[2]].Num));
   end;
   popN_BXOR:begin
    Registers^[Operands^[0]].Num:=int64(System.trunc(Registers^[Operands^[1]].Num)) xor int64(System.trunc(Registers^[Operands^[2]].Num));
   end;
   popN_BOR:begin
    Registers^[Operands^[0]].Num:=int64(System.trunc(Registers^[Operands^[1]].Num)) or int64(System.trunc(Registers^[Operands^[2]].Num));
   end;
   popN_BNOT:begin
    Registers^[Operands^[0]].Num:=int64(not int64(System.trunc(Registers^[Operands^[1]].Num)));
   end;
   popN_BSHL:begin
    Registers^[Operands^[0]].Num:=int64(System.trunc(Registers^[Operands^[1]].Num)) shl int64(System.trunc(Registers^[Operands^[2]].Num));
   end;
   popN_BSHR:begin
    Registers^[Operands^[0]].Num:=sar64(int64(System.trunc(Registers^[Operands^[1]].Num)),longint(trunc(Registers^[Operands^[2]].Num)));
   end;
   popN_BUSHR:begin
    Registers^[Operands^[0]].Num:=int64(System.trunc(Registers^[Operands^[1]].Num)) shr int64(System.trunc(Registers^[Operands^[2]].Num));
   end;
   popN_MOD:begin
    Registers^[Operands^[0]].Num:=Modulo(Registers^[Operands^[1]].Num,Registers^[Operands^[2]].Num);
   end;
   popN_POW:begin
    Registers^[Operands^[0]].Num:=Math.Power(Registers^[Operands^[1]].Num,Registers^[Operands^[2]].Num);
   end;
   popN_INRANGE:begin
    Registers^[Operands^[0]].Num:=ord((Registers^[Operands^[2]].Num<=Registers^[Operands^[1]].Num) and (Registers^[Operands^[1]].Num<=Registers^[Operands^[3]].Num));
   end;
   popN_JIFTRUE:begin
    if Registers^[Operands^[1]].Num<>0 then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFFALSE:begin
    if Registers^[Operands^[1]].Num=0 then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFTRUELOOP:begin
    if Registers^[Operands^[1]].Num<>0 then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFFALSELOOP:begin
    if Registers^[Operands^[1]].Num=0 then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFLT:begin
    if Registers^[Operands^[1]].Num<Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFLTEQ:begin
    if Registers^[Operands^[1]].Num<=Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFGT:begin
    if Registers^[Operands^[1]].Num>Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFGTEQ:begin
    if Registers^[Operands^[1]].Num>=Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFEQ:begin
    if Registers^[Operands^[1]].Num=Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFNEQ:begin
    if Registers^[Operands^[1]].Num<>Registers^[Operands^[2]].Num then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFLTLOOP:begin
    if Registers^[Operands^[1]].Num<Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFLTEQLOOP:begin
    if Registers^[Operands^[1]].Num<=Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFGTLOOP:begin
    if Registers^[Operands^[1]].Num>Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFGTEQLOOP:begin
    if Registers^[Operands^[1]].Num>=Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFEQLOOP:begin
    if Registers^[Operands^[1]].Num=Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popN_JIFNEQLOOP:begin
    if Registers^[Operands^[1]].Num<>Registers^[Operands^[2]].Num then begin
     if Context^.Instance^.Globals.Bottleneck then begin
      POCAGarbageCollectorDoBottleneck(Context^.Instance);
     end;
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   popUPDATESTRING:begin
    if POCAIsValueString(Registers^[Operands^[0]]) then begin
     POCAStringUpdate(Context,Registers^[Operands^[0]]);
    end;
   end;
   popREGEXP:begin
    a:=Code^.RegExps^[Operands^[1]];
    if POCAGhostGetType(Code^.RegExps^[Operands^[1]])<>@POCARegExpGhost then begin
     a:=POCARegExpFunctionCOMPILE(Context,POCAValueNull,@Registers^[Operands^[2]],1,nil);
     POCAAtomicSetValue(Code^.RegExps^[Operands^[1]],a);
    end;
    Registers^[Operands^[0]]:=a;
   end;
   popREGEXPEQ:begin
    if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoREGEXPEQ) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else if POCAGhostGetType(Code^.RegExps^[Operands^[2]])=@POCARegExpGhost then begin
     Registers^[Operands^[0]]:=POCARegExpFunctionTEST(Context,POCAValueNull,@Registers^[Operands^[1]],2,nil);
    end else begin
     Registers^[Operands^[0]].Num:=0;
    end;
   end;
   popREGEXPNEQ:begin
    if POCARunHashEventBinaryOp(Context,Frame,Operands,pmoREGEXPNEQ) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else if POCAGhostGetType(Code^.RegExps^[Operands^[2]])=@POCARegExpGhost then begin
     Registers^[Operands^[0]].Num:=ord(POCARegExpFunctionTEST(Context,POCAValueNull,@Registers^[Operands^[1]],2,nil).Num=0);
    end else begin
     Registers^[Operands^[0]].Num:=0;
    end;
   end;
   popSQRT:begin
    if POCARunHashEventUnaryOp(Context,Frame,Operands,pmoSQRT) then begin
     Code:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Frame.Func))^.Code));
     Registers:=@Frame^.Registers[0];
    end else begin
     Registers^[Operands^[0]].Num:=sqrt(POCAGetNumberValue(Context,Registers^[Operands^[1]]));
    end;
   end;
   popN_SQRT:begin
    Registers^[Operands^[0]].Num:=sqrt(Registers^[Operands^[1]].Num);
   end;
   popGETPROTOTYPE:begin
    Registers^[Operands^[0]]:=POCAValueGetPrototypeValue(Context,Registers^[Operands^[1]],0);
   end;
   popSETPROTOTYPE:begin
    POCAValueSetPrototypeValue(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],0);
   end;
   popGETCONSTRUCTOR:begin
    Registers^[Operands^[0]]:=POCAValueGetConstructorValue(Context,Registers^[Operands^[1]],0);
   end;
   popSETCONSTRUCTOR:begin
    POCAValueSetConstructorValue(Context,Registers^[Operands^[0]],Registers^[Operands^[1]],0);
   end;
   popDELETE:begin
    Registers^[Operands^[0]].Num:=ord(POCAHashDelete(Context,Registers^[Operands^[1]],Code^.Constants^[Operands^[2]]));
   end;
   popDELETEEX:begin
    case POCAGetValueType(Registers^[Operands^[1]]) of
     pvtNULL:begin
      Registers^[Operands^[0]].Num:=0;
     end;
     pvtHASH:begin
      Registers^[Operands^[0]].Num:=ord(POCAHashDelete(Context,Registers^[Operands^[1]],Registers^[Operands^[2]]));
     end;
     pvtARRAY:begin
      a.CastedInt64:=System.trunc(POCAGetNumberValue(Context,Registers^[Operands^[2]]));
      if (a.CastedInt64>=0) and (a.CastedInt64<POCAArraySize(Registers^[Operands^[1]])) then begin
       POCAArraySet(Registers^[Operands^[1]],a.CastedInt64,POCAValueNull);
       Registers^[Operands^[0]].Num:=1;
      end else begin
       Registers^[Operands^[0]].Num:=0;
      end;
     end;
     else begin
      Registers^[Operands^[0]].Num:=0;
     end;
    end;
   end;
   popDEFINED:begin
    Registers^[Operands^[0]].Num:=ord(POCAHashExist(Context,Registers^[Operands^[1]],Code^.Constants^[Operands^[2]]));
   end;
   popDEFINEDEX:begin
    case POCAGetValueType(Registers^[Operands^[1]]) of
     pvtNULL:begin
      Registers^[Operands^[0]].Num:=0;
     end;
     pvtHASH:begin
      Registers^[Operands^[0]].Num:=ord(POCAHashExist(Context,Registers^[Operands^[1]],Registers^[Operands^[2]]));
     end;
     pvtARRAY:begin
      a.CastedInt64:=System.trunc(POCAGetNumberValue(Context,Registers^[Operands^[2]]));
      if (a.CastedInt64>=0) and (a.CastedInt64<POCAArraySize(Registers^[Operands^[1]])) then begin
       b:=POCAArrayGet(Registers^[Operands^[1]],a.CastedInt64);
       Registers^[Operands^[0]].Num:=ord(not POCAIsValueNull(b));
      end else begin
       Registers^[Operands^[0]].Num:=0;
      end;
     end;
     else begin
      Registers^[Operands^[0]].Num:=0;
     end;
    end;
   end;
   popLOADGLOBAL:begin
    Registers^[Operands^[0]]:=Context^.Instance.Globals.Namespace;
   end;
   popLOADBASECLASS:begin
    Registers^[Operands^[0]]:=Context^.Instance.Globals.BaseClass;
   end;
   popGETHASHKIND:begin
    Registers^[Operands^[0]].Num:=POCAHashGetKind(Registers^[Operands^[1]]);
   end;
   popSETHASHKIND:begin
    POCAHashSetKind(Context,Registers^[Operands^[0]],trunc(POCAGetNumberValue(Context,Registers^[Operands^[1]])));
   end;
   popTYPEOF:begin
    Registers^[Operands^[0]]:=POCATypeOf(Context,Registers^[Operands^[1]]);
   end;
   popIDOF:begin
    Registers^[Operands^[0]]:=POCAIDOf(Context,Registers^[Operands^[1]]);
   end;
   popGHOSTTYPEOF:begin
    Registers^[Operands^[0]]:=POCAGhostTypeOf(Context,Registers^[Operands^[1]]);
   end;
   popELVIS:begin
    if POCAGetBooleanValue(Context,Registers^[Operands^[1]]) then begin
     Registers^[Operands^[0]]:=Registers^[Operands^[1]];
    end else begin
     Registers^[Operands^[0]]:=Registers^[Operands^[2]];
    end;
   end;
   popIS:begin
    Registers^[Operands^[0]].Num:=ord(POCAObjectIs(Context,Registers^[Operands^[1]],Registers^[Operands^[2]]));
   end;
   popJIFNULL:begin
    if Registers^[Operands^[1]].CastedInt64=POCAValueNull.CastedInt64 then begin
     Frame^.InstructionPointer:=Operands^[0];
    end;
   end;
   else begin
    POCARuntimeError(Context,'Invalid unknown opcode instruction');
   end;
  end;
 end;
end;

function POCARun(Context:PPOCAContext):TPOCAValue;
var OldFPUExceptionMask:TFPUExceptionMask;
    OldFPURoundingMode:TFPURoundingMode;
    OldFPUPrecisionMode:TFPUPrecisionMode;
begin
 OldFPUExceptionMask:=GetExceptionMask;
 OldFPURoundingMode:=GetRoundMode;
 OldFPUPrecisionMode:=GetPrecisionMode;
 try
  if OldFPUExceptionMask<>FPUExceptionMask then begin
   SetExceptionMask(FPUExceptionMask);
  end;
  if OldFPURoundingMode<>FPURoundingMode then begin
   SetRoundMode(FPURoundingMode);
  end;
  if OldFPUPrecisionMode<>FPUPrecisionMode then begin
   SetPrecisionMode(FPUPrecisionMode);
  end;
  result:=POCARunByteCode(Context);
 finally
  if OldFPUExceptionMask<>FPUExceptionMask then begin
   SetExceptionMask(OldFPUExceptionMask);
  end;
  if OldFPURoundingMode<>FPURoundingMode then begin
   SetRoundMode(OldFPURoundingMode);
  end;
  if OldFPUPrecisionMode<>FPUPrecisionMode then begin
   SetPrecisionMode(OldFPUPrecisionMode);
  end;
 end;
end;

function POCACall(Context:PPOCAContext;Func:TPOCAValue;Arguments:PPOCAValues;CountArguments:longint;Obj:TPOCAValue;Locals:TPOCAValue):TPOCAValue;
var i:longint;
    Frame:PPOCAFrame;
    CodePointer:PPOCACode;
    HashEvents:PPOCAHashEvents;
    NativeCode:PPOCANativeCode;
begin
 if not assigned(Context^.CallParent) then begin
  POCAGarbageCollectorLock(Context);
 end;
 try
  POCATemporarySave(Context,Func);
  for i:=0 to CountArguments-1 do begin
   POCATemporarySave(Context,Arguments^[i]);
  end;
  POCATemporarySave(Context,Obj);
  POCATemporarySave(Context,Locals);
  if POCAIsValueEventHash(Func) or POCAIsValueGhostEventHash(Func) then begin
   HashEvents:=POCAHashGetHashEvents(Func);
   if assigned(HashEvents) then begin
    if POCAIsValueNull(Obj) then begin
     Obj:=Func;
    end;
    Func:=HashEvents^[pmoCALL];
   end;
  end;
  if not (POCAIsValueFunction(Func) or POCAIsValueCode(Func) or POCAIsValueNativeCode(Func)) then begin
   if POCAIsValueNull(Obj) then begin
    POCARuntimeError(Context,'Function call on uncallable object');
   end else begin
    POCARuntimeError(Context,'Method call on uncallable object');
   end;
  end;
  if POCAIsValueFunction(Func) and POCAIsValueNativeCode(PPOCAFunction(POCAGetValueReferencePointer(Func))^.Code) then begin
   NativeCode:=PPOCANativeCode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Func))^.Code));
   result:=NativeCode^.FunctionPointer(Context,Obj,Arguments,CountArguments,NativeCode^.UserData);
  end else if POCAIsValueNativeCode(Func) then begin
   NativeCode:=PPOCANativeCode(POCAGetValueReferencePointer(Func));
   result:=NativeCode^.FunctionPointer(Context,Obj,Arguments,CountArguments,NativeCode^.UserData);
  end else begin
   begin
    if POCAIsValueNull(Locals) and not PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Func))^.Code))^.FastFunction then begin
     Locals:=POCANewHash(Context);
    end;
    if not POCAIsValueFunction(Func) then begin
     Func:=POCANewFunction(Context,Func);
     PPOCAFunction(POCAGetValueReferencePointer(Func))^.Namespace:=Locals;
     PPOCAFunction(POCAGetValueReferencePointer(Func))^.Obj:=Obj;
    end else begin
     if POCAIsValueNull(Obj) then begin
      Obj:=PPOCAFunction(POCAGetValueReferencePointer(Func))^.Obj;
     end;
    end;
   end;
   CodePointer:=PPOCACode(POCAGetValueReferencePointer(PPOCAFunction(POCAGetValueReferencePointer(Func))^.Code));
   begin
    Context^.FrameTop:=1;
    Frame:=@Context^.FrameStack[0];
    Frame^.Func:=Func;
    Frame^.Locals:=Locals;
    Frame^.Obj:=Obj;
    Frame^.InstructionPointer:=0;
    POCASetupRegisters(Frame,CodePointer);
   end;
   POCASetupArguments(Context,@Context^.FrameStack[0],CodePointer,Arguments,CountArguments);
   result:=POCARun(Context);
  end;
 finally
  if not assigned(Context^.CallParent) then begin
   POCAGarbageCollectorUnlock(Context);
  end;
 end;
end;

{$hints off}
function POCAGetFileContent(FileName:TPOCAUTF8String):TPOCARawByteString;
var OldFileMode:byte;
    f:file;
begin
 result:='';
 OldFileMode:=FileMode;
 try
  FileMode:=0;
  AssignFile(f,PUCUUTF8ToUTF16(FileName));
  {$i-}Reset(f,1);{$i+};
  if IOResult=0 then begin
   SetLength(result,FileSize(f));
   if length(result)>0 then begin
    {$i-}BlockRead(f,result[1],length(result));{$i+}
    if IOResult<>0 then begin
     {$i-}CloseFile(f);{$i+}
     FileMode:=OldFileMode;
     exit;
    end;
   end;
   {$i-}CloseFile(f);{$i+}
  end;
 finally
  FileMode:=OldFileMode;
 end;
end;

procedure InitializePOCA;
const POCASignature:TPOCAUTF8String=' POCA - Version '+POCAVersion+' - Copyright (C) 2011-2023, Benjamin ''BeRo'' Rosseaux - benjamin@rosseaux.com - http://www.rosseaux.com ';
      FPUExceptionMask:TFPUExceptionMask=[exInvalidOp,exDenormalized,exZeroDivide,exOverflow,exUnderflow,exPrecision];
      FPURoundingMode:TFPURoundingMode=rmNearest;
      FPUPrecisionMode:TFPUPrecisionMode={$ifdef HAS_TYPE_EXTENDED}pmEXTENDED{$else}pmDOUBLE{$endif};
 procedure InitializeTokens;
 var i:longint;
     t:TPOCATokenType;
     p:PPOCATokenPrecedence;
     pbp:PPOCATokenBinaryPrefix;
 begin
  POCABinaryTokens:=[];
  POCAReverseTokens:=[];
  POCAPrefixTokens:=[];
  POCASuffixTokens:=[];
  for i:=low(POCATokenPrecedences) to high(POCATokenPrecedences) do begin
   p:=@POCATokenPrecedences[i];
   case p^.Rule of
    prBINARY:begin
     POCABinaryTokens:=POCABinaryTokens+p^.Tokens;
    end;
    prREVERSE:Begin
     POCAReverseTokens:=POCAReverseTokens+p^.Tokens;
    end;
    prPREFIX:begin
     POCAPrefixTokens:=POCAPrefixTokens+p^.Tokens;
    end;
    prSUFFIX:begin
     POCASuffixTokens:=POCASuffixTokens+p^.Tokens;
    end;
   end;
  end;
  POCABinaryOrPrefixTokens:=POCABinaryTokens+POCAPrefixTokens;
  for t:=low(TPOCATokenType) to high(TPOCATokenType) do begin
   POCABinaryToPrefixUnaryTokenCorrectionMap[t]:=t;
  end;
  for i:=low(POCATokenBinaryPrefixes) to high(POCATokenBinaryPrefixes) do begin
   pbp:=@POCATokenBinaryPrefixes[i];
   POCABinaryToPrefixUnaryTokenCorrectionMap[pbp^.BinaryToken]:=pbp^.PrefixToken;
   POCABinaryToPrefixUnaryTokenCorrectionMap[pbp^.PrefixToken]:=pbp^.PrefixToken;
  end;
 end;
 procedure InitializeKeywords;
  procedure AddKeywordToken(Token:TPOCATokenType;const Str:TPOCARawByteString);
  var Node:PPOCALexerKeywordTokenCharTreeNode;
      Index:longint;
      CurrentChar:ansichar;
  begin
   Node:=LexerKeywordTokenCharTreeRootNode;
   for Index:=1 to length(Str) do begin
    CurrentChar:=Str[Index];
    if CurrentChar in POCAKeywordChars then begin
     if Node^.HasChildren and assigned(Node^.Children[CurrentChar]) then begin
      Node:=Node^.Children[CurrentChar];
     end else begin
      New(Node^.Children[CurrentChar]);
      Node^.HasChildren:=true;
      Node:=Node^.Children[CurrentChar];
      FillChar(Node^,sizeof(TPOCALexerKeywordTokenCharTreeNode),#0);
      Node^.HasChildren:=false;
      Node^.Token:=ptNONE;
     end;
    end else begin
     break;
    end;
   end;
   if assigned(Node) and (Node<>LexerKeywordTokenCharTreeRootNode) then begin
    Node^.Token:=Token;
   end;
   LexerKeywordTokens[Token]:=Str;
  end;
 begin
  FillChar(LexerKeywordTokens,sizeof(TPOCALexerKeywordTokens),#0);
  LexerKeywordTokenCharTreeRootNode:=nil;
  New(LexerKeywordTokenCharTreeRootNode);
  FillChar(LexerKeywordTokenCharTreeRootNode^,sizeof(TPOCALexerKeywordTokenCharTreeNode),#0);
  LexerKeywordTokenCharTreeRootNode^.Token:=ptNONE;
  AddKeywordToken(ptIF,'if');
  AddKeywordToken(ptELSEIF,'elseif');
  AddKeywordToken(ptELSE,'else');
  AddKeywordToken(ptFOR,'for');
  AddKeywordToken(ptFOREACH,'foreach');
  AddKeywordToken(ptWHILE,'while');
  AddKeywordToken(ptRETURN,'return');
  AddKeywordToken(ptBREAK,'break');
  AddKeywordToken(ptCONTINUE,'continue');
  AddKeywordToken(ptFUNCTION,'function');
  AddKeywordToken(ptNULL,'null');
  AddKeywordToken(ptVAR,'var');
  AddKeywordToken(ptFORINDEX,'forindex');
  AddKeywordToken(ptLAND,'and');
  AddKeywordToken(ptLOR,'or');
  AddKeywordToken(ptTRY,'try');
  AddKeywordToken(ptCATCH,'catch');
  AddKeywordToken(ptFINALLY,'finally');
  AddKeywordToken(ptTHROW,'throw');
  AddKeywordToken(ptDO,'do');
  AddKeywordToken(ptWHEN,'when');
  AddKeywordToken(ptSWITCH,'switch');
  AddKeywordToken(ptCASE,'case');
  AddKeywordToken(ptDEFAULT,'default');
  AddKeywordToken(ptFALLTHROUGH,'fallthrough');
  AddKeywordToken(ptRETRY,'retry');
  AddKeywordToken(ptREGISTER,'register');
  AddKeywordToken(ptBLOCK,'block');
  AddKeywordToken(ptINLINEBLOCK,'inlineblock');
  AddKeywordToken(ptTHAT,'that');
  AddKeywordToken(ptTHIS,'this');
  AddKeywordToken(ptSELF,'self');
  AddKeywordToken(ptLOCAL,'local');
  AddKeywordToken(ptDEFINED,'defined');
  AddKeywordToken(ptNEW,'new');
  AddKeywordToken(ptTRUE,'true');
  AddKeywordToken(ptFALSE,'false');
  AddKeywordToken(ptFASTFUNCTION,'fastfunction');
  AddKeywordToken(ptFORKEY,'forkey');
  AddKeywordToken(ptINSTANCEOF,'instanceof');
  AddKeywordToken(ptIN,'in');
  AddKeywordToken(ptIS,'is');
  AddKeywordToken(ptSUPER,'super');
  AddKeywordToken(ptPROTOTYPE,'prototype');
  AddKeywordToken(ptDELETE,'delete');
  AddKeywordToken(ptCLASS,'class');
  AddKeywordToken(ptMODULE,'module');
  AddKeywordToken(ptEXTENDS,'extends');
  AddKeywordToken(ptGLOBAL,'global');
  AddKeywordToken(ptBASECLASS,'baseclass');
  AddKeywordToken(ptLET,'let');
  AddKeywordToken(ptREG,'reg');
  AddKeywordToken(ptCONST,'const');
  AddKeywordToken(ptFUNC,'func');
  AddKeywordToken(ptFASTFUNC,'fastfunc');
  AddKeywordToken(ptTYPEOF,'typeof');
  AddKeywordToken(ptIDOF,'idof');
  AddKeywordToken(ptGHOSTTYPEOF,'ghosttypeof');
  AddKeywordToken(ptCONSTRUCTOR,'constructor');
  AddKeywordToken(ptBREAKPOINT,'breakpoint');
  AddKeywordToken(ptIMPORT,'import');
  AddKeywordToken(ptEXPORT,'export');
 end;
 procedure InitializeMetaOpNames;
 var i:TPOCAMetaOp;
 begin
  FillChar(MetaOpNames,sizeof(TPOCAMetaOpNames),#0);
  MetaOpNames[pmoADD]:='__add';
  MetaOpNames[pmoSUB]:='__sub';
  MetaOpNames[pmoMUL]:='__mul';
  MetaOpNames[pmoDIV]:='__div';
  MetaOpNames[pmoMOD]:='__mod';
  MetaOpNames[pmoPOW]:='__pow';
  MetaOpNames[pmoNEG]:='__neg';
  MetaOpNames[pmoLNOT]:='__lnot';
  MetaOpNames[pmoBNOT]:='__bnot';
  MetaOpNames[pmoBAND]:='__band';
  MetaOpNames[pmoBOR]:='__bor';
  MetaOpNames[pmoBXOR]:='__bxor';
  MetaOpNames[pmoBSHL]:='__bshl';
  MetaOpNames[pmoBSHR]:='__bshr';
  MetaOpNames[pmoBUSHR]:='__bushr';
  MetaOpNames[pmoDEC]:='__dec';
  MetaOpNames[pmoINC]:='__inc';
  MetaOpNames[pmoEQ]:='__eq';
  MetaOpNames[pmoNEQ]:='__neq';
  MetaOpNames[pmoSEQ]:='__seq';
  MetaOpNames[pmoSNEQ]:='__sneq';
  MetaOpNames[pmoLT]:='__lt';
  MetaOpNames[pmoLTEQ]:='__lteq';
  MetaOpNames[pmoGT]:='__gt';
  MetaOpNames[pmoGTEQ]:='__gteq';
  MetaOpNames[pmoIN]:='__in';
  MetaOpNames[pmoINRANGE]:='__inrange';
  MetaOpNames[pmoCONCAT]:='__concat';
  MetaOpNames[pmoCOMPARE]:='__compare';
  MetaOpNames[pmoEXIST]:='__exist';
  MetaOpNames[pmoGET]:='__get';
  MetaOpNames[pmoSET]:='__set';
  MetaOpNames[pmoDELETE]:='__delete';
  MetaOpNames[pmoSIZE]:='__size';
  MetaOpNames[pmoCALL]:='__call';
  MetaOpNames[pmoKEYS]:='__keys';
  MetaOpNames[pmoTONUMBER]:='__tonumber';
  MetaOpNames[pmoTOSTRING]:='__tostring';
  MetaOpNames[pmoREGEXPEQ]:='__regexpeq';
  MetaOpNames[pmoREGEXPNEQ]:='__regexpneq';
  MetaOpNames[pmoSQRT]:='__sqrt';
  begin
   MetaOpNamesHashMap:=TPOCAStringHashMap.Create(false);
   for i:=low(TPOCAMetaOpNames) to high(TPOCAMetaOpNames) do begin
    MetaOpNamesHashMap.SetValue(MetaOpNames[i],Integer(i));
   end;
  end;
 end;
var OldFPUExceptionMask:TFPUExceptionMask;
    OldFPURoundingMode:TFPURoundingMode;
    OldFPUPrecisionMode:TFPUPrecisionMode;
begin
 if (not POCAInitialized) and (length(POCASignature)>0) then begin
  POCAInitialized:=true;
{$ifdef POCAHasJIT}
{$ifdef unix}
{$ifdef darwin}
  fpmprotect:=dlsym(dlopen('libc.dylib',RTLD_NOW),'mprotect');
{$else}
  fpmprotect:=dlsym(dlopen('libc.so',RTLD_NOW),'mprotect');
{$endif}
  if not assigned(fpmprotect) then begin
   raise Exception.Create('Importing of mprotect from libc.so failed!');
  end;
{$endif}
{$endif}
  InitializeLocaleFormatSettings;
  InitializeTokens;
  InitializeKeywords;
  InitializeMetaOpNames;
  begin
   OldFPUExceptionMask:=GetExceptionMask;
   OldFPURoundingMode:=GetRoundMode;
   OldFPUPrecisionMode:=GetPrecisionMode;
   try
    if OldFPUExceptionMask<>FPUExceptionMask then begin
     SetExceptionMask(FPUExceptionMask);
    end;
    if OldFPURoundingMode<>FPURoundingMode then begin
     SetRoundMode(FPURoundingMode);
    end;
    if OldFPUPrecisionMode<>FPUPrecisionMode then begin
     SetPrecisionMode(FPUPrecisionMode);
    end;
   finally
    if OldFPUExceptionMask<>FPUExceptionMask then begin
     SetExceptionMask(OldFPUExceptionMask);
    end;
    if OldFPURoundingMode<>FPURoundingMode then begin
     SetRoundMode(OldFPURoundingMode);
    end;
    if OldFPUPrecisionMode<>FPUPrecisionMode then begin
     SetPrecisionMode(OldFPUPrecisionMode);
    end;
   end;
  end;
 end;
end;

procedure FinalizePOCA;
 procedure FreeLexerKeywordTokenCharTreeNode(var Node:PPOCALexerKeywordTokenCharTreeNode);
 var c:ansichar;
 begin
  if assigned(Node) then begin
   for c:=low(TPOCAKeywordChars) to high(TPOCAKeywordChars) do begin
    FreeLexerKeywordTokenCharTreeNode(Node^.Children[c]);
   end;
   Dispose(Node);
   Node:=nil;
  end;
 end;
var i:TPOCAMetaOp;
    t:TPOCATokenType;
begin
 if POCAInitialized then begin
  FreeLexerKeywordTokenCharTreeNode(LexerKeywordTokenCharTreeRootNode);
  for t:=low(LexerKeywordTokens) to high(LexerKeywordTokens) do begin
   LexerKeywordTokens[t]:='';
  end;
  for i:=low(TPOCAMetaOpNames) to high(TPOCAMetaOpNames) do begin
   MetaOpNames[i]:='';
  end;
  FreeAndNil(MetaOpNamesHashMap);
  POCAInitialized:=false;
 end;
end;

initialization
 InitializePOCA;
finalization
 FinalizePOCA;
end.

