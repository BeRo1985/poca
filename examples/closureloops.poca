#pragma closurecopyoniteration on // if enabled, closures in loops capture per-iteration values; otherwise all iterations share the same binding

// Test 1: labeled break across nested loops with closures
puts("Test 1: labeled break across nested for loops");
let fns1 = [];
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    fns1.push(() => i.toString() ~ "," ~ j.toString());
    if (j == 1) {
      break outer;
    }
  }
}
foreach (let fn in fns1) {
  puts(fn());
}
// Expected: 0,0 then 0,1

// Test 2: try/catch inside loop with closures
puts("Test 2: try/catch inside for loop");
let fns2 = [];
for (let i = 0; i < 3; i++) {
  try {
    fns2.push(() => i);
    if (i == 1) {
      throw "test error";
    }
  } catch (let e) {
    fns2.push(() => i * 10);
  }
}
foreach (let fn in fns2) {
  puts(fn().toString());
}
// Expected: 0, 1, 10, 2

// Test 3: try/finally inside loop with closures
puts("Test 3: try/finally inside for loop");
let fns3 = [];
for (let i = 0; i < 3; i++) {
  try {
    fns3.push(() => i);
  } finally {
  }
}
foreach (let fn in fns3) {
  puts(fn().toString());
}
// Expected: 0, 1, 2

// Test 4: continue with label across nested loops
puts("Test 4: labeled continue");
let fns4 = [];
outer2: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (j == 1) {
      continue outer2;
    }
    fns4.push(() => i.toString() ~ "," ~ j.toString());
  }
}
foreach (let fn in fns4) {
  puts(fn());
}
// Expected: 0,0 then 1,0 then 2,0

// Test 5: break from while inside for
puts("Test 5: break from while inside for");
let fns5 = [];
for (let i = 0; i < 3; i++) {
  let j = 0;
  while (j < 5) {
    let k = j; // capture j in closure to test while-body scoping
    fns5.push(() => i.toString() ~ "," ~ k.toString());
    j++;
    if (j >= 2) {
      break;
    }
  }
}
foreach (let fn in fns5) {
  puts(fn());
}
// Expected: 0,0 0,1 1,0 1,1 2,0 2,1
// Note: j is while-body scoped, so j captures the value at iteration time
